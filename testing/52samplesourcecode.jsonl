{"address": "0xe952bda8c06481506e4731c4f54ced2d4ab81659", "attacktype": "Reentrancy, Token standard incompatibility", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FNFTHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"./interfaces/IRevest.sol\\\";\\nimport \\\"./interfaces/IAddressRegistry.sol\\\";\\nimport \\\"./interfaces/ILockManager.sol\\\";\\nimport \\\"./interfaces/ITokenVault.sol\\\";\\nimport \\\"./interfaces/IAddressLock.sol\\\";\\nimport \\\"./utils/RevestAccessControl.sol\\\";\\nimport \\\"./interfaces/IFNFTHandler.sol\\\";\\nimport \\\"./interfaces/IMetadataHandler.sol\\\";\\n\\ncontract FNFTHandler is ERC1155, AccessControl, RevestAccessControl, IFNFTHandler {\\n\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    mapping(uint => uint) public supply;\\n    uint public fnftsCreated = 0;\\n\\n    /**\\n     * @dev Primary constructor to create an instance of NegativeEntropy\\n     * Grants ADMIN and MINTER_ROLE to whoever creates the contract\\n     */\\n    constructor(address provider) ERC1155(\\\"\\\") RevestAccessControl(provider) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override (AccessControl, ERC1155) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController {\\n        supply[id] += amount;\\n        _mint(account, id, amount, data);\\n        fnftsCreated += 1;\\n    }\\n\\n    function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController {\\n        supply[id] += newSupply;\\n        for(uint i = 0; i < quantities.length; i++) {\\n            _mint(recipients[i], id, quantities[i], data);\\n        }\\n        fnftsCreated += 1;\\n    }\\n\\n    function mintBatch(address to, uint[] memory ids, uint[] memory amounts, bytes memory data) external override onlyRevestController {\\n        _mintBatch(to, ids, amounts, data);\\n    }\\n\\n    function setURI(string memory newuri) external override onlyRevestController {\\n        _setURI(newuri);\\n    }\\n\\n    function burn(address account, uint id, uint amount) external override onlyRevestController {\\n        supply[id] -= amount;\\n        _burn(account, id, amount);\\n    }\\n\\n    function burnBatch(address account, uint[] memory ids, uint[] memory amounts) external override onlyRevestController {\\n        _burnBatch(account, ids, amounts);\\n    }\\n\\n    function getBalance(address account, uint id) external view override returns (uint) {\\n        return balanceOf(account, id);\\n    }\\n\\n    function getSupply(uint fnftId) public view override returns (uint) {\\n        return supply[fnftId];\\n    }\\n\\n    function getNextId() public view override returns (uint) {\\n        return fnftsCreated;\\n    }\\n\\n\\n    // OVERIDDEN ERC-1155 METHODS\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint[] memory ids,\\n        uint[] memory amounts,\\n        bytes memory data\\n    ) internal override {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n        // Loop because all batch transfers must be checked\\n        // Will only execute once on singular transfer\\n        if (from != address(0) && to != address(0)) {\\n            address vault = addressesProvider.getTokenVault();\\n            bool canTransfer = !ITokenVault(vault).getNontransferable(ids[0]);\\n            // Only check if not from minter\\n            // And not being burned\\n            if(ids.length > 1) {\\n                uint iterator = 0;\\n                while (canTransfer && iterator < ids.length) {\\n                    canTransfer = !ITokenVault(vault).getNontransferable(ids[iterator]);\\n                    iterator += 1;\\n                }\\n            }\\n            require(canTransfer, \\\"E046\\\");\\n        }\\n    }\\n\\n    function uri(uint fnftId) public view override returns (string memory) {\\n        return IMetadataHandler(addressesProvider.getMetadataHandler()).getTokenURI(fnftId);\\n    }\\n\\n    function renderTokenURI(\\n        uint tokenId,\\n        address owner\\n    ) public view returns (\\n        string memory baseRenderURI,\\n        string[] memory parameters\\n    ) {\\n        return IMetadataHandler(addressesProvider.getMetadataHandler()).getRenderTokenURI(tokenId, owner);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][account] = accountBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRevest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\ninterface IRevest {\\n    event FNFTTimeLockMinted(\\n        address indexed asset,\\n        address indexed from,\\n        uint indexed fnftId,\\n        uint endTime,\\n        uint[] quantities,\\n        FNFTConfig fnftConfig\\n    );\\n\\n    event FNFTValueLockMinted(\\n        address indexed primaryAsset,\\n        address indexed from,\\n        uint indexed fnftId,\\n        address compareTo,\\n        address oracleDispatch,\\n        uint[] quantities,\\n        FNFTConfig fnftConfig\\n    );\\n\\n    event FNFTAddressLockMinted(\\n        address indexed asset,\\n        address indexed from,\\n        uint indexed fnftId,\\n        address trigger,\\n        uint[] quantities,\\n        FNFTConfig fnftConfig\\n    );\\n\\n    event FNFTWithdrawn(\\n        address indexed from,\\n        uint indexed fnftId,\\n        uint indexed quantity\\n    );\\n\\n    event FNFTSplit(\\n        address indexed from,\\n        uint[] indexed newFNFTId,\\n        uint[] indexed proportions,\\n        uint quantity\\n    );\\n\\n    event FNFTUnlocked(\\n        address indexed from,\\n        uint indexed fnftId\\n    );\\n\\n    event FNFTMaturityExtended(\\n        address indexed from,\\n        uint indexed fnftId,\\n        uint indexed newExtendedTime\\n    );\\n\\n    event FNFTAddionalDeposited(\\n        address indexed from,\\n        uint indexed newFNFTId,\\n        uint indexed quantity,\\n        uint amount\\n    );\\n\\n    struct FNFTConfig {\\n        address asset; // The token being stored\\n        address pipeToContract; // Indicates if FNFT will pipe to another contract\\n        uint depositAmount; // How many tokens\\n        uint depositMul; // Deposit multiplier\\n        uint split; // Number of splits remaining\\n        uint depositStopTime; //\\n        bool maturityExtension; // Maturity extensions remaining\\n        bool isMulti; //\\n        bool nontransferrable; // False by default (transferrable) //\\n    }\\n\\n    // Refers to the global balance for an ERC20, encompassing possibly many FNFTs\\n    struct TokenTracker {\\n        uint lastBalance;\\n        uint lastMul;\\n    }\\n\\n    enum LockType {\\n        DoesNotExist,\\n        TimeLock,\\n        ValueLock,\\n        AddressLock\\n    }\\n\\n    struct LockParam {\\n        address addressLock;\\n        uint timeLockExpiry;\\n        LockType lockType;\\n        ValueLock valueLock;\\n    }\\n\\n    struct Lock {\\n        address addressLock;\\n        LockType lockType;\\n        ValueLock valueLock;\\n        uint timeLockExpiry;\\n        uint creationTime;\\n        bool unlocked;\\n    }\\n\\n    struct ValueLock {\\n        address asset;\\n        address compareTo;\\n        address oracle;\\n        uint unlockValue;\\n        bool unlockRisingEdge;\\n    }\\n\\n    function mintTimeLock(\\n        uint endTime,\\n        address[] memory recipients,\\n        uint[] memory quantities,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external payable returns (uint);\\n\\n    function mintValueLock(\\n        address primaryAsset,\\n        address compareTo,\\n        uint unlockValue,\\n        bool unlockRisingEdge,\\n        address oracleDispatch,\\n        address[] memory recipients,\\n        uint[] memory quantities,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external payable returns (uint);\\n\\n    function mintAddressLock(\\n        address trigger,\\n        bytes memory arguments,\\n        address[] memory recipients,\\n        uint[] memory quantities,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external payable returns (uint);\\n\\n    function withdrawFNFT(uint tokenUID, uint quantity) external;\\n\\n    function unlockFNFT(uint tokenUID) external;\\n\\n    function splitFNFT(\\n        uint fnftId,\\n        uint[] memory proportions,\\n        uint quantity\\n    ) external returns (uint[] memory newFNFTIds);\\n\\n    function depositAdditionalToFNFT(\\n        uint fnftId,\\n        uint amount,\\n        uint quantity\\n    ) external returns (uint);\\n\\n    function setFlatWeiFee(uint wethFee) external;\\n\\n    function setERC20Fee(uint erc20) external;\\n\\n    function getFlatWeiFee() external returns (uint);\\n\\n    function getERC20Fee() external returns (uint);\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Provider interface for Revest FNFTs\\n * @dev\\n *\\n */\\ninterface IAddressRegistry {\\n\\n    function initialize(\\n        address lock_manager_,\\n        address liquidity_,\\n        address revest_token_,\\n        address token_vault_,\\n        address revest_,\\n        address fnft_,\\n        address metadata_,\\n        address admin_,\\n        address rewards_\\n    ) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function setAdmin(address admin) external;\\n\\n    function getLockManager() external view returns (address);\\n\\n    function setLockManager(address manager) external;\\n\\n    function getTokenVault() external view returns (address);\\n\\n    function setTokenVault(address vault) external;\\n\\n    function getRevestFNFT() external view returns (address);\\n\\n    function setRevestFNFT(address fnft) external;\\n\\n    function getMetadataHandler() external view returns (address);\\n\\n    function setMetadataHandler(address metadata) external;\\n\\n    function getRevest() external view returns (address);\\n\\n    function setRevest(address revest) external;\\n\\n    function getDEX(uint index) external view returns (address);\\n\\n    function setDex(address dex) external;\\n\\n    function getRevestToken() external view returns (address);\\n\\n    function setRevestToken(address token) external;\\n\\n    function getRewardsHandler() external view returns(address);\\n\\n    function setRewardsHandler(address esc) external;\\n\\n    function getAddress(bytes32 id) external view returns (address);\\n\\n    function getLPs() external view returns (address);\\n\\n    function setLPs(address liquidToken) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILockManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IRevest.sol\\\";\\n\\ninterface ILockManager {\\n\\n    function createLock(uint fnftId, IRevest.LockParam memory lock) external returns (uint);\\n\\n    function getLock(uint lockId) external view returns (IRevest.Lock memory);\\n\\n    function fnftIdToLockId(uint fnftId) external view returns (uint);\\n\\n    function fnftIdToLock(uint fnftId) external view returns (IRevest.Lock memory);\\n\\n    function pointFNFTToLock(uint fnftId, uint lockId) external;\\n\\n    function lockTypes(uint tokenId) external view returns (IRevest.LockType);\\n\\n    function unlockFNFT(uint fnftId, address sender) external returns (bool);\\n\\n    function getLockMaturity(uint fnftId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IRevest.sol\\\";\\n\\ninterface ITokenVault {\\n\\n    function createFNFT(\\n        uint fnftId,\\n        IRevest.FNFTConfig memory fnftConfig,\\n        uint quantity,\\n        address from\\n    ) external;\\n\\n    function withdrawToken(\\n        uint fnftId,\\n        uint quantity,\\n        address user\\n    ) external;\\n\\n    function depositToken(\\n        uint fnftId,\\n        uint amount,\\n        uint quantity\\n    ) external;\\n\\n    function cloneFNFTConfig(IRevest.FNFTConfig memory old) external returns (IRevest.FNFTConfig memory);\\n\\n    function mapFNFTToToken(\\n        uint fnftId,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external;\\n\\n    function handleMultipleDeposits(\\n        uint fnftId,\\n        uint newFNFTId,\\n        uint amount\\n    ) external;\\n\\n    function splitFNFT(\\n        uint fnftId,\\n        uint[] memory newFNFTIds,\\n        uint[] memory proportions,\\n        uint quantity\\n    ) external;\\n\\n    function getFNFT(uint fnftId) external view returns (IRevest.FNFTConfig memory);\\n    function getFNFTCurrentValue(uint fnftId) external view returns (uint);\\n    function getNontransferable(uint fnftId) external view returns (bool);\\n    function getSplitsRemaining(uint fnftId) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IRegistryProvider.sol\\\";\\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\n\\n/**\\n * @title Provider interface for Revest FNFTs\\n * @dev Address locks MUST be non-upgradeable to be considered for trusted status\\n * @author Revest\\n */\\ninterface IAddressLock is IRegistryProvider, IERC165{\\n\\n    /// Creates a lock to the specified lockID\\n    /// @param fnftId the fnftId to map this lock to. Not recommended for typical locks, as it will break on splitting\\n    /// @param lockId the lockId to map this lock to. Recommended uint for storing references to lock configurations\\n    /// @param arguments an abi.encode() bytes array. Allows frontend to encode and pass in an arbitrary set of parameters\\n    /// @dev creates a lock for the specified lockId. Will be called during the creation process for address locks when the address\\n    ///      of a contract implementing this interface is passed in as the \\\"trigger\\\" address for minting an address lock. The bytes\\n    ///      representing any parameters this lock requires are passed through to this method, where abi.decode must be call on them\\n    function createLock(uint fnftId, uint lockId, bytes memory arguments) external;\\n\\n    /// Updates a lock at the specified lockId\\n    /// @param fnftId the fnftId that can map to a lock config stored in implementing contracts. Not recommended, as it will break on splitting\\n    /// @param lockId the lockId that maps to the lock config which should be updated. Recommended for retrieving references to lock configurations\\n    /// @param arguments an abi.encode() bytes array. Allows frontend to encode and pass in an arbitrary set of parameters\\n    /// @dev updates a lock for the specified lockId. Will be called by the frontend from the information section if an update is requested\\n    ///      can further accept and decode parameters to use in modifying the lock's config or triggering other actions\\n    ///      such as triggering an on-chain oracle to update\\n    function updateLock(uint fnftId, uint lockId, bytes memory arguments) external;\\n\\n    /// Whether or not the lock can be unlocked\\n    /// @param fnftId the fnftId that can map to a lock config stored in implementing contracts. Not recommended, as it will break on splitting\\n    /// @param lockId the lockId that maps to the lock config which should be updated. Recommended for retrieving references to lock configurations\\n    /// @dev this method is called during the unlocking and withdrawal processes by the Revest contract - it is also used by the frontend\\n    ///      if this method is returning true and someone attempts to unlock or withdraw from an FNFT attached to the requested lock, the request will succeed\\n    /// @return whether or not this lock may be unlocked\\n    function isUnlockable(uint fnftId, uint lockId) external view returns (bool);\\n\\n    /// Provides an encoded bytes arary that represents values this lock wants to display on the info screen\\n    /// Info to decode these values is provided in the metadata file\\n    /// @param fnftId the fnftId that can map to a lock config stored in implementing contracts. Not recommended, as it will break on splitting\\n    /// @param lockId the lockId that maps to the lock config which should be updated. Recommended for retrieving references to lock configurations\\n    /// @dev used by the frontend to fetch on-chain data on the state of any given lock\\n    /// @return a bytes array that represents the result of calling abi.encode on values which the developer wants to appear on the frontend\\n    function getDisplayValues(uint fnftId, uint lockId) external view returns (bytes memory);\\n\\n    /// Maps to a URL, typically IPFS-based, that contains information on how to encode and decode paramters sent to and from this lock\\n    /// Please see additional documentation for JSON config info\\n    /// @dev this method will be called by the frontend only but is crucial to properly implement for proper minting and information workflows\\n    /// @return a URL to the JSON file containing this lock's metadata schema\\n    function getMetadata() external view returns (string memory);\\n\\n    /// Whether or not this lock will need updates and should display the option for them\\n    /// @dev this will be called by the frontend to determine if update inputs and buttons should be displayed\\n    /// @return whether or not the locks created by this contract will need updates\\n    function needsUpdate() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RevestAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IAddressRegistry.sol\\\";\\nimport \\\"../interfaces/ILockManager.sol\\\";\\nimport \\\"../interfaces/IRewardsHandler.sol\\\";\\nimport \\\"../interfaces/ITokenVault.sol\\\";\\nimport \\\"../interfaces/IRevestToken.sol\\\";\\nimport \\\"../interfaces/IFNFTHandler.sol\\\";\\nimport \\\"../lib/uniswap/IUniswapV2Factory.sol\\\";\\nimport \\\"../interfaces/IInterestHandler.sol\\\";\\n\\n\\ncontract RevestAccessControl is Ownable {\\n    IAddressRegistry internal addressesProvider;\\n    address addressProvider;\\n\\n    constructor(address provider) Ownable() {\\n        addressesProvider = IAddressRegistry(provider);\\n        addressProvider = provider;\\n    }\\n\\n    modifier onlyRevest() {\\n        require(_msgSender() != address(0), \\\"E004\\\");\\n        require(\\n                _msgSender() == addressesProvider.getLockManager() ||\\n                _msgSender() == addressesProvider.getRewardsHandler() ||\\n                _msgSender() == addressesProvider.getTokenVault() ||\\n                _msgSender() == addressesProvider.getRevest() ||\\n                _msgSender() == addressesProvider.getRevestToken(),\\n            \\\"E016\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyRevestController() {\\n        require(_msgSender() != address(0), \\\"E004\\\");\\n        require(_msgSender() == addressesProvider.getRevest(), \\\"E017\\\");\\n        _;\\n    }\\n\\n    modifier onlyTokenVault() {\\n        require(_msgSender() != address(0), \\\"E004\\\");\\n        require(_msgSender() == addressesProvider.getTokenVault(), \\\"E017\\\");\\n        _;\\n    }\\n\\n    function setAddressRegistry(address registry) external onlyOwner {\\n        addressesProvider = IAddressRegistry(registry);\\n    }\\n\\n    function getAdmin() internal view returns (address) {\\n        return addressesProvider.getAdmin();\\n    }\\n\\n    function getRevest() internal view returns (IRevest) {\\n        return IRevest(addressesProvider.getRevest());\\n    }\\n\\n    function getRevestToken() internal view returns (IRevestToken) {\\n        return IRevestToken(addressesProvider.getRevestToken());\\n    }\\n\\n    function getLockManager() internal view returns (ILockManager) {\\n        return ILockManager(addressesProvider.getLockManager());\\n    }\\n\\n    function getTokenVault() internal view returns (ITokenVault) {\\n        return ITokenVault(addressesProvider.getTokenVault());\\n    }\\n\\n    function getUniswapV2() internal view returns (IUniswapV2Factory) {\\n        return IUniswapV2Factory(addressesProvider.getDEX(0));\\n    }\\n\\n    function getFNFTHandler() internal view returns (IFNFTHandler) {\\n        return IFNFTHandler(addressesProvider.getRevestFNFT());\\n    }\\n\\n    function getRewardsHandler() internal view returns (IRewardsHandler) {\\n        return IRewardsHandler(addressesProvider.getRewardsHandler());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFNFTHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\n\\ninterface IFNFTHandler  {\\n    function mint(address account, uint id, uint amount, bytes memory data) external;\\n\\n    function mintBatchRec(address[] memory recipients, uint[] memory quantities, uint id, uint newSupply, bytes memory data) external;\\n\\n    function mintBatch(address to, uint[] memory ids, uint[] memory amounts, bytes memory data) external;\\n\\n    function setURI(string memory newuri) external;\\n\\n    function burn(address account, uint id, uint amount) external;\\n\\n    function burnBatch(address account, uint[] memory ids, uint[] memory amounts) external;\\n\\n    function getBalance(address tokenHolder, uint id) external view returns (uint);\\n\\n    function getSupply(uint fnftId) external view returns (uint);\\n\\n    function getNextId() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMetadataHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMetadataHandler {\\n\\n    function getTokenURI(uint fnftId) external view returns (string memory );\\n\\n    function setTokenURI(uint fnftId, string memory _uri) external;\\n\\n    function getRenderTokenURI(\\n        uint tokenId,\\n        address owner\\n    ) external view returns (\\n        string memory baseRenderURI,\\n        string[] memory parameters\\n    );\\n\\n    function setRenderTokenURI(\\n        uint tokenID,\\n        string memory baseRenderURI\\n    ) external;\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistryProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IAddressRegistry.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/ILockManager.sol\\\";\\nimport \\\"../interfaces/ITokenVault.sol\\\";\\nimport \\\"../lib/uniswap/IUniswapV2Factory.sol\\\";\\n\\ninterface IRegistryProvider {\\n    function setAddressRegistry(address revest) external;\\n\\n    function getAddressRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/uniswap/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardsHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\ninterface IRewardsHandler {\\n\\n    struct UserBalance {\\n        uint allocPoint; // Allocation points\\n        uint lastMul;\\n    }\\n\\n    function receiveFee(address token, uint amount) external;\\n\\n    function updateLPShares(uint fnftId, uint newShares) external;\\n\\n    function updateBasicShares(uint fnftId, uint newShares) external;\\n\\n    function getAllocPoint(uint fnftId, address token, bool isBasic) external view returns (uint);\\n\\n    function claimRewards(uint fnftId, address caller) external returns (uint);\\n\\n    function setStakingContract(address stake) external;\\n\\n    function getRewards(uint fnftId, address token) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRevestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRevestToken is IERC20 {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\ninterface IInterestHandler  {\\n\\n    function registerDeposit(uint fnftId) external;\\n\\n    function getPrincipal(uint fnftId) external view returns (uint);\\n\\n    function getInterest(uint fnftId) external view returns (uint);\\n\\n    function getAmountToWithdraw(uint fnftId) external view returns (uint);\\n\\n    function getUnderlyingToken(uint fnftId) external view returns (address);\\n\\n    function getUnderlyingValue(uint fnftId) external view returns (uint);\\n\\n    //These methods exist for external operations\\n    function getPrincipalDetail(uint historic, uint amount, address asset) external view returns (uint);\\n\\n    function getInterestDetail(uint historic, uint amount, address asset) external view returns (uint);\\n\\n    function getUnderlyingTokenDetail(address asset) external view returns (address);\\n\\n    function getInterestRate(address asset) external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x55dbb68f69337fcabe261f296b50b4723d333830", "attacktype": "On-chain oracle manipulation, Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/xSNXAdmin.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"synthetix/contracts/interfaces/IFeePool.sol\\\";\\n\\nimport \\\"./TradeAccounting.sol\\\";\\n\\nimport \\\"./interface/IRebalancingSetIssuanceModule.sol\\\";\\nimport \\\"./interface/IxSNX.sol\\\";\\n\\nimport \\\"./DebtRepayment.sol\\\";\\n\\ncontract xSNXAdmin is Ownable, DebtRepayment {\\n    using SafeMath for uint256;\\n\\n    address\\n        private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private susdAddress;\\n    address private setAddress;\\n    address private snxAddress;\\n    address private setTransferProxy;\\n\\n    address private xsnxTokenAddress;\\n\\n    address private manager;\\n\\n    bytes32 constant susd = \\\"sUSD\\\";\\n\\n    bytes32 constant feePoolName = \\\"FeePool\\\";\\n    bytes32 constant synthetixName = \\\"Synthetix\\\";\\n    bytes32 constant rewardEscrowName = \\\"RewardEscrow\\\";\\n\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private constant LIQUIDATION_WAIT_PERIOD = 3 weeks;\\n\\n    ISynthetix private synthetix;\\n    TradeAccounting private tradeAccounting;\\n    IAddressResolver private addressResolver;\\n    IRebalancingSetIssuanceModule private rebalancingModule;\\n\\n    uint256 public lastClaimedTimestamp;\\n\\n    event RebalanceToSnx(uint256 timestamp, uint256 setSold);\\n    event RebalanceToHedge(uint256 timestamp, uint256 snxSold);\\n\\n    bytes32 constant rewardEscrowV2Name = \\\"RewardEscrowV2\\\";\\n\\n    bool newTokenAddressSet;\\n\\n    function initialize(\\n        address payable _tradeAccountingAddress,\\n        address _setAddress,\\n        address _snxAddress,\\n        address _susdAddress,\\n        address _setTransferProxy,\\n        address _addressResolver,\\n        address _rebalancingModule,\\n        address _ownerAddress\\n    ) public initializer {\\n        Ownable.initialize(_ownerAddress);\\n\\n        //Set parameters\\n        tradeAccounting = TradeAccounting(_tradeAccountingAddress);\\n        setAddress = _setAddress;\\n        snxAddress = _snxAddress;\\n        susdAddress = _susdAddress;\\n        setTransferProxy = _setTransferProxy;\\n        addressResolver = IAddressResolver(_addressResolver);\\n        rebalancingModule = IRebalancingSetIssuanceModule(_rebalancingModule);\\n\\n        lastClaimedTimestamp = block.timestamp;\\n    }\\n\\n    /*\\n     * @dev Function to transfer ETH to token contract on burn\\n     * @param valueToSend: token burn redemption value\\n     */\\n    function sendEthOnRedemption(uint256 valueToSend) public onlyTokenContract {\\n        (bool success, ) = xsnxTokenAddress.call.value(valueToSend)(\\\"\\\");\\n        require(success, \\\"Redeem transfer failed\\\");\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                   Fund Management                                         */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @notice Hedge strategy management function callable by admin\\n     * @dev Issues synths on Synthetix\\n     * @dev Exchanges sUSD for Set and ETH in terms defined by tradeAccounting.ETH_TARGET\\n     * @param mintAmount: sUSD to mint\\n     * @param minKyberRates: kyber.getExpectedRate([usdc=>eth, usdc=>currentSetAsset])\\n     * @param minCurveReturns: curve.get_dy_underlying([(ethAllocation, susd=>usdc), ((mintAmount.sub(ethAllocation)), susd>usdc)])\\n     * @param ethAllocation: tradeAccounting.getEthAllocationOnHedge(mintAmount)\\n     */\\n    function hedge(\\n        uint256 mintAmount,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        uint256 ethAllocation\\n    ) external onlyOwnerOrManager {\\n        _stake(mintAmount);\\n\\n        _allocateToEth(ethAllocation, minKyberRates[0], minCurveReturns[0]);\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _issueMaxSet(\\n            mintAmount.sub(ethAllocation),\\n            minKyberRates[1],\\n            activeAsset,\\n            minCurveReturns[1]\\n        );\\n    }\\n\\n    function _allocateToEth(\\n        uint256 _susdValue,\\n        uint256 _minKyberRate,\\n        uint256 _minCurveReturn\\n    ) private {\\n        _swapTokenToEther(\\n            susdAddress,\\n            _susdValue,\\n            _minKyberRate,\\n            _minCurveReturn\\n        );\\n    }\\n\\n    function _stake(uint256 mintAmount) private {\\n        ISynthetix(addressResolver.getAddress(synthetixName)).issueSynths(\\n            mintAmount\\n        );\\n    }\\n\\n    /*\\n     * @notice Claims weekly sUSD and SNX rewards\\n     * @notice Fixes c-ratio if necessary\\n     * @param susdToBurnToFixCollat: tradeAccounting.calculateSusdToBurnToFixRatioExternal()\\n     * @param minKyberRates: kyber.getExpectedRate[setAsset => usdc, usdc => eth]\\n     * @param minCurveReturns: curve.get_dy_underlying([(setAssetBalance, usdc=>susd), (susdBalance susd=>usdc)])\\n     * @param feesClaimable: feePool.isFeesClaimable(address(this)) - on Synthetix contract\\n     */\\n    function claim(\\n        uint256 susdToBurnToFixCollat,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        bool feesClaimable\\n    ) external onlyOwnerOrManager {\\n        lastClaimedTimestamp = block.timestamp;\\n\\n        if (!feesClaimable) {\\n            _redeemSet(susdToBurnToFixCollat);\\n            _swapTokenToToken(\\n                getAssetCurrentlyActiveInSet(),\\n                getActiveSetAssetBalance(),\\n                susdAddress,\\n                minKyberRates[0],\\n                minCurveReturns[0]\\n            );\\n            _burnSynths(getSusdBalance());\\n        }\\n\\n        IFeePool(addressResolver.getAddress(feePoolName)).claimFees();\\n\\n        // fee collection\\n        uint256 feeDivisor = IxSNX(xsnxTokenAddress).getClaimFeeDivisor();\\n        IERC20(susdAddress).transfer(\\n            xsnxTokenAddress,\\n            getSusdBalance().div(feeDivisor)\\n        );\\n\\n        _swapTokenToEther(\\n            susdAddress,\\n            getSusdBalance(),\\n            minKyberRates[1],\\n            minCurveReturns[1]\\n        );\\n    }\\n\\n    function _burnSynths(uint256 _amount) private {\\n        ISynthetix(addressResolver.getAddress(synthetixName)).burnSynths(\\n            _amount\\n        );\\n    }\\n\\n    function _swapTokenToEther(\\n        address _fromToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate,\\n        uint256 _minCurveReturn\\n    ) private {\\n        if (_amount > 0) {\\n            IERC20(_fromToken).transfer(address(tradeAccounting), _amount);\\n            tradeAccounting.swapTokenToEther(\\n                _fromToken,\\n                _amount,\\n                _minKyberRate,\\n                _minCurveReturn\\n            );\\n        }\\n    }\\n\\n    function _swapTokenToToken(\\n        address _fromToken,\\n        uint256 _amount,\\n        address _toToken,\\n        uint256 _minKyberRate,\\n        uint256 _minCurveReturn\\n    ) private {\\n        IERC20(_fromToken).transfer(address(tradeAccounting), _amount);\\n        tradeAccounting.swapTokenToToken(\\n            _fromToken,\\n            _amount,\\n            _toToken,\\n            _minKyberRate,\\n            _minCurveReturn\\n        );\\n    }\\n\\n    function _swapEtherToToken(\\n        address _toToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate\\n    ) private {\\n        if (_amount > 0) {\\n            (bool success, ) = address(tradeAccounting).call.value(_amount)(\\\"\\\");\\n            require(success, \\\"Not enough eth in contract\\\");\\n            tradeAccounting.swapEtherToToken(_toToken, _amount, _minKyberRate);\\n        }\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                      Rebalances                                           */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @notice Called when hedge assets value meaningfully exceeds debt liabilities\\n     * @dev Hedge assets (Set + ETH) > liabilities (debt) by more than rebalance threshold\\n     * @param: minRate: kyber.getExpectedRate(activeAsset=>snx)\\n     */\\n    function rebalanceTowardsSnx(uint256 minRate) external onlyOwnerOrManager {\\n        require(\\n            tradeAccounting.isRebalanceTowardsSnxRequired(),\\n            \\\"Rebalance unnecessary\\\"\\n        );\\n        (uint256 setToSell, address activeAsset) = tradeAccounting\\n            .getRebalanceTowardsSnxUtils();\\n\\n        _redeemRebalancingSet(setToSell);\\n\\n        _swapTokenToToken(\\n            activeAsset,\\n            getActiveSetAssetBalance(),\\n            snxAddress,\\n            minRate,\\n            0\\n        );\\n\\n        emit RebalanceToSnx(block.timestamp, setToSell);\\n    }\\n\\n    /*\\n     * @notice Called when debt value meaningfully exceeds value of hedge assets\\n     * @notice Allocates fully to ETH reserve\\n     * @dev `Liabilities (debt) > assets (Set + ETH)` by more than rebalance threshold\\n     * @param: totalSusdToBurn: tradeAccounting.getRebalanceTowardsHedgeUtils()\\n     * @param: minKyberRates: kyber.getExpectedRate([activeSetAsset => usdc, snx => eth])\\n     * @param: minCurveReturns: curve.get_dy_underlying([(expectedUsdcBalance, usdc=>susd), (0)])\\n     * @param: snxToSell: tradeAccounting.getRebalanceTowardsHedgeUtils()\\n     */\\n    function rebalanceTowardsHedge(\\n        uint256 totalSusdToBurn,\\n        uint256[] memory minKyberRates,\\n        uint256[] memory minCurveReturns,\\n        uint256 snxToSell\\n    ) public onlyOwnerOrManager {\\n        require(\\n            tradeAccounting.isRebalanceTowardsHedgeRequired(),\\n            \\\"Rebalance unnecessary\\\"\\n        );\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _unwindStakedPosition(\\n            totalSusdToBurn,\\n            activeAsset,\\n            minKyberRates,\\n            minCurveReturns,\\n            snxToSell\\n        );\\n        emit RebalanceToHedge(block.timestamp, snxToSell);\\n    }\\n\\n    /*\\n     * @notice Callable whenever ETH bal is less than (hedgeAssets / ETH_TARGET)\\n     * @dev Rebalances Set holdings to ETH holdings\\n     * @param minRate: kyber.getExpectedRate(activeAsset => ETH)\\n     */\\n    function rebalanceSetToEth(uint256 minRate) external onlyOwnerOrManager {\\n        uint256 redemptionQuantity = tradeAccounting\\n            .calculateSetToSellForRebalanceSetToEth();\\n        _redeemRebalancingSet(redemptionQuantity);\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        uint256 activeAssetBalance = getActiveSetAssetBalance();\\n        _swapTokenToEther(activeAsset, activeAssetBalance, minRate, 0);\\n    }\\n\\n    function _unwindStakedPosition(\\n        uint256 _totalSusdToBurn,\\n        address _activeAsset,\\n        uint256[] memory _minKyberRates,\\n        uint256[] memory _minCurveReturns,\\n        uint256 _snxToSell\\n    ) private {\\n        if (_totalSusdToBurn > 0) {\\n            _redeemSet(_totalSusdToBurn);\\n            _swapTokenToToken(\\n                _activeAsset,\\n                getActiveSetAssetBalance(),\\n                susdAddress,\\n                _minKyberRates[0],\\n                _minCurveReturns[0]\\n            );\\n            _burnSynths(getSusdBalance());\\n        }\\n\\n        _swapTokenToEther(snxAddress, _snxToSell, _minKyberRates[1], 0);\\n    }\\n\\n    /*\\n     * @notice Exit valve to reduce staked position in favor of liquid ETH\\n     * @notice Unlikely to be called in the normal course of mgmt\\n     * @params: refer to `rebalanceToHedge` for descriptions, however params here are discretionary\\n     */\\n    function unwindStakedPosition(\\n        uint256 totalSusdToBurn,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        uint256 snxToSell\\n    ) external onlyOwnerOrManager {\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _unwindStakedPosition(\\n            totalSusdToBurn,\\n            activeAsset,\\n            minKyberRates,\\n            minCurveReturns,\\n            snxToSell\\n        );\\n    }\\n\\n    /*\\n     * @notice Emergency exit valve to reduce staked position in favor of liquid ETH\\n     * in the event of operator failure/incapacitation\\n     * @dev: Params will depend on current C-RATIO, i.e., may not immediately be able\\n     * to liquidate all debt and SNX\\n     * @dev: May be callable multiple times as SNX escrow vests\\n     */\\n    function liquidationUnwind(\\n        uint256 totalSusdToBurn,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        uint256 snxToSell\\n    ) external {\\n        require(\\n            lastClaimedTimestamp.add(LIQUIDATION_WAIT_PERIOD) < block.timestamp,\\n            \\\"Liquidation not available\\\"\\n        );\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _unwindStakedPosition(\\n            totalSusdToBurn,\\n            activeAsset,\\n            minKyberRates,\\n            minCurveReturns,\\n            snxToSell\\n        );\\n\\n        uint256 susdBalRemaining = getSusdBalance();\\n        _swapTokenToEther(susdAddress, susdBalRemaining, 0, 0);\\n    }\\n\\n    /*\\n     * @dev Unlock escrowed SNX rewards\\n     * @param entryIDs: vesting entries\\n     */\\n    function vest(uint256[] memory entryIDs) public {\\n        IRewardEscrowV2 rewardEscrow = IRewardEscrowV2(\\n            addressResolver.getAddress(rewardEscrowV2Name)\\n        );\\n        rewardEscrow.vest(entryIDs);\\n    }\\n\\n    function setNewXsnxTokenAddress(address _newXsnxTokenAddress) external onlyOwnerOrManager {\\n        require(!newTokenAddressSet, \\\"New address already set\\\");\\n        newTokenAddressSet = true;\\n        xsnxTokenAddress = _newXsnxTokenAddress;\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                     Set Protocol                                          */\\n    /* ========================================================================================= */\\n\\n    function _issueMaxSet(\\n        uint256 _susdAmount,\\n        uint256 _minRate,\\n        address _activeAsset,\\n        uint256 _minCurveReturn\\n    ) private {\\n        if(_susdAmount > 0) {\\n            _swapTokenToToken(\\n                susdAddress,\\n                _susdAmount,\\n                _activeAsset,\\n                _minRate,\\n                _minCurveReturn\\n            );\\n\\n            uint256 issuanceQuantity = tradeAccounting\\n                .calculateSetIssuanceQuantity();\\n            rebalancingModule.issueRebalancingSet(\\n                setAddress,\\n                issuanceQuantity,\\n                false\\n            );\\n        }\\n    }\\n\\n    function _redeemSet(uint256 _totalSusdToBurn) private {\\n        uint256 redemptionQuantity = tradeAccounting\\n            .calculateSetRedemptionQuantity(_totalSusdToBurn);\\n        _redeemRebalancingSet(redemptionQuantity);\\n    }\\n\\n    function _redeemRebalancingSet(uint256 _redemptionQuantity) private {\\n        rebalancingModule.redeemRebalancingSet(\\n            setAddress,\\n            _redemptionQuantity,\\n            false\\n        );\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                        Utils                                              */\\n    /* ========================================================================================= */\\n\\n    function getAssetCurrentlyActiveInSet() internal view returns (address) {\\n        return tradeAccounting.getAssetCurrentlyActiveInSet();\\n    }\\n\\n    function getActiveSetAssetBalance() internal view returns (uint256) {\\n        return tradeAccounting.getActiveSetAssetBalance();\\n    }\\n\\n    function getSusdBalance() internal view returns (uint256) {\\n        return tradeAccounting.getSusdBalance();\\n    }\\n\\n    function setManagerAddress(address _manager) public onlyOwner {\\n        manager = _manager;\\n    }\\n\\n    modifier onlyOwnerOrManager {\\n        require(isOwner() || msg.sender == manager, \\\"Non-admin caller\\\");\\n        _;\\n    }\\n\\n    modifier onlyTokenContract {\\n        require(msg.sender == xsnxTokenAddress, \\\"Non token caller\\\");\\n        _;\\n    }\\n\\n    // approve [setComponentA, setComponentB] on deployment\\n    function approveSetTransferProxy(address tokenAddress) public onlyOwner {\\n        IERC20(tokenAddress).approve(setTransferProxy, MAX_UINT);\\n    }\\n\\n     /**\\n     * Swap snx for eth in contract\\n     */\\n    function swapSnxForEth(\\n        uint256 snxAmount,\\n        uint256 minKyberRate,\\n        uint256 minCurveReturn\\n    ) public onlyOwnerOrManager {\\n        _swapTokenToEther(snxAddress, snxAmount, minKyberRate, minCurveReturn);\\n    }\\n\\n    /**\\n     * Swap eth for snx in contract\\n     */\\n    function swapEthForSnx(\\n        uint256 ethAmount,\\n        uint256 minKyberRate\\n    ) public onlyOwnerOrManager {\\n        _swapEtherToToken(snxAddress, ethAmount, minKyberRate);\\n    }\\n\\n    /**\\n     * Repay sUSD debt with ETH in the contract\\n     */\\n    function repayDebtWithEth(uint256 amount, uint256 minKyberRate) public onlyOwnerOrManager {\\n        _swapEtherToToken(susdAddress, amount, minKyberRate);\\n        uint256 susdBalance = IERC20(susdAddress).balanceOf(address(this));\\n        _burnSynths(susdBalance);\\n    }\\n\\n    // Debt repayment logic\\n    // Used when c-ratio is below a certain threshold\\n    // And debt cannot be repaid due to locked SNX\\n\\n    function repayDebt(uint256 loanAmount, uint256 snxAmount) public onlyOwnerOrManager {\\n        super.repayDebt(loanAmount, snxAmount);\\n    }\\n\\n    function approveUsdc() external onlyOwnerOrManager {\\n        address soloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\\n        IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\n        USDC.approve(soloMargin, uint(-1));\\n    }\\n\\n    /**\\n    * Called as a callback to repayDebt()\\n    * Flash loan function which burns sUSD debt\\n    */\\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) public {\\n        (\\n            address payable actualSender,\\n            uint256 loanAmount,\\n            uint256 snxAmount\\n        ) = abi.decode(data, (\\n            address, uint256, uint256\\n        ));\\n        require(sender == address(this), \\\"Must be called using repayDebt\\\");\\n\\n        address usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n        // swap \\\"loanAmount\\\" USDC for sUSD\\n        _swapTokenToToken(usdcAddress, loanAmount, susdAddress, 0, 0);\\n\\n        uint256 susdBalance = IERC20(susdAddress).balanceOf(address(this));\\n        _burnSynths(susdBalance);\\n\\n        // swap SNX to sUSD and sUSD back to USDC to repay loan\\n        _swapTokenToToken(snxAddress, snxAmount, susdAddress, 0, 0);\\n        susdBalance = IERC20(susdAddress).balanceOf(address(this));\\n        // swap sUSD to USDC\\n        _swapTokenToToken(susdAddress, susdBalance, usdcAddress, 0, 0);\\n\\n        uint256 usdcBalance = IERC20(usdcAddress).balanceOf(address(this));\\n        \\n        require(usdcBalance > loanAmount + 2, \\\"cannot repay loan\\\");\\n    }\\n\\n    function() external payable {}\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Initializable, Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function initialize(address sender) public initializer {\\n        _owner = sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IFeePool.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\\ninterface IFeePool {\\n    // Views\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function FEE_ADDRESS() external view returns (address);\\n\\n    function feesAvailable(address account) external view returns (uint, uint);\\n\\n    function feePeriodDuration() external view returns (uint);\\n\\n    function isFeesClaimable(address account) external view returns (bool);\\n\\n    function targetThreshold() external view returns (uint);\\n\\n    function totalFeesAvailable() external view returns (uint);\\n\\n    function totalRewardsAvailable() external view returns (uint);\\n\\n    // Mutative Functions\\n    function claimFees() external returns (bool);\\n\\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\\n\\n    function closeCurrentFeePeriod() external;\\n\\n    // Restricted: used internally to Synthetix\\n    function appendAccountIssuanceRecord(\\n        address account,\\n        uint lockedAmount,\\n        uint debtEntryIndex\\n    ) external;\\n\\n    function recordFeePaid(uint sUSDAmount) external;\\n\\n    function setRewardsToDistribute(uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/TradeAccounting.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"synthetix/contracts/interfaces/ISynthetix.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IRewardEscrowV2.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IExchangeRates.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/ISynthetixState.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IAddressResolver.sol\\\";\\n\\nimport \\\"./interface/ISystemSettings.sol\\\";\\n\\nimport \\\"./interface/ICurveFi.sol\\\";\\nimport \\\"./interface/ISetToken.sol\\\";\\nimport \\\"./interface/IKyberNetworkProxy.sol\\\";\\nimport \\\"./interface/ISetAssetBaseCollateral.sol\\\";\\n\\n/* \\n\\txSNX Target Allocation (assuming 800% C-RATIO)\\n\\t----------------------\\n\\tAllocation         |  NAV   | % NAV\\n\\t--------------------------------------\\n\\t800 SNX @ $1/token | $800   | 100%\\n\\t100 sUSD Debt\\t   | ($100)\\t| (12.5%)\\n\\t75 USD equiv Set   | $75    | 9.375%\\n\\t25 USD equiv ETH   | $25    | 3.125%\\n\\t--------------------------------------\\n\\tTotal                $800   | 100%   \\n */\\n\\n/* \\n\\tConditions for `isRebalanceTowardsHedgeRequired` to return true\\n\\tAssuming 5% rebalance threshold\\n\\n\\tAllocation         |  NAV   | % NAV\\n\\t--------------------------------------\\n\\t800 SNX @ $1/token | $800   | 100.63%\\n\\t105 sUSD Debt\\t   | ($105)\\t| (13.21%)\\n\\t75 USD equiv Set   | $75    | 9.43%\\n\\t25 USD equiv ETH   | $25    | 3.14%\\n\\t--------------------------------------\\n\\tTotal                $795   | 100%   \\n\\n\\tDebt value\\t\\t   | $105\\n\\tHedge Assets\\t   | $100\\n\\t-------------------------\\n\\tDebt/hedge ratio   | 105%\\n  */\\n\\n/* \\n\\tConditions for `isRebalanceTowardsSnxRequired` to return true\\n\\tAssuming 5% rebalance threshold\\n\\n\\tAllocation         |  NAV   | % NAV\\n\\t--------------------------------------\\n\\t800 SNX @ $1/token | $800   | 99.37%\\n\\t100 sUSD Debt\\t   | ($100)\\t| (12.42%)\\n\\t75 USD equiv Set   | $75    | 9.31%\\n\\t30 USD equiv ETH   | $30    | 3.72%\\n\\t--------------------------------------\\n\\tTotal                $805   | 100%   \\n\\n\\tHedge Assets\\t   | $105\\n\\tDebt value\\t\\t   | $100\\n\\t-------------------------\\n\\tHedge/debt ratio   | 105%\\n  */\\n\\ncontract TradeAccounting is Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant TEN = 10;\\n    uint256 private constant DEC_18 = 1e18;\\n    uint256 private constant PERCENT = 100;\\n    uint256 private constant ETH_TARGET = 4; // targets 1/4th of hedge portfolio\\n    uint256 private constant SLIPPAGE_RATE = 99;\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private constant RATE_STALE_TIME = 28800; // 8 hours\\n    uint256 private constant REBALANCE_THRESHOLD = 105; // 5%\\n    uint256 private constant INITIAL_SUPPLY_MULTIPLIER = 10;\\n\\n    int128 usdcIndex;\\n    int128 susdIndex;\\n\\n    ICurveFi private curveFi;\\n    ISynthetixState private synthetixState;\\n    IAddressResolver private addressResolver;\\n    IKyberNetworkProxy private kyberNetworkProxy;\\n\\n    address private xSNXAdminInstance;\\n    address private addressValidator;\\n\\n    address private setAddress;\\n    address private susdAddress;\\n    address private usdcAddress;\\n\\n    address private nextCurveAddress;\\n\\n    bytes32 constant snx = \\\"SNX\\\";\\n    bytes32 constant susd = \\\"sUSD\\\";\\n    bytes32 constant seth = \\\"sETH\\\";\\n\\n    bytes32[2] synthSymbols;\\n\\n    address[2] setComponentAddresses;\\n\\n    bytes32 constant rewardEscrowName = \\\"RewardEscrow\\\";\\n    bytes32 constant exchangeRatesName = \\\"ExchangeRates\\\";\\n    bytes32 constant synthetixName = \\\"Synthetix\\\";\\n    bytes32 constant systemSettingsName = \\\"SystemSettings\\\";\\n    bytes32 constant rewardEscrowV2Name = \\\"RewardEscrowV2\\\";\\n\\n    uint256 private constant RATE_STALE_TIME_NEW = 86400; // 24 hours\\n\\n    function initialize(\\n        address _setAddress,\\n        address _kyberProxyAddress,\\n        address _addressResolver,\\n        address _susdAddress,\\n        address _usdcAddress,\\n        address _addressValidator,\\n        bytes32[2] memory _synthSymbols,\\n        address[2] memory _setComponentAddresses,\\n        address _ownerAddress\\n    ) public initializer {\\n        Ownable.initialize(_ownerAddress);\\n\\n        setAddress = _setAddress;\\n        kyberNetworkProxy = IKyberNetworkProxy(_kyberProxyAddress);\\n        addressResolver = IAddressResolver(_addressResolver);\\n        susdAddress = _susdAddress;\\n        usdcAddress = _usdcAddress;\\n        addressValidator = _addressValidator;\\n        synthSymbols = _synthSymbols;\\n        setComponentAddresses = _setComponentAddresses;\\n    }\\n\\n    modifier onlyXSNXAdmin {\\n        require(\\n            msg.sender == xSNXAdminInstance,\\n            \\\"Only xSNXAdmin contract can call\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                         Kyber/Curve                                       */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Function that processes all token to token exchanges,\\n     * sometimes via Kyber and sometimes via a combination of Kyber & Curve\\n     * @dev Only callable by xSNXAdmin contract\\n     */\\n    function swapTokenToToken(\\n        address fromToken,\\n        uint256 amount,\\n        address toToken,\\n        uint256 minKyberRate,\\n        uint256 minCurveReturn\\n    ) public onlyXSNXAdmin {\\n        if (fromToken == susdAddress) {\\n            _exchangeUnderlying(susdIndex, usdcIndex, amount, minCurveReturn);\\n\\n            if (toToken != usdcAddress) {\\n                uint256 usdcBal = getUsdcBalance();\\n                _swapTokenToToken(usdcAddress, usdcBal, toToken, minKyberRate);\\n            }\\n        } else if (toToken == susdAddress) {\\n            if (fromToken != usdcAddress) {\\n                _swapTokenToToken(fromToken, amount, usdcAddress, minKyberRate);\\n            }\\n\\n            uint256 usdcBal = getUsdcBalance();\\n            _exchangeUnderlying(usdcIndex, susdIndex, usdcBal, minCurveReturn);\\n        } else {\\n            _swapTokenToToken(fromToken, amount, toToken, minKyberRate);\\n        }\\n\\n        IERC20(toToken).transfer(\\n            xSNXAdminInstance,\\n            IERC20(toToken).balanceOf(address(this))\\n        );\\n    }\\n\\n    function _swapTokenToToken(\\n        address _fromToken,\\n        uint256 _amount,\\n        address _toToken,\\n        uint256 _minKyberRate\\n    ) private {\\n        kyberNetworkProxy.swapTokenToToken(\\n            ERC20(_fromToken),\\n            _amount,\\n            ERC20(_toToken),\\n            _minKyberRate\\n        );\\n    }\\n\\n    /*\\n     * @dev Function that processes all token to ETH exchanges,\\n     * sometimes via Kyber and sometimes via a combination of Kyber & Curve\\n     * @dev Only callable by xSNXAdmin contract\\n     */\\n    function swapTokenToEther(\\n        address fromToken,\\n        uint256 amount,\\n        uint256 minKyberRate,\\n        uint256 minCurveReturn\\n    ) public onlyXSNXAdmin {\\n        if (fromToken == susdAddress) {\\n            _exchangeUnderlying(susdIndex, usdcIndex, amount, minCurveReturn);\\n\\n            uint256 usdcBal = getUsdcBalance();\\n            _swapTokenToEther(usdcAddress, usdcBal, minKyberRate);\\n        } else {\\n            _swapTokenToEther(fromToken, amount, minKyberRate);\\n        }\\n\\n        uint256 ethBal = address(this).balance;\\n        (bool success, ) = msg.sender.call.value(ethBal)(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function _swapTokenToEther(\\n        address _fromToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate\\n    ) private {\\n        kyberNetworkProxy.swapTokenToEther(\\n            ERC20(_fromToken),\\n            _amount,\\n            _minKyberRate\\n        );\\n    }\\n\\n    /*\\n     * @dev Function that processes all ETH to token exchanges\\n     * @dev Processed using kyber\\n     * @dev Only callable by xSNXAdmin contract\\n     */\\n    function swapEtherToToken(\\n        address toToken,\\n        uint256 amount,\\n        uint256 minKyberRate\\n    ) public onlyXSNXAdmin {\\n        _swapEtherToToken(toToken, amount, minKyberRate);\\n        IERC20(toToken).transfer(\\n            xSNXAdminInstance,\\n            IERC20(toToken).balanceOf(address(this))\\n        );\\n    }\\n\\n    function _swapEtherToToken(\\n        address _toToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate\\n    ) private {\\n        kyberNetworkProxy.swapEtherToToken.value(_amount)(\\n            ERC20(_toToken),\\n            _minKyberRate\\n        );\\n    }\\n\\n    function _exchangeUnderlying(\\n        int128 _inputIndex,\\n        int128 _outputIndex,\\n        uint256 _amount,\\n        uint256 _minReturn\\n    ) private {\\n        curveFi.exchange_underlying(\\n            _inputIndex,\\n            _outputIndex,\\n            _amount,\\n            _minReturn\\n        );\\n    }\\n\\n    function getUsdcBalance() internal view returns (uint256) {\\n        return IERC20(usdcAddress).balanceOf(address(this));\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                          NAV                                              */\\n    /* ========================================================================================= */\\n\\n    function getEthBalance() public view returns (uint256) {\\n        return address(xSNXAdminInstance).balance;\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.burn` that outputs NAV\\n     * redemption value in ETH terms\\n     * @param totalSupply: xSNX.totalSupply()\\n     * @param tokensToRedeem: xSNX to burn\\n     */\\n    function calculateRedemptionValue(\\n        uint256 totalSupply,\\n        uint256 tokensToRedeem\\n    ) public view returns (uint256 valueToRedeem) {\\n        uint256 snxBalanceOwned = getSnxBalanceOwned();\\n        uint256 contractDebtValue = getContractDebtValue();\\n\\n        uint256 pricePerToken = calculateRedeemTokenPrice(\\n            totalSupply,\\n            snxBalanceOwned,\\n            contractDebtValue\\n        );\\n\\n        valueToRedeem = pricePerToken.mul(tokensToRedeem).div(DEC_18);\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.mint` that\\n     * 1) determines whether ETH contribution should be maintained in ETH or exchanged for SNX and\\n     * 2) outputs the `nonSnxAssetValue` value to be used in NAV calculation\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function getMintWithEthUtils(uint256 totalSupply)\\n        public\\n        view\\n        returns (bool allocateToEth, uint256 nonSnxAssetValue)\\n    {\\n        uint256 setHoldingsInWei = getSetHoldingsValueInWei();\\n\\n        // called before eth transferred from xSNX to xSNXAdmin\\n        uint256 ethBalBefore = getEthBalance();\\n        \\n        allocateToEth = shouldAllocateEthToEthReserve(\\n            setHoldingsInWei,\\n            ethBalBefore,\\n            totalSupply\\n        );\\n        nonSnxAssetValue = setHoldingsInWei.add(ethBalBefore);\\n    }\\n\\n    /*\\n     * @notice xSNX system targets 25% of hedge portfolio to be maintained in ETH\\n     * @dev Function produces binary yes allocate/no allocate decision point\\n     * determining whether ETH sent on xSNX.mint() is held or exchanged\\n     * @param setHoldingsInWei: value of Set portfolio in ETH terms\\n     * @param ethBalBefore: value of ETH reserve prior to tx\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function shouldAllocateEthToEthReserve(\\n        uint256 setHoldingsInWei,\\n        uint256 ethBalBefore,\\n        uint256 totalSupply\\n    ) public pure returns (bool allocateToEth) {\\n        if (totalSupply == 0) return false;\\n\\n        if (ethBalBefore.mul(ETH_TARGET) < ethBalBefore.add(setHoldingsInWei)) {\\n            // ETH reserve is under target\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /*\\n     * @dev Helper function for calculateIssueTokenPrice\\n     * @dev Called indirectly by `xSNX.mint` and `xSNX.mintWithSnx`\\n     * @dev Calculates NAV of the fund, including value of escrowed SNX, in ETH terms\\n     * @param weiPerOneSnx: SNX price in ETH terms\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param nonSnxAssetValue: NAV of non-SNX slice of fund\\n     */\\n    function calculateNetAssetValueOnMint(\\n        uint256 weiPerOneSnx,\\n        uint256 snxBalanceBefore,\\n        uint256 nonSnxAssetValue\\n    ) internal view returns (uint256) {\\n        uint256 snxTokenValueInWei = snxBalanceBefore.mul(weiPerOneSnx).div(\\n            DEC_18\\n        );\\n        uint256 contractDebtValue = getContractDebtValue();\\n        uint256 contractDebtValueInWei = calculateDebtValueInWei(\\n            contractDebtValue\\n        );\\n        return\\n            snxTokenValueInWei.add(nonSnxAssetValue).sub(\\n                contractDebtValueInWei\\n            );\\n    }\\n\\n    /*\\n     * @dev Helper function for calculateRedeemTokenPrice\\n     * @dev Called indirectly by `xSNX.burn`\\n     * @dev Calculates NAV of the fund, excluding value of escrowed SNX, in ETH terms\\n     * @param weiPerOneSnx: SNX price in ETH terms\\n     * @param snxBalanceOwned: non-escrowed SNX balance\\n     * @param contractDebtValueInWei: sUSD debt balance of fund in ETH terms\\n     */\\n    function calculateNetAssetValueOnRedeem(\\n        uint256 weiPerOneSnx,\\n        uint256 snxBalanceOwned,\\n        uint256 contractDebtValueInWei\\n    ) internal view returns (uint256) {\\n        uint256 snxTokenValueInWei = snxBalanceOwned.mul(weiPerOneSnx).div(\\n            DEC_18\\n        );\\n        uint256 nonSnxAssetValue = calculateNonSnxAssetValue();\\n        return\\n            snxTokenValueInWei.add(nonSnxAssetValue).sub(\\n                contractDebtValueInWei\\n            );\\n    }\\n\\n    /*\\n     * @dev NAV value of non-SNX assets, computed in ETH terms\\n     */\\n    function calculateNonSnxAssetValue() internal view returns (uint256) {\\n        return getSetHoldingsValueInWei().add(getEthBalance());\\n    }\\n\\n    /*\\n     * @dev SNX price in ETH terms, calculated for purposes of redemption NAV\\n     * @notice Return value discounted slightly to better represent liquidation price\\n     */\\n    function getWeiPerOneSnxOnRedeem()\\n        internal\\n        view\\n        returns (uint256 weiPerOneSnx)\\n    {\\n        uint256 snxUsdPrice = getSnxPrice();\\n        uint256 ethUsdPrice = getSynthPrice(seth);\\n        weiPerOneSnx = snxUsdPrice\\n            .mul(DEC_18)\\n            .div(ethUsdPrice)\\n            .mul(SLIPPAGE_RATE) // used to better represent liquidation price as volume scales\\n            .div(PERCENT);\\n    }\\n\\n    /*\\n     * @dev Returns Synthetix synth symbol for asset currently held in TokenSet (e.g., sETH for WETH)\\n     * @notice xSNX contract complex only compatible with Sets that hold a single asset at a time\\n     */\\n    function getActiveAssetSynthSymbol()\\n        internal\\n        view\\n        returns (bytes32 synthSymbol)\\n    {\\n        synthSymbol = getAssetCurrentlyActiveInSet() == setComponentAddresses[0]\\n            ? (synthSymbols[0])\\n            : (synthSymbols[1]);\\n    }\\n\\n    /*\\n     * @dev Returns SNX price in ETH terms, calculated for purposes of issuance NAV (when allocateToEth)\\n     */\\n    function getWeiPerOneSnxOnMint() internal view returns (uint256) {\\n        uint256 snxUsd = getSynthPrice(snx);\\n        uint256 ethUsd = getSynthPrice(seth);\\n        return snxUsd.mul(DEC_18).div(ethUsd);\\n    }\\n\\n    /*\\n     * @dev Single use function to define initial xSNX issuance\\n     */\\n    function getInitialSupply() internal view returns (uint256) {\\n        return\\n            IERC20(addressResolver.getAddress(synthetixName))\\n                .balanceOf(xSNXAdminInstance)\\n                .mul(INITIAL_SUPPLY_MULTIPLIER);\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.mint` that calculates token issuance\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param ethContributed: ETH payable on mint, less fees\\n     * @param nonSnxAssetValue: NAV of non-SNX slice of fund\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function calculateTokensToMintWithEth(\\n        uint256 snxBalanceBefore,\\n        uint256 ethContributed,\\n        uint256 nonSnxAssetValue,\\n        uint256 totalSupply\\n    ) public view returns (uint256) {\\n        if (totalSupply == 0) {\\n            return getInitialSupply();\\n        }\\n\\n        uint256 pricePerToken = calculateIssueTokenPrice(\\n            getWeiPerOneSnxOnMint(),\\n            snxBalanceBefore,\\n            nonSnxAssetValue,\\n            totalSupply\\n        );\\n\\n        return ethContributed.mul(DEC_18).div(pricePerToken);\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.mintWithSnx` that calculates token issuance\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param snxAddedToBalance: SNX contributed by mint\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function calculateTokensToMintWithSnx(\\n        uint256 snxBalanceBefore,\\n        uint256 snxAddedToBalance,\\n        uint256 totalSupply\\n    ) public view returns (uint256) {\\n        if (totalSupply == 0) {\\n            return getInitialSupply();\\n        }\\n\\n        uint256 weiPerOneSnx = getWeiPerOneSnxOnMint();\\n        // need to derive snx contribution in eth terms for NAV calc\\n        uint256 proxyEthContribution = weiPerOneSnx.mul(snxAddedToBalance).div(\\n            DEC_18\\n        );\\n        uint256 nonSnxAssetValue = calculateNonSnxAssetValue();\\n        uint256 pricePerToken = calculateIssueTokenPrice(\\n            weiPerOneSnx,\\n            snxBalanceBefore,\\n            nonSnxAssetValue,\\n            totalSupply\\n        );\\n        return proxyEthContribution.mul(DEC_18).div(pricePerToken);\\n    }\\n\\n    /*\\n     * @dev Called indirectly by `xSNX.mint` and `xSNX.mintWithSnx`\\n     * @dev Calculates token price on issuance, including value of escrowed SNX\\n     * @param weiPerOneSnx: SNX price in ETH terms\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param nonSnxAssetValue: Non-SNX slice of fund\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function calculateIssueTokenPrice(\\n        uint256 weiPerOneSnx,\\n        uint256 snxBalanceBefore,\\n        uint256 nonSnxAssetValue,\\n        uint256 totalSupply\\n    ) public view returns (uint256 pricePerToken) {\\n        pricePerToken = calculateNetAssetValueOnMint(\\n            weiPerOneSnx,\\n            snxBalanceBefore,\\n            nonSnxAssetValue\\n        )\\n            .mul(DEC_18)\\n            .div(totalSupply);\\n    }\\n\\n    /*\\n     * @dev Called indirectly by `xSNX.burn`\\n     * @dev Calculates token price on redemption, excluding value of escrowed SNX\\n     * @param totalSupply: xSNX.totalSupply()\\n     * @param snxBalanceOwned: non-escrowed SNX balance\\n     * @param contractDebtValue: sUSD debt in USD terms\\n     */\\n    function calculateRedeemTokenPrice(\\n        uint256 totalSupply,\\n        uint256 snxBalanceOwned,\\n        uint256 contractDebtValue\\n    ) public view returns (uint256 pricePerToken) {\\n        // SNX won't actually be sold (burns are only distributed in available ETH) but\\n        // this is a proxy for the return value of SNX that would be sold\\n        uint256 weiPerOneSnx = getWeiPerOneSnxOnRedeem();\\n\\n        uint256 debtValueInWei = calculateDebtValueInWei(contractDebtValue);\\n        pricePerToken = calculateNetAssetValueOnRedeem(\\n            weiPerOneSnx,\\n            snxBalanceOwned,\\n            debtValueInWei\\n        )\\n            .mul(DEC_18)\\n            .div(totalSupply);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                          Set                                              */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Balance of underlying asset \\\"active\\\" in Set (e.g., WETH or USDC)\\n     */\\n    function getActiveSetAssetBalance() public view returns (uint256) {\\n        return\\n            IERC20(getAssetCurrentlyActiveInSet()).balanceOf(xSNXAdminInstance);\\n    }\\n\\n    /*\\n     * @dev Calculates quantity of Set Token equivalent to quantity of underlying asset token\\n     * @notice rebalancingSetQuantity return value is reduced slightly to ensure successful execution\\n     * @param componentQuantity: balance of underlying Set asset, e.g., WETH\\n     */\\n    function calculateSetQuantity(uint256 componentQuantity)\\n        public\\n        view\\n        returns (uint256 rebalancingSetQuantity)\\n    {\\n        uint256 baseSetNaturalUnit = getBaseSetNaturalUnit();\\n        uint256 baseSetComponentUnits = getBaseSetComponentUnits();\\n        uint256 baseSetIssuable = componentQuantity.mul(baseSetNaturalUnit).div(\\n            baseSetComponentUnits\\n        );\\n\\n        uint256 rebalancingSetNaturalUnit = getSetNaturalUnit();\\n        uint256 unitShares = getSetUnitShares();\\n        rebalancingSetQuantity = baseSetIssuable\\n            .mul(rebalancingSetNaturalUnit)\\n            .div(unitShares)\\n            .mul(99) // ensure sufficient balance in underlying asset\\n            .div(100)\\n            .div(rebalancingSetNaturalUnit)\\n            .mul(rebalancingSetNaturalUnit);\\n    }\\n\\n    /*\\n     * @dev Calculates mintable quantity of Set Token given asset holdings\\n     */\\n    function calculateSetIssuanceQuantity()\\n        public\\n        view\\n        returns (uint256 rebalancingSetIssuable)\\n    {\\n        uint256 componentQuantity = getActiveSetAssetBalance();\\n        rebalancingSetIssuable = calculateSetQuantity(componentQuantity);\\n    }\\n\\n    /*\\n     * @dev Calculates Set token to sell given sUSD burn requirements\\n     * @param totalSusdToBurn: sUSD to burn to fix ratio or unlock staked SNX\\n     */\\n    function calculateSetRedemptionQuantity(uint256 totalSusdToBurn)\\n        public\\n        view\\n        returns (uint256 rebalancingSetRedeemable)\\n    {\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n\\n        bytes32 activeAssetSynthSymbol = getActiveAssetSynthSymbol();\\n        uint256 synthUsd = getSynthPrice(activeAssetSynthSymbol);\\n\\n        // expectedSetAssetRate = amount of current set asset needed to redeem for 1 sUSD\\n        uint256 expectedSetAssetRate = DEC_18.mul(DEC_18).div(synthUsd);\\n\\n        uint256 setAssetCollateralToSell = expectedSetAssetRate\\n            .mul(totalSusdToBurn)\\n            .div(DEC_18)\\n            .mul(103) // err on the high side\\n            .div(PERCENT);\\n\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        setAssetCollateralToSell = setAssetCollateralToSell.mul(decimals).div(\\n            DEC_18\\n        );\\n\\n        rebalancingSetRedeemable = calculateSetQuantity(\\n            setAssetCollateralToSell\\n        );\\n    }\\n\\n    /*\\n     * @dev Calculates value of a single 1e18 Set unit in ETH terms\\n     */\\n    function calculateEthValueOfOneSetUnit()\\n        internal\\n        view\\n        returns (uint256 ethValue)\\n    {\\n        uint256 unitShares = getSetUnitShares();\\n        uint256 rebalancingSetNaturalUnit = getSetNaturalUnit();\\n        uint256 baseSetRequired = DEC_18.mul(unitShares).div(\\n            rebalancingSetNaturalUnit\\n        );\\n\\n        uint256 unitsOfUnderlying = getBaseSetComponentUnits();\\n        uint256 baseSetNaturalUnit = getBaseSetNaturalUnit();\\n        uint256 componentRequired = baseSetRequired.mul(unitsOfUnderlying).div(\\n            baseSetNaturalUnit\\n        );\\n\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        componentRequired = componentRequired.mul(DEC_18).div(decimals);\\n\\n        bytes32 activeAssetSynthSymbol = getActiveAssetSynthSymbol();\\n\\n        uint256 synthUsd = getSynthPrice(activeAssetSynthSymbol);\\n        uint256 ethUsd = getSynthPrice(seth);\\n        ethValue = componentRequired.mul(synthUsd).div(ethUsd);\\n    }\\n\\n    /*\\n     * @dev Calculates value of Set Holdings in ETH terms\\n     */\\n    function getSetHoldingsValueInWei()\\n        public\\n        view\\n        returns (uint256 setValInWei)\\n    {\\n        uint256 setCollateralTokens = getSetCollateralTokens();\\n        bytes32 synthSymbol = getActiveAssetSynthSymbol();\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n\\n        uint256 synthUsd = getSynthPrice(synthSymbol);\\n        uint256 ethUsd = getSynthPrice(seth);\\n\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        setCollateralTokens = setCollateralTokens.mul(DEC_18).div(decimals);\\n        setValInWei = setCollateralTokens.mul(synthUsd).div(ethUsd);\\n    }\\n\\n    function getBaseSetNaturalUnit() internal view returns (uint256) {\\n        return getCurrentCollateralSet().naturalUnit();\\n    }\\n\\n    /*\\n     * @dev Outputs current active Set asset\\n     * @notice xSNX contracts complex only compatible with Sets that hold a single asset at a time\\n     */\\n    function getAssetCurrentlyActiveInSet() public view returns (address) {\\n        address[] memory currentAllocation = getCurrentCollateralSet()\\n            .getComponents();\\n        return currentAllocation[0];\\n    }\\n\\n    function getCurrentCollateralSet()\\n        internal\\n        view\\n        returns (ISetAssetBaseCollateral)\\n    {\\n        return ISetAssetBaseCollateral(getCurrentSet());\\n    }\\n\\n    function getCurrentSet() internal view returns (address) {\\n        return ISetToken(setAddress).currentSet();\\n    }\\n\\n    /*\\n     * @dev Returns the number of underlying tokens in the current Set asset\\n     * e.g., the contract's Set holdings are collateralized by 10.4 WETH\\n     */\\n    function getSetCollateralTokens() internal view returns (uint256) {\\n        return\\n            getSetBalanceCollateral().mul(getBaseSetComponentUnits()).div(\\n                getBaseSetNaturalUnit()\\n            );\\n    }\\n\\n    function getSetBalanceCollateral() internal view returns (uint256) {\\n        uint256 unitShares = getSetUnitShares();\\n        uint256 naturalUnit = getSetNaturalUnit();\\n        return getContractSetBalance().mul(unitShares).div(naturalUnit);\\n    }\\n\\n    function getSetUnitShares() internal view returns (uint256) {\\n        return ISetToken(setAddress).unitShares();\\n    }\\n\\n    function getSetNaturalUnit() internal view returns (uint256) {\\n        return ISetToken(setAddress).naturalUnit();\\n    }\\n\\n    function getContractSetBalance() internal view returns (uint256) {\\n        return IERC20(setAddress).balanceOf(xSNXAdminInstance);\\n    }\\n\\n    function getBaseSetComponentUnits() internal view returns (uint256) {\\n        return ISetAssetBaseCollateral(getCurrentSet()).getUnits()[0];\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                         Synthetix\\t                                     */\\n    /* ========================================================================================= */\\n\\n    function getSusdBalance() public view returns (uint256) {\\n        return IERC20(susdAddress).balanceOf(xSNXAdminInstance);\\n    }\\n\\n    function getSnxBalance() public view returns (uint256) {\\n        return getSnxBalanceOwned().add(getSnxBalanceEscrowed());\\n    }\\n\\n    function getSnxBalanceOwned() internal view returns (uint256) {\\n        return\\n            IERC20(addressResolver.getAddress(synthetixName)).balanceOf(\\n                xSNXAdminInstance\\n            );\\n    }\\n\\n    function getSnxBalanceEscrowed() internal view returns (uint256) {\\n        return\\n            IRewardEscrowV2(addressResolver.getAddress(rewardEscrowV2Name))\\n                .balanceOf(xSNXAdminInstance);\\n    }\\n\\n    function getContractEscrowedSnxValue() internal view returns (uint256) {\\n        return getSnxBalanceEscrowed().mul(getSnxPrice()).div(DEC_18);\\n    }\\n\\n    function getContractOwnedSnxValue() internal view returns (uint256) {\\n        return getSnxBalanceOwned().mul(getSnxPrice()).div(DEC_18);\\n    }\\n\\n    function getSnxPrice() internal view returns (uint256) {\\n        (uint256 rate, uint256 time) = IExchangeRates(\\n            addressResolver.getAddress(exchangeRatesName)\\n        )\\n            .rateAndUpdatedTime(snx);\\n        require(time.add(RATE_STALE_TIME_NEW) > block.timestamp, \\\"Rate stale\\\");\\n        return rate;\\n    }\\n\\n    function getSynthPrice(bytes32 synth) internal view returns (uint256) {\\n        (uint256 rate, uint256 time) = IExchangeRates(\\n            addressResolver.getAddress(exchangeRatesName)\\n        )\\n            .rateAndUpdatedTime(synth);\\n        if (synth != susd) {\\n            require(time.add(RATE_STALE_TIME_NEW) > block.timestamp, \\\"Rate stale\\\");\\n        }\\n        return rate;\\n    }\\n\\n    /*\\n     * @dev Converts sUSD debt value into ETH terms\\n     * @param debtValue: sUSD-denominated debt value\\n     */\\n    function calculateDebtValueInWei(uint256 debtValue)\\n        internal\\n        view\\n        returns (uint256 debtBalanceInWei)\\n    {\\n        uint256 ethUsd = getSynthPrice(seth);\\n        debtBalanceInWei = debtValue.mul(DEC_18).div(ethUsd);\\n    }\\n\\n    function getContractDebtValue() internal view returns (uint256) {\\n        return\\n            ISynthetix(addressResolver.getAddress(synthetixName)).debtBalanceOf(\\n                xSNXAdminInstance,\\n                susd\\n            );\\n    }\\n\\n    /*\\n     * @notice Returns inverse of target C-RATIO\\n     */\\n    function getIssuanceRatio() internal view returns (uint256) {\\n        return\\n            ISystemSettings(addressResolver.getAddress(systemSettingsName))\\n                .issuanceRatio();\\n    }\\n\\n    /*\\n     * @notice Returns NAV contribution of SNX holdings in USD terms\\n     */\\n    function getContractSnxValue() internal view returns (uint256) {\\n        return getSnxBalance().mul(getSnxPrice()).div(DEC_18);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                       Burning sUSD                                        */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Calculates sUSD to burn to restore C-RATIO\\n     * @param snxValueHeld: USD value of SNX\\n     * @param contractDebtValue: USD value of sUSD debt\\n     * @param issuanceRatio: Synthetix C-RATIO requirement\\n     */\\n    function calculateSusdToBurnToFixRatio(\\n        uint256 snxValueHeld,\\n        uint256 contractDebtValue,\\n        uint256 issuanceRatio\\n    ) internal pure returns (uint256) {\\n        uint256 subtractor = issuanceRatio.mul(snxValueHeld).div(DEC_18);\\n\\n        if (subtractor > contractDebtValue) return 0;\\n        return contractDebtValue.sub(subtractor);\\n    }\\n\\n    /*\\n     * @dev Calculates sUSD to burn to restore C-RATIO\\n     */\\n    function calculateSusdToBurnToFixRatioExternal()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 snxValueHeld = getContractSnxValue();\\n        uint256 debtValue = getContractDebtValue();\\n        uint256 issuanceRatio = getIssuanceRatio();\\n        return\\n            calculateSusdToBurnToFixRatio(\\n                snxValueHeld,\\n                debtValue,\\n                issuanceRatio\\n            );\\n    }\\n\\n    /*\\n     * @dev Calculates sUSD to burn to eclipse value of escrowed SNX\\n     * @notice Synthetix system requires escrowed SNX to be \\\"unlocked\\\" first\\n     * @param issuanceRatio: Synthetix C-RATIO requirement\\n     */\\n    function calculateSusdToBurnToEclipseEscrowed(uint256 issuanceRatio)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 escrowedSnxValue = getContractEscrowedSnxValue();\\n        if (escrowedSnxValue == 0) return 0;\\n\\n        return escrowedSnxValue.mul(issuanceRatio).div(DEC_18);\\n    }\\n\\n    /*\\n     * @dev Helper function to calculate sUSD burn required for a potential redemption\\n     * @param tokensToRedeem: potential tokens to burn\\n     * @param totalSupply: xSNX.totalSupply()\\n     * @param contractDebtValue: sUSD debt value\\n     * @param issuanceRatio: Synthetix C-RATIO requirement\\n     */\\n    function calculateSusdToBurnForRedemption(\\n        uint256 tokensToRedeem,\\n        uint256 totalSupply,\\n        uint256 contractDebtValue,\\n        uint256 issuanceRatio\\n    ) public view returns (uint256 susdToBurn) {\\n        uint256 nonEscrowedSnxValue = getContractOwnedSnxValue();\\n        uint256 lockedSnxValue = contractDebtValue.mul(DEC_18).div(\\n            issuanceRatio\\n        );\\n        uint256 valueOfSnxToSell = nonEscrowedSnxValue.mul(tokensToRedeem).div(\\n            totalSupply\\n        );\\n        susdToBurn = (\\n            lockedSnxValue.add(valueOfSnxToSell).sub(nonEscrowedSnxValue)\\n        )\\n            .mul(issuanceRatio)\\n            .div(DEC_18);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                        Rebalances                                         */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsHedge()\\n     */\\n    function calculateAssetChangesForRebalanceToHedge()\\n        internal\\n        view\\n        returns (uint256 totalSusdToBurn, uint256 snxToSell)\\n    {\\n        uint256 snxValueHeld = getContractSnxValue();\\n        uint256 debtValueInUsd = getContractDebtValue();\\n        uint256 issuanceRatio = getIssuanceRatio();\\n\\n        uint256 susdToBurnToFixRatio = calculateSusdToBurnToFixRatio(\\n            snxValueHeld,\\n            debtValueInUsd,\\n            issuanceRatio\\n        );\\n\\n\\n            uint256 susdToBurnToEclipseEscrowed\\n         = calculateSusdToBurnToEclipseEscrowed(issuanceRatio);\\n\\n        uint256 hedgeAssetsValueInUsd = calculateHedgeAssetsValueInUsd();\\n        uint256 valueToUnlockInUsd = debtValueInUsd.sub(hedgeAssetsValueInUsd);\\n\\n        uint256 susdToBurnToUnlockTransfer = valueToUnlockInUsd\\n            .mul(issuanceRatio)\\n            .div(DEC_18);\\n\\n        totalSusdToBurn = (\\n            susdToBurnToFixRatio.add(susdToBurnToEclipseEscrowed).add(\\n                susdToBurnToUnlockTransfer\\n            )\\n        );\\n        snxToSell = valueToUnlockInUsd.mul(DEC_18).div(getSnxPrice());\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsSnx()\\n     */\\n    function calculateAssetChangesForRebalanceToSnx()\\n        public\\n        view\\n        returns (uint256 setToSell)\\n    {\\n        (\\n            uint256 debtValueInWei,\\n            uint256 hedgeAssetsBalance\\n        ) = getRebalanceUtils();\\n        uint256 setValueToSell = hedgeAssetsBalance.sub(debtValueInWei);\\n        uint256 ethValueOfOneSet = calculateEthValueOfOneSetUnit();\\n        setToSell = setValueToSell.mul(DEC_18).div(ethValueOfOneSet);\\n\\n        // Set quantity must be multiple of natural unit\\n        uint256 naturalUnit = getSetNaturalUnit();\\n        setToSell = setToSell.div(naturalUnit).mul(naturalUnit);\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsSnx()\\n     */\\n    function getRebalanceTowardsSnxUtils()\\n        public\\n        view\\n        returns (uint256 setToSell, address activeAsset)\\n    {\\n        setToSell = calculateAssetChangesForRebalanceToSnx();\\n        activeAsset = getAssetCurrentlyActiveInSet();\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsSnx(), xSNXAdmin.rebalanceTowardsHedge()\\n     * @dev Denominated in ETH terms\\n     */\\n    function getRebalanceUtils()\\n        public\\n        view\\n        returns (uint256 debtValueInWei, uint256 hedgeAssetsBalance)\\n    {\\n        uint256 setHoldingsInWei = getSetHoldingsValueInWei();\\n        uint256 ethBalance = getEthBalance();\\n\\n        uint256 debtValue = getContractDebtValue();\\n        debtValueInWei = calculateDebtValueInWei(debtValue);\\n        hedgeAssetsBalance = setHoldingsInWei.add(ethBalance);\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsHedge()\\n     * @dev Denominated in USD terms\\n     */\\n    function calculateHedgeAssetsValueInUsd()\\n        internal\\n        view\\n        returns (uint256 hedgeAssetsValueInUsd)\\n    {\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        uint256 setCollateralTokens = getSetCollateralTokens();\\n        setCollateralTokens = setCollateralTokens.mul(DEC_18).div(decimals);\\n\\n        bytes32 activeAssetSynthSymbol = getActiveAssetSynthSymbol();\\n\\n        uint256 synthUsd = getSynthPrice(activeAssetSynthSymbol);\\n        uint256 setValueUsd = setCollateralTokens.mul(synthUsd).div(DEC_18);\\n\\n        uint256 ethBalance = getEthBalance();\\n        uint256 ethUsd = getSynthPrice(seth);\\n        uint256 ethValueUsd = ethBalance.mul(ethUsd).div(DEC_18);\\n\\n        hedgeAssetsValueInUsd = setValueUsd.add(ethValueUsd);\\n    }\\n\\n    /*\\n     * @dev Helper function to determine whether xSNXAdmin.rebalanceTowardsSnx() is required\\n     */\\n    function isRebalanceTowardsSnxRequired() public view returns (bool) {\\n        (\\n            uint256 debtValueInWei,\\n            uint256 hedgeAssetsBalance\\n        ) = getRebalanceUtils();\\n\\n        if (\\n            debtValueInWei.mul(REBALANCE_THRESHOLD).div(PERCENT) <\\n            hedgeAssetsBalance\\n        ) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /*\\n     * @dev Helper function to determine whether xSNXAdmin.rebalanceTowardsHedge() is required\\n     */\\n    function isRebalanceTowardsHedgeRequired() public view returns (bool) {\\n        (\\n            uint256 debtValueInWei,\\n            uint256 hedgeAssetsBalance\\n        ) = getRebalanceUtils();\\n\\n        if (\\n            hedgeAssetsBalance.mul(REBALANCE_THRESHOLD).div(PERCENT) <\\n            debtValueInWei\\n        ) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsHedge()\\n     * @notice Will fail if !isRebalanceTowardsHedgeRequired()\\n     */\\n    function getRebalanceTowardsHedgeUtils()\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            address\\n        )\\n    {\\n        (\\n            uint256 totalSusdToBurn,\\n            uint256 snxToSell\\n        ) = calculateAssetChangesForRebalanceToHedge();\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        return (totalSusdToBurn, snxToSell, activeAsset);\\n    }\\n\\n    /*\\n     * @dev Helper for `hedge` function\\n     * @dev Determines share of sUSD to allocate to ETH\\n     * @dev Implicitly determines Set allocation as well\\n     * @param susdBal: sUSD balance post minting\\n     */\\n    function getEthAllocationOnHedge(uint256 susdBal)\\n        public\\n        view\\n        returns (uint256 ethAllocation)\\n    {\\n        uint256 ethUsd = getSynthPrice(seth);\\n\\n        uint256 setHoldingsInUsd = getSetHoldingsValueInWei().mul(ethUsd).div(\\n            DEC_18\\n        );\\n        uint256 ethBalInUsd = getEthBalance().mul(ethUsd).div(DEC_18);\\n        uint256 hedgeAssets = setHoldingsInUsd.add(ethBalInUsd);\\n\\n        if (ethBalInUsd.mul(ETH_TARGET) >= hedgeAssets.add(susdBal)) {\\n            // full bal directed toward Set\\n            // eth allocation is 0\\n        } else if ((ethBalInUsd.add(susdBal)).mul(ETH_TARGET) < hedgeAssets) {\\n            // full bal directed toward Eth\\n            ethAllocation = susdBal;\\n        } else {\\n            // fractionate allocation\\n            ethAllocation = ((hedgeAssets.add(susdBal)).div(ETH_TARGET)).sub(\\n                ethBalInUsd\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceSetToEth()\\n     */\\n    function calculateSetToSellForRebalanceSetToEth()\\n        public\\n        view\\n        returns (uint256 setQuantityToSell)\\n    {\\n        uint256 setHoldingsInWei = getSetHoldingsValueInWei();\\n        uint256 ethBal = getEthBalance();\\n        uint256 hedgeAssets = setHoldingsInWei.add(ethBal);\\n        require(\\n            ethBal.mul(ETH_TARGET) < hedgeAssets,\\n            \\\"Rebalance not necessary\\\"\\n        );\\n\\n        uint256 ethToAdd = ((hedgeAssets.div(ETH_TARGET)).sub(ethBal));\\n        setQuantityToSell = getContractSetBalance().mul(ethToAdd).div(\\n            setHoldingsInWei\\n        );\\n\\n        uint256 naturalUnit = getSetNaturalUnit();\\n        setQuantityToSell = setQuantityToSell.div(naturalUnit).mul(naturalUnit);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                     Address Setters                                       */\\n    /* ========================================================================================= */\\n\\n    function setAdminInstanceAddress(address _xSNXAdminInstance)\\n        public\\n        onlyOwner\\n    {\\n        if (xSNXAdminInstance == address(0)) {\\n            xSNXAdminInstance = _xSNXAdminInstance;\\n        }\\n    }\\n\\n    function setCurve(\\n        address curvePoolAddress,\\n        int128 _usdcIndex,\\n        int128 _susdIndex\\n    ) public onlyOwner {\\n        if (address(curveFi) == address(0)) {\\n            // if initial set on deployment, immediately activate Curve address\\n            curveFi = ICurveFi(curvePoolAddress);\\n            nextCurveAddress = curvePoolAddress;\\n        } else {\\n            // if updating Curve address (i.e., not initial setting of address on deployment),\\n            // store nextCurveAddress but don't activate until addressValidator has confirmed\\n            nextCurveAddress = curvePoolAddress;\\n        }\\n        usdcIndex = _usdcIndex;\\n        susdIndex = _susdIndex;\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                   \\t\\t Utils           \\t\\t                         */\\n    /* ========================================================================================= */\\n\\n    // admin on deployment approve [snx, susd, setComponentA, setComponentB]\\n    function approveKyber(address tokenAddress) public onlyOwner {\\n        IERC20(tokenAddress).approve(address(kyberNetworkProxy), MAX_UINT);\\n    }\\n\\n    // admin on deployment approve [susd, usdc]\\n    function approveCurve(address tokenAddress) public onlyOwner {\\n        IERC20(tokenAddress).approve(address(curveFi), MAX_UINT);\\n    }\\n\\n    function confirmCurveAddress(address _nextCurveAddress) public {\\n        require(msg.sender == addressValidator, \\\"Incorrect caller\\\");\\n        require(nextCurveAddress == _nextCurveAddress, \\\"Addresses don't match\\\");\\n        curveFi = ICurveFi(nextCurveAddress);\\n    }\\n\\n    function() external payable {}\\n}\"\r\n    },\r\n    \"contracts/interface/IRebalancingSetIssuanceModule.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface IRebalancingSetIssuanceModule {\\n    //  call if eth is active asset in eth20smaco\\n    function issueRebalancingSetWrappingEther(\\n        address _rebalancingSetAddress,\\n        uint256 _rebalancingSetQuantity,\\n        bool _keepChangeInVault\\n    ) external payable;\\n\\n    //  call with usdc if usdc is active asset in eth20smaco\\n    function issueRebalancingSet(\\n        address _rebalancingSetAddress,\\n        uint256 _rebalancingSetQuantity,\\n        bool _keepChangeInVault\\n    ) external;\\n\\n    function redeemRebalancingSet(\\n        address _rebalancingSetAddress,\\n        uint256 _rebalancingSetQuantity,\\n        bool _keepChangeInVault\\n    )\\n    external;\\n}\"\r\n    },\r\n    \"contracts/interface/IxSNX.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ncontract IxSNX {\\n    function getClaimFeeDivisor() external view returns(uint);\\n}\"\r\n    },\r\n    \"contracts/DebtRepayment.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Types {\\n    enum AssetDenomination {\\n        Wei,\\n        Par\\n    }\\n    enum AssetReference {\\n        Delta,\\n        Target\\n    }\\n    struct AssetAmount {\\n        bool sign;\\n        AssetDenomination denomination;\\n        AssetReference ref;\\n        uint256 value;\\n    }\\n}\\n\\nlibrary Account {\\n    struct Info {\\n        address owner;\\n        uint256 number;\\n    }\\n}\\n\\nlibrary Actions {\\n    enum ActionType {\\n        Deposit,\\n        Withdraw,\\n        Transfer,\\n        Buy,\\n        Sell,\\n        Trade,\\n        Liquidate,\\n        Vaporize,\\n        Call\\n    }\\n    struct ActionArgs {\\n        ActionType actionType;\\n        uint256 accountId;\\n        Types.AssetAmount amount;\\n        uint256 primaryMarketId;\\n        uint256 secondaryMarketId;\\n        address otherAddress;\\n        uint256 otherAccountId;\\n        bytes data;\\n    }\\n}\\n\\ninterface ISoloMargin {\\n    function operate(\\n        Account.Info[] calldata accounts,\\n        Actions.ActionArgs[] calldata actions\\n    ) external;\\n}\\n\\n// The interface for a contract to be callable after receiving a flash loan\\ninterface ICallee {\\n    function callFunction(\\n        address sender,\\n        Account.Info calldata accountInfo,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ncontract DebtRepayment is ICallee {\\n    /**\\n     * Debt repayment function\\n     * Called when c-ratio is below a certain point\\n     * And SNX collateral is locked\\n     * Takes flash loan from dydx in USDC\\n     * Calls callFunction in xSNXAdmin.sol\\n     */\\n    function repayDebt(uint256 loanAmount, uint256 snxAmount) public {\\n        ISoloMargin soloMargin = ISoloMargin(\\n            0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e\\n        );\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Withdraw,\\n            accountId: 0,\\n            amount: Types.AssetAmount({\\n                sign: false,\\n                denomination: Types.AssetDenomination.Wei,\\n                ref: Types.AssetReference.Delta,\\n                value: loanAmount // Amount to borrow\\n            }),\\n            primaryMarketId: 2, // USDC\\n            secondaryMarketId: 0,\\n            otherAddress: address(this),\\n            otherAccountId: 0,\\n            data: \\\"\\\"\\n        });\\n\\n        operations[1] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Call,\\n            accountId: 0,\\n            amount: Types.AssetAmount({\\n                sign: false,\\n                denomination: Types.AssetDenomination.Wei,\\n                ref: Types.AssetReference.Delta,\\n                value: 0\\n            }),\\n            primaryMarketId: 2,\\n            secondaryMarketId: 0,\\n            otherAddress: address(this),\\n            otherAccountId: 0,\\n            data: abi.encode(\\n                msg.sender,\\n                loanAmount,\\n                snxAmount // snx amount to swap to repay the loan\\n            )\\n        });\\n\\n        operations[2] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Deposit,\\n            accountId: 0,\\n            amount: Types.AssetAmount({\\n                sign: true,\\n                denomination: Types.AssetDenomination.Wei,\\n                ref: Types.AssetReference.Delta,\\n                value: loanAmount + 2 // Repayment amount with 2 wei fee\\n            }),\\n            primaryMarketId: 2, // USDC\\n            secondaryMarketId: 0,\\n            otherAddress: address(this),\\n            otherAccountId: 0,\\n            data: \\\"\\\"\\n        });\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = Account.Info({owner: address(this), number: 1});\\n\\n        soloMargin.operate(accountInfos, operations);\\n    }\\n\\n    function() external payable {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is Initializable, IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/ISynthetix.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\nimport \\\"./ISynth.sol\\\";\\nimport \\\"./IVirtualSynth.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\\ninterface ISynthetix {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\\n\\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\\n\\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint);\\n\\n    function transferableSynthetix(address account) external view returns (uint transferable);\\n\\n    // Mutative Functions\\n    function burnSynths(uint amount) external;\\n\\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\\n\\n    function burnSynthsToTarget() external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\\n\\n    function exchange(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalf(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTracking(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address originator,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalfWithTracking(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address originator,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithVirtual(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\\n\\n    function issueMaxSynths() external;\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\\n\\n    function issueSynths(uint amount) external;\\n\\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\\n\\n    function mint() external returns (bool);\\n\\n    function settle(bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    // Liquidations\\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\\n\\n    // Restricted Functions\\n\\n    function mintSecondary(address account, uint amount) external;\\n\\n    function mintSecondaryRewards(uint amount) external;\\n\\n    function burnSecondary(address account, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IRewardEscrowV2.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\npragma experimental ABIEncoderV2;\\n\\nlibrary VestingEntries {\\n    struct VestingEntry {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n    }\\n    struct VestingEntryWithID {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n        uint256 entryID;\\n    }\\n}\\n\\ninterface IRewardEscrowV2 {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function numVestingEntries(address account) external view returns (uint);\\n\\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\\n\\n    function totalVestedAccountBalance(address account) external view returns (uint);\\n\\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\\n\\n    function getVestingSchedules(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\\n\\n    function getAccountVestingEntryIDs(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (uint256[] memory);\\n\\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\\n\\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\\n\\n    // Mutative functions\\n    function vest(uint256[] calldata entryIDs) external;\\n\\n    function createEscrowEntry(\\n        address beneficiary,\\n        uint256 deposit,\\n        uint256 duration\\n    ) external;\\n\\n    function appendVestingEntry(\\n        address account,\\n        uint256 quantity,\\n        uint256 duration\\n    ) external;\\n\\n    function migrateVestingSchedule(address _addressToMigrate) external;\\n\\n    function migrateAccountEscrowBalances(\\n        address[] calldata accounts,\\n        uint256[] calldata escrowBalances,\\n        uint256[] calldata vestedBalances\\n    ) external;\\n\\n    // Account Merging\\n    function startMergingWindow() external;\\n\\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\\n\\n    function nominateAccountToMerge(address account) external;\\n\\n    function accountMergingIsOpen() external view returns (bool);\\n\\n    // L2 Migration\\n    function importVestingEntries(\\n        address account,\\n        uint256 escrowedAmount,\\n        VestingEntries.VestingEntry[] calldata vestingEntries\\n    ) external;\\n\\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\\n    function burnForMigration(address account, uint256[] calldata entryIDs)\\n        external\\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IExchangeRates.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\\ninterface IExchangeRates {\\n    // Structs\\n    struct RateAndUpdatedTime {\\n        uint216 rate;\\n        uint40 time;\\n    }\\n\\n    struct InversePricing {\\n        uint entryPoint;\\n        uint upperLimit;\\n        uint lowerLimit;\\n        bool frozenAtUpperLimit;\\n        bool frozenAtLowerLimit;\\n    }\\n\\n    // Views\\n    function aggregators(bytes32 currencyKey) external view returns (address);\\n\\n    function aggregatorWarningFlags() external view returns (address);\\n\\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\\n\\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\\n\\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\\n\\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\\n\\n    function effectiveValue(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external view returns (uint value);\\n\\n    function effectiveValueAndRates(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint value,\\n            uint sourceRate,\\n            uint destinationRate\\n        );\\n\\n    function effectiveValueAtRound(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external view returns (uint value);\\n\\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\\n\\n    function getLastRoundIdBeforeElapsedSecs(\\n        bytes32 currencyKey,\\n        uint startingRoundId,\\n        uint startingTimestamp,\\n        uint timediff\\n    ) external view returns (uint);\\n\\n    function inversePricing(bytes32 currencyKey)\\n        external\\n        view\\n        returns (\\n            uint entryPoint,\\n            uint upperLimit,\\n            uint lowerLimit,\\n            bool frozenAtUpperLimit,\\n            bool frozenAtLowerLimit\\n        );\\n\\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\\n\\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\\n\\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\\n\\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\\n\\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateStalePeriod() external view returns (uint);\\n\\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\\n        external\\n        view\\n        returns (uint[] memory rates, uint[] memory times);\\n\\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\\n        external\\n        view\\n        returns (uint[] memory rates, bool anyRateInvalid);\\n\\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\\n\\n    // Mutative functions\\n    function freezeRate(bytes32 currencyKey) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/ISynthetixState.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixstate\\ninterface ISynthetixState {\\n    // Views\\n    function debtLedger(uint index) external view returns (uint);\\n\\n    function issuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\\n\\n    function debtLedgerLength() external view returns (uint);\\n\\n    function hasIssued(address account) external view returns (bool);\\n\\n    function lastDebtLedgerEntry() external view returns (uint);\\n\\n    // Mutative functions\\n    function incrementTotalIssuerCount() external;\\n\\n    function decrementTotalIssuerCount() external;\\n\\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\\n\\n    function appendDebtLedgerValue(uint value) external;\\n\\n    function clearIssuanceData(address account) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IAddressResolver.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getSynth(bytes32 key) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ISystemSettings.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ISystemSettings {\\n    function issuanceRatio() external view returns(uint);\\n}\"\r\n    },\r\n    \"contracts/interface/ICurveFi.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ICurveFi {\\n  function exchange(\\n    int128 i,\\n    int128 j,\\n    uint256 dx,\\n    uint256 min_dy\\n  ) external;\\n  function exchange_underlying(\\n    int128 i,\\n    int128 j,\\n    uint256 dx,\\n    uint256 min_dy\\n  ) external;\\n  function get_dx_underlying(\\n    int128 i,\\n    int128 j,\\n    uint256 dy\\n  ) external view returns (uint256);\\n  function get_dy_underlying(\\n    int128 i,\\n    int128 j,\\n    uint256 dx\\n  ) external view returns (uint256);\\n  function get_dx(\\n    int128 i,\\n    int128 j,\\n    uint256 dy\\n  ) external view returns (uint256);\\n  function get_dy(\\n    int128 i,\\n    int128 j,\\n    uint256 dx\\n  ) external view returns (uint256);\\n  function get_virtual_price() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interface/ISetToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ISetToken {\\n    function unitShares() external view returns(uint);\\n    function naturalUnit() external view returns(uint);\\n    function currentSet() external view returns(address);\\n    // function getUnits() external view returns (uint256[] memory);\\n}\"\r\n    },\r\n    \"contracts/interface/IKyberNetworkProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract IKyberNetworkProxy {\\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\\n    function swapEtherToToken(ERC20 token, uint minConversionRate) external payable returns(uint);\\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external payable returns(uint);\\n    function swapTokenToToken(ERC20 src, uint srcAmount, ERC20 dest, uint minConversionRate) public returns(uint);\\n}\"\r\n    },\r\n    \"contracts/interface/ISetAssetBaseCollateral.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ISetAssetBaseCollateral {\\n    function getComponents() external view returns(address[] memory);\\n    function naturalUnit() external view returns(uint);\\n    function getUnits() external view returns (uint256[] memory);\\n}\"\r\n    },\r\n    \"synthetix/contracts/interfaces/ISynth.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\\ninterface ISynth {\\n    // Views\\n    function currencyKey() external view returns (bytes32);\\n\\n    function transferableSynths(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function transferAndSettle(address to, uint value) external returns (bool);\\n\\n    function transferFromAndSettle(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Restricted: used internally to Synthetix\\n    function burn(address account, uint amount) external;\\n\\n    function issue(address account, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IVirtualSynth.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\nimport \\\"./ISynth.sol\\\";\\n\\ninterface IVirtualSynth {\\n    // Views\\n    function balanceOfUnderlying(address account) external view returns (uint);\\n\\n    function rate() external view returns (uint);\\n\\n    function readyToSettle() external view returns (bool);\\n\\n    function secsLeftInWaitingPeriod() external view returns (uint);\\n\\n    function settled() external view returns (bool);\\n\\n    function synth() external view returns (ISynth);\\n\\n    // Mutative functions\\n    function settle(address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Initializable, Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x4e3fbd56cd56c3e72c1403e103b45db9da5b9d2b", "attacktype": "Governance attack", "sourcecode": "// SPDX-License-Identifier: MIT\r\n\r\n\r\n// File: contracts\\Interfaces.sol\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary MathUtil {\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\ninterface ICurveGauge {\r\n    function deposit(uint256) external;\r\n    function balanceOf(address) external view returns (uint256);\r\n    function withdraw(uint256) external;\r\n    function claim_rewards() external;\r\n    function reward_tokens(uint256) external view returns(address);//v2\r\n    function rewarded_token() external view returns(address);//v1\r\n}\r\n\r\ninterface ICurveVoteEscrow {\r\n    function create_lock(uint256, uint256) external;\r\n    function increase_amount(uint256) external;\r\n    function increase_unlock_time(uint256) external;\r\n    function withdraw() external;\r\n    function smart_wallet_checker() external view returns (address);\r\n}\r\n\r\ninterface IWalletChecker {\r\n    function check(address) external view returns (bool);\r\n}\r\n\r\ninterface IVoting{\r\n    function vote(uint256, bool, bool) external; //voteId, support, executeIfDecided\r\n    function getVote(uint256) external view returns(bool,bool,uint64,uint64,uint64,uint64,uint256,uint256,uint256,bytes memory); \r\n    function vote_for_gauge_weights(address,uint256) external;\r\n}\r\n\r\ninterface IMinter{\r\n    function mint(address) external;\r\n}\r\n\r\ninterface IRegistry{\r\n    function get_registry() external view returns(address);\r\n    function get_address(uint256 _id) external view returns(address);\r\n    function gauge_controller() external view returns(address);\r\n    function get_lp_token(address) external view returns(address);\r\n    function get_gauges(address) external view returns(address[10] memory,uint128[10] memory);\r\n}\r\n\r\ninterface IStaker{\r\n    function deposit(address, address) external;\r\n    function withdraw(address) external;\r\n    function withdraw(address, address, uint256) external;\r\n    function withdrawAll(address, address) external;\r\n    function createLock(uint256, uint256) external;\r\n    function increaseAmount(uint256) external;\r\n    function increaseTime(uint256) external;\r\n    function release() external;\r\n    function claimCrv(address) external returns (uint256);\r\n    function claimRewards(address) external;\r\n    function claimFees(address,address) external;\r\n    function setStashAccess(address, bool) external;\r\n    function vote(uint256,address,bool) external;\r\n    function voteGaugeWeight(address,uint256) external;\r\n    function balanceOfPool(address) external view returns (uint256);\r\n    function operator() external view returns (address);\r\n    function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory);\r\n}\r\n\r\ninterface IRewards{\r\n    function stake(address, uint256) external;\r\n    function stakeFor(address, uint256) external;\r\n    function withdraw(address, uint256) external;\r\n    function exit(address) external;\r\n    function getReward(address) external;\r\n    function queueNewRewards(uint256) external;\r\n    function notifyRewardAmount(uint256) external;\r\n    function addExtraReward(address) external;\r\n    function stakingToken() external returns (address);\r\n}\r\n\r\ninterface IStash{\r\n    function stashRewards() external returns (bool);\r\n    function processStash() external returns (bool);\r\n    function claimRewards() external returns (bool);\r\n}\r\n\r\ninterface IFeeDistro{\r\n    function claim() external;\r\n    function token() external view returns(address);\r\n}\r\n\r\ninterface ITokenMinter{\r\n    function mint(address,uint256) external;\r\n    function burn(address,uint256) external;\r\n}\r\n\r\ninterface IDeposit{\r\n    function isShutdown() external view returns(bool);\r\n    function balanceOf(address _account) external view returns(uint256);\r\n    function totalSupply() external view returns(uint256);\r\n    function poolInfo(uint256) external view returns(address,address,address,address,address, bool);\r\n    function rewardClaimed(uint256,address,uint256) external;\r\n    function withdrawTo(uint256,uint256,address) external;\r\n    function claimRewards(uint256,address) external returns(bool);\r\n    function rewardArbitrator() external returns(address);\r\n}\r\n\r\ninterface ICrvDeposit{\r\n    function deposit(uint256, bool) external;\r\n    function lockIncentive() external view returns(uint256);\r\n}\r\n\r\ninterface IRewardFactory{\r\n    function setAccess(address,bool) external;\r\n    function CreateCrvRewards(uint256,address) external returns(address);\r\n    function CreateTokenRewards(address,address,address) external returns(address);\r\n    function activeRewardCount(address) external view returns(uint256);\r\n    function addActiveReward(address,uint256) external returns(bool);\r\n    function removeActiveReward(address,uint256) external returns(bool);\r\n}\r\n\r\ninterface IStashFactory{\r\n    function CreateStash(uint256,address,address,uint256) external returns(address);\r\n}\r\n\r\ninterface ITokenFactory{\r\n    function CreateDepositToken(address) external returns(address);\r\n}\r\n\r\ninterface IPools{\r\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);\r\n    function shutdownPool(uint256 _pid) external returns(bool);\r\n    function poolInfo(uint256) external view returns(address,address,address,address,address,bool);\r\n    function poolLength() external view returns (uint256);\r\n    function gaugeMap(address) external view returns(bool);\r\n    function setPoolManager(address _poolM) external;\r\n}\r\n\r\ninterface IVestedEscrow{\r\n    function fund(address[] calldata _recipient, uint256[] calldata _amount) external returns(bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\utils\\Address.sol\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts\\utils\\Context.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal virtual {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: contracts\\Cvx.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ncontract ConvexToken is ERC20{\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    address public operator;\r\n    address public vecrvProxy;\r\n\r\n    uint256 public maxSupply = 100 * 1000000 * 1e18; //100mil\r\n    uint256 public totalCliffs = 1000;\r\n    uint256 public reductionPerCliff;\r\n\r\n    constructor(address _proxy)\r\n        public\r\n        ERC20(\r\n            \"Convex Token\",\r\n            \"CVX\"\r\n        )\r\n    {\r\n        operator = msg.sender;\r\n        vecrvProxy = _proxy;\r\n        reductionPerCliff = maxSupply.div(totalCliffs);\r\n    }\r\n\r\n    //get current operator off proxy incase there was a change\r\n    function updateOperator() public {\r\n        operator = IStaker(vecrvProxy).operator();\r\n    }\r\n    \r\n    function mint(address _to, uint256 _amount) external {\r\n        if(msg.sender != operator){\r\n            //dont error just return. if a shutdown happens, rewards on old system\r\n            //can still be claimed, just wont mint cvx\r\n            return;\r\n        }\r\n\r\n        uint256 supply = totalSupply();\r\n        if(supply == 0){\r\n            //premine, one time only\r\n            _mint(_to,_amount);\r\n            //automatically switch operators\r\n            updateOperator();\r\n            return;\r\n        }\r\n        \r\n        //use current supply to gauge cliff\r\n        //this will cause a bit of overflow into the next cliff range\r\n        //but should be within reasonable levels.\r\n        //requires a max supply check though\r\n        uint256 cliff = supply.div(reductionPerCliff);\r\n        //mint if below total cliffs\r\n        if(cliff < totalCliffs){\r\n            //for reduction% take inverse of current cliff\r\n            uint256 reduction = totalCliffs.sub(cliff);\r\n            //reduce\r\n            _amount = _amount.mul(reduction).div(totalCliffs);\r\n\r\n            //supply cap check\r\n            uint256 amtTillMax = maxSupply.sub(supply);\r\n            if(_amount > amtTillMax){\r\n                _amount = amtTillMax;\r\n            }\r\n\r\n            //mint\r\n            _mint(_to, _amount);\r\n        }\r\n    }\r\n\r\n}"}
{"address": "0x833e440332caa07597a5116fbb6163f0e15f743d", "attacktype": "On-chain oracle manipulation", "sourcecode": "pragma solidity ^0.6.10;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface CErc20 {\r\n    function underlying() external view returns (address);\r\n}\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address account) external view returns (uint);\r\n}\r\n\r\ncontract UniswapConfig {\r\n    enum PriceSource {\r\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\r\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\r\n        REPORTER   /// implies the price is set by the reporter\r\n    }\r\n\r\n    /// @dev Describe how the USD price should be determined for an asset.\r\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\r\n    struct TokenConfig {\r\n        address sToken;\r\n        address underlying;\r\n        bytes32 symbolHash;\r\n        uint256 baseUnit;\r\n        PriceSource priceSource;\r\n        uint256 fixedPrice;\r\n        address uniswapMarket;\r\n        bool isUniswapReversed;\r\n        bool isLP;\r\n    }\r\n\r\n    /// @notice The max number of tokens this contract is hardcoded to support\r\n    /// @dev Do not change this variable without updating all the fields throughout the contract.\r\n    uint public constant maxTokens = 20;\r\n\r\n    /// @notice The number of tokens this contract actually supports\r\n    uint public immutable numTokens;\r\n\r\n    address internal immutable sToken00;\r\n    address internal immutable sToken01;\r\n    address internal immutable sToken02;\r\n    address internal immutable sToken03;\r\n    address internal immutable sToken04;\r\n    address internal immutable sToken05;\r\n    address internal immutable sToken06;\r\n    address internal immutable sToken07;\r\n    address internal immutable sToken08;\r\n    address internal immutable sToken09;\r\n    address internal immutable sToken10;\r\n    address internal immutable sToken11;\r\n    address internal immutable sToken12;\r\n    address internal immutable sToken13;\r\n    address internal immutable sToken14;\r\n    address internal immutable sToken15;\r\n    address internal immutable sToken16;\r\n    address internal immutable sToken17;\r\n    address internal immutable sToken18;\r\n    address internal immutable sToken19;\r\n\r\n\r\n    address internal immutable underlying00;\r\n    address internal immutable underlying01;\r\n    address internal immutable underlying02;\r\n    address internal immutable underlying03;\r\n    address internal immutable underlying04;\r\n    address internal immutable underlying05;\r\n    address internal immutable underlying06;\r\n    address internal immutable underlying07;\r\n    address internal immutable underlying08;\r\n    address internal immutable underlying09;\r\n    address internal immutable underlying10;\r\n    address internal immutable underlying11;\r\n    address internal immutable underlying12;\r\n    address internal immutable underlying13;\r\n    address internal immutable underlying14;\r\n    address internal immutable underlying15;\r\n    address internal immutable underlying16;\r\n    address internal immutable underlying17;\r\n    address internal immutable underlying18;\r\n    address internal immutable underlying19;\r\n\r\n\r\n    bytes32 internal immutable symbolHash00;\r\n    bytes32 internal immutable symbolHash01;\r\n    bytes32 internal immutable symbolHash02;\r\n    bytes32 internal immutable symbolHash03;\r\n    bytes32 internal immutable symbolHash04;\r\n    bytes32 internal immutable symbolHash05;\r\n    bytes32 internal immutable symbolHash06;\r\n    bytes32 internal immutable symbolHash07;\r\n    bytes32 internal immutable symbolHash08;\r\n    bytes32 internal immutable symbolHash09;\r\n    bytes32 internal immutable symbolHash10;\r\n    bytes32 internal immutable symbolHash11;\r\n    bytes32 internal immutable symbolHash12;\r\n    bytes32 internal immutable symbolHash13;\r\n    bytes32 internal immutable symbolHash14;\r\n    bytes32 internal immutable symbolHash15;\r\n    bytes32 internal immutable symbolHash16;\r\n    bytes32 internal immutable symbolHash17;\r\n    bytes32 internal immutable symbolHash18;\r\n    bytes32 internal immutable symbolHash19;\r\n\r\n    uint256 internal immutable baseUnit00;\r\n    uint256 internal immutable baseUnit01;\r\n    uint256 internal immutable baseUnit02;\r\n    uint256 internal immutable baseUnit03;\r\n    uint256 internal immutable baseUnit04;\r\n    uint256 internal immutable baseUnit05;\r\n    uint256 internal immutable baseUnit06;\r\n    uint256 internal immutable baseUnit07;\r\n    uint256 internal immutable baseUnit08;\r\n    uint256 internal immutable baseUnit09;\r\n    uint256 internal immutable baseUnit10;\r\n    uint256 internal immutable baseUnit11;\r\n    uint256 internal immutable baseUnit12;\r\n    uint256 internal immutable baseUnit13;\r\n    uint256 internal immutable baseUnit14;\r\n    uint256 internal immutable baseUnit15;\r\n    uint256 internal immutable baseUnit16;\r\n    uint256 internal immutable baseUnit17;\r\n    uint256 internal immutable baseUnit18;\r\n    uint256 internal immutable baseUnit19;\r\n\r\n    PriceSource internal immutable priceSource00;\r\n    PriceSource internal immutable priceSource01;\r\n    PriceSource internal immutable priceSource02;\r\n    PriceSource internal immutable priceSource03;\r\n    PriceSource internal immutable priceSource04;\r\n    PriceSource internal immutable priceSource05;\r\n    PriceSource internal immutable priceSource06;\r\n    PriceSource internal immutable priceSource07;\r\n    PriceSource internal immutable priceSource08;\r\n    PriceSource internal immutable priceSource09;\r\n    PriceSource internal immutable priceSource10;\r\n    PriceSource internal immutable priceSource11;\r\n    PriceSource internal immutable priceSource12;\r\n    PriceSource internal immutable priceSource13;\r\n    PriceSource internal immutable priceSource14;\r\n    PriceSource internal immutable priceSource15;\r\n    PriceSource internal immutable priceSource16;\r\n    PriceSource internal immutable priceSource17;\r\n    PriceSource internal immutable priceSource18;\r\n    PriceSource internal immutable priceSource19;\r\n\r\n    uint256 internal immutable fixedPrice00;\r\n    uint256 internal immutable fixedPrice01;\r\n    uint256 internal immutable fixedPrice02;\r\n    uint256 internal immutable fixedPrice03;\r\n    uint256 internal immutable fixedPrice04;\r\n    uint256 internal immutable fixedPrice05;\r\n    uint256 internal immutable fixedPrice06;\r\n    uint256 internal immutable fixedPrice07;\r\n    uint256 internal immutable fixedPrice08;\r\n    uint256 internal immutable fixedPrice09;\r\n    uint256 internal immutable fixedPrice10;\r\n    uint256 internal immutable fixedPrice11;\r\n    uint256 internal immutable fixedPrice12;\r\n    uint256 internal immutable fixedPrice13;\r\n    uint256 internal immutable fixedPrice14;\r\n    uint256 internal immutable fixedPrice15;\r\n    uint256 internal immutable fixedPrice16;\r\n    uint256 internal immutable fixedPrice17;\r\n    uint256 internal immutable fixedPrice18;\r\n    uint256 internal immutable fixedPrice19;\r\n\r\n    address internal immutable uniswapMarket00;\r\n    address internal immutable uniswapMarket01;\r\n    address internal immutable uniswapMarket02;\r\n    address internal immutable uniswapMarket03;\r\n    address internal immutable uniswapMarket04;\r\n    address internal immutable uniswapMarket05;\r\n    address internal immutable uniswapMarket06;\r\n    address internal immutable uniswapMarket07;\r\n    address internal immutable uniswapMarket08;\r\n    address internal immutable uniswapMarket09;\r\n    address internal immutable uniswapMarket10;\r\n    address internal immutable uniswapMarket11;\r\n    address internal immutable uniswapMarket12;\r\n    address internal immutable uniswapMarket13;\r\n    address internal immutable uniswapMarket14;\r\n    address internal immutable uniswapMarket15;\r\n    address internal immutable uniswapMarket16;\r\n    address internal immutable uniswapMarket17;\r\n    address internal immutable uniswapMarket18;\r\n    address internal immutable uniswapMarket19;\r\n\r\n    bool internal immutable isUniswapReversed00;\r\n    bool internal immutable isUniswapReversed01;\r\n    bool internal immutable isUniswapReversed02;\r\n    bool internal immutable isUniswapReversed03;\r\n    bool internal immutable isUniswapReversed04;\r\n    bool internal immutable isUniswapReversed05;\r\n    bool internal immutable isUniswapReversed06;\r\n    bool internal immutable isUniswapReversed07;\r\n    bool internal immutable isUniswapReversed08;\r\n    bool internal immutable isUniswapReversed09;\r\n    bool internal immutable isUniswapReversed10;\r\n    bool internal immutable isUniswapReversed11;\r\n    bool internal immutable isUniswapReversed12;\r\n    bool internal immutable isUniswapReversed13;\r\n    bool internal immutable isUniswapReversed14;\r\n    bool internal immutable isUniswapReversed15;\r\n    bool internal immutable isUniswapReversed16;\r\n    bool internal immutable isUniswapReversed17;\r\n    bool internal immutable isUniswapReversed18;\r\n    bool internal immutable isUniswapReversed19;\r\n\r\n    bool internal immutable isLP00;\r\n    bool internal immutable isLP01;\r\n    bool internal immutable isLP02;\r\n    bool internal immutable isLP03;\r\n    bool internal immutable isLP04;\r\n    bool internal immutable isLP05;\r\n    bool internal immutable isLP06;\r\n    bool internal immutable isLP07;\r\n    bool internal immutable isLP08;\r\n    bool internal immutable isLP09;\r\n    bool internal immutable isLP10;\r\n    bool internal immutable isLP11;\r\n    bool internal immutable isLP12;\r\n    bool internal immutable isLP13;\r\n    bool internal immutable isLP14;\r\n    bool internal immutable isLP15;\r\n    bool internal immutable isLP16;\r\n    bool internal immutable isLP17;\r\n    bool internal immutable isLP18;\r\n    bool internal immutable isLP19;\r\n\r\n    constructor(address[] memory sTokens_, address[] memory underlyings_,\r\n        bytes32[] memory symbolHashs_, uint256[] memory baseUints_,\r\n        PriceSource[] memory priceSources_, uint256[] memory fixedPrices_, address[] memory uniswapMarkets_, bool[] memory isUniswapReverseds_,\r\n        bool[] memory isLP_) public {\r\n\r\n        require(sTokens_.length <= maxTokens, \"too many sToken\");\r\n        TokenConfig[] memory configs = new TokenConfig[](maxTokens);\r\n        for (uint i = 0; i < sTokens_.length; i++) {\r\n            TokenConfig memory config = TokenConfig({\r\n            sToken : sTokens_[i],\r\n            underlying : underlyings_[i],\r\n            symbolHash : symbolHashs_[i],\r\n            baseUnit : baseUints_[i],\r\n            priceSource: priceSources_[i],\r\n            fixedPrice: fixedPrices_[i],\r\n            uniswapMarket : uniswapMarkets_[i],\r\n            isUniswapReversed : isUniswapReverseds_[i],\r\n            isLP: isLP_[i]\r\n            });\r\n            configs[i] = config;\r\n        }\r\n\r\n        require(configs.length <= maxTokens, \"too many configs\");\r\n        numTokens = configs.length;\r\n\r\n        sToken00 = get(configs, 0).sToken;\r\n        sToken01 = get(configs, 1).sToken;\r\n        sToken02 = get(configs, 2).sToken;\r\n        sToken03 = get(configs, 3).sToken;\r\n        sToken04 = get(configs, 4).sToken;\r\n        sToken05 = get(configs, 5).sToken;\r\n        sToken06 = get(configs, 6).sToken;\r\n        sToken07 = get(configs, 7).sToken;\r\n        sToken08 = get(configs, 8).sToken;\r\n        sToken09 = get(configs, 9).sToken;\r\n        sToken10 = get(configs, 10).sToken;\r\n        sToken11 = get(configs, 11).sToken;\r\n        sToken12 = get(configs, 12).sToken;\r\n        sToken13 = get(configs, 13).sToken;\r\n        sToken14 = get(configs, 14).sToken;\r\n        sToken15 = get(configs, 15).sToken;\r\n        sToken16 = get(configs, 16).sToken;\r\n        sToken17 = get(configs, 17).sToken;\r\n        sToken18 = get(configs, 18).sToken;\r\n        sToken19 = get(configs, 19).sToken;\r\n\r\n        underlying00 = get(configs, 0).underlying;\r\n        underlying01 = get(configs, 1).underlying;\r\n        underlying02 = get(configs, 2).underlying;\r\n        underlying03 = get(configs, 3).underlying;\r\n        underlying04 = get(configs, 4).underlying;\r\n        underlying05 = get(configs, 5).underlying;\r\n        underlying06 = get(configs, 6).underlying;\r\n        underlying07 = get(configs, 7).underlying;\r\n        underlying08 = get(configs, 8).underlying;\r\n        underlying09 = get(configs, 9).underlying;\r\n        underlying10 = get(configs, 10).underlying;\r\n        underlying11 = get(configs, 11).underlying;\r\n        underlying12 = get(configs, 12).underlying;\r\n        underlying13 = get(configs, 13).underlying;\r\n        underlying14 = get(configs, 14).underlying;\r\n        underlying15 = get(configs, 15).underlying;\r\n        underlying16 = get(configs, 16).underlying;\r\n        underlying17 = get(configs, 17).underlying;\r\n        underlying18 = get(configs, 18).underlying;\r\n        underlying19 = get(configs, 19).underlying;\r\n\r\n        symbolHash00 = get(configs, 0).symbolHash;\r\n        symbolHash01 = get(configs, 1).symbolHash;\r\n        symbolHash02 = get(configs, 2).symbolHash;\r\n        symbolHash03 = get(configs, 3).symbolHash;\r\n        symbolHash04 = get(configs, 4).symbolHash;\r\n        symbolHash05 = get(configs, 5).symbolHash;\r\n        symbolHash06 = get(configs, 6).symbolHash;\r\n        symbolHash07 = get(configs, 7).symbolHash;\r\n        symbolHash08 = get(configs, 8).symbolHash;\r\n        symbolHash09 = get(configs, 9).symbolHash;\r\n        symbolHash10 = get(configs, 10).symbolHash;\r\n        symbolHash11 = get(configs, 11).symbolHash;\r\n        symbolHash12 = get(configs, 12).symbolHash;\r\n        symbolHash13 = get(configs, 13).symbolHash;\r\n        symbolHash14 = get(configs, 14).symbolHash;\r\n        symbolHash15 = get(configs, 15).symbolHash;\r\n        symbolHash16 = get(configs, 16).symbolHash;\r\n        symbolHash17 = get(configs, 17).symbolHash;\r\n        symbolHash18 = get(configs, 18).symbolHash;\r\n        symbolHash19 = get(configs, 19).symbolHash;\r\n\r\n        baseUnit00 = get(configs, 0).baseUnit;\r\n        baseUnit01 = get(configs, 1).baseUnit;\r\n        baseUnit02 = get(configs, 2).baseUnit;\r\n        baseUnit03 = get(configs, 3).baseUnit;\r\n        baseUnit04 = get(configs, 4).baseUnit;\r\n        baseUnit05 = get(configs, 5).baseUnit;\r\n        baseUnit06 = get(configs, 6).baseUnit;\r\n        baseUnit07 = get(configs, 7).baseUnit;\r\n        baseUnit08 = get(configs, 8).baseUnit;\r\n        baseUnit09 = get(configs, 9).baseUnit;\r\n        baseUnit10 = get(configs, 10).baseUnit;\r\n        baseUnit11 = get(configs, 11).baseUnit;\r\n        baseUnit12 = get(configs, 12).baseUnit;\r\n        baseUnit13 = get(configs, 13).baseUnit;\r\n        baseUnit14 = get(configs, 14).baseUnit;\r\n        baseUnit15 = get(configs, 15).baseUnit;\r\n        baseUnit16 = get(configs, 16).baseUnit;\r\n        baseUnit17 = get(configs, 17).baseUnit;\r\n        baseUnit18 = get(configs, 18).baseUnit;\r\n        baseUnit19 = get(configs, 19).baseUnit;\r\n\r\n        priceSource00 = get(configs, 0).priceSource;\r\n        priceSource01 = get(configs, 1).priceSource;\r\n        priceSource02 = get(configs, 2).priceSource;\r\n        priceSource03 = get(configs, 3).priceSource;\r\n        priceSource04 = get(configs, 4).priceSource;\r\n        priceSource05 = get(configs, 5).priceSource;\r\n        priceSource06 = get(configs, 6).priceSource;\r\n        priceSource07 = get(configs, 7).priceSource;\r\n        priceSource08 = get(configs, 8).priceSource;\r\n        priceSource09 = get(configs, 9).priceSource;\r\n        priceSource10 = get(configs, 10).priceSource;\r\n        priceSource11 = get(configs, 11).priceSource;\r\n        priceSource12 = get(configs, 12).priceSource;\r\n        priceSource13 = get(configs, 13).priceSource;\r\n        priceSource14 = get(configs, 14).priceSource;\r\n        priceSource15 = get(configs, 15).priceSource;\r\n        priceSource16 = get(configs, 16).priceSource;\r\n        priceSource17 = get(configs, 17).priceSource;\r\n        priceSource18 = get(configs, 18).priceSource;\r\n        priceSource19 = get(configs, 19).priceSource;\r\n\r\n        fixedPrice00 = get(configs, 0).fixedPrice;\r\n        fixedPrice01 = get(configs, 1).fixedPrice;\r\n        fixedPrice02 = get(configs, 2).fixedPrice;\r\n        fixedPrice03 = get(configs, 3).fixedPrice;\r\n        fixedPrice04 = get(configs, 4).fixedPrice;\r\n        fixedPrice05 = get(configs, 5).fixedPrice;\r\n        fixedPrice06 = get(configs, 6).fixedPrice;\r\n        fixedPrice07 = get(configs, 7).fixedPrice;\r\n        fixedPrice08 = get(configs, 8).fixedPrice;\r\n        fixedPrice09 = get(configs, 9).fixedPrice;\r\n        fixedPrice10 = get(configs, 10).fixedPrice;\r\n        fixedPrice11 = get(configs, 11).fixedPrice;\r\n        fixedPrice12 = get(configs, 12).fixedPrice;\r\n        fixedPrice13 = get(configs, 13).fixedPrice;\r\n        fixedPrice14 = get(configs, 14).fixedPrice;\r\n        fixedPrice15 = get(configs, 15).fixedPrice;\r\n        fixedPrice16 = get(configs, 16).fixedPrice;\r\n        fixedPrice17 = get(configs, 17).fixedPrice;\r\n        fixedPrice18 = get(configs, 18).fixedPrice;\r\n        fixedPrice19 = get(configs, 19).fixedPrice;\r\n\r\n        uniswapMarket00 = get(configs, 0).uniswapMarket;\r\n        uniswapMarket01 = get(configs, 1).uniswapMarket;\r\n        uniswapMarket02 = get(configs, 2).uniswapMarket;\r\n        uniswapMarket03 = get(configs, 3).uniswapMarket;\r\n        uniswapMarket04 = get(configs, 4).uniswapMarket;\r\n        uniswapMarket05 = get(configs, 5).uniswapMarket;\r\n        uniswapMarket06 = get(configs, 6).uniswapMarket;\r\n        uniswapMarket07 = get(configs, 7).uniswapMarket;\r\n        uniswapMarket08 = get(configs, 8).uniswapMarket;\r\n        uniswapMarket09 = get(configs, 9).uniswapMarket;\r\n        uniswapMarket10 = get(configs, 10).uniswapMarket;\r\n        uniswapMarket11 = get(configs, 11).uniswapMarket;\r\n        uniswapMarket12 = get(configs, 12).uniswapMarket;\r\n        uniswapMarket13 = get(configs, 13).uniswapMarket;\r\n        uniswapMarket14 = get(configs, 14).uniswapMarket;\r\n        uniswapMarket15 = get(configs, 15).uniswapMarket;\r\n        uniswapMarket16 = get(configs, 16).uniswapMarket;\r\n        uniswapMarket17 = get(configs, 17).uniswapMarket;\r\n        uniswapMarket18 = get(configs, 18).uniswapMarket;\r\n        uniswapMarket19 = get(configs, 19).uniswapMarket;\r\n\r\n        isUniswapReversed00 = get(configs, 0).isUniswapReversed;\r\n        isUniswapReversed01 = get(configs, 1).isUniswapReversed;\r\n        isUniswapReversed02 = get(configs, 2).isUniswapReversed;\r\n        isUniswapReversed03 = get(configs, 3).isUniswapReversed;\r\n        isUniswapReversed04 = get(configs, 4).isUniswapReversed;\r\n        isUniswapReversed05 = get(configs, 5).isUniswapReversed;\r\n        isUniswapReversed06 = get(configs, 6).isUniswapReversed;\r\n        isUniswapReversed07 = get(configs, 7).isUniswapReversed;\r\n        isUniswapReversed08 = get(configs, 8).isUniswapReversed;\r\n        isUniswapReversed09 = get(configs, 9).isUniswapReversed;\r\n        isUniswapReversed10 = get(configs, 10).isUniswapReversed;\r\n        isUniswapReversed11 = get(configs, 11).isUniswapReversed;\r\n        isUniswapReversed12 = get(configs, 12).isUniswapReversed;\r\n        isUniswapReversed13 = get(configs, 13).isUniswapReversed;\r\n        isUniswapReversed14 = get(configs, 14).isUniswapReversed;\r\n        isUniswapReversed15 = get(configs, 15).isUniswapReversed;\r\n        isUniswapReversed16 = get(configs, 16).isUniswapReversed;\r\n        isUniswapReversed17 = get(configs, 17).isUniswapReversed;\r\n        isUniswapReversed18 = get(configs, 18).isUniswapReversed;\r\n        isUniswapReversed19 = get(configs, 19).isUniswapReversed;\r\n\r\n        isLP00 = get(configs, 0).isLP;\r\n        isLP01 = get(configs, 1).isLP;\r\n        isLP02 = get(configs, 2).isLP;\r\n        isLP03 = get(configs, 3).isLP;\r\n        isLP04 = get(configs, 4).isLP;\r\n        isLP05 = get(configs, 5).isLP;\r\n        isLP06 = get(configs, 6).isLP;\r\n        isLP07 = get(configs, 7).isLP;\r\n        isLP08 = get(configs, 8).isLP;\r\n        isLP09 = get(configs, 9).isLP;\r\n        isLP10 = get(configs, 10).isLP;\r\n        isLP11 = get(configs, 11).isLP;\r\n        isLP12 = get(configs, 12).isLP;\r\n        isLP13 = get(configs, 13).isLP;\r\n        isLP14 = get(configs, 14).isLP;\r\n        isLP15 = get(configs, 15).isLP;\r\n        isLP16 = get(configs, 16).isLP;\r\n        isLP17 = get(configs, 17).isLP;\r\n        isLP18 = get(configs, 18).isLP;\r\n        isLP19 = get(configs, 19).isLP;\r\n    }\r\n\r\n    function get(TokenConfig[] memory configs, uint i) internal pure returns (TokenConfig memory) {\r\n        if (i < configs.length)\r\n            return configs[i];\r\n        return TokenConfig({\r\n        sToken : address(0),\r\n        underlying : address(0),\r\n        symbolHash : bytes32(0),\r\n        baseUnit : uint256(0),\r\n        priceSource: PriceSource(0),\r\n        fixedPrice: uint256(0),\r\n        uniswapMarket : address(0),\r\n        isUniswapReversed : false,\r\n        isLP : false\r\n        });\r\n    }\r\n\r\n    function getCTokenIndex(address sToken) internal view returns (uint) {\r\n        if (sToken == sToken00) return 0;\r\n        if (sToken == sToken01) return 1;\r\n        if (sToken == sToken02) return 2;\r\n        if (sToken == sToken03) return 3;\r\n        if (sToken == sToken04) return 4;\r\n        if (sToken == sToken05) return 5;\r\n        if (sToken == sToken06) return 6;\r\n        if (sToken == sToken07) return 7;\r\n        if (sToken == sToken08) return 8;\r\n        if (sToken == sToken09) return 9;\r\n        if (sToken == sToken10) return 10;\r\n        if (sToken == sToken11) return 11;\r\n        if (sToken == sToken12) return 12;\r\n        if (sToken == sToken13) return 13;\r\n        if (sToken == sToken14) return 14;\r\n        if (sToken == sToken15) return 15;\r\n        if (sToken == sToken16) return 16;\r\n        if (sToken == sToken17) return 17;\r\n        if (sToken == sToken18) return 18;\r\n        if (sToken == sToken19) return 19;\r\n\r\n        return uint(- 1);\r\n    }\r\n\r\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\r\n        if (underlying == underlying00) return 0;\r\n        if (underlying == underlying01) return 1;\r\n        if (underlying == underlying02) return 2;\r\n        if (underlying == underlying03) return 3;\r\n        if (underlying == underlying04) return 4;\r\n        if (underlying == underlying05) return 5;\r\n        if (underlying == underlying06) return 6;\r\n        if (underlying == underlying07) return 7;\r\n        if (underlying == underlying08) return 8;\r\n        if (underlying == underlying09) return 9;\r\n        if (underlying == underlying10) return 10;\r\n        if (underlying == underlying11) return 11;\r\n        if (underlying == underlying12) return 12;\r\n        if (underlying == underlying13) return 13;\r\n        if (underlying == underlying14) return 14;\r\n        if (underlying == underlying15) return 15;\r\n        if (underlying == underlying16) return 16;\r\n        if (underlying == underlying17) return 17;\r\n        if (underlying == underlying18) return 18;\r\n        if (underlying == underlying19) return 19;\r\n\r\n        return uint(- 1);\r\n    }\r\n\r\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\r\n        if (symbolHash == symbolHash00) return 0;\r\n        if (symbolHash == symbolHash01) return 1;\r\n        if (symbolHash == symbolHash02) return 2;\r\n        if (symbolHash == symbolHash03) return 3;\r\n        if (symbolHash == symbolHash04) return 4;\r\n        if (symbolHash == symbolHash05) return 5;\r\n        if (symbolHash == symbolHash06) return 6;\r\n        if (symbolHash == symbolHash07) return 7;\r\n        if (symbolHash == symbolHash08) return 8;\r\n        if (symbolHash == symbolHash09) return 9;\r\n        if (symbolHash == symbolHash10) return 10;\r\n        if (symbolHash == symbolHash11) return 11;\r\n        if (symbolHash == symbolHash12) return 12;\r\n        if (symbolHash == symbolHash13) return 13;\r\n        if (symbolHash == symbolHash14) return 14;\r\n        if (symbolHash == symbolHash15) return 15;\r\n        if (symbolHash == symbolHash16) return 16;\r\n        if (symbolHash == symbolHash17) return 17;\r\n        if (symbolHash == symbolHash18) return 18;\r\n        if (symbolHash == symbolHash19) return 19;\r\n\r\n        return uint(- 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the i-th config, according to the order they were passed in originally\r\n     * @param i The index of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\r\n        require(i < numTokens, \"token config not found\");\r\n\r\n        if (i == 0) return TokenConfig({sToken: sToken00, underlying: underlying00, symbolHash: symbolHash00, baseUnit: baseUnit00, priceSource: priceSource00, fixedPrice: fixedPrice00, uniswapMarket: uniswapMarket00, isUniswapReversed: isUniswapReversed00, isLP: isLP00});\r\n        if (i == 1) return TokenConfig({sToken: sToken01, underlying: underlying01, symbolHash: symbolHash01, baseUnit: baseUnit01, priceSource: priceSource01, fixedPrice: fixedPrice01, uniswapMarket: uniswapMarket01, isUniswapReversed: isUniswapReversed01, isLP: isLP01});\r\n        if (i == 2) return TokenConfig({sToken: sToken02, underlying: underlying02, symbolHash: symbolHash02, baseUnit: baseUnit02, priceSource: priceSource02, fixedPrice: fixedPrice02, uniswapMarket: uniswapMarket02, isUniswapReversed: isUniswapReversed02, isLP: isLP02});\r\n        if (i == 3) return TokenConfig({sToken: sToken03, underlying: underlying03, symbolHash: symbolHash03, baseUnit: baseUnit03, priceSource: priceSource03, fixedPrice: fixedPrice03, uniswapMarket: uniswapMarket03, isUniswapReversed: isUniswapReversed03, isLP: isLP03});\r\n        if (i == 4) return TokenConfig({sToken: sToken04, underlying: underlying04, symbolHash: symbolHash04, baseUnit: baseUnit04, priceSource: priceSource04, fixedPrice: fixedPrice04, uniswapMarket: uniswapMarket04, isUniswapReversed: isUniswapReversed04, isLP: isLP04});\r\n        if (i == 5) return TokenConfig({sToken: sToken05, underlying: underlying05, symbolHash: symbolHash05, baseUnit: baseUnit05, priceSource: priceSource05, fixedPrice: fixedPrice05, uniswapMarket: uniswapMarket05, isUniswapReversed: isUniswapReversed05, isLP: isLP05});\r\n        if (i == 6) return TokenConfig({sToken: sToken06, underlying: underlying06, symbolHash: symbolHash06, baseUnit: baseUnit06, priceSource: priceSource06, fixedPrice: fixedPrice06, uniswapMarket: uniswapMarket06, isUniswapReversed: isUniswapReversed06, isLP: isLP06});\r\n        if (i == 7) return TokenConfig({sToken: sToken07, underlying: underlying07, symbolHash: symbolHash07, baseUnit: baseUnit07, priceSource: priceSource07, fixedPrice: fixedPrice07, uniswapMarket: uniswapMarket07, isUniswapReversed: isUniswapReversed07, isLP: isLP07});\r\n        if (i == 8) return TokenConfig({sToken: sToken08, underlying: underlying08, symbolHash: symbolHash08, baseUnit: baseUnit08, priceSource: priceSource08, fixedPrice: fixedPrice08, uniswapMarket: uniswapMarket08, isUniswapReversed: isUniswapReversed08, isLP: isLP08});\r\n        if (i == 9) return TokenConfig({sToken: sToken09, underlying: underlying09, symbolHash: symbolHash09, baseUnit: baseUnit09, priceSource: priceSource09, fixedPrice: fixedPrice09, uniswapMarket: uniswapMarket09, isUniswapReversed: isUniswapReversed09, isLP: isLP09});\r\n\r\n        if (i == 10) return TokenConfig({sToken: sToken10, underlying: underlying10, symbolHash: symbolHash10, baseUnit: baseUnit10, priceSource: priceSource10, fixedPrice: fixedPrice10, uniswapMarket: uniswapMarket10, isUniswapReversed: isUniswapReversed10, isLP: isLP10});\r\n        if (i == 11) return TokenConfig({sToken: sToken11, underlying: underlying11, symbolHash: symbolHash11, baseUnit: baseUnit11, priceSource: priceSource11, fixedPrice: fixedPrice11, uniswapMarket: uniswapMarket11, isUniswapReversed: isUniswapReversed11, isLP: isLP11});\r\n        if (i == 12) return TokenConfig({sToken: sToken12, underlying: underlying12, symbolHash: symbolHash12, baseUnit: baseUnit12, priceSource: priceSource12, fixedPrice: fixedPrice12, uniswapMarket: uniswapMarket12, isUniswapReversed: isUniswapReversed12, isLP: isLP12});\r\n        if (i == 13) return TokenConfig({sToken: sToken13, underlying: underlying13, symbolHash: symbolHash13, baseUnit: baseUnit13, priceSource: priceSource13, fixedPrice: fixedPrice13, uniswapMarket: uniswapMarket13, isUniswapReversed: isUniswapReversed13, isLP: isLP13});\r\n        if (i == 14) return TokenConfig({sToken: sToken14, underlying: underlying14, symbolHash: symbolHash14, baseUnit: baseUnit14, priceSource: priceSource14, fixedPrice: fixedPrice14, uniswapMarket: uniswapMarket14, isUniswapReversed: isUniswapReversed14, isLP: isLP14});\r\n        if (i == 15) return TokenConfig({sToken: sToken15, underlying: underlying15, symbolHash: symbolHash15, baseUnit: baseUnit15, priceSource: priceSource15, fixedPrice: fixedPrice15, uniswapMarket: uniswapMarket15, isUniswapReversed: isUniswapReversed15, isLP: isLP15});\r\n        if (i == 16) return TokenConfig({sToken: sToken16, underlying: underlying16, symbolHash: symbolHash16, baseUnit: baseUnit16, priceSource: priceSource16, fixedPrice: fixedPrice16, uniswapMarket: uniswapMarket16, isUniswapReversed: isUniswapReversed16, isLP: isLP16});\r\n        if (i == 17) return TokenConfig({sToken: sToken17, underlying: underlying17, symbolHash: symbolHash17, baseUnit: baseUnit17, priceSource: priceSource17, fixedPrice: fixedPrice17, uniswapMarket: uniswapMarket17, isUniswapReversed: isUniswapReversed17, isLP: isLP17});\r\n        if (i == 18) return TokenConfig({sToken: sToken18, underlying: underlying18, symbolHash: symbolHash18, baseUnit: baseUnit18, priceSource: priceSource18, fixedPrice: fixedPrice18, uniswapMarket: uniswapMarket18, isUniswapReversed: isUniswapReversed18, isLP: isLP18});\r\n        if (i == 19) return TokenConfig({sToken: sToken19, underlying: underlying19, symbolHash: symbolHash19, baseUnit: baseUnit19, priceSource: priceSource19, fixedPrice: fixedPrice19, uniswapMarket: uniswapMarket19, isUniswapReversed: isUniswapReversed19, isLP: isLP19});\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for symbol\r\n     * @param symbol The symbol of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\r\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for the symbolHash\r\n     * @param symbolHash The keccack256 of the symbol of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\r\n        uint index = getSymbolHashIndex(symbolHash);\r\n        if (index != uint(- 1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        revert(\"token config not found\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for the sToken\r\n     * @dev If a config for the sToken is not found, falls back to searching for the underlying.\r\n     * @param sToken The address of the sToken of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigByCToken(address sToken) public view returns (TokenConfig memory) {\r\n        uint index = getCTokenIndex(sToken);\r\n        if (index != uint(- 1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        return getTokenConfigByUnderlying(CErc20(sToken).underlying());\r\n    }\r\n\r\n    /**\r\n     * @notice Get the config for an underlying asset\r\n     * @param underlying The address of the underlying asset of the config to get\r\n     * @return The config object\r\n     */\r\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\r\n        uint index = getUnderlyingIndex(underlying);\r\n        if (index != uint(- 1)) {\r\n            return getTokenConfig(index);\r\n        }\r\n\r\n        revert(\"token config not found\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << 112) / denominator);\r\n    }\r\n\r\n    // decode a uq112x112 into a uint with 18 decimals of precision\r\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\r\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\r\n        // instead, get close to:\r\n        //  (x * 1e18) >> 112\r\n        // without risk of overflowing, e.g.:\r\n        //  (x) / 2 ** (112 - lg(1e18))\r\n        return uint(self._x) / 5192296858534827;\r\n    }\r\n}\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n}\r\n\r\n\r\n    struct Observation {\r\n        uint timestamp;\r\n        uint acc;\r\n    }\r\n\r\ncontract CheesePriceOracle is UniswapConfig {\r\n    using FixedPoint for *;\r\n\r\n    /// @notice The number of wei in 1 ETH\r\n    uint public constant ethBaseUnit = 1e18;\r\n\r\n    /// @notice A common scaling factor to maintain precision\r\n    uint public constant expScale = 1e18;\r\n\r\n    /// @notice The Price Oracle admin\r\n    address public immutable admin;\r\n\r\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\r\n    uint public immutable anchorPeriod;\r\n\r\n    /// @notice Official prices by symbol hash\r\n    mapping(bytes32 => uint) public prices;\r\n\r\n    /// @notice The old observation for each symbolHash\r\n    mapping(bytes32 => Observation) public oldObservations;\r\n\r\n    /// @notice The new observation for each symbolHash\r\n    mapping(bytes32 => Observation) public newObservations;\r\n\r\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\r\n    event PriceGuarded(string symbol, uint reporter, uint anchor);\r\n\r\n    /// @notice The event emitted when the stored price is updated\r\n    event PriceUpdated(string symbol, uint price);\r\n\r\n    /// @notice The event emitted when anchor price is updated\r\n    event AnchorPriceUpdated(string symbol, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\r\n\r\n    /// @notice The event emitted when the uniswap window changes\r\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\r\n\r\n    bytes32 constant ethHash = keccak256(abi.encodePacked(\"ETH\"));\r\n\r\n    constructor(uint anchorPeriod_,\r\n        address[] memory sTokens_, address[] memory underlyings_,\r\n        bytes32[] memory symbolHashs_, uint256[] memory baseUints_,\r\n        PriceSource[] memory priceSources_, uint256[] memory fixedPrices_,\r\n        address[] memory uniswapMarkets_, bool[] memory isUniswapReverseds_,\r\n        bool[] memory isLP_)\r\n    UniswapConfig(sTokens_, underlyings_, symbolHashs_, baseUints_, priceSources_, fixedPrices_, uniswapMarkets_,\r\n        isUniswapReverseds_, isLP_) public {\r\n        admin = msg.sender;\r\n\r\n        anchorPeriod = anchorPeriod_;\r\n\r\n        for (uint i = 0; i < sTokens_.length; i++) {\r\n            TokenConfig memory config = TokenConfig({ sToken : sTokens_[i], underlying : underlyings_[i],\r\n            symbolHash : symbolHashs_[i], baseUnit : baseUints_[i],\r\n            priceSource: priceSources_[i], fixedPrice: fixedPrices_[i],\r\n            uniswapMarket : uniswapMarkets_[i], isUniswapReversed : isUniswapReverseds_[i],\r\n            isLP : isLP_[i]});\r\n            require(config.baseUnit > 0, \"baseUnit must be greater than zero\");\r\n            address uniswapMarket = config.uniswapMarket;\r\n            if (config.priceSource == PriceSource.REPORTER) {\r\n                require(uniswapMarket != address(0), \"reported prices must have an anchor\");\r\n                bytes32 symbolHash = config.symbolHash;\r\n                uint cumulativePrice = currentCumulativePrice(config);\r\n                oldObservations[symbolHash].timestamp = block.timestamp;\r\n                newObservations[symbolHash].timestamp = block.timestamp;\r\n                oldObservations[symbolHash].acc = cumulativePrice;\r\n                newObservations[symbolHash].acc = cumulativePrice;\r\n                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\r\n            } else {\r\n                require(uniswapMarket == address(0), \"only reported prices utilize an anchor\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the official price for a symbol\r\n     * @param symbol The symbol to fetch the price of\r\n     * @return Price denominated in USD, with 6 decimals\r\n     */\r\n    function price(string memory symbol) external view returns (uint) {\r\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\r\n        return priceInternal(config);\r\n    }\r\n\r\n    function priceInternal(TokenConfig memory config) internal view returns (uint) {\r\n        if (config.priceSource == PriceSource.REPORTER) return prices[config.symbolHash];\r\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\r\n        if (config.priceSource == PriceSource.FIXED_ETH) {\r\n            uint usdPerEth = prices[ethHash];\r\n            require(usdPerEth > 0, \"ETH price not set, cannot convert to dollars\");\r\n            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying price of a sToken\r\n     * @dev Implements the PriceOracle interface for Compound v2.\r\n     * @param sToken The sToken address for price retrieval\r\n     * @return Price denominated in USD, with 18 decimals, for the given sToken address\r\n     */\r\n    function getUnderlyingPrice(address sToken) external view returns (uint) {\r\n        TokenConfig memory config = getTokenConfigByCToken(sToken);\r\n        // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\r\n        // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\r\n        return mul(1e30, priceInternal(config)) / config.baseUnit;\r\n    }\r\n\r\n    function refresh(string[] calldata symbols) external {\r\n        uint ethPrice = fetchEthPrice();\r\n\r\n        // Try to update the view storage\r\n        for (uint i = 0; i < symbols.length; i++) {\r\n            postPriceInternal(symbols[i], ethPrice);\r\n        }\r\n    }\r\n\r\n    function postPriceInternal(string memory symbol, uint ethPrice) internal {\r\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\r\n\r\n        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\r\n        uint anchorPrice;\r\n        if (symbolHash == ethHash) {\r\n            anchorPrice = ethPrice;\r\n        } else if (config.isLP) {\r\n            anchorPrice = fetchLPAnchorPrice(symbol, config, ethPrice);\r\n        } else {\r\n            anchorPrice = fetchAnchorPrice(symbol, config, ethPrice);\r\n        }\r\n        prices[symbolHash] = anchorPrice;\r\n        emit PriceUpdated(symbol, anchorPrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches the current token/eth price accumulator from uniswap.\r\n     */\r\n    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\r\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\r\n        if (config.isUniswapReversed) {\r\n            return cumulativePrice1;\r\n        } else {\r\n            return cumulativePrice0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\r\n     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\r\n     */\r\n    function fetchEthPrice() internal returns (uint) {\r\n        return fetchAnchorPrice(\"ETH\", getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\r\n    }\r\n\r\n    /**\r\n    * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\r\n    * @param ethPrice a 6 decimal ETH-USDT price in the case of other assets\r\n    */\r\n    function fetchLPAnchorPrice(string memory symbol, TokenConfig memory config, uint ethPrice) internal virtual returns (uint) {\r\n        //only support ETH pair\r\n        ERC20 wETH = ERC20(getTokenConfigBySymbolHash(ethHash).underlying);\r\n        uint wEthBalance = wETH.balanceOf(config.uniswapMarket);\r\n        uint pairBalance = mul(wEthBalance, 2);\r\n        uint totalValue = mul(pairBalance, ethPrice);\r\n\r\n        IUniswapV2Pair pair = IUniswapV2Pair(config.uniswapMarket);\r\n        uint anchorPrice = totalValue / pair.totalSupply();\r\n\r\n        return anchorPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\r\n     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\r\n     */\r\n    function fetchAnchorPrice(string memory symbol, TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\r\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\r\n\r\n        // This should be impossible, but better safe than sorry\r\n        require(block.timestamp > oldTimestamp, \"now must come after before\");\r\n        uint timeElapsed = block.timestamp - oldTimestamp;\r\n\r\n        // Calculate uniswap time-weighted average price\r\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\r\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\r\n        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\r\n        uint anchorPrice;\r\n\r\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\r\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\r\n        if (config.isUniswapReversed) {\r\n            // unscaledPriceMantissa * ethBaseUnit / config.baseUnit / expScale, but we simplify bc ethBaseUnit == expScale\r\n            anchorPrice = unscaledPriceMantissa / config.baseUnit;\r\n        }else {\r\n            anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\r\n        }\r\n        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\r\n\r\n        return anchorPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Get time-weighted average prices for a token at the current timestamp.\r\n     *  Update new and old observations of lagging window if period elapsed.\r\n     */\r\n    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\r\n        bytes32 symbolHash = config.symbolHash;\r\n        uint cumulativePrice = currentCumulativePrice(config);\r\n\r\n        Observation memory newObservation = newObservations[symbolHash];\r\n\r\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\r\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\r\n        if (timeElapsed >= anchorPeriod) {\r\n            oldObservations[symbolHash].timestamp = newObservation.timestamp;\r\n            oldObservations[symbolHash].acc = newObservation.acc;\r\n\r\n            newObservations[symbolHash].timestamp = block.timestamp;\r\n            newObservations[symbolHash].acc = cumulativePrice;\r\n            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\r\n        }\r\n        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Recovers the source address which signed a message\r\n     * @dev Comparing to a claimed address would add nothing,\r\n     *  as the caller could simply perform the recover and claim that address.\r\n     * @param message The data that was presumably signed\r\n     * @param signature The fingerprint of the data + private key\r\n     * @return The source address which signed the message, presumably\r\n     */\r\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /// @dev Overflow proof multiplication\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) return 0;\r\n        uint c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n        return c;\r\n    }\r\n}"}
{"address": "0x74bcb8b78996f49f46497be185174b2a89191fd6", "attacktype": "Absence of code logic or sanity check", "sourcecode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: contracts/strategies/IStrategy.sol\r\n\r\n// Assume the strategy generates `TOKEN`.\r\ninterface IStrategy {\r\n\r\n    function approve(IERC20 _token) external;\r\n\r\n    function getValuePerShare(address _vault) external view returns(uint256);\r\n    function pendingValuePerShare(address _vault) external view returns (uint256);\r\n\r\n    // Deposit tokens to a farm to yield more tokens.\r\n    function deposit(address _vault, uint256 _amount) external;\r\n\r\n    // Claim the profit from a farm.\r\n    function claim(address _vault) external;\r\n\r\n    // Withdraw the principal from a farm.\r\n    function withdraw(address _vault, uint256 _amount) external;\r\n\r\n    // Target farming token of this strategy.\r\n    function getTargetToken() external view returns(address);\r\n}\r\n\r\n// File: contracts/SodaMaster.sol\r\n\r\n/*\r\n\r\nHere we have a list of constants. In order to get access to an address\r\nmanaged by SodaMaster, the calling contract should copy and define\r\nsome of these constants and use them as keys.\r\n\r\nKeys themselves are immutable. Addresses can be immutable or mutable.\r\n\r\na) Vault addresses are immutable once set, and the list may grow:\r\n\r\nK_VAULT_WETH = 0;\r\nK_VAULT_USDT_ETH_SUSHI_LP = 1;\r\nK_VAULT_SOETH_ETH_UNI_V2_LP = 2;\r\nK_VAULT_SODA_ETH_UNI_V2_LP = 3;\r\nK_VAULT_GT = 4;\r\nK_VAULT_GT_ETH_UNI_V2_LP = 5;\r\n\r\n\r\nb) SodaMade token addresses are immutable once set, and the list may grow:\r\n\r\nK_MADE_SOETH = 0;\r\n\r\n\r\nc) Strategy addresses are mutable:\r\n\r\nK_STRATEGY_CREATE_SODA = 0;\r\nK_STRATEGY_EAT_SUSHI = 1;\r\nK_STRATEGY_SHARE_REVENUE = 2;\r\n\r\n\r\nd) Calculator addresses are mutable:\r\n\r\nK_CALCULATOR_WETH = 0;\r\n\r\nSolidity doesn't allow me to define global constants, so please\r\nalways make sure the key name and key value are copied as the same\r\nin different contracts.\r\n\r\n*/\r\n\r\n\r\n// SodaMaster manages the addresses all the other contracts of the system.\r\n// This contract is owned by Timelock.\r\ncontract SodaMaster is Ownable {\r\n\r\n    address public pool;\r\n    address public bank;\r\n    address public revenue;\r\n    address public dev;\r\n\r\n    address public soda;\r\n    address public wETH;\r\n    address public usdt;\r\n\r\n    address public uniswapV2Factory;\r\n\r\n    mapping(address => bool) public isVault;\r\n    mapping(uint256 => address) public vaultByKey;\r\n\r\n    mapping(address => bool) public isSodaMade;\r\n    mapping(uint256 => address) public sodaMadeByKey;\r\n\r\n    mapping(address => bool) public isStrategy;\r\n    mapping(uint256 => address) public strategyByKey;\r\n\r\n    mapping(address => bool) public isCalculator;\r\n    mapping(uint256 => address) public calculatorByKey;\r\n\r\n    // Immutable once set.\r\n    function setPool(address _pool) external onlyOwner {\r\n        require(pool == address(0));\r\n        pool = _pool;\r\n    }\r\n\r\n    // Immutable once set.\r\n    // Bank owns all the SodaMade tokens.\r\n    function setBank(address _bank) external onlyOwner {\r\n        require(bank == address(0));\r\n        bank = _bank;\r\n    }\r\n\r\n    // Mutable in case we want to upgrade this module.\r\n    function setRevenue(address _revenue) external onlyOwner {\r\n        revenue = _revenue;\r\n    }\r\n\r\n    // Mutable in case we want to upgrade this module.\r\n    function setDev(address _dev) external onlyOwner {\r\n        dev = _dev;\r\n    }\r\n\r\n    // Mutable, in case Uniswap has changed or we want to switch to sushi.\r\n    // The core systems, Pool and Bank, don't rely on Uniswap, so there is no risk.\r\n    function setUniswapV2Factory(address _uniswapV2Factory) external onlyOwner {\r\n        uniswapV2Factory = _uniswapV2Factory;\r\n    }\r\n\r\n    // Immutable once set.\r\n    function setWETH(address _wETH) external onlyOwner {\r\n       require(wETH == address(0));\r\n       wETH = _wETH;\r\n    }\r\n\r\n    // Immutable once set. Hopefully Tether is reliable.\r\n    // Even if it fails, not a big deal, we only used USDT to estimate APY.\r\n    function setUSDT(address _usdt) external onlyOwner {\r\n        require(usdt == address(0));\r\n        usdt = _usdt;\r\n    }\r\n \r\n    // Immutable once set.\r\n    function setSoda(address _soda) external onlyOwner {\r\n        require(soda == address(0));\r\n        soda = _soda;\r\n    }\r\n\r\n    // Immutable once added, and you can always add more.\r\n    function addVault(uint256 _key, address _vault) external onlyOwner {\r\n        require(vaultByKey[_key] == address(0), \"vault: key is taken\");\r\n\r\n        isVault[_vault] = true;\r\n        vaultByKey[_key] = _vault;\r\n    }\r\n\r\n    // Immutable once added, and you can always add more.\r\n    function addSodaMade(uint256 _key, address _sodaMade) external onlyOwner {\r\n        require(sodaMadeByKey[_key] == address(0), \"sodaMade: key is taken\");\r\n\r\n        isSodaMade[_sodaMade] = true;\r\n        sodaMadeByKey[_key] = _sodaMade;\r\n    }\r\n\r\n    // Mutable and removable.\r\n    function addStrategy(uint256 _key, address _strategy) external onlyOwner {\r\n        isStrategy[_strategy] = true;\r\n        strategyByKey[_key] = _strategy;\r\n    }\r\n\r\n    function removeStrategy(uint256 _key) external onlyOwner {\r\n        isStrategy[strategyByKey[_key]] = false;\r\n        delete strategyByKey[_key];\r\n    }\r\n\r\n    // Mutable and removable.\r\n    function addCalculator(uint256 _key, address _calculator) external onlyOwner {\r\n        isCalculator[_calculator] = true;\r\n        calculatorByKey[_key] = _calculator;\r\n    }\r\n\r\n    function removeCalculator(uint256 _key) external onlyOwner {\r\n        isCalculator[calculatorByKey[_key]] = false;\r\n        delete calculatorByKey[_key];\r\n    }\r\n}\r\n\r\n// File: contracts/tokens/SodaVault.sol\r\n\r\n// SodaVault is owned by Timelock\r\ncontract SodaVault is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant PER_SHARE_SIZE = 1e12;\r\n\r\n    mapping (address => uint256) public lockedAmount;\r\n    mapping (address => mapping(uint256 => uint256)) public rewards;\r\n    mapping (address => mapping(uint256 => uint256)) public debts;\r\n\r\n    IStrategy[] public strategies;\r\n\r\n    SodaMaster public sodaMaster;\r\n\r\n    constructor (SodaMaster _sodaMaster, string memory _name, string memory _symbol) ERC20(_name, _symbol) public  {\r\n        sodaMaster = _sodaMaster;\r\n    }\r\n\r\n    function setStrategies(IStrategy[] memory _strategies) public onlyOwner {\r\n        delete strategies;\r\n        for (uint256 i = 0; i < _strategies.length; ++i) {\r\n            strategies.push(_strategies[i]);\r\n        }\r\n    }\r\n\r\n    function getStrategyCount() view public returns(uint count) {\r\n        return strategies.length;\r\n    }\r\n\r\n    /// @notice Creates `_amount` token to `_to`. Must only be called by SodaPool.\r\n    function mintByPool(address _to, uint256 _amount) public {\r\n        require(_msgSender() == sodaMaster.pool(), \"not pool\");\r\n\r\n        _deposit(_amount);\r\n        _updateReward(_to);\r\n        if (_amount > 0) {\r\n            _mint(_to, _amount);\r\n        }\r\n        _updateDebt(_to);\r\n    }\r\n\r\n    // Must only be called by SodaPool.\r\n    function burnByPool(address _account, uint256 _amount) public {\r\n        require(_msgSender() == sodaMaster.pool(), \"not pool\");\r\n\r\n        uint256 balance = balanceOf(_account);\r\n        require(lockedAmount[_account] + _amount <= balance, \"Vault: burn too much\");\r\n\r\n        _withdraw(_amount);\r\n        _updateReward(_account);\r\n        _burn(_account, _amount);\r\n        _updateDebt(_account);\r\n    }\r\n\r\n    // Must only be called by SodaBank.\r\n    function transferByBank(address _from, address _to, uint256 _amount) public {\r\n        require(_msgSender() == sodaMaster.bank(), \"not bank\");\r\n\r\n        uint256 balance = balanceOf(_from);\r\n        require(lockedAmount[_from] + _amount <= balance);\r\n\r\n        _claim();\r\n        _updateReward(_from);\r\n        _updateReward(_to);\r\n        _transfer(_from, _to, _amount);\r\n        _updateDebt(_to);\r\n        _updateDebt(_from);\r\n    }\r\n\r\n    // Any user can transfer to another user.\r\n    function transfer(address _to, uint256 _amount) public override returns (bool) {\r\n        uint256 balance = balanceOf(_msgSender());\r\n        require(lockedAmount[_msgSender()] + _amount <= balance, \"transfer: <= balance\");\r\n\r\n        _updateReward(_msgSender());\r\n        _updateReward(_to);\r\n        _transfer(_msgSender(), _to, _amount);\r\n        _updateDebt(_to);\r\n        _updateDebt(_msgSender());\r\n\r\n        return true;\r\n    }\r\n\r\n    // Must only be called by SodaBank.\r\n    function lockByBank(address _account, uint256 _amount) public {\r\n        require(_msgSender() == sodaMaster.bank(), \"not bank\");\r\n\r\n        uint256 balance = balanceOf(_account);\r\n        require(lockedAmount[_account] + _amount <= balance, \"Vault: lock too much\");\r\n        lockedAmount[_account] += _amount;\r\n    }\r\n\r\n    // Must only be called by SodaBank.\r\n    function unlockByBank(address _account, uint256 _amount) public {\r\n        require(_msgSender() == sodaMaster.bank(), \"not bank\");\r\n\r\n        require(_amount <= lockedAmount[_account], \"Vault: unlock too much\");\r\n        lockedAmount[_account] -= _amount;\r\n    }\r\n\r\n    // Must only be called by SodaPool.\r\n    function clearRewardByPool(address _who) public {\r\n        require(_msgSender() == sodaMaster.pool(), \"not pool\");\r\n\r\n        for (uint256 i = 0; i < strategies.length; ++i) {\r\n            rewards[_who][i] = 0;\r\n        }\r\n    }\r\n\r\n    function getPendingReward(address _who, uint256 _index) public view returns (uint256) {\r\n        uint256 total = totalSupply();\r\n        if (total == 0 || _index >= strategies.length) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 value = strategies[_index].getValuePerShare(address(this));\r\n        uint256 pending = strategies[_index].pendingValuePerShare(address(this));\r\n        uint256 balance = balanceOf(_who);\r\n\r\n        return balance.mul(value.add(pending)).div(PER_SHARE_SIZE).sub(debts[_who][_index]);\r\n    }\r\n\r\n    function _deposit(uint256 _amount) internal {\r\n        for (uint256 i = 0; i < strategies.length; ++i) {\r\n            strategies[i].deposit(address(this), _amount);\r\n        }\r\n    }\r\n\r\n    function _withdraw(uint256 _amount) internal {\r\n        for (uint256 i = 0; i < strategies.length; ++i) {\r\n            strategies[i].withdraw(address(this), _amount);\r\n        }\r\n    }\r\n\r\n    function _claim() internal {\r\n        for (uint256 i = 0; i < strategies.length; ++i) {\r\n            strategies[i].claim(address(this));\r\n        }\r\n    }\r\n\r\n    function _updateReward(address _who) internal {\r\n        uint256 balance = balanceOf(_who);\r\n        if (balance > 0) {\r\n            for (uint256 i = 0; i < strategies.length; ++i) {\r\n                uint256 value = strategies[i].getValuePerShare(address(this));\r\n                rewards[_who][i] = rewards[_who][i].add(balance.mul(\r\n                    value).div(PER_SHARE_SIZE).sub(debts[_who][i]));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateDebt(address _who) internal {\r\n        uint256 balance = balanceOf(_who);\r\n        for (uint256 i = 0; i < strategies.length; ++i) {\r\n            uint256 value = strategies[i].getValuePerShare(address(this));\r\n            debts[_who][i] = balance.mul(value).div(PER_SHARE_SIZE);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/components/SodaPool.sol\r\n\r\n// This contract is owned by Timelock.\r\ncontract SodaPool is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 token;           // Address of token contract.\r\n        SodaVault vault;           // Address of vault contract.\r\n        uint256 startTime;\r\n    }\r\n\r\n    // Info of each pool.\r\n    mapping (uint256 => PoolInfo) public poolMap;  // By poolId\r\n\r\n    event Deposit(address indexed user, uint256 indexed poolId, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed poolId, uint256 amount);\r\n    event Claim(address indexed user, uint256 indexed poolId);\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function setPoolInfo(uint256 _poolId, IERC20 _token, SodaVault _vault, uint256 _startTime) public onlyOwner {\r\n        poolMap[_poolId].token = _token;\r\n        poolMap[_poolId].vault = _vault;\r\n        poolMap[_poolId].startTime = _startTime;\r\n    }\r\n\r\n    function _handleDeposit(SodaVault _vault, IERC20 _token, uint256 _amount) internal {\r\n        uint256 count = _vault.getStrategyCount();\r\n        require(count == 1 || count == 2, \"_handleDeposit: count\");\r\n\r\n        // NOTE: strategy0 is always the main strategy.\r\n        address strategy0 = address(_vault.strategies(0));\r\n        _token.safeTransferFrom(address(msg.sender), strategy0, _amount);\r\n    }\r\n\r\n    function _handleWithdraw(SodaVault _vault, IERC20 _token, uint256 _amount) internal {\r\n        uint256 count = _vault.getStrategyCount();\r\n        require(count == 1 || count == 2, \"_handleWithdraw: count\");\r\n\r\n        address strategy0 = address(_vault.strategies(0));\r\n        _token.safeTransferFrom(strategy0, address(msg.sender), _amount);\r\n    }\r\n\r\n    function _handleRewards(SodaVault _vault) internal {\r\n        uint256 count = _vault.getStrategyCount();\r\n\r\n        for (uint256 i = 0; i < count; ++i) {\r\n            uint256 rewardPending = _vault.rewards(msg.sender, i);\r\n            if (rewardPending > 0) {\r\n                IERC20(_vault.strategies(i).getTargetToken()).safeTransferFrom(\r\n                    address(_vault.strategies(i)), msg.sender, rewardPending);\r\n            }\r\n        }\r\n\r\n        _vault.clearRewardByPool(msg.sender);\r\n    }\r\n\r\n    // Deposit tokens to SodaPool for SODA allocation.\r\n    // If we have a strategy, then tokens will be moved there.\r\n    function deposit(uint256 _poolId, uint256 _amount) public {\r\n        PoolInfo storage pool = poolMap[_poolId];\r\n        require(now >= pool.startTime, \"deposit: after startTime\");\r\n\r\n        _handleDeposit(pool.vault, pool.token, _amount);\r\n        pool.vault.mintByPool(msg.sender, _amount);\r\n\r\n        emit Deposit(msg.sender, _poolId, _amount);\r\n    }\r\n\r\n    // Claim SODA (and potentially other tokens depends on strategy).\r\n    function claim(uint256 _poolId) public {\r\n        PoolInfo storage pool = poolMap[_poolId];\r\n        require(now >= pool.startTime, \"claim: after startTime\");\r\n\r\n        pool.vault.mintByPool(msg.sender, 0);\r\n        _handleRewards(pool.vault);\r\n\r\n        emit Claim(msg.sender, _poolId);\r\n    }\r\n\r\n    // Withdraw tokens from SodaPool (from a strategy first if there is one).\r\n    function withdraw(uint256 _poolId, uint256 _amount) public {\r\n        PoolInfo storage pool = poolMap[_poolId];\r\n        require(now >= pool.startTime, \"withdraw: after startTime\");\r\n\r\n        pool.vault.burnByPool(msg.sender, _amount);\r\n\r\n        _handleWithdraw(pool.vault, pool.token, _amount);\r\n        _handleRewards(pool.vault);\r\n\r\n        emit Withdraw(msg.sender, _poolId, _amount);\r\n    }\r\n}"}
{"address": "0x0624eb9691d99178d0d2bd76c72f1dbb4db05286", "attacktype": "On-chain oracle manipulation", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Hypervisor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/libraries/TickMath.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/libraries/FullMath.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\n\\nimport \\\"../interfaces/IVault.sol\\\";\\nimport \\\"../interfaces/IUniversalVault.sol\\\";\\n\\n// @title Hypervisor\\n// @notice A Uniswap V2-like interface with fungible liquidity to Uniswap V3\\n// which allows for arbitrary liquidity provision: one-sided, lop-sided, and\\n// balanced\\ncontract Hypervisor is IVault, IUniswapV3MintCallback, IUniswapV3SwapCallback, ERC20 {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    IUniswapV3Pool public pool;\\n    IERC20 public token0;\\n    IERC20 public token1;\\n    uint24 public fee;\\n    int24 public tickSpacing;\\n\\n    int24 public baseLower;\\n    int24 public baseUpper;\\n    int24 public limitLower;\\n    int24 public limitUpper;\\n\\n    address public owner;\\n    uint256 public deposit0Max;\\n    uint256 public deposit1Max;\\n    uint256 public maxTotalSupply;\\n    mapping(address=>bool) public list;\\n    bool public whitelisted;\\n\\n    uint256 constant public PRECISION = 1e36;\\n\\n    // @param _pool Uniswap V3 pool for which liquidity is managed\\n    // @param _owner Owner of the Hypervisor\\n    constructor(\\n        address _pool,\\n        address _owner,\\n        string memory name,\\n        string memory symbol\\n    ) ERC20(name, symbol) {\\n        pool = IUniswapV3Pool(_pool);\\n        token0 = IERC20(pool.token0());\\n        token1 = IERC20(pool.token1());\\n        fee = pool.fee();\\n        tickSpacing = pool.tickSpacing();\\n\\n        owner = _owner;\\n\\n        maxTotalSupply = 0; // no cap\\n        deposit0Max = uint256(-1);\\n        deposit1Max = uint256(-1);\\n        whitelisted = false;\\n    }\\n\\n    // @param deposit0 Amount of token0 transfered from sender to Hypervisor\\n    // @param deposit1 Amount of token0 transfered from sender to Hypervisor\\n    // @param to Address to which liquidity tokens are minted\\n    // @return shares Quantity of liquidity tokens minted as a result of deposit\\n    function deposit(\\n        uint256 deposit0,\\n        uint256 deposit1,\\n        address to\\n    ) external override returns (uint256 shares) {\\n        require(deposit0 > 0 || deposit1 > 0, \\\"deposits must be nonzero\\\");\\n        require(deposit0 < deposit0Max && deposit1 < deposit1Max, \\\"deposits must be less than maximum amounts\\\");\\n        require(to != address(0) && to != address(this), \\\"to\\\");\\n        if(whitelisted) {\\n          require(list[to], \\\"must be on the list\\\");\\n        }  \\n\\n        // update fess for inclusion in total pool amounts\\n        (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);\\n        if (baseLiquidity > 0) {\\n            pool.burn(baseLower, baseUpper, 0);\\n        }\\n        (uint128 limitLiquidity,,)  = _position(limitLower, limitUpper);\\n        if (limitLiquidity > 0) {\\n            pool.burn(limitLower, limitUpper, 0);\\n        }\\n\\n        uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(currentTick());\\n        uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));\\n\\n        (uint256 pool0, uint256 pool1) = getTotalAmounts();\\n\\n        uint256 deposit0PricedInToken1 = deposit0.mul(price).div(PRECISION);\\n        shares = deposit1.add(deposit0PricedInToken1);\\n\\n        if (deposit0 > 0) {\\n          token0.safeTransferFrom(msg.sender, address(this), deposit0);\\n        }\\n        if (deposit1 > 0) {\\n          token1.safeTransferFrom(msg.sender, address(this), deposit1);\\n        }\\n\\n        if (totalSupply() != 0) {\\n          uint256 pool0PricedInToken1 = pool0.mul(price).div(PRECISION);\\n          shares = shares.mul(totalSupply()).div(pool0PricedInToken1.add(pool1));\\n        }\\n        _mint(to, shares);\\n        emit Deposit(msg.sender, to, shares, deposit0, deposit1);\\n        // Check total supply cap not exceeded. A value of 0 means no limit.\\n        require(maxTotalSupply == 0 || totalSupply() <= maxTotalSupply, \\\"maxTotalSupply\\\");\\n    }\\n\\n    // @param shares Number of liquidity tokens to redeem as pool assets\\n    // @param to Address to which redeemed pool assets are sent\\n    // @param from Address from which liquidity tokens are sent\\n    // @return amount0 Amount of token0 redeemed by the submitted liquidity tokens\\n    // @return amount1 Amount of token1 redeemed by the submitted liquidity tokens\\n    function withdraw(\\n        uint256 shares,\\n        address to,\\n        address from\\n    ) external override returns (uint256 amount0, uint256 amount1) {\\n        require(shares > 0, \\\"shares\\\");\\n        require(to != address(0), \\\"to\\\");\\n\\n        // Withdraw liquidity from Uniswap pool\\n        (uint256 base0, uint256 base1) =\\n            _burnLiquidity(baseLower, baseUpper, _liquidityForShares(baseLower, baseUpper, shares), to, false);\\n        (uint256 limit0, uint256 limit1) =\\n            _burnLiquidity(limitLower, limitUpper, _liquidityForShares(limitLower, limitUpper, shares), to, false);\\n\\n        // Push tokens proportional to unused balances\\n        uint256 totalSupply = totalSupply();\\n        uint256 unusedAmount0 = token0.balanceOf(address(this)).mul(shares).div(totalSupply);\\n        uint256 unusedAmount1 = token1.balanceOf(address(this)).mul(shares).div(totalSupply);\\n        if (unusedAmount0 > 0) token0.safeTransfer(to, unusedAmount0);\\n        if (unusedAmount1 > 0) token1.safeTransfer(to, unusedAmount1);\\n\\n        amount0 = base0.add(limit0).add(unusedAmount0);\\n        amount1 = base1.add(limit1).add(unusedAmount1);\\n\\n        require(from == msg.sender || IUniversalVault(from).owner() == msg.sender, \\\"Sender must own the tokens\\\");\\n        _burn(from, shares);\\n\\n        emit Withdraw(from, to, shares, amount0, amount1);\\n    }\\n\\n    // @param _baseLower The lower tick of the base position\\n    // @param _baseUpper The upper tick of the base position\\n    // @param _limitLower The lower tick of the limit position\\n    // @param _limitUpper The upper tick of the limit position\\n    // @param feeRecipient Address of recipient of 10% of earned fees since last rebalance\\n    // @param swapQuantity Quantity of tokens to swap; if quantity is positive,\\n    // `swapQuantity` token0 are swaped for token1, if negative, `swapQuantity`\\n    // token1 is swaped for token0\\n    function rebalance(\\n        int24 _baseLower,\\n        int24 _baseUpper,\\n        int24 _limitLower,\\n        int24 _limitUpper,\\n        address feeRecipient,\\n        int256 swapQuantity\\n    ) external override onlyOwner {\\n        require(_baseLower < _baseUpper && _baseLower % tickSpacing == 0 && _baseUpper % tickSpacing == 0,\\n                \\\"base position invalid\\\");\\n        require(_limitLower < _limitUpper && _limitLower % tickSpacing == 0 && _limitUpper % tickSpacing == 0,\\n                \\\"limit position invalid\\\");\\n\\n        // update fees\\n        (uint128 baseLiquidity,,) = _position(baseLower, baseUpper);\\n        if (baseLiquidity > 0) {\\n            pool.burn(baseLower, baseUpper, 0);\\n        }\\n        (uint128 limitLiquidity,,)  = _position(limitLower, limitUpper);\\n        if (limitLiquidity > 0) {\\n            pool.burn(limitLower, limitUpper, 0);\\n        }\\n\\n        // Withdraw all liquidity and collect all fees from Uniswap pool\\n        (, uint256 feesLimit0, uint256 feesLimit1) = _position(baseLower, baseUpper);\\n        (, uint256 feesBase0, uint256 feesBase1)  = _position(limitLower, limitUpper);\\n\\n        uint256 fees0 = feesBase0.add(feesLimit0);\\n        uint256 fees1 = feesBase1.add(feesLimit1);\\n        _burnLiquidity(baseLower, baseUpper, baseLiquidity, address(this), true);\\n        _burnLiquidity(limitLower, limitUpper, limitLiquidity, address(this), true);\\n\\n        // transfer 10% of fees for VISR buybacks\\n        if(fees0 > 0) token0.safeTransfer(feeRecipient, fees0);\\n        if(fees1 > 0) token1.safeTransfer(feeRecipient, fees1);\\n\\n        emit Rebalance(\\n            currentTick(),\\n            token0.balanceOf(address(this)),\\n            token1.balanceOf(address(this)),\\n            fees0,\\n            fees1,\\n            totalSupply()\\n        );\\n\\n        // swap tokens if required\\n        if (swapQuantity != 0) {\\n            pool.swap(\\n                address(this),\\n                swapQuantity > 0,\\n                swapQuantity > 0 ? swapQuantity : -swapQuantity,\\n                swapQuantity > 0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,\\n                abi.encode(address(this))\\n            );\\n        }\\n\\n        baseLower = _baseLower;\\n        baseUpper = _baseUpper;\\n        baseLiquidity = _liquidityForAmounts(\\n            baseLower,\\n            baseUpper,\\n            token0.balanceOf(address(this)),\\n            token1.balanceOf(address(this))\\n        );\\n        _mintLiquidity(baseLower, baseUpper, baseLiquidity, address(this));\\n\\n        limitLower = _limitLower;\\n        limitUpper = _limitUpper;\\n        limitLiquidity = _liquidityForAmounts(\\n            limitLower,\\n            limitUpper,\\n            token0.balanceOf(address(this)),\\n            token1.balanceOf(address(this))\\n        );\\n        _mintLiquidity(limitLower, limitUpper, limitLiquidity, address(this));\\n    }\\n\\n    function _mintLiquidity(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity,\\n        address payer\\n    ) internal returns (uint256 amount0, uint256 amount1) {\\n      if (liquidity > 0) {\\n            (amount0, amount1) = pool.mint(\\n                address(this),\\n                tickLower,\\n                tickUpper,\\n                liquidity,\\n                abi.encode(payer)\\n            );\\n        }\\n    }\\n\\n    function _burnLiquidity(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity,\\n        address to,\\n        bool collectAll\\n    ) internal returns (uint256 amount0, uint256 amount1) {\\n        if (liquidity > 0) {\\n            // Burn liquidity\\n            (uint256 owed0, uint256 owed1) = pool.burn(tickLower, tickUpper, liquidity);\\n\\n            // Collect amount owed\\n            uint128 collect0 = collectAll ? type(uint128).max : _uint128Safe(owed0);\\n            uint128 collect1 = collectAll ? type(uint128).max : _uint128Safe(owed1);\\n            if (collect0 > 0 || collect1 > 0) {\\n                (amount0, amount1) = pool.collect(to, tickLower, tickUpper, collect0, collect1);\\n            }\\n        }\\n    }\\n\\n    function _liquidityForShares(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint256 shares\\n    ) internal view returns (uint128) {\\n        (uint128 position,,) = _position(tickLower, tickUpper);\\n        return _uint128Safe(uint256(position).mul(shares).div(totalSupply()));\\n    }\\n\\n    function _position(int24 tickLower, int24 tickUpper)\\n        internal\\n        view\\n        returns (uint128 liquidity, uint128 tokensOwed0, uint128 tokensOwed1)\\n    {\\n        bytes32 positionKey = keccak256(abi.encodePacked(address(this), tickLower, tickUpper));\\n        (liquidity, , , tokensOwed0, tokensOwed1) = pool.positions(positionKey);\\n    }\\n\\n    function uniswapV3MintCallback(\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external override {\\n        require(msg.sender == address(pool));\\n        address payer = abi.decode(data, (address));\\n\\n        if (payer == address(this)) {\\n            if (amount0 > 0) token0.safeTransfer(msg.sender, amount0);\\n            if (amount1 > 0) token1.safeTransfer(msg.sender, amount1);\\n        } else {\\n            if (amount0 > 0) token0.safeTransferFrom(payer, msg.sender, amount0);\\n            if (amount1 > 0) token1.safeTransferFrom(payer, msg.sender, amount1);\\n        }\\n    }\\n\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external override {\\n        require(msg.sender == address(pool));\\n        address payer = abi.decode(data, (address));\\n\\n        if (amount0Delta > 0) {\\n            if (payer == address(this)) {\\n                token0.safeTransfer(msg.sender, uint256(amount0Delta));\\n            } else {\\n                token0.safeTransferFrom(payer, msg.sender, uint256(amount0Delta));\\n            }\\n        } else if (amount1Delta > 0) {\\n            if (payer == address(this)) {\\n                token1.safeTransfer(msg.sender, uint256(amount1Delta));\\n            } else {\\n                token1.safeTransferFrom(payer, msg.sender, uint256(amount1Delta));\\n            }\\n        }\\n    }\\n\\n    // @return total0 Quantity of token0 in both positions and unused in the Hypervisor\\n    // @return total1 Quantity of token1 in both positions and unused in the Hypervisor\\n    function getTotalAmounts() public view override returns (uint256 total0, uint256 total1) {\\n        (, uint256 base0, uint256 base1) = getBasePosition();\\n        (, uint256 limit0, uint256 limit1) = getLimitPosition();\\n        total0 = token0.balanceOf(address(this)).add(base0).add(limit0);\\n        total1 = token1.balanceOf(address(this)).add(base1).add(limit1);\\n    }\\n\\n    // @return liquidity Amount of total liquidity in the base position\\n    // @return amount0 Estimated amount of token0 that could be collected by\\n    // burning the base position\\n    // @return amount1 Estimated amount of token1 that could be collected by\\n    // burning the base position\\n    function getBasePosition()\\n        public\\n        view\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(baseLower, baseUpper);\\n        (amount0, amount1) = _amountsForLiquidity(baseLower, baseUpper, positionLiquidity);\\n        amount0 = amount0.add(uint256(tokensOwed0));\\n        amount1 = amount1.add(uint256(tokensOwed1));\\n        liquidity = positionLiquidity;\\n    }\\n\\n    // @return liquidity Amount of total liquidity in the limit position\\n    // @return amount0 Estimated amount of token0 that could be collected by\\n    // burning the limit position\\n    // @return amount1 Estimated amount of token1 that could be collected by\\n    // burning the limit position\\n    function getLimitPosition()\\n        public\\n        view\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(limitLower, limitUpper);\\n        (amount0, amount1) = _amountsForLiquidity(limitLower, limitUpper, positionLiquidity);\\n        amount0 = amount0.add(uint256(tokensOwed0));\\n        amount1 = amount1.add(uint256(tokensOwed1));\\n        liquidity = positionLiquidity;\\n    }\\n\\n    function _amountsForLiquidity(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity\\n    ) internal view returns (uint256, uint256) {\\n        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\\n        return\\n            LiquidityAmounts.getAmountsForLiquidity(\\n                sqrtRatioX96,\\n                TickMath.getSqrtRatioAtTick(tickLower),\\n                TickMath.getSqrtRatioAtTick(tickUpper),\\n                liquidity\\n            );\\n    }\\n\\n    function _liquidityForAmounts(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal view returns (uint128) {\\n        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\\n        return\\n            LiquidityAmounts.getLiquidityForAmounts(\\n                sqrtRatioX96,\\n                TickMath.getSqrtRatioAtTick(tickLower),\\n                TickMath.getSqrtRatioAtTick(tickUpper),\\n                amount0,\\n                amount1\\n            );\\n    }\\n\\n    // @return tick Uniswap pool's current price tick\\n    function currentTick() public view returns (int24 tick) {\\n        (, tick, , , , , ) = pool.slot0();\\n    }\\n\\n    function _uint128Safe(uint256 x) internal pure returns (uint128) {\\n        assert(x <= type(uint128).max);\\n        return uint128(x);\\n    }\\n\\n    // @param _maxTotalSupply The maximum liquidity token supply the contract allows\\n    function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyOwner {\\n        maxTotalSupply = _maxTotalSupply;\\n    }\\n\\n    // @param _deposit0Max The maximum amount of token0 allowed in a deposit\\n    // @param _deposit1Max The maximum amount of token1 allowed in a deposit\\n    function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external onlyOwner {\\n        deposit0Max = _deposit0Max;\\n        deposit1Max = _deposit1Max;\\n    }\\n\\n    function emergencyWithdraw(IERC20 token, uint256 amount) external onlyOwner {\\n        token.safeTransfer(msg.sender, amount);\\n    }\\n\\n    function emergencyBurn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity\\n    ) external onlyOwner {\\n        pool.burn(tickLower, tickUpper, liquidity);\\n        pool.collect(msg.sender, tickLower, tickUpper, type(uint128).max, type(uint128).max);\\n    }\\n\\n    function appendList(address[] memory listed) external onlyOwner {\\n        for (uint8 i; i < listed.length; i++) {\\n          list[listed[i]] = true; \\n        }\\n    }\\n\\n    function toggleWhitelist() external onlyOwner {\\n      whitelisted = whitelisted ? false : true;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"only owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#mint\\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\\ninterface IUniswapV3MintCallback {\\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\\n    function uniswapV3MintCallback(\\n        uint256 amount0Owed,\\n        uint256 amount1Owed,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport './pool/IUniswapV3PoolImmutables.sol';\\nimport './pool/IUniswapV3PoolState.sol';\\nimport './pool/IUniswapV3PoolDerivedState.sol';\\nimport './pool/IUniswapV3PoolActions.sol';\\nimport './pool/IUniswapV3PoolOwnerActions.sol';\\nimport './pool/IUniswapV3PoolEvents.sol';\\n\\n/// @title The interface for a Uniswap V3 Pool\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\n/// to the ERC20 specification\\n/// @dev The pool interface is broken up into many smaller pieces\\ninterface IUniswapV3Pool is\\n    IUniswapV3PoolImmutables,\\n    IUniswapV3PoolState,\\n    IUniswapV3PoolDerivedState,\\n    IUniswapV3PoolActions,\\n    IUniswapV3PoolOwnerActions,\\n    IUniswapV3PoolEvents\\n{\\n\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/libraries/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(MAX_TICK), 'T');\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = -denominator & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/libraries/LiquidityAmounts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\\n\\n/// @title Liquidity amount functions\\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\\nlibrary LiquidityAmounts {\\n    /// @notice Downcasts uint256 to uint128\\n    /// @param x The uint258 to be downcasted\\n    /// @return y The passed value, downcasted to uint128\\n    function toUint128(uint256 x) private pure returns (uint128 y) {\\n        require((y = uint128(x)) == x);\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount0 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount0(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount1 The amount1 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount1(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount of token0 being sent in\\n    /// @param amount1 The amount of token1 being sent in\\n    /// @return liquidity The maximum amount of liquidity received\\n    function getLiquidityForAmounts(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\n\\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n        } else {\\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\n        }\\n    }\\n\\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    function getAmount0ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return\\n            FullMath.mulDiv(\\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\\n                sqrtRatioBX96 - sqrtRatioAX96,\\n                sqrtRatioBX96\\n            ) / sqrtRatioAX96;\\n    }\\n\\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount1 The amount of token1\\n    function getAmount1ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    /// @return amount1 The amount of token1\\n    function getAmountsForLiquidity(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\n        } else {\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\npragma solidity 0.7.6;\\n\\ninterface IVault {\\n    function deposit(\\n        uint256,\\n        uint256,\\n        address\\n    ) external returns (uint256);\\n\\n    function withdraw(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (uint256, uint256);\\n\\n    function rebalance(\\n        int24 _baseLower,\\n        int24 _baseUpper,\\n        int24 _limitLower,\\n        int24 _limitUpper,\\n        address feeRecipient,\\n        int256 swapQuantity\\n    ) external;\\n\\n    function getTotalAmounts() external view returns (uint256, uint256);\\n\\n    event Deposit(\\n        address indexed sender,\\n        address indexed to,\\n        uint256 shares,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed to,\\n        uint256 shares,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event Rebalance(\\n        int24 tick,\\n        uint256 totalAmount0,\\n        uint256 totalAmount1,\\n        uint256 feeAmount0,\\n        uint256 feeAmount1,\\n        uint256 totalSupply\\n    );\\n}\\n\"\r\n    },\r\n    \"interfaces/IUniversalVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\ninterface IUniversalVault {\\n    /* user events */\\n\\n    event Locked(address delegate, address token, uint256 amount);\\n    event Unlocked(address delegate, address token, uint256 amount);\\n    event RageQuit(address delegate, address token, bool notified, string reason);\\n\\n    /* data types */\\n\\n    struct LockData {\\n        address delegate;\\n        address token;\\n        uint256 balance;\\n    }\\n\\n    /* initialize function */\\n\\n    function initialize() external;\\n\\n    /* user functions */\\n\\n    function lock(\\n        address token,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external;\\n\\n    function unlock(\\n        address token,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external;\\n\\n    function rageQuit(address delegate, address token)\\n        external\\n        returns (bool notified, string memory error);\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function transferETH(address to, uint256 amount) external payable;\\n\\n    /* pure functions */\\n\\n    function calculateLockID(address delegate, address token)\\n        external\\n        pure\\n        returns (bytes32 lockID);\\n\\n    /* getter functions */\\n\\n    function getPermissionHash(\\n        bytes32 eip712TypeHash,\\n        address delegate,\\n        address token,\\n        uint256 amount,\\n        uint256 nonce\\n    ) external view returns (bytes32 permissionHash);\\n\\n    function getNonce() external view returns (uint256 nonce);\\n\\n    function owner() external view returns (address ownerAddress);\\n\\n    function getLockSetCount() external view returns (uint256 count);\\n\\n    function getLockAt(uint256 index) external view returns (LockData memory lockData);\\n\\n    function getBalanceDelegated(address token, address delegate)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function getBalanceLocked(address token) external view returns (uint256 balance);\\n\\n    function checkBalances() external view returns (bool validity);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that never changes\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\ninterface IUniswapV3PoolImmutables {\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\n    /// @return The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that is not stored\\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\n/// blockchain. The functions here may have variable gas costs.\\ninterface IUniswapV3PoolDerivedState {\\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n    /// you must call it with secondsAgos = [3600, 0].\\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\\n    /// timestamp\\n    function observe(uint32[] calldata secondsAgos)\\n        external\\n        view\\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\\n\\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\n    /// snapshot is taken and the second snapshot is taken.\\n    /// @param tickLower The lower tick of the range\\n    /// @param tickUpper The upper tick of the range\\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (\\n            int56 tickCumulativeInside,\\n            uint160 secondsPerLiquidityInsideX128,\\n            uint32 secondsInside\\n        );\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissionless pool actions\\n/// @notice Contains pool methods that can be called by anyone\\ninterface IUniswapV3PoolActions {\\n    /// @notice Sets the initial price for the pool\\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\\n    function initialize(uint160 sqrtPriceX96) external;\\n\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to mint\\n    /// @param data Any data that should be passed through to the callback\\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    function mint(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount,\\n        bytes calldata data\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Collects tokens owed to a position\\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n    /// @param recipient The address which should receive the fees collected\\n    /// @param tickLower The lower tick of the position for which to collect fees\\n    /// @param tickUpper The upper tick of the position for which to collect fees\\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n    /// @dev Fees must be collected separately via a call to #collect\\n    /// @param tickLower The lower tick of the position for which to burn liquidity\\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\\n    /// @param amount How much liquidity to burn\\n    /// @return amount0 The amount of token0 sent to the recipient\\n    /// @return amount1 The amount of token1 sent to the recipient\\n    function burn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Swap token0 for token1, or token1 for token0\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\n    /// @param amount0 The amount of token0 to send\\n    /// @param amount1 The amount of token1 to send\\n    /// @param data Any data to be passed through to the callback\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissioned pool actions\\n/// @notice Contains pool methods that may only be called by the factory owner\\ninterface IUniswapV3PoolOwnerActions {\\n    /// @notice Set the denominator of the protocol's % share of the fees\\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\\n\\n    /// @notice Collect the protocol fee accrued to the pool\\n    /// @param recipient The address to which collected protocol fees should be sent\\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\\n    /// @return amount0 The protocol fee collected in token0\\n    /// @return amount1 The protocol fee collected in token1\\n    function collectProtocol(\\n        address recipient,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Events emitted by a pool\\n/// @notice Contains all events emitted by the pool\\ninterface IUniswapV3PoolEvents {\\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\\n\\n    /// @notice Emitted when liquidity is minted for a given position\\n    /// @param sender The address that minted the liquidity\\n    /// @param owner The owner of the position and recipient of any minted liquidity\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity minted to the position range\\n    /// @param amount0 How much token0 was required for the minted liquidity\\n    /// @param amount1 How much token1 was required for the minted liquidity\\n    event Mint(\\n        address sender,\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted when fees are collected by the owner of a position\\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\n    /// @param owner The owner of the position for which fees are collected\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount0 The amount of token0 fees collected\\n    /// @param amount1 The amount of token1 fees collected\\n    event Collect(\\n        address indexed owner,\\n        address recipient,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount0,\\n        uint128 amount1\\n    );\\n\\n    /// @notice Emitted when a position's liquidity is removed\\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\n    /// @param owner The owner of the position for which liquidity is removed\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity to remove\\n    /// @param amount0 The amount of token0 withdrawn\\n    /// @param amount1 The amount of token1 withdrawn\\n    event Burn(\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted by the pool for any swaps between token0 and token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the output of the swap\\n    /// @param amount0 The delta of the token0 balance of the pool\\n    /// @param amount1 The delta of the token1 balance of the pool\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    /// @param liquidity The liquidity of the pool after the swap\\n    /// @param tick The log base 1.0001 of price of the pool after the swap\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        int256 amount0,\\n        int256 amount1,\\n        uint160 sqrtPriceX96,\\n        uint128 liquidity,\\n        int24 tick\\n    );\\n\\n    /// @notice Emitted by the pool for any flashes of token0/token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the tokens from flash\\n    /// @param amount0 The amount of token0 that was flashed\\n    /// @param amount1 The amount of token1 that was flashed\\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\n    event Flash(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 paid0,\\n        uint256 paid1\\n    );\\n\\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n    /// just before a mint/swap/burn.\\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n    event IncreaseObservationCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    /// @notice Emitted when the protocol fee is changed by the pool\\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\\n\\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\\n    /// @param sender The address that collects the protocol fees\\n    /// @param recipient The address that receives the collected protocol fees\\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x7b3b69eab43c1aa677df04b4b65f0d169fcdc6ca", "attacktype": "Visibility errors, including unrestricted action", "sourcecode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Copyright (c) 2021 0xdev0 - All rights reserved\r\n// https://twitter.com/0xdev0\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n  function initialize() external;\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address account) external view returns (uint);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint);\r\n  function approve(address spender, uint amount) external returns (bool);\r\n  function mint(address account, uint amount) external;\r\n  function burn(address account, uint amount) external;\r\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IInterestRateModel {\r\n  function systemRate(ILendingPair _pair) external view returns(uint);\r\n  function supplyRatePerBlock(ILendingPair _pair, address _token) external view returns(uint);\r\n  function borrowRatePerBlock(ILendingPair _pair, address _token) external view returns(uint);\r\n}\r\n\r\ninterface IController {\r\n  function interestRateModel() external view returns(IInterestRateModel);\r\n  function feeRecipient() external view returns(address);\r\n  function liqMinHealth() external view returns(uint);\r\n  function liqFeePool() external view returns(uint);\r\n  function liqFeeSystem() external view returns(uint);\r\n  function liqFeeCaller() external view returns(uint);\r\n  function liqFeesTotal() external view returns(uint);\r\n  function tokenPrice(address _token) external view returns(uint);\r\n  function depositLimit(address _lendingPair, address _token) external view returns(uint);\r\n}\r\n\r\ninterface ILendingPair {\r\n  function checkAccountHealth(address _account) external view;\r\n  function accrueAccount(address _account) external;\r\n  function accrue() external;\r\n  function accountHealth(address _account) external view returns(uint);\r\n  function totalDebt(address _token) external view returns(uint);\r\n  function tokenA() external view returns(address);\r\n  function tokenB() external view returns(address);\r\n  function lpToken(address _token) external view returns(IERC20);\r\n  function debtOf(address _account, address _token) external view returns(uint);\r\n  function deposit(address _token, uint _amount) external;\r\n  function withdraw(address _token, uint _amount) external;\r\n  function borrow(address _token, uint _amount) external;\r\n  function repay(address _token, uint _amount) external;\r\n  function withdrawRepay(address _token, uint _amount) external;\r\n  function withdrawBorrow(address _token, uint _amount) external;\r\n  function controller() external view returns(IController);\r\n\r\n  function convertTokenValues(\r\n    address _fromToken,\r\n    address _toToken,\r\n    uint    _inputAmount\r\n  ) external view returns(uint);\r\n}\r\n\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), owner);\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == owner;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(owner, address(0));\r\n    owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract LPTokenMaster is Ownable {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n  mapping (address => uint) public balanceOf;\r\n  mapping (address => mapping (address => uint)) public allowance;\r\n\r\n  string public constant name     = \"WILD-LP\";\r\n  string public constant symbol   = \"WILD-LP\";\r\n  uint8  public constant decimals = 18;\r\n  uint public totalSupply;\r\n\r\n  function initialize() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function transfer(address _recipient, uint _amount) public returns (bool) {\r\n    _transfer(msg.sender, _recipient, _amount);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint _amount) public returns (bool) {\r\n    _approve(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _sender, address _recipient, uint _amount) public returns (bool) {\r\n    _transfer(_sender, _recipient, _amount);\r\n    _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);\r\n    return true;\r\n  }\r\n\r\n  function _transfer(address _sender, address _recipient, uint _amount) internal {\r\n    require(_sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(_recipient != address(0), \"ERC20: transfer to the zero address\");\r\n    require(balanceOf[_sender] >= _amount, \"ERC20: insufficient funds\");\r\n\r\n    ILendingPair pair = ILendingPair(owner);\r\n    pair.accrueAccount(_sender);\r\n    pair.accrueAccount(_recipient);\r\n\r\n    balanceOf[_sender] -= _amount;\r\n    balanceOf[_recipient] += _amount;\r\n\r\n    pair.checkAccountHealth(_sender);\r\n    emit Transfer(_sender, _recipient, _amount);\r\n  }\r\n\r\n  function mint(address _account, uint _amount) public onlyOwner {\r\n    _mint(_account, _amount);\r\n  }\r\n\r\n  function burn(address _account, uint _amount) public onlyOwner {\r\n    _burn(_account, _amount);\r\n  }\r\n\r\n  function selfBurn(uint _amount) public {\r\n    _burn(msg.sender, _amount);\r\n  }\r\n\r\n  function _mint(address _account, uint _amount) internal {\r\n    require(_account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n    totalSupply += _amount;\r\n    balanceOf[_account] += _amount;\r\n    emit Transfer(address(0), _account, _amount);\r\n  }\r\n\r\n  function _burn(address _account, uint _amount) internal {\r\n    require(_account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n    balanceOf[_account] -= _amount;\r\n    totalSupply -= _amount;\r\n    emit Transfer(_account, address(0), _amount);\r\n  }\r\n\r\n  function _approve(address _owner, address _spender, uint _amount) internal {\r\n    require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(_spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    allowance[_owner][_spender] = _amount;\r\n    emit Approval(_owner, _spender, _amount);\r\n  }\r\n\r\n  function _concat(\r\n    string memory a,\r\n    string memory b,\r\n    string memory c,\r\n    string memory d,\r\n    string memory e\r\n  ) internal pure returns(string memory) {\r\n    return string(abi.encodePacked(a, b, c, e, d));\r\n  }\r\n}"}
{"address": "0x3212b29e33587a00fb1c83346f5dbfa69a458923", "attacktype": "Token standard incompatibility, Reentrancy", "sourcecode": "pragma solidity 0.5.0;\r\n// File: src/erc777/IERC777.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See `IERC1820Registry` and\r\n * `ERC1820Implementer`.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`owner`).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * If send or receive hooks are registered for the caller and `recipient`,\r\n     * the corresponding functions will be called with `data` and empty\r\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\r\n     *\r\n     * Emits a `Sent` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\r\n     * interface.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\r\n     *\r\n     * Emits a `Burned` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of `tokenHolder`.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See `operatorSend` and `operatorBurn`.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See `isOperatorFor`.\r\n     *\r\n     * Emits an `AuthorizedOperator` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See `isOperatorFor` and `defaultOperators`.\r\n     *\r\n     * Emits a `RevokedOperator` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if `authorizeOperator` was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * `revokeOperator`, in which case `isOperatorFor` will return false.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\r\n     * be an operator of `sender`.\r\n     *\r\n     * If send or receive hooks are registered for `sender` and `recipient`,\r\n     * the corresponding functions will be called with `data` and\r\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\r\n     *\r\n     * Emits a `Sent` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `sender` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `sender`.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\r\n     * The caller must be an operator of `account`.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `data` and `operatorData`. See `IERC777Sender`.\r\n     *\r\n     * Emits a `Burned` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `account`.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n// File: src/erc777/IERC777Recipient.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of `IERC777` tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\r\n *\r\n * See `IERC1820Registry` and `ERC1820Implementer`.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an `IERC777` token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n// File: src/erc777/IERC777Sender.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\r\n *\r\n * `IERC777` Token holders can be notified of operations performed on their\r\n * tokens by having a contract implement this interface (contract holders can be\r\n *  their own implementer) and registering it on the\r\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\r\n *\r\n * See `IERC1820Registry` and `ERC1820Implementer`.\r\n */\r\ninterface IERC777Sender {\r\n    /**\r\n     * @dev Called by an `IERC777` token contract whenever a registered holder's\r\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\r\n     * is conveyed by `to` being the zero address or not.\r\n     *\r\n     * This call occurs _before_ the token contract's state is updated, so\r\n     * `IERC777.balanceOf`, etc., can be used to query the pre-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC1820Registry.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-1820). Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * `IERC165` interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a `ManagerChanged` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See `setManager`.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as `account`'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See `interfaceHash` to learn how these are created.\r\n     *\r\n     * Emits an `InterfaceImplementerSet` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an `IERC165` interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement `IERC1820Implementer` and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * `IERC1820Implementer.canImplementInterfaceForAddress`.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an `IERC165` interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * [section of the EIP](https://eips.ethereum.org/EIPS/eip-1820#interface-name).\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  'updateERC165Cache' with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account.address()` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account.address()` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n// File: src/erc777/EarnERC777.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract EarnERC777 is IERC777, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    struct Balance {\r\n        uint256 value;\r\n        uint256 exchangeRate;\r\n    }\r\n\r\n    uint256 constant RATE_SCALE = 10**18;\r\n    uint256 constant DECIMAL_SCALE = 10**18;\r\n\r\n    IERC1820Registry internal _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    mapping(address => Balance) internal _balances;\r\n\r\n    uint256 internal _totalSupply;\r\n    uint256 internal _exchangeRate;\r\n\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint8 internal _decimals;\r\n\r\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\r\n    // See https://github.com/ethereum/solidity/issues/4024.\r\n\r\n    // keccak256(\"ERC777TokensSender\")\r\n    bytes32 constant internal TOKENS_SENDER_INTERFACE_HASH =\r\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\r\n\r\n    // keccak256(\"ERC777TokensRecipient\")\r\n    bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\r\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n    //Empty, This is only used to respond the defaultOperators query.\r\n    address[] internal _defaultOperatorsArray;\r\n\r\n    // For each account, a mapping of its operators and revoked default operators.\r\n    mapping(address => mapping(address => bool)) internal _operators;\r\n\r\n    // ERC20-allowances\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n    constructor(\r\n        string memory symbol,\r\n        string memory name,\r\n        uint8 decimals\r\n    ) public {\r\n        require(decimals <= 18, \"decimals must be less or equal than 18\");\r\n\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n\r\n        _exchangeRate = 10**18;\r\n\r\n        // register interfaces\r\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\r\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.name`.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.symbol`.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See `ERC20Detailed.decimals`.\r\n     *\r\n     * Always returns 18, as per the\r\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\r\n     */\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.granularity`.\r\n     *\r\n     * This implementation always returns `1`.\r\n     */\r\n    function granularity() external view returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.totalSupply`.\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply.div(DECIMAL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\r\n     */\r\n    function balanceOf(address who) external view returns (uint256) {\r\n        return _balanceOf(who);\r\n    }\r\n\r\n    function _balanceOf(address who) internal view returns (uint256) {\r\n        return _getBalance(who).value.div(DECIMAL_SCALE);\r\n    }\r\n\r\n    function accuracyBalanceOf(address who) external view returns (uint256) {\r\n        return _getBalance(who).value ;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.send`.\r\n     *\r\n     * Also emits a `Transfer` event for ERC20 compatibility.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external {\r\n        _send(msg.sender, msg.sender, recipient, amount, data, \"\", true);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Unlike `send`, `recipient` is _not_ required to implement the `tokensReceived`\r\n     * interface if it is a contract.\r\n     *\r\n     * Also emits a `Sent` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        return _transfer(recipient, amount);\r\n    }\r\n\r\n    function _transfer(address recipient, uint256 amount) internal returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\r\n\r\n        address from = msg.sender;\r\n\r\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\r\n\r\n        _move(from, from, recipient, amount, \"\", \"\");\r\n\r\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.burn`.\r\n     *\r\n     * Also emits a `Transfer` event for ERC20 compatibility.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external {\r\n        _burn(msg.sender, msg.sender, amount, data, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.isOperatorFor`.\r\n     */\r\n    function isOperatorFor(\r\n        address operator,\r\n        address tokenHolder\r\n    ) public view returns (bool) {\r\n        return operator == tokenHolder ||\r\n            _operators[tokenHolder][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.authorizeOperator`.\r\n     */\r\n    function authorizeOperator(address operator) external {\r\n        require(msg.sender != operator, \"ERC777: authorizing self as operator\");\r\n\r\n       _operators[msg.sender][operator] = true;\r\n\r\n        emit AuthorizedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.revokeOperator`.\r\n     */\r\n    function revokeOperator(address operator) external {\r\n        require(operator != msg.sender, \"ERC777: revoking self as operator\");\r\n\r\n        delete _operators[msg.sender][operator];\r\n\r\n        emit RevokedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.defaultOperators`.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory) {\r\n        return _defaultOperatorsArray;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.operatorSend`.\r\n     *\r\n     * Emits `Sent` and `Transfer` events.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external {\r\n        require(isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\r\n        _send(msg.sender, sender, recipient, amount, data, operatorData, true);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC777.operatorBurn`.\r\n     *\r\n     * Emits `Sent` and `Transfer` events.\r\n     */\r\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\r\n        require(isOperatorFor(msg.sender, account), \"ERC777: caller is not an operator for holder\");\r\n        _burn(msg.sender, account, amount, data, operatorData);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     *\r\n     * Note that operator and allowance concepts are orthogonal: operators may\r\n     * not have allowance, and accounts with allowance may not be operators\r\n     * themselves.\r\n     */\r\n    function allowance(address holder, address spender) external view returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Note that accounts cannot have allowance issued by their operators.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool) {\r\n        address holder = msg.sender;\r\n        _approve(holder, spender, value);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    * @dev See `IERC20.transferFrom`.\r\n    *\r\n    * Note that operator and allowance concepts are orthogonal: operators cannot\r\n    * call `transferFrom` (unless they have allowance), and accounts with\r\n    * allowance cannot call `operatorSend` (unless they are operators).\r\n    *\r\n    * Emits `Sent` and `Transfer` events.\r\n    */\r\n    function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {\r\n        return _transferFrom(holder, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address holder, address recipient, uint256 amount) internal returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\r\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\r\n\r\n        address spender = msg.sender;\r\n\r\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\r\n\r\n        _move(spender, holder, recipient, amount, \"\", \"\");\r\n\r\n        _approve(holder, spender, _allowances[holder][spender].sub(amount));\r\n\r\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * If a send hook is registered for `raccount`, the corresponding function\r\n     * will be called with `operator`, `data` and `operatorData`.\r\n     *\r\n     * See `IERC777Sender` and `IERC777Recipient`.\r\n     *\r\n     * Emits `Sent` and `Transfer` events.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - if `account` is a contract, it must implement the `tokensReceived`\r\n     * interface.\r\n     */\r\n    function _mint(\r\n        address operator,\r\n        address account,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n    internal\r\n    {\r\n        require(account != address(0), \"ERC777: mint to the zero address\");\r\n\r\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, false);\r\n\r\n        uint256 scaleAmount = amount.mul(DECIMAL_SCALE);\r\n        _totalSupply = _totalSupply.add(scaleAmount);\r\n        _addBalance(account, scaleAmount);\r\n\r\n        emit Minted(operator, account, amount, userData, operatorData);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _getBalance(address account) internal view returns (Balance memory) {\r\n        Balance memory balance = _balances[account];\r\n\r\n        if (balance.value == uint256(0)) {\r\n            balance.value = 0;\r\n            balance.exchangeRate = _exchangeRate;\r\n        } else if (balance.exchangeRate != _exchangeRate) {\r\n            balance.value = balance.value.mul(_exchangeRate).div(balance.exchangeRate);\r\n            balance.exchangeRate = _exchangeRate;\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    function _addBalance(address account, uint256 amount) internal {\r\n        Balance memory balance = _getBalance(account);\r\n\r\n        balance.value = balance.value.add(amount);\r\n\r\n        _balances[account] = balance;\r\n    }\r\n\r\n    function _subBalance(address account, uint256 amount) internal {\r\n        Balance memory balance = _getBalance(account);\r\n\r\n        balance.value = balance.value.sub(amount);\r\n\r\n        _balances[account] = balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Send tokens\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _send(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n        internal\r\n    {\r\n        require(from != address(0), \"ERC777: send from the zero address\");\r\n        require(to != address(0), \"ERC777: send to the zero address\");\r\n\r\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\r\n\r\n        _move(operator, from, to, amount, userData, operatorData);\r\n\r\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\r\n    }\r\n\r\n    /**\r\n     * @dev Burn tokens\r\n     * @param operator address operator requesting the operation\r\n     * @param from address token holder address\r\n     * @param amount uint256 amount of tokens to burn\r\n     * @param data bytes extra information provided by the token holder\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _burn(\r\n        address operator,\r\n        address from,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    )\r\n        internal\r\n    {\r\n        require(from != address(0), \"ERC777: burn from the zero address\");\r\n\r\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\r\n\r\n        uint256 scaleAmount = amount.mul(DECIMAL_SCALE);\r\n\r\n        _totalSupply = _totalSupply.sub(scaleAmount);\r\n        _subBalance(from, scaleAmount);\r\n\r\n        emit Burned(operator, from, amount, data, operatorData);\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _move(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n        internal\r\n    {\r\n        uint256 scaleAmount = amount.mul(DECIMAL_SCALE);\r\n\r\n        _subBalance(from,scaleAmount);\r\n        _addBalance(to,scaleAmount);\r\n\r\n        emit Sent(operator, from, to, amount, userData, operatorData);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _approve(address holder, address spender, uint256 value) internal {\r\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\r\n        // currently unnecessary.\r\n        //require(holder != address(0), \"ERC777: approve from the zero address\");\r\n        require(spender != address(0), \"ERC777: approve to the zero address\");\r\n\r\n        _allowances[holder][spender] = value;\r\n        emit Approval(holder, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Call from.tokensToSend() if the interface is registered\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _callTokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    )\r\n        internal\r\n    {\r\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\r\n     * tokensReceived() was not registered for the recipient\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _callTokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    )\r\n        internal\r\n    {\r\n        address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\r\n        if (implementer != address(0)) {\r\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\r\n        } else if (requireReceptionAck) {\r\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\r\n        }\r\n    }\r\n\r\n    function _distributeRevenue(address account) internal returns (bool) {\r\n        uint256 value = _getBalance(account).value;\r\n\r\n        require(value > 0, 'Token: the revenue balance must be large than zero');\r\n        require(_totalSupply > value, 'Token: total supply must be large than revenue');\r\n\r\n        delete _balances[account];\r\n\r\n        _exchangeRate = _exchangeRate.mul(_totalSupply.mul(RATE_SCALE).div(_totalSupply.sub(value))).div(RATE_SCALE);\r\n\r\n        emit Transfer(account, address(0), value.div(DECIMAL_SCALE));\r\n        emit RevenueDistributed(account, _exchangeRate, value.div(DECIMAL_SCALE), value.mod(DECIMAL_SCALE));\r\n\r\n        return true;\r\n    }\r\n\r\n    function exchangeRate() external view returns (uint256) {\r\n        return _exchangeRate;\r\n    }\r\n\r\n    event RevenueDistributed(address indexed account, uint256 exchangeRate, uint256 value, uint256 remainder);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: src/Ownable.sol\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _newOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the new owner will be set\r\n     */\r\n     function newOwner() public view returns (address) {\r\n        return _newOwner;\r\n     }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address account) public onlyOwner {\r\n        _transferOwnership(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address account) internal {\r\n        require(account != address(0), \"Ownable: new owner is the zero address\");\r\n        require(account != _newOwner, \"Ownable: new owner is the same as previous owner\");\r\n\r\n        _newOwner = account;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (\u2018 newOwner \u2018).\r\n     * Can only be called by the current owner .\r\n     */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == _newOwner, \"Ownable: msg.sender is not the same as newOwner\");\r\n\r\n        emit OwnershipTransferred(_owner, _newOwner);\r\n\r\n        _owner = _newOwner;\r\n        _newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: src/MinterRole.sol\r\n\r\n\r\n\r\n\r\n contract MinterRole is Ownable {\r\n     using Roles for Roles.Role;\r\n\r\n     event MinterAdded(address indexed operator, address indexed account);\r\n     event MinterRemoved(address indexed operator, address indexed account);\r\n\r\n     Roles.Role private _minters;\r\n\r\n     constructor () internal {\r\n         _addMinter(msg.sender);\r\n     }\r\n\r\n     modifier onlyMinter() {\r\n         require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\r\n         _;\r\n     }\r\n\r\n     function isMinter(address account) public view returns (bool) {\r\n         return _minters.has(account);\r\n     }\r\n\r\n     function addMinter(address account) public onlyOwner {\r\n         _addMinter(account);\r\n     }\r\n\r\n     function removeMinter(address account) public onlyOwner {\r\n         _removeMinter(account);\r\n     }\r\n\r\n     function _addMinter(address account) internal {\r\n         _minters.add(account);\r\n         emit MinterAdded(msg.sender, account);\r\n     }\r\n\r\n     function _removeMinter(address account) internal {\r\n         _minters.remove(account);\r\n         emit MinterRemoved(msg.sender, account);\r\n     }\r\n }\r\n\r\n// File: src/Pausable.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Ownable {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address indexed account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address indexed account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: src/SwitchTransferable.sol\r\n\r\n\r\n\r\ncontract SwitchTransferable is Ownable {\r\n    event TransferEnabled(address indexed operator);\r\n    event TransferDisabled(address indexed operator);\r\n\r\n    bool private _transferable;\r\n\r\n    constructor () internal {\r\n        _transferable = false;\r\n    }\r\n\r\n    modifier whenTransferable() {\r\n        require(_transferable, \"transferable must be true\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotTransferable() {\r\n        require(!_transferable, \"transferable must not be true\");\r\n        _;\r\n    }\r\n\r\n    function transferable() public view returns (bool) {\r\n        return _transferable;\r\n    }\r\n\r\n    function enableTransfer() public onlyOwner whenNotTransferable {\r\n        _transferable = true;\r\n        emit TransferEnabled(msg.sender);\r\n    }\r\n\r\n    function disableTransfer() public onlyOwner whenTransferable {\r\n        _transferable = false;\r\n        emit TransferDisabled(msg.sender);\r\n    }\r\n}\r\n\r\n// File: src/IMBTC.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IMBTC is EarnERC777, MinterRole, Pausable, SwitchTransferable {\r\n    address internal _revenueAddress;\r\n\r\n    constructor() EarnERC777(\"imBTC\",\"The Tokenized Bitcoin\",8) public {\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external whenNotPaused whenTransferable returns (bool) {\r\n        return super._transfer(recipient, amount);\r\n    }\r\n\r\n    function send(address recipient, uint256 amount, bytes calldata data) external whenTransferable whenNotPaused {\r\n        super._send(msg.sender, msg.sender, recipient, amount, data, \"\", true);\r\n    }\r\n\r\n    function burn(uint256 amount, bytes calldata data) external whenTransferable whenNotPaused {\r\n        super._burn(msg.sender, msg.sender, amount, data, \"\");\r\n    }\r\n\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external whenTransferable whenNotPaused {\r\n        require(isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\r\n        super._send(msg.sender, sender, recipient, amount, data, operatorData, true);\r\n    }\r\n\r\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData)\r\n        external whenTransferable whenNotPaused {\r\n        require(isOperatorFor(msg.sender, account), \"ERC777: caller is not an operator for holder\");\r\n        super._burn(msg.sender, account, amount, data, operatorData);\r\n    }\r\n\r\n    function mint(address recipient, uint256 amount,\r\n            bytes calldata userData, bytes calldata operatorData) external onlyMinter whenNotPaused {\r\n        super._mint(msg.sender, recipient, amount, userData, operatorData);\r\n    }\r\n\r\n    function transferFrom(address holder, address recipient, uint256 amount) external whenNotPaused returns (bool) {\r\n        require(transferable(), \"Token: transferable must be true\");\r\n        return super._transferFrom(holder, recipient, amount);\r\n   }\r\n\r\n   function setRevenueAddress(address account) external onlyOwner {\r\n       require(_allowances[account][address(this)] > 0, \"Token: the allowances of account must be large than zero\");\r\n\r\n       _revenueAddress = account;\r\n\r\n       emit RevenueAddressSet(account);\r\n   }\r\n\r\n   function revenueAddress() external view returns (address) {\r\n       return _revenueAddress;\r\n   }\r\n\r\n   function revenue() external view returns (uint256) {\r\n       return _balanceOf(_revenueAddress);\r\n   }\r\n\r\n   event RevenueAddressSet(address indexed account);\r\n\r\n   function distributeRevenue() external whenNotPaused {\r\n       require(_revenueAddress != address(0), 'Token: revenue address must not be zero');\r\n\r\n       _distributeRevenue(_revenueAddress);\r\n   }\r\n}"}
{"address": "0x5bd628141c62a901e0a83e630ce5fafa95bbdee4", "attacktype": "Unfair slippage protection, Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"temp-contracts/balancer/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BConst {\\n  uint256 public constant VERSION_NUMBER = 1;\\n\\n/* ---  Weight Updates  --- */\\n\\n  // Minimum time passed between each weight update for a token.\\n  uint256 internal constant WEIGHT_UPDATE_DELAY = 30 minutes;\\n\\n  // Maximum percent by which a weight can adjust at a time\\n  // relative to the current weight.\\n  // The number of iterations needed to move from weight A to weight B is the floor of:\\n  // (A > B): (ln(A) - ln(B)) / ln(1.01)\\n  // (B > A): (ln(A) - ln(B)) / ln(0.99)\\n  uint256 internal constant WEIGHT_CHANGE_PCT = BONE/100;\\n\\n  uint256 internal constant BONE = 10**18;\\n\\n  uint256 internal constant MIN_BOUND_TOKENS = 2;\\n  uint256 internal constant MAX_BOUND_TOKENS = 10;\\n\\n  // Minimum swap fee.\\n  uint256 internal constant MIN_FEE = BONE / 10**6;\\n  // Maximum swap or exit fee.\\n  uint256 internal constant MAX_FEE = BONE / 10;\\n  // Actual exit fee.\\n  uint256 internal constant EXIT_FEE = 5e15;\\n\\n  // Default total of all desired weights. Can differ by up to BONE.\\n  uint256 internal constant DEFAULT_TOTAL_WEIGHT = BONE * 25;\\n  // Minimum weight for any token (1/100).\\n  uint256 internal constant MIN_WEIGHT = BONE / 4;\\n  uint256 internal constant MAX_WEIGHT = BONE * 25;\\n  // Maximum total weight.\\n  uint256 internal constant MAX_TOTAL_WEIGHT = BONE * 27;\\n  // Minimum balance for a token (only applied at initialization)\\n  uint256 internal constant MIN_BALANCE = BONE / 10**12;\\n  // Initial pool tokens\\n  uint256 internal constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\\n\\n  // Maximum ratio of input tokens to balance for swaps.\\n  uint256 internal constant MAX_IN_RATIO = BONE / 2;\\n  // Maximum ratio of output tokens to balance for swaps.\\n  uint256 internal constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BMath.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BMath is BConst, BNum {\\n  /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcSpotPrice(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 spotPrice) {\\n    uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n    uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n    uint256 ratio = bdiv(numer, denom);\\n    uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\\n    return (spotPrice = bmul(ratio, scale));\\n  }\\n\\n  /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcOutGivenIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n    uint256 adjustedIn = bsub(BONE, swapFee);\\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n    uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n    uint256 foo = bpow(y, weightRatio);\\n    uint256 bar = bsub(BONE, foo);\\n    tokenAmountOut = bmul(tokenBalanceOut, bar);\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n    uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\\n    uint256 y = bdiv(tokenBalanceOut, diff);\\n    uint256 foo = bpow(y, weightRatio);\\n    foo = bsub(foo, BONE);\\n    tokenAmountIn = bsub(BONE, swapFee);\\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n  function calcPoolOutGivenSingleIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountOut) {\\n    // Charge the trading fee for the proportion of tokenAi\\n    ///  which is implicitly traded to the other pool tokens.\\n    // That proportion is (1- weightTokenIn)\\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n    uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n    uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n    // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n    uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    poolAmountOut = bsub(newPoolSupply, poolSupply);\\n    return poolAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n  function calcSingleInGivenPoolOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n    uint256 boo = bdiv(BONE, normalizedWeight);\\n    uint256 tokenInRatio = bpow(poolRatio, boo);\\n    uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n    uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n    //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n    uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n  function calcSingleOutGivenPoolIn(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    // charge exit fee on the pool token side\\n    // pAiAfterExitFee = pAi*(1-exitFee)\\n    uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n    uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    // newBalTo = poolRatio^(1/weightTo) * balTo;\\n    uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n    uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n    uint256 tokenAmountOutBeforeSwapFee = bsub(\\n      tokenBalanceOut,\\n      newTokenBalanceOut\\n    );\\n\\n    // charge swap fee on the output token side\\n    //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n  function calcPoolInGivenSingleOut(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountIn) {\\n    // charge swap fee on the output token side\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n    uint256 zoo = bsub(BONE, normalizedWeight);\\n    uint256 zar = bmul(zoo, swapFee);\\n    uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n    uint256 newTokenBalanceOut = bsub(\\n      tokenBalanceOut,\\n      tokenAmountOutBeforeSwapFee\\n    );\\n    uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n    //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n    uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n    // charge exit fee on the pool token side\\n    // pAi = pAiAfterExitFee/(1-exitFee)\\n    poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n    return poolAmountIn;\\n  }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BConst.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BNum is BConst {\\n  function btoi(uint256 a) internal pure returns (uint256) {\\n    return a / BONE;\\n  }\\n\\n  function bfloor(uint256 a) internal pure returns (uint256) {\\n    return btoi(a) * BONE;\\n  }\\n\\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    (uint256 c, bool flag) = bsubSign(a, b);\\n    require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsubSign(uint256 a, uint256 b)\\n    internal\\n    pure\\n    returns (uint256, bool)\\n  {\\n    if (a >= b) {\\n      return (a - b, false);\\n    } else {\\n      return (b - a, true);\\n    }\\n  }\\n\\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c0 = a * b;\\n    require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n    uint256 c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n    uint256 c1 = c0 + (b / 2);\\n    require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n    uint256 c2 = c1 / b;\\n    return c2;\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n    uint256 z = n % 2 != 0 ? a : BONE;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      a = bmul(a, a);\\n\\n      if (n % 2 != 0) {\\n        z = bmul(z, a);\\n      }\\n    }\\n    return z;\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n    require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n    require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n    uint256 whole = bfloor(exp);\\n    uint256 remain = bsub(exp, whole);\\n\\n    uint256 wholePow = bpowi(base, btoi(whole));\\n\\n    if (remain == 0) {\\n      return wholePow;\\n    }\\n\\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n    return bmul(wholePow, partialResult);\\n  }\\n\\n  function bpowApprox(\\n    uint256 base,\\n    uint256 exp,\\n    uint256 precision\\n  ) internal pure returns (uint256) {\\n    // term 0:\\n    uint256 a = exp;\\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\\n    uint256 term = BONE;\\n    uint256 sum = term;\\n    bool negative = false;\\n\\n    // term(k) = numer / denom\\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\\n    // continue until term is less than precision\\n    for (uint256 i = 1; term >= precision; i++) {\\n      uint256 bigK = i * BONE;\\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n      term = bmul(term, bmul(c, x));\\n      term = bdiv(term, bigK);\\n      if (term == 0) break;\\n\\n      if (xneg) negative = !negative;\\n      if (cneg) negative = !negative;\\n      if (negative) {\\n        sum = bsub(sum, term);\\n      } else {\\n        sum = badd(sum, term);\\n      }\\n    }\\n\\n    return sum;\\n  }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BToken.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\n// Highly opinionated token implementation\\ninterface IERC20 {\\n  event Approval(address indexed src, address indexed dst, uint256 amt);\\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address whom) external view returns (uint256);\\n\\n  function allowance(address src, address dst) external view returns (uint256);\\n\\n  function approve(address dst, uint256 amt) external returns (bool);\\n\\n  function transfer(address dst, uint256 amt) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) external returns (bool);\\n}\\n\\n\\ncontract BTokenBase is BNum {\\n  mapping(address => uint256) internal _balance;\\n  mapping(address => mapping(address => uint256)) internal _allowance;\\n  uint256 internal _totalSupply;\\n\\n  event Approval(address indexed src, address indexed dst, uint256 amt);\\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\\n\\n  function _mint(uint256 amt) internal {\\n    _balance[address(this)] = badd(_balance[address(this)], amt);\\n    _totalSupply = badd(_totalSupply, amt);\\n    emit Transfer(address(0), address(this), amt);\\n  }\\n\\n  function _burn(uint256 amt) internal {\\n    require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    _balance[address(this)] = bsub(_balance[address(this)], amt);\\n    _totalSupply = bsub(_totalSupply, amt);\\n    emit Transfer(address(this), address(0), amt);\\n  }\\n\\n  function _move(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) internal {\\n    require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    _balance[src] = bsub(_balance[src], amt);\\n    _balance[dst] = badd(_balance[dst], amt);\\n    emit Transfer(src, dst, amt);\\n  }\\n\\n  function _push(address to, uint256 amt) internal {\\n    _move(address(this), to, amt);\\n  }\\n\\n  function _pull(address from, uint256 amt) internal {\\n    _move(from, address(this), amt);\\n  }\\n}\\n\\n\\ncontract BToken is BTokenBase, IERC20 {\\n  uint8 private constant DECIMALS = 18;\\n  string private _name;\\n  string private _symbol;\\n\\n  function _initializeToken(string memory name, string memory symbol) internal {\\n    require(\\n      bytes(_name).length == 0 &&\\n      bytes(name).length != 0 &&\\n      bytes(symbol).length != 0,\\n      \\\"ERR_BTOKEN_INITIALIZED\\\"\\n    );\\n    _name = name;\\n    _symbol = symbol;\\n  }\\n\\n  function name()\\n    external\\n    override\\n    view\\n    returns (string memory)\\n  {\\n    return _name;\\n  }\\n\\n  function symbol()\\n    external\\n    override\\n    view\\n    returns (string memory)\\n  {\\n    return _symbol;\\n  }\\n\\n  function decimals()\\n    external\\n    override\\n    view\\n    returns (uint8)\\n  {\\n    return DECIMALS;\\n  }\\n\\n  function allowance(address src, address dst)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return _allowance[src][dst];\\n  }\\n\\n  function balanceOf(address whom) external override view returns (uint256) {\\n    return _balance[whom];\\n  }\\n\\n  function totalSupply() public override view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function approve(address dst, uint256 amt) external override returns (bool) {\\n    _allowance[msg.sender][dst] = amt;\\n    emit Approval(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function increaseApproval(address dst, uint256 amt) external returns (bool) {\\n    _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n    return true;\\n  }\\n\\n  function decreaseApproval(address dst, uint256 amt) external returns (bool) {\\n    uint256 oldValue = _allowance[msg.sender][dst];\\n    if (amt > oldValue) {\\n      _allowance[msg.sender][dst] = 0;\\n    } else {\\n      _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n    }\\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n    return true;\\n  }\\n\\n  function transfer(address dst, uint256 amt) external override returns (bool) {\\n    _move(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) external override returns (bool) {\\n    require(\\n      msg.sender == src || amt <= _allowance[src][msg.sender],\\n      \\\"ERR_BTOKEN_BAD_CALLER\\\"\\n    );\\n    _move(src, dst, amt);\\n    if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\n      _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n      emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"temp-contracts/balancer/IndexPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n/* ========== Internal Inheritance ========== */\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\n/* ========== Internal Interfaces ========== */\\nimport \\\"../interfaces/IIndexPool.sol\\\";\\nimport \\\"../interfaces/ICompLikeToken.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract IndexPool is BToken, BMath, IIndexPool {\\n/* ==========  Modifiers  ========== */\\n\\n  modifier _lock_ {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _mutex = true;\\n    _;\\n    _mutex = false;\\n  }\\n\\n  modifier _viewlock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _;\\n  }\\n\\n  modifier _control_ {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    _;\\n  }\\n\\n  modifier _public_ {\\n    require(_publicSwap, \\\"ERR_NOT_PUBLIC\\\");\\n    _;\\n  }\\n\\n/* ==========  Storage  ========== */\\n\\n  bool internal _mutex;\\n\\n  // Account with CONTROL role. Able to modify the swap fee,\\n  // adjust token weights, bind and unbind tokens and lock\\n  // public swaps & joins.\\n  address internal _controller;\\n\\n  // Contract that handles unbound tokens.\\n  TokenUnbindHandler internal _unbindHandler;\\n\\n  // True if PUBLIC can call SWAP & JOIN functions\\n  bool internal _publicSwap;\\n\\n  // `setSwapFee` requires CONTROL\\n  uint256 internal _swapFee;\\n\\n  // Array of underlying tokens in the pool.\\n  address[] internal _tokens;\\n\\n  // Internal records of the pool's underlying tokens\\n  mapping(address => Record) internal _records;\\n\\n  // Total denormalized weight of the pool.\\n  uint256 internal _totalWeight;\\n\\n  // Minimum balances for tokens which have been added without the\\n  // requisite initial balance.\\n  mapping(address => uint256) internal _minimumBalances;\\n\\n  // Recipient for exit fees\\n  address internal _exitFeeRecipient;\\n\\n/* ==========  Controls  ========== */\\n\\n  /**\\n   * @dev Sets the controller address and the token name & symbol.\\n   *\\n   * Note: This saves on storage costs for multi-step pool deployment.\\n   *\\n   * @param controller Controller of the pool\\n   * @param name Name of the pool token\\n   * @param symbol Symbol of the pool token\\n   * @param exitFeeRecipient Address that receives exit fees\\n   */\\n  function configure(\\n    address controller,\\n    string calldata name,\\n    string calldata symbol,\\n    address exitFeeRecipient\\n  ) external override {\\n    require(_controller == address(0), \\\"ERR_CONFIGURED\\\");\\n    require(controller != address(0) && exitFeeRecipient != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    _controller = controller;\\n    // default fee is 2%\\n    _swapFee = BONE / 50;\\n    _exitFeeRecipient = exitFeeRecipient;\\n    _initializeToken(name, symbol);\\n  }\\n\\n  /**\\n   * @dev Sets up the initial assets for the pool.\\n   *\\n   * Note: `tokenProvider` must have approved the pool to transfer the\\n   * corresponding `balances` of `tokens`.\\n   *\\n   * @param tokens Underlying tokens to initialize the pool with\\n   * @param balances Initial balances to transfer\\n   * @param denorms Initial denormalized weights for the tokens\\n   * @param tokenProvider Address to transfer the balances from\\n   */\\n  function initialize(\\n    address[] calldata tokens,\\n    uint256[] calldata balances,\\n    uint96[] calldata denorms,\\n    address tokenProvider,\\n    address unbindHandler\\n  )\\n    external\\n    override\\n    _control_\\n  {\\n    require(_tokens.length == 0, \\\"ERR_INITIALIZED\\\");\\n    uint256 len = tokens.length;\\n    require(len >= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n    require(len <= MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n    require(balances.length == len && denorms.length == len, \\\"ERR_ARR_LEN\\\");\\n    uint256 totalWeight = 0;\\n    for (uint256 i = 0; i < len; i++) {\\n      address token = tokens[i];\\n      uint96 denorm = denorms[i];\\n      uint256 balance = balances[i];\\n      require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n      require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n      require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n      _records[token] = Record({\\n        bound: true,\\n        ready: true,\\n        lastDenormUpdate: uint40(now),\\n        denorm: denorm,\\n        desiredDenorm: denorm,\\n        index: uint8(i),\\n        balance: balance\\n      });\\n      _tokens.push(token);\\n      totalWeight = badd(totalWeight, denorm);\\n      _pullUnderlying(token, tokenProvider, balance);\\n    }\\n    require(totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n    _totalWeight = totalWeight;\\n    _publicSwap = true;\\n    emit LOG_PUBLIC_SWAP_ENABLED();\\n    _mintPoolShare(INIT_POOL_SUPPLY);\\n    _pushPoolShare(tokenProvider, INIT_POOL_SUPPLY);\\n    _unbindHandler = TokenUnbindHandler(unbindHandler);\\n  }\\n\\n  /**\\n   * @dev Set the swap fee.\\n   * Note: Swap fee must be between 0.0001% and 10%\\n   */\\n  function setSwapFee(uint256 swapFee) external override _control_ {\\n    require(swapFee >= MIN_FEE && swapFee <= MAX_FEE, \\\"ERR_INVALID_FEE\\\");\\n    _swapFee = swapFee;\\n    emit LOG_SWAP_FEE_UPDATED(swapFee);\\n  }\\n\\n  /**\\n   * @dev Delegate a comp-like governance token to an address\\n   * specified by the controller.\\n   */\\n  function delegateCompLikeToken(address token,address delegatee)\\n    external\\n    override\\n    _control_\\n  {\\n    ICompLikeToken(token).delegate(delegatee);\\n  }\\n\\n  /**\\n   * @dev Set the exit fee recipient address.\\n   */\\n  function setExitFeeRecipient(address exitFeeRecipient) external override _control_ {\\n    require(exitFeeRecipient != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    _exitFeeRecipient = exitFeeRecipient;\\n    emit LOG_EXIT_FEE_RECIPIENT_UPDATED(exitFeeRecipient);\\n  }\\n\\n  /**\\n   * @dev Set the controller address\\n   */\\n  function setController(address controller) external override _control_ {\\n    require(controller != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    _controller = controller;\\n    emit LOG_CONTROLLER_UPDATED(controller);\\n  }\\n\\n/* ==========  Token Management Actions  ========== */\\n\\n  /**\\n   * @dev Sets the desired weights for the pool tokens, which\\n   * will be adjusted over time as they are swapped.\\n   *\\n   * Note: This does not check for duplicate tokens or that the total\\n   * of the desired weights is equal to the target total weight (25).\\n   * Those assumptions should be met in the controller. Further, the\\n   * provided tokens should only include the tokens which are not set\\n   * for removal.\\n   */\\n  function reweighTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms\\n  )\\n    external\\n    override\\n    _lock_\\n    _control_\\n  {\\n    require(desiredDenorms.length == tokens.length, \\\"ERR_ARR_LEN\\\");\\n    for (uint256 i = 0; i < tokens.length; i++)\\n      _setDesiredDenorm(tokens[i], desiredDenorms[i]);\\n  }\\n\\n  /**\\n   * @dev Update the underlying assets held by the pool and their associated\\n   * weights. Tokens which are not currently bound will be gradually added\\n   * as they are swapped in to reach the provided minimum balances, which must\\n   * be an amount of tokens worth the minimum weight of the total pool value.\\n   * If a currently bound token is not received in this call, the token's\\n   * desired weight will be set to 0.\\n   */\\n  function reindexTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms,\\n    uint256[] calldata minimumBalances\\n  )\\n    external\\n    override\\n    _lock_\\n    _control_\\n  {\\n    require(\\n      desiredDenorms.length == tokens.length && minimumBalances.length == tokens.length,\\n      \\\"ERR_ARR_LEN\\\"\\n    );\\n    // This size may not be the same as the input size, as it is possible\\n    // to temporarily exceed the index size while tokens are being phased in\\n    // or out.\\n    uint256 tLen = _tokens.length;\\n    bool[] memory receivedIndices = new bool[](tLen);\\n    // We need to read token records in two separate loops, so\\n    // write them to memory to avoid duplicate storage reads.\\n    Record[] memory records = new Record[](tokens.length);\\n    // Read all the records from storage and mark which of the existing tokens\\n    // were represented in the reindex call.\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      records[i] = _records[tokens[i]];\\n      if (records[i].bound) receivedIndices[records[i].index] = true;\\n    }\\n    // If any bound tokens were not sent in this call, set their desired weights to 0.\\n    for (uint256 i = 0; i < tLen; i++) {\\n      if (!receivedIndices[i]) {\\n        _setDesiredDenorm(_tokens[i], 0);\\n      }\\n    }\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tokens[i];\\n      // If an input weight is less than the minimum weight, use that instead.\\n      uint96 denorm = desiredDenorms[i];\\n      if (denorm < MIN_WEIGHT) denorm = uint96(MIN_WEIGHT);\\n      if (!records[i].bound) {\\n        // If the token is not bound, bind it.\\n        _bind(token, minimumBalances[i], denorm);\\n      } else {\\n        _setDesiredDenorm(token, denorm);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the minimum balance for an uninitialized token.\\n   * This becomes useful if a token's external price significantly\\n   * rises after being bound, since the pool can not send a token\\n   * out until it reaches the minimum balance.\\n   */\\n  function setMinimumBalance(\\n    address token,\\n    uint256 minimumBalance\\n  )\\n    external\\n    override\\n    _control_\\n  {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    require(!record.ready, \\\"ERR_READY\\\");\\n    _minimumBalances[token] = minimumBalance;\\n    emit LOG_MINIMUM_BALANCE_UPDATED(token, minimumBalance);\\n  }\\n\\n/* ==========  Liquidity Provider Actions  ========== */\\n\\n  /**\\n   * @dev Mint new pool tokens by providing the proportional amount of each\\n   * underlying token's balance relative to the proportion of pool tokens minted.\\n   *\\n   * For any underlying tokens which are not initialized, the caller must provide\\n   * the proportional share of the minimum balance for the token rather than the\\n   * actual balance.\\n   *\\n   * @param poolAmountOut Amount of pool tokens to mint\\n   * @param maxAmountsIn Maximum amount of each token to pay in the same\\n   * order as the pool's _tokens list.\\n   */\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\\n    external\\n    override\\n    _lock_\\n    _public_\\n  {\\n    uint256 poolTotal = totalSupply();\\n    uint256 ratio = bdiv(poolAmountOut, poolTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(maxAmountsIn.length == _tokens.length, \\\"ERR_ARR_LEN\\\");\\n\\n    for (uint256 i = 0; i < maxAmountsIn.length; i++) {\\n      address t = _tokens[i];\\n      (Record memory record, uint256 realBalance) = _getInputToken(t);\\n      uint256 tokenAmountIn = bmul(ratio, record.balance);\\n      require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n      require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n      _updateInputToken(t, record, badd(realBalance, tokenAmountIn));\\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n      _pullUnderlying(t, msg.sender, tokenAmountIn);\\n    }\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n  }\\n\\n  /**\\n   * @dev Pay `tokenAmountIn` of `tokenIn` to mint at least `minPoolAmountOut`\\n   * pool tokens.\\n   *\\n   * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\\n   * underlying tokens. Thus a swap fee is charged against the input tokens.\\n   *\\n   * @param tokenIn Token to send the pool\\n   * @param tokenAmountIn Exact amount of `tokenIn` to pay\\n   * @param minPoolAmountOut Minimum amount of pool tokens to mint\\n   * @return poolAmountOut - Amount of pool tokens minted\\n   */\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    uint256 minPoolAmountOut\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256/* poolAmountOut */)\\n  {\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n\\n    require(tokenAmountIn != 0, \\\"ERR_ZERO_IN\\\");\\n\\n    require(\\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\\n      \\\"ERR_MAX_IN_RATIO\\\"\\n    );\\n\\n    uint256 poolAmountOut = calcPoolOutGivenSingleIn(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      tokenAmountIn,\\n      _swapFee\\n    );\\n\\n    require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    _updateInputToken(tokenIn, inRecord, badd(realInBalance, tokenAmountIn));\\n\\n    emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n    return poolAmountOut;\\n  }\\n\\n  /**\\n   * @dev Pay up to `maxAmountIn` of `tokenIn` to mint exactly `poolAmountOut`.\\n   *\\n   * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\\n   * underlying tokens. Thus a swap fee is charged against the input tokens.\\n   *\\n   * @param tokenIn Token to send the pool\\n   * @param poolAmountOut Exact amount of pool tokens to mint\\n   * @param maxAmountIn Maximum amount of `tokenIn` to pay\\n   * @return tokenAmountIn - Amount of `tokenIn` paid\\n   */\\n  function joinswapPoolAmountOut(\\n    address tokenIn,\\n    uint256 poolAmountOut,\\n    uint256 maxAmountIn\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256/* tokenAmountIn */)\\n  {\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n\\n    uint256 tokenAmountIn = calcSingleInGivenPoolOut(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      poolAmountOut,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    require(\\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\\n      \\\"ERR_MAX_IN_RATIO\\\"\\n    );\\n\\n    _updateInputToken(tokenIn, inRecord, badd(realInBalance, tokenAmountIn));\\n\\n    emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n    return tokenAmountIn;\\n  }\\n\\n  /**\\n   * @dev Burns `poolAmountIn` pool tokens in exchange for the amounts of each\\n   * underlying token's balance proportional to the ratio of tokens burned to\\n   * total pool supply. The amount of each token transferred to the caller must\\n   * be greater than or equal to the associated minimum output amount from the\\n   * `minAmountsOut` array.\\n   *\\n   * @param poolAmountIn Exact amount of pool tokens to burn\\n   * @param minAmountsOut Minimum amount of each token to receive, in the same\\n   * order as the pool's _tokens list.\\n   */\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\\n    external\\n    override\\n    _lock_\\n  {\\n    require(minAmountsOut.length == _tokens.length, \\\"ERR_ARR_LEN\\\");\\n    uint256 poolTotal = totalSupply();\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n    uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n    uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _pushPoolShare(_exitFeeRecipient, exitFee);\\n    _burnPoolShare(pAiAfterExitFee);\\n    for (uint256 i = 0; i < minAmountsOut.length; i++) {\\n      address t = _tokens[i];\\n      Record memory record = _records[t];\\n      if (record.ready) {\\n        uint256 tokenAmountOut = bmul(ratio, record.balance);\\n        require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n\\n        _records[t].balance = bsub(record.balance, tokenAmountOut);\\n        emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n        _pushUnderlying(t, msg.sender, tokenAmountOut);\\n      } else {\\n        // If the token is not initialized, it can not exit the pool.\\n        require(minAmountsOut[i] == 0, \\\"ERR_OUT_NOT_READY\\\");\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Burns `poolAmountIn` pool tokens in exchange for at least `minAmountOut`\\n   * of `tokenOut`. Returns the number of tokens sent to the caller.\\n   *\\n   * The pool implicitly burns the tokens for all underlying tokens and swaps them\\n   * to the desired output token. A swap fee is charged against the output tokens.\\n   *\\n   * @param tokenOut Token to receive\\n   * @param poolAmountIn Exact amount of pool tokens to burn\\n   * @param minAmountOut Minimum amount of `tokenOut` to receive\\n   * @return tokenAmountOut - Amount of `tokenOut` received\\n   */\\n  function exitswapPoolAmountIn(\\n    address tokenOut,\\n    uint256 poolAmountIn,\\n    uint256 minAmountOut\\n  )\\n    external\\n    override\\n    _lock_\\n    returns (uint256/* tokenAmountOut */)\\n  {\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n\\n    uint256 tokenAmountOut = calcSingleOutGivenPoolIn(\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      poolAmountIn,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    require(\\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n      \\\"ERR_MAX_OUT_RATIO\\\"\\n    );\\n\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n    _records[tokenOut].balance = bsub(outRecord.balance, tokenAmountOut);\\n    _decreaseDenorm(outRecord, tokenOut);\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n    emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _burnPoolShare(bsub(poolAmountIn, exitFee));\\n    _pushPoolShare(_exitFeeRecipient, exitFee);\\n\\n    return tokenAmountOut;\\n  }\\n\\n  /**\\n   * @dev Burn up to `maxPoolAmountIn` for exactly `tokenAmountOut` of `tokenOut`.\\n   * Returns the number of pool tokens burned.\\n   *\\n   * The pool implicitly burns the tokens for all underlying tokens and swaps them\\n   * to the desired output token. A swap fee is charged against the output tokens.\\n   *\\n   * @param tokenOut Token to receive\\n   * @param tokenAmountOut Exact amount of `tokenOut` to receive\\n   * @param maxPoolAmountIn Maximum amount of pool tokens to burn\\n   * @return poolAmountIn - Amount of pool tokens burned\\n   */\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPoolAmountIn\\n  )\\n    external\\n    override\\n    _lock_\\n    returns (uint256/* poolAmountIn */)\\n  {\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n    require(\\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n      \\\"ERR_MAX_OUT_RATIO\\\"\\n    );\\n\\n    uint256 poolAmountIn = calcPoolInGivenSingleOut(\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _totalSupply,\\n      _totalWeight,\\n      tokenAmountOut,\\n      _swapFee\\n    );\\n\\n    require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(poolAmountIn <= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n    _records[tokenOut].balance = bsub(outRecord.balance, tokenAmountOut);\\n    _decreaseDenorm(outRecord, tokenOut);\\n\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n    emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _burnPoolShare(bsub(poolAmountIn, exitFee));\\n    _pushPoolShare(_exitFeeRecipient, exitFee);\\n\\n    return poolAmountIn;\\n  }\\n\\n/* ==========  Other  ========== */\\n\\n  /**\\n   * @dev Absorb any tokens that have been sent to the pool.\\n   * If the token is not bound, it will be sent to the unbound\\n   * token handler.\\n   */\\n  function gulp(address token) external override _lock_ {\\n    Record storage record = _records[token];\\n    uint256 balance = IERC20(token).balanceOf(address(this));\\n    if (record.bound) {\\n      if (!record.ready) {\\n        uint256 minimumBalance = _minimumBalances[token];\\n        if (balance >= minimumBalance) {\\n          _minimumBalances[token] = 0;\\n          record.ready = true;\\n          emit LOG_TOKEN_READY(token);\\n          uint256 additionalBalance = bsub(balance, minimumBalance);\\n          uint256 balRatio = bdiv(additionalBalance, minimumBalance);\\n          uint96 newDenorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\\n          record.denorm = newDenorm;\\n          record.lastDenormUpdate = uint40(now);\\n          _totalWeight = badd(_totalWeight, newDenorm);\\n          emit LOG_DENORM_UPDATED(token, record.denorm);\\n        }\\n      }\\n      _records[token].balance = balance;\\n    } else {\\n      _pushUnderlying(token, address(_unbindHandler), balance);\\n      _unbindHandler.handleUnbindToken(token, balance);\\n    }\\n  }\\n\\n/* ==========  Token Swaps  ========== */\\n\\n  /**\\n   * @dev Execute a token swap with a specified amount of input\\n   * tokens and a minimum amount of output tokens.\\n   *\\n   * Note: Will revert if `tokenOut` is uninitialized.\\n   *\\n   * @param tokenIn Token to swap in\\n   * @param tokenAmountIn Exact amount of `tokenIn` to swap in\\n   * @param tokenOut Token to swap out\\n   * @param minAmountOut Minimum amount of `tokenOut` to receive\\n   * @param maxPrice Maximum ratio of input to output tokens\\n   * @return (tokenAmountOut, spotPriceAfter)\\n   */\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */)\\n  {\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n\\n    require(\\n      tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\\n      \\\"ERR_MAX_IN_RATIO\\\"\\n    );\\n\\n    uint256 spotPriceBefore = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n    uint256 tokenAmountOut = calcOutGivenIn(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      tokenAmountIn,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    // Update the in-memory record for the spotPriceAfter calculation,\\n    // then update the storage record with the local balance.\\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n    _records[tokenOut].balance = outRecord.balance;\\n    // If needed, update the output token's weight.\\n    _decreaseDenorm(outRecord, tokenOut);\\n\\n    realInBalance = badd(realInBalance, tokenAmountIn);\\n    _updateInputToken(tokenIn, inRecord, realInBalance);\\n    if (inRecord.ready) {\\n      inRecord.balance = realInBalance;\\n    }\\n\\n    uint256 spotPriceAfter = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n\\n    require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX_2\\\");\\n    require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n    require(\\n      spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\\n      \\\"ERR_MATH_APPROX\\\"\\n    );\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    return (tokenAmountOut, spotPriceAfter);\\n  }\\n\\n  /**\\n   * @dev Trades at most `maxAmountIn` of `tokenIn` for exactly `tokenAmountOut`\\n   * of `tokenOut`.\\n   *\\n   * Returns the actual input amount and the new spot price after the swap,\\n   * which can not exceed `maxPrice`.\\n   *\\n   * @param tokenIn Token to swap in\\n   * @param maxAmountIn Maximum amount of `tokenIn` to pay\\n   * @param tokenOut Token to swap out\\n   * @param tokenAmountOut Exact amount of `tokenOut` to receive\\n   * @param maxPrice Maximum ratio of input to output tokens\\n   * @return (tokenAmountIn, spotPriceAfter)\\n   */\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  )\\n    external\\n    override\\n    _lock_\\n    _public_\\n    returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */)\\n  {\\n    (Record memory inRecord, uint256 realInBalance) = _getInputToken(tokenIn);\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n\\n    require(\\n      tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\\n      \\\"ERR_MAX_OUT_RATIO\\\"\\n    );\\n\\n    uint256 spotPriceBefore = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n    uint256 tokenAmountIn = calcInGivenOut(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      tokenAmountOut,\\n      _swapFee\\n    );\\n\\n    require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    // Update the in-memory record for the spotPriceAfter calculation,\\n    // then update the storage record with the local balance.\\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n    _records[tokenOut].balance = outRecord.balance;\\n    // If needed, update the output token's weight.\\n    _decreaseDenorm(outRecord, tokenOut);\\n\\n    // Update the balance and (if necessary) weight of the input token.\\n    realInBalance = badd(realInBalance, tokenAmountIn);\\n    _updateInputToken(tokenIn, inRecord, realInBalance);\\n    if (inRecord.ready) {\\n      inRecord.balance = realInBalance;\\n    }\\n\\n    uint256 spotPriceAfter = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n\\n    require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n    require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n    require(\\n      spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\\n      \\\"ERR_MATH_APPROX\\\"\\n    );\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    return (tokenAmountIn, spotPriceAfter);\\n  }\\n\\n/* ==========  Config Queries  ========== */\\n  /**\\n   * @dev Check if swapping tokens and joining the pool is allowed.\\n   */\\n  function isPublicSwap() external view override returns (bool) {\\n    return _publicSwap;\\n  }\\n\\n  function getSwapFee() external view override _viewlock_ returns (uint256/* swapFee */) {\\n    return _swapFee;\\n  }\\n\\n  function getExitFee() external view override _viewlock_ returns (uint256/* exitFee */) {\\n    return EXIT_FEE;\\n  }\\n\\n  /**\\n   * @dev Returns the controller address.\\n   */\\n  function getController() external view override returns (address)\\n  {\\n    return _controller;\\n  }\\n\\n  /**\\n   * @dev Returns the exit fee recipient address.\\n   */\\n  function getExitFeeRecipient() external view override returns (address) {\\n    return _exitFeeRecipient;\\n  }\\n\\n/* ==========  Token Queries  ========== */\\n\\n  /**\\n   * @dev Check if a token is bound to the pool.\\n   */\\n  function isBound(address t) external view override returns (bool) {\\n    return _records[t].bound;\\n  }\\n\\n  /**\\n   * @dev Get the number of tokens bound to the pool.\\n   */\\n  function getNumTokens() external view override returns (uint256) {\\n    return _tokens.length;\\n  }\\n\\n  /**\\n   * @dev Get all bound tokens.\\n   */\\n  function getCurrentTokens()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (address[] memory tokens)\\n  {\\n    tokens = _tokens;\\n  }\\n\\n  /**\\n   * @dev Returns the list of tokens which have a desired weight above 0.\\n   * Tokens with a desired weight of 0 are set to be phased out of the pool.\\n   */\\n  function getCurrentDesiredTokens()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (address[] memory tokens)\\n  {\\n    address[] memory tempTokens = _tokens;\\n    tokens = new address[](tempTokens.length);\\n    uint256 usedIndex = 0;\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tempTokens[i];\\n      if (_records[token].desiredDenorm > 0) {\\n        tokens[usedIndex++] = token;\\n      }\\n    }\\n    assembly { mstore(tokens, usedIndex) }\\n  }\\n\\n  /**\\n   * @dev Returns the denormalized weight of a bound token.\\n   */\\n  function getDenormalizedWeight(address token)\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (uint256/* denorm */)\\n  {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    return _records[token].denorm;\\n  }\\n\\n  /**\\n   * @dev Returns the record for a token bound to the pool.\\n   */\\n  function getTokenRecord(address token)\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (Record memory record)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n  }\\n\\n  /**\\n   * @dev Finds the first token which is both initialized and has a\\n   * desired weight above 0, then returns the address of that token\\n   * and the extrapolated value of the pool in terms of that token.\\n   *\\n   * The value is extrapolated by multiplying the token's\\n   * balance by the reciprocal of its normalized weight.\\n   * @return (token, extrapolatedValue)\\n   */\\n  function extrapolatePoolValueFromToken()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (address/* token */, uint256/* extrapolatedValue */)\\n  {\\n    address token;\\n    uint256 extrapolatedValue;\\n    uint256 len = _tokens.length;\\n    for (uint256 i = 0; i < len; i++) {\\n      token = _tokens[i];\\n      Record storage record = _records[token];\\n      if (record.ready && record.desiredDenorm > 0) {\\n        extrapolatedValue = bmul(\\n          record.balance,\\n          bdiv(_totalWeight, record.denorm)\\n        );\\n        break;\\n      }\\n    }\\n    require(extrapolatedValue > 0, \\\"ERR_NONE_READY\\\");\\n    return (token, extrapolatedValue);\\n  }\\n\\n  /**\\n   * @dev Get the total denormalized weight of the pool.\\n   */\\n  function getTotalDenormalizedWeight()\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (uint256)\\n  {\\n    return _totalWeight;\\n  }\\n\\n  /**\\n   * @dev Returns the stored balance of a bound token.\\n   */\\n  function getBalance(address token) external view override _viewlock_ returns (uint256) {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    return record.balance;\\n  }\\n\\n  /**\\n   * @dev Get the minimum balance of an uninitialized token.\\n   * Note: Throws if the token is initialized.\\n   */\\n  function getMinimumBalance(address token) external view override _viewlock_ returns (uint256) {\\n    Record memory record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    require(!record.ready, \\\"ERR_READY\\\");\\n    return _minimumBalances[token];\\n  }\\n\\n  /**\\n   * @dev Returns the balance of a token which is used in price\\n   * calculations. If the token is initialized, this is the\\n   * stored balance; if not, this is the minimum balance.\\n   */\\n  function getUsedBalance(address token) external view override _viewlock_ returns (uint256) {\\n    Record memory record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    if (!record.ready) {\\n      return _minimumBalances[token];\\n    }\\n    return record.balance;\\n  }\\n\\n/* ==========  Price Queries  ========== */\\n  /**\\n   * @dev Returns the spot price for `tokenOut` in terms of `tokenIn`.\\n   */\\n  function getSpotPrice(address tokenIn, address tokenOut)\\n    external\\n    view\\n    override\\n    _viewlock_\\n    returns (uint256)\\n  {\\n    (Record memory inRecord,) = _getInputToken(tokenIn);\\n    Record memory outRecord = _getOutputToken(tokenOut);\\n    return\\n      calcSpotPrice(\\n        inRecord.balance,\\n        inRecord.denorm,\\n        outRecord.balance,\\n        outRecord.denorm,\\n        _swapFee\\n      );\\n  }\\n\\n/* ==========  Pool Share Internal Functions  ========== */\\n\\n  function _pullPoolShare(address from, uint256 amount) internal {\\n    _pull(from, amount);\\n  }\\n\\n  function _pushPoolShare(address to, uint256 amount) internal {\\n    _push(to, amount);\\n  }\\n\\n  function _mintPoolShare(uint256 amount) internal {\\n    _mint(amount);\\n  }\\n\\n  function _burnPoolShare(uint256 amount) internal {\\n    _burn(amount);\\n  }\\n\\n/* ==========  Underlying Token Internal Functions  ========== */\\n  // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n  // You must `_lock_` or otherwise ensure reentry-safety\\n\\n  function _pullUnderlying(\\n    address erc20,\\n    address from,\\n    uint256 amount\\n  ) internal {\\n    (bool success, bytes memory data) = erc20.call(\\n      abi.encodeWithSelector(\\n        IERC20.transferFrom.selector,\\n        from,\\n        address(this),\\n        amount\\n      )\\n    );\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      \\\"ERR_ERC20_FALSE\\\"\\n    );\\n  }\\n\\n  function _pushUnderlying(\\n    address erc20,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    (bool success, bytes memory data) = erc20.call(\\n      abi.encodeWithSelector(\\n        IERC20.transfer.selector,\\n        to,\\n        amount\\n      )\\n    );\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      \\\"ERR_ERC20_FALSE\\\"\\n    );\\n  }\\n\\n/* ==========  Token Management Internal Functions  ========== */\\n\\n  /**\\n   * @dev Bind a token by address without actually depositing a balance.\\n   * The token will be unable to be swapped out until it reaches the minimum balance.\\n   * Note: Token must not already be bound.\\n   * Note: `minimumBalance` should represent an amount of the token which is worth\\n   * the portion of the current pool value represented by the minimum weight.\\n   * @param token Address of the token to bind\\n   * @param minimumBalance minimum balance to reach before the token can be swapped out\\n   * @param desiredDenorm Desired weight for the token.\\n   */\\n  function _bind(\\n    address token,\\n    uint256 minimumBalance,\\n    uint96 desiredDenorm\\n  ) internal {\\n    require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n\\n    require(desiredDenorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n    require(desiredDenorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n    require(minimumBalance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n    _records[token] = Record({\\n      bound: true,\\n      ready: false,\\n      lastDenormUpdate: 0,\\n      denorm: 0,\\n      desiredDenorm: desiredDenorm,\\n      index: uint8(_tokens.length),\\n      balance: 0\\n    });\\n    _tokens.push(token);\\n    _minimumBalances[token] = minimumBalance;\\n    emit LOG_TOKEN_ADDED(token, desiredDenorm, minimumBalance);\\n  }\\n\\n  /**\\n   * @dev Remove a token from the pool.\\n   * Replaces the address in the tokens array with the last address,\\n   * then removes it from the array.\\n   * Note: This should only be called after the total weight has been adjusted.\\n   * Note: Must be called in a function with:\\n   * - _lock_ modifier to prevent reentrance\\n   * - requirement that the token is bound\\n   */\\n  function _unbind(address token) internal {\\n    Record memory record = _records[token];\\n    uint256 tokenBalance = record.balance;\\n\\n    // Swap the token-to-unbind with the last token,\\n    // then delete the last token\\n    uint256 index = record.index;\\n    uint256 last = _tokens.length - 1;\\n    // Only swap the token with the last token if it is not\\n    // already at the end of the array.\\n    if (index != last) {\\n      _tokens[index] = _tokens[last];\\n      _records[_tokens[index]].index = uint8(index);\\n    }\\n    _tokens.pop();\\n    _records[token] = Record({\\n      bound: false,\\n      ready: false,\\n      lastDenormUpdate: 0,\\n      denorm: 0,\\n      desiredDenorm: 0,\\n      index: 0,\\n      balance: 0\\n    });\\n    // transfer any remaining tokens out\\n    _pushUnderlying(token, address(_unbindHandler), tokenBalance);\\n    _unbindHandler.handleUnbindToken(token, tokenBalance);\\n    emit LOG_TOKEN_REMOVED(token);\\n  }\\n\\n  function _setDesiredDenorm(address token, uint96 desiredDenorm) internal {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    // If the desired weight is 0, this will trigger a gradual unbinding of the token.\\n    // Therefore the weight only needs to be above the minimum weight if it isn't 0.\\n    require(\\n      desiredDenorm >= MIN_WEIGHT || desiredDenorm == 0,\\n      \\\"ERR_MIN_WEIGHT\\\"\\n    );\\n    require(desiredDenorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n    record.desiredDenorm = desiredDenorm;\\n    emit LOG_DESIRED_DENORM_SET(token, desiredDenorm);\\n  }\\n\\n  function _increaseDenorm(Record memory record, address token) internal {\\n    // If the weight does not need to increase or the token is not\\n    // initialized, don't do anything.\\n    if (\\n      record.denorm >= record.desiredDenorm ||\\n      !record.ready ||\\n      now - record.lastDenormUpdate < WEIGHT_UPDATE_DELAY\\n    ) return;\\n    uint96 oldWeight = record.denorm;\\n    uint96 denorm = record.desiredDenorm;\\n    uint256 maxDiff = bmul(oldWeight, WEIGHT_CHANGE_PCT);\\n    uint256 diff = bsub(denorm, oldWeight);\\n    if (diff > maxDiff) {\\n      denorm = uint96(badd(oldWeight, maxDiff));\\n      diff = maxDiff;\\n    }\\n    // If new total weight exceeds the maximum, do not update\\n    uint256 newTotalWeight = badd(_totalWeight, diff);\\n    if (newTotalWeight > MAX_TOTAL_WEIGHT) return;\\n    _totalWeight = newTotalWeight;\\n    // Update the in-memory denorm value for spot-price computations.\\n    record.denorm = denorm;\\n    // Update the storage record\\n    _records[token].denorm = denorm;\\n    _records[token].lastDenormUpdate = uint40(now);\\n    emit LOG_DENORM_UPDATED(token, denorm);\\n  }\\n\\n  function _decreaseDenorm(Record memory record, address token) internal {\\n    // If the weight does not need to decrease, don't do anything.\\n    if (\\n      record.denorm <= record.desiredDenorm ||\\n      !record.ready ||\\n      now - record.lastDenormUpdate < WEIGHT_UPDATE_DELAY\\n    ) return;\\n    uint96 oldWeight = record.denorm;\\n    uint96 denorm = record.desiredDenorm;\\n    uint256 maxDiff = bmul(oldWeight, WEIGHT_CHANGE_PCT);\\n    uint256 diff = bsub(oldWeight, denorm);\\n    if (diff > maxDiff) {\\n      denorm = uint96(bsub(oldWeight, maxDiff));\\n      diff = maxDiff;\\n    }\\n    if (denorm <= MIN_WEIGHT) {\\n      denorm = 0;\\n      _totalWeight = bsub(_totalWeight, denorm);\\n      // Because this is removing the token from the pool, the\\n      // in-memory denorm value is irrelevant, as it is only used\\n      // to calculate the new spot price, but the spot price calc\\n      // will throw if it is passed 0 for the denorm.\\n      _unbind(token);\\n    } else {\\n      _totalWeight = bsub(_totalWeight, diff);\\n      // Update the in-memory denorm value for spot-price computations.\\n      record.denorm = denorm;\\n      // Update the stored denorm value\\n      _records[token].denorm = denorm;\\n      _records[token].lastDenormUpdate = uint40(now);\\n      emit LOG_DENORM_UPDATED(token, denorm);\\n    }\\n  }\\n\\n  /**\\n   * @dev Handles weight changes and initialization of an\\n   * input token.\\n   *\\n   * If the token is not initialized and the new balance is\\n   * still below the minimum, this will not do anything.\\n   *\\n   * If the token is not initialized but the new balance will\\n   * bring the token above the minimum balance, this will\\n   * mark the token as initialized, remove the minimum\\n   * balance and set the weight to the minimum weight plus\\n   * 1%.\\n   *\\n   *\\n   * @param token Address of the input token\\n   * @param record Token record with minimums applied to the balance\\n   * and weight if the token was uninitialized.\\n   */\\n  function _updateInputToken(\\n    address token,\\n    Record memory record,\\n    uint256 realBalance\\n  )\\n    internal\\n  {\\n    if (!record.ready) {\\n      // Check if the minimum balance has been reached\\n      if (realBalance >= record.balance) {\\n        // Remove the minimum balance record\\n        _minimumBalances[token] = 0;\\n        // Mark the token as initialized\\n        _records[token].ready = true;\\n        record.ready = true;\\n        emit LOG_TOKEN_READY(token);\\n        // Set the initial denorm value to the minimum weight times one plus\\n        // the ratio of the increase in balance over the minimum to the minimum\\n        // balance.\\n        // weight = (1 + ((bal - min_bal) / min_bal)) * min_weight\\n        uint256 additionalBalance = bsub(realBalance, record.balance);\\n        uint256 balRatio = bdiv(additionalBalance, record.balance);\\n        record.denorm = uint96(badd(MIN_WEIGHT, bmul(MIN_WEIGHT, balRatio)));\\n        _records[token].denorm = record.denorm;\\n        _records[token].lastDenormUpdate = uint40(now);\\n        _totalWeight = badd(_totalWeight, record.denorm);\\n        emit LOG_DENORM_UPDATED(token, record.denorm);\\n      } else {\\n        uint256 realToMinRatio = bdiv(\\n          bsub(record.balance, realBalance),\\n          record.balance\\n        );\\n        uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\\n        record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\\n      }\\n      // If the token is still not ready, do not adjust the weight.\\n    } else {\\n      // If the token is already initialized, update the weight (if any adjustment\\n      // is needed).\\n      _increaseDenorm(record, token);\\n    }\\n    // Regardless of whether the token is initialized, store the actual new balance.\\n    _records[token].balance = realBalance;\\n  }\\n\\n/* ==========  Token Query Internal Functions  ========== */\\n\\n  /**\\n   * @dev Get the record for a token which is being swapped in.\\n   * The token must be bound to the pool. If the token is not\\n   * initialized (meaning it does not have the minimum balance)\\n   * this function will return the actual balance of the token\\n   * which the pool holds, but set the record's balance and weight\\n   * to the token's minimum balance and the pool's minimum weight.\\n   * This allows the token swap to be priced correctly even if the\\n   * pool does not own any of the tokens.\\n   */\\n  function _getInputToken(address token)\\n    internal\\n    view\\n    returns (Record memory record, uint256 realBalance)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n\\n    realBalance = record.balance;\\n    // If the input token is not initialized, we use the minimum\\n    // initial weight and minimum initial balance instead of the\\n    // real values for price and output calculations.\\n    if (!record.ready) {\\n      record.balance = _minimumBalances[token];\\n      uint256 realToMinRatio = bdiv(\\n        bsub(record.balance, realBalance),\\n        record.balance\\n      );\\n      uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\\n      record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\\n    }\\n  }\\n\\n  function _getOutputToken(address token)\\n    internal\\n    view\\n    returns (Record memory record)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    // Tokens which have not reached their minimum balance can not be\\n    // swapped out.\\n    require(record.ready, \\\"ERR_OUT_NOT_READY\\\");\\n  }\\n}\\n\\n\\ninterface TokenUnbindHandler {\\n  /**\\n   * @dev Receive `amount` of `token` from the pool.\\n   */\\n  function handleUnbindToken(address token, uint256 amount) external;\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/IIndexPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IIndexPool {\\n  /**\\n   * @dev Token record data structure\\n   * @param bound is token bound to pool\\n   * @param ready has token been initialized\\n   * @param lastDenormUpdate timestamp of last denorm change\\n   * @param denorm denormalized weight\\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\\n   * @param index index of address in tokens array\\n   * @param balance token balance\\n   */\\n  struct Record {\\n    bool bound;\\n    bool ready;\\n    uint40 lastDenormUpdate;\\n    uint96 denorm;\\n    uint96 desiredDenorm;\\n    uint8 index;\\n    uint256 balance;\\n  }\\n\\n/* ==========  EVENTS  ========== */\\n\\n  /** @dev Emitted when tokens are swapped. */\\n  event LOG_SWAP(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 tokenAmountIn,\\n    uint256 tokenAmountOut\\n  );\\n\\n  /** @dev Emitted when underlying tokens are deposited for pool tokens. */\\n  event LOG_JOIN(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    uint256 tokenAmountIn\\n  );\\n\\n  /** @dev Emitted when pool tokens are burned for underlying. */\\n  event LOG_EXIT(\\n    address indexed caller,\\n    address indexed tokenOut,\\n    uint256 tokenAmountOut\\n  );\\n\\n  /** @dev Emitted when a token's weight updates. */\\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\\n\\n  /** @dev Emitted when a token's desired weight is set. */\\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\\n\\n  /** @dev Emitted when a token is unbound from the pool. */\\n  event LOG_TOKEN_REMOVED(address token);\\n\\n  /** @dev Emitted when a token is unbound from the pool. */\\n  event LOG_TOKEN_ADDED(\\n    address indexed token,\\n    uint256 desiredDenorm,\\n    uint256 minimumBalance\\n  );\\n\\n  /** @dev Emitted when a token's minimum balance is updated. */\\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\\n\\n  /** @dev Emitted when a token reaches its minimum balance. */\\n  event LOG_TOKEN_READY(address indexed token);\\n\\n  /** @dev Emitted when public trades are enabled. */\\n  event LOG_PUBLIC_SWAP_ENABLED();\\n\\n  /** @dev Emitted when the swap fee is updated. */\\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\\n\\n  /** @dev Emitted when exit fee recipient is updated. */\\n  event LOG_EXIT_FEE_RECIPIENT_UPDATED(address exitFeeRecipient);\\n\\n  /** @dev Emitted when controller is updated. */\\n  event LOG_CONTROLLER_UPDATED(address exitFeeRecipient);\\n\\n  function configure(\\n    address controller,\\n    string calldata name,\\n    string calldata symbol,\\n    address exitFeeRecipient\\n  ) external;\\n\\n  function initialize(\\n    address[] calldata tokens,\\n    uint256[] calldata balances,\\n    uint96[] calldata denorms,\\n    address tokenProvider,\\n    address unbindHandler\\n  ) external;\\n\\n  function setSwapFee(uint256 swapFee) external;\\n\\n  function delegateCompLikeToken(address token, address delegatee) external;\\n\\n  function setExitFeeRecipient(address exitFeeRecipient) external;\\n\\n  function setController(address controller) external;\\n\\n  function reweighTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms\\n  ) external;\\n\\n  function reindexTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata desiredDenorms,\\n    uint256[] calldata minimumBalances\\n  ) external;\\n\\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\\n\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    uint256 minPoolAmountOut\\n  ) external returns (uint256/* poolAmountOut */);\\n\\n  function joinswapPoolAmountOut(\\n    address tokenIn,\\n    uint256 poolAmountOut,\\n    uint256 maxAmountIn\\n  ) external returns (uint256/* tokenAmountIn */);\\n\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n  function exitswapPoolAmountIn(\\n    address tokenOut,\\n    uint256 poolAmountIn,\\n    uint256 minAmountOut\\n  )\\n    external returns (uint256/* tokenAmountOut */);\\n\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPoolAmountIn\\n  ) external returns (uint256/* poolAmountIn */);\\n\\n  function gulp(address token) external;\\n\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\\n\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\\n\\n  function isPublicSwap() external view returns (bool);\\n\\n  function getSwapFee() external view returns (uint256/* swapFee */);\\n\\n  function getExitFee() external view returns (uint256/* exitFee */);\\n\\n  function getController() external view returns (address);\\n\\n  function getExitFeeRecipient() external view returns (address);\\n\\n  function isBound(address t) external view returns (bool);\\n\\n  function getNumTokens() external view returns (uint256);\\n\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\\n\\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\\n\\n  function getTokenRecord(address token) external view returns (Record memory record);\\n\\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n  function getMinimumBalance(address token) external view returns (uint256);\\n\\n  function getUsedBalance(address token) external view returns (uint256);\\n\\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\\n}\"\r\n    },\r\n    \"temp-contracts/interfaces/ICompLikeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n\\ninterface ICompLikeToken {\\n  function delegate(address delegatee) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x32e574b0400cdb93dc33a34a30986737186bde43", "attacktype": "Flash liquidity borrow, purchase, mint or deposit", "sourcecode": "{\"BColor.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\ncontract BColor {\\n    function getColor()\\n        external view\\n        returns (bytes32);\\n}\\n\\ncontract BBronze is BColor {\\n    function getColor()\\n        external view\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"},\"BConst.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BColor.sol\\\";\\n\\ncontract BConst is BBronze {\\n    uint public constant BONE              = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 8;\\n\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    uint public constant EXIT_FEE          = 0;\\n\\n    uint public constant MIN_WEIGHT        = BONE;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"},\"BMath.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BMath is BBronze, BConst, BNum {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint spotPrice)\\n    {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountOut)\\n    {\\n        // Charge the trading fee for the proportion of tokenAi\\n        ///  which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n      \\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight); \\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        // charge exit fee on the pool token side\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n     \\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side \\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountIn)\\n    {\\n\\n        // charge swap fee on the output token side \\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee); \\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n        // charge exit fee on the pool token side\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n        return poolAmountIn;\\n    }\\n\\n\\n}\\n\"},\"BNum.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a \\u003e= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base \\u003e= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base \\u003c= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);   \\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1--\\u003ek) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term \\u003e= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"},\"BPool.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\ncontract BPool is BBronze, BToken, BMath {\\n\\n    struct Record {\\n        bool bound;   // is token bound to pool\\n        uint index;   // private\\n        uint denorm;  // denormalized weight\\n        uint balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n    ) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _factory;    // BFactory address to push token exitFee to\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    uint private _swapFee;\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address=\\u003eRecord) private  _records;\\n    uint private _totalWeight;\\n\\n    constructor() public {\\n        _controller = msg.sender;\\n        _factory = msg.sender;\\n        _swapFee = MIN_FEE;\\n        _publicSwap = false;\\n        _finalized = false;\\n    }\\n\\n    function isPublicSwap()\\n        external view\\n        returns (bool)\\n    {\\n        return _publicSwap;\\n    }\\n\\n    function isFinalized()\\n        external view\\n        returns (bool)\\n    {\\n        return _finalized;\\n    }\\n\\n    function isBound(address t)\\n        external view\\n        returns (bool)\\n    {\\n        return _records[t].bound;\\n    }\\n\\n    function getNumTokens()\\n        external view\\n        returns (uint) \\n    {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens()\\n        external view _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    function getFinalTokens()\\n        external view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].denorm;\\n    }\\n\\n    function getTotalDenormalizedWeight()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    function getNormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        uint denorm = _records[token].denorm;\\n        return bdiv(denorm, _totalWeight);\\n    }\\n\\n    function getBalance(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].balance;\\n    }\\n\\n    function getSwapFee()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _swapFee;\\n    }\\n\\n    function getController()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _controller;\\n    }\\n\\n    function setSwapFee(uint swapFee)\\n        external\\n        _logs_\\n        _lock_\\n    { \\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(swapFee \\u003e= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFee \\u003c= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _swapFee = swapFee;\\n    }\\n\\n    function setController(address manager)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _controller = manager;\\n    }\\n\\n    function setPublicSwap(bool public_)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _publicSwap = public_;\\n    }\\n\\n    function finalize()\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(_tokens.length \\u003e= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n\\n    function bind(address token, uint balance, uint denorm)\\n        external\\n        _logs_\\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(_tokens.length \\u003c MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0,    // balance and denorm will be validated\\n            balance: 0   // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    function rebind(address token, uint balance, uint denorm)\\n        public\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(denorm \\u003e= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm \\u003c= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance \\u003e= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint oldWeight = _records[token].denorm;\\n        if (denorm \\u003e oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight \\u003c= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm \\u003c oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }        \\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance \\u003e oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance \\u003c oldBalance) {\\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\\n            _pushUnderlying(token, _factory, tokenExitFee);\\n        }\\n    }\\n\\n    function unbind(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        uint tokenBalance = _records[token].balance;\\n        uint tokenExitFee = bmul(tokenBalance, EXIT_FEE);\\n\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({\\n            bound: false,\\n            index: 0,\\n            denorm: 0,\\n            balance: 0\\n        });\\n\\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\\n        _pushUnderlying(token, _factory, tokenExitFee);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function getSpotPrice(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n    }\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\n    }\\n\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountIn = bmul(ratio, bal);\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn \\u003c= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = totalSupply();\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(_factory, exitFee);\\n        _burnPoolShare(pAiAfterExitFee);\\n\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountOut = bmul(ratio, bal);\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountOut \\u003e= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n\\n    }\\n\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\n    {\\n\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountIn \\u003c= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore \\u003c= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n        require(tokenAmountOut \\u003e= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter \\u003e= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");     \\n        require(spotPriceAfter \\u003c= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore \\u003c= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint maxAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_ \\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountOut \\u003c= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore \\u003c= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n        require(tokenAmountIn \\u003c= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter \\u003e= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter \\u003c= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore \\u003c= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n\\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountOut)\\n\\n    {        \\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountIn \\u003c= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountOut \\u003e= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return poolAmountOut;\\n    }\\n\\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountIn)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            poolAmountOut,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountIn \\u003c= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n        \\n        require(tokenAmountIn \\u003c= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return tokenAmountIn;\\n    }\\n\\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            poolAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountOut \\u003e= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n        \\n        require(tokenAmountOut \\u003c= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return tokenAmountOut;\\n    }\\n\\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountIn)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountOut \\u003c= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(poolAmountIn \\u003c= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);        \\n\\n        return poolAmountIn;\\n    }\\n\\n\\n    // ==\\n    // \\u0027Underlying\\u0027 token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(address erc20, address to, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount)\\n        internal\\n    {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n\\n}\\n\"},\"BToken.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\ninterface IERC20 {\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address =\\u003e uint)                   internal _balance;\\n    mapping(address =\\u003e mapping(address=\\u003euint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] \\u003e= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] \\u003e= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20 {\\n\\n    string  private _name     = \\\"Balancer Pool Token\\\";\\n    string  private _symbol   = \\\"BPT\\\";\\n    uint8   private _decimals = 18;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt \\u003e oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\\n        require(msg.sender == src || amt \\u003c= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src \\u0026\\u0026 _allowance[src][msg.sender] != uint256(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"}}"}
{"address": "0x39b1df026010b5aea781f90542ee19e900f2db15", "attacktype": "On-chain oracle manipulation, Frontrunning", "sourcecode": "/**\r\n *Submitted for verification at Etherscan.io on 2021-04-19\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.2;\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ninterface IKeep3rV1 {\r\n    function keepers(address keeper) external returns (bool);\r\n    function KPRH() external view returns (IKeep3rV1Helper);\r\n    function receipt(address credit, address keeper, uint amount) external;\r\n}\r\n\r\ninterface IKeep3rV1Helper {\r\n    function getQuoteLimit(uint gasUsed) external view returns (uint);\r\n}\r\n\r\n// sliding oracle that uses observations collected to provide moving price averages in the past\r\ncontract Keep3rV2Oracle {\r\n\r\n    constructor(address _pair) {\r\n        _factory = msg.sender;\r\n        pair = _pair;\r\n        (,,uint32 timestamp) = IUniswapV2Pair(_pair).getReserves();\r\n        uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(_pair).price0CumulativeLast() * e10 / Q112);\r\n        uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(_pair).price1CumulativeLast() * e10 / Q112);\r\n        observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\r\n    }\r\n\r\n    struct Observation {\r\n        uint32 timestamp;\r\n        uint112 price0Cumulative;\r\n        uint112 price1Cumulative;\r\n    }\r\n\r\n    modifier factory() {\r\n        require(msg.sender == _factory, \"!F\");\r\n        _;\r\n    }\r\n\r\n    Observation[65535] public observations;\r\n    uint16 public length;\r\n\r\n    address immutable _factory;\r\n    address immutable public pair;\r\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\r\n    uint constant periodSize = 1800;\r\n    uint Q112 = 2**112;\r\n    uint e10 = 10**18;\r\n\r\n    // Pre-cache slots for cheaper oracle writes\r\n    function cache(uint size) external {\r\n        uint _length = length+size;\r\n        for (uint i = length; i < _length; i++) observations[i].timestamp = 1;\r\n    }\r\n\r\n    // update the current feed for free\r\n    function update() external factory returns (bool) {\r\n        return _update();\r\n    }\r\n\r\n    function updateable() external view returns (bool) {\r\n        Observation memory _point = observations[length-1];\r\n        (,, uint timestamp) = IUniswapV2Pair(pair).getReserves();\r\n        uint timeElapsed = timestamp - _point.timestamp;\r\n        return timeElapsed > periodSize;\r\n    }\r\n\r\n    function _update() internal returns (bool) {\r\n        Observation memory _point = observations[length-1];\r\n        (,, uint32 timestamp) = IUniswapV2Pair(pair).getReserves();\r\n        uint32 timeElapsed = timestamp - _point.timestamp;\r\n        if (timeElapsed > periodSize) {\r\n            uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112);\r\n            uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112);\r\n            observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _computeAmountOut(uint start, uint end, uint elapsed, uint amountIn) internal view returns (uint amountOut) {\r\n        amountOut = amountIn * (end - start) / e10 / elapsed;\r\n    }\r\n\r\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut, uint lastUpdatedAgo) {\r\n        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\r\n\r\n        Observation memory _observation = observations[length-1];\r\n        uint price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112;\r\n        uint price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112;\r\n        (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\r\n\r\n        // Handle edge cases where we have no updates, will revert on first reading set\r\n        if (timestamp == _observation.timestamp) {\r\n            _observation = observations[length-2];\r\n        }\r\n\r\n        uint timeElapsed = timestamp - _observation.timestamp;\r\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\r\n        if (token0 == tokenIn) {\r\n            amountOut = _computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\r\n        } else {\r\n            amountOut = _computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\r\n        }\r\n        lastUpdatedAgo = timeElapsed;\r\n    }\r\n\r\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint amountOut, uint lastUpdatedAgo) {\r\n        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\r\n\r\n        uint priceAverageCumulative = 0;\r\n        uint _length = length-1;\r\n        uint i = _length - points;\r\n        Observation memory currentObservation;\r\n        Observation memory nextObservation;\r\n\r\n        uint nextIndex = 0;\r\n        if (token0 == tokenIn) {\r\n            for (; i < _length; i++) {\r\n                nextIndex = i+1;\r\n                currentObservation = observations[i];\r\n                nextObservation = observations[nextIndex];\r\n                priceAverageCumulative += _computeAmountOut(\r\n                    currentObservation.price0Cumulative,\r\n                    nextObservation.price0Cumulative,\r\n                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\r\n            }\r\n        } else {\r\n            for (; i < _length; i++) {\r\n                nextIndex = i+1;\r\n                currentObservation = observations[i];\r\n                nextObservation = observations[nextIndex];\r\n                priceAverageCumulative += _computeAmountOut(\r\n                    currentObservation.price1Cumulative,\r\n                    nextObservation.price1Cumulative,\r\n                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\r\n            }\r\n        }\r\n        amountOut = priceAverageCumulative / points;\r\n\r\n        (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\r\n        lastUpdatedAgo = timestamp - nextObservation.timestamp;\r\n    }\r\n\r\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint[] memory prices, uint lastUpdatedAgo) {\r\n        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\r\n        prices = new uint[](points);\r\n\r\n        if (token0 == tokenIn) {\r\n            {\r\n                uint _length = length-1;\r\n                uint i = _length - (points * window);\r\n                uint _index = 0;\r\n                Observation memory nextObservation;\r\n                for (; i < _length; i+=window) {\r\n                    Observation memory currentObservation;\r\n                    currentObservation = observations[i];\r\n                    nextObservation = observations[i + window];\r\n                    prices[_index] = _computeAmountOut(\r\n                        currentObservation.price0Cumulative,\r\n                        nextObservation.price0Cumulative,\r\n                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\r\n                    _index = _index + 1;\r\n                }\r\n\r\n                (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\r\n                lastUpdatedAgo = timestamp - nextObservation.timestamp;\r\n            }\r\n        } else {\r\n            {\r\n                uint _length = length-1;\r\n                uint i = _length - (points * window);\r\n                uint _index = 0;\r\n                Observation memory nextObservation;\r\n                for (; i < _length; i+=window) {\r\n                    Observation memory currentObservation;\r\n                    currentObservation = observations[i];\r\n                    nextObservation = observations[i + window];\r\n                    prices[_index] = _computeAmountOut(\r\n                        currentObservation.price1Cumulative,\r\n                        nextObservation.price1Cumulative,\r\n                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\r\n                    _index = _index + 1;\r\n                }\r\n\r\n                (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\r\n                lastUpdatedAgo = timestamp - nextObservation.timestamp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Keep3rV2OracleFactory {\r\n\r\n    function pairForSushi(address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                0xc35DADB65012eC5796536bD9864eD8773aBc74C4,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\r\n            )))));\r\n    }\r\n\r\n    function pairForUni(address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            )))));\r\n    }\r\n\r\n    modifier keeper() {\r\n        require(KP3R.keepers(msg.sender), \"!K\");\r\n        _;\r\n    }\r\n\r\n    modifier upkeep() {\r\n        uint _gasUsed = gasleft();\r\n        require(KP3R.keepers(msg.sender), \"!K\");\r\n        _;\r\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed - gasleft());\r\n        KP3R.receipt(address(KP3R), msg.sender, _received);\r\n    }\r\n\r\n    address public governance;\r\n    address public pendingGovernance;\r\n\r\n    /**\r\n     * @notice Allows governance to change governance (for future upgradability)\r\n     * @param _governance new governance address to set\r\n     */\r\n    function setGovernance(address _governance) external {\r\n        require(msg.sender == governance, \"!G\");\r\n        pendingGovernance = _governance;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\r\n     */\r\n    function acceptGovernance() external {\r\n        require(msg.sender == pendingGovernance, \"!pG\");\r\n        governance = pendingGovernance;\r\n    }\r\n\r\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\r\n\r\n    address[] internal _pairs;\r\n    mapping(address => Keep3rV2Oracle) public feeds;\r\n\r\n    function pairs() external view returns (address[] memory) {\r\n        return _pairs;\r\n    }\r\n\r\n    constructor() {\r\n        governance = msg.sender;\r\n    }\r\n\r\n    function update(address pair) external keeper returns (bool) {\r\n        return feeds[pair].update();\r\n    }\r\n\r\n    function byteCode(address pair) external pure returns (bytes memory bytecode) {\r\n        bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\r\n    }\r\n\r\n    function deploy(address pair) external returns (address feed) {\r\n        require(msg.sender == governance, \"!G\");\r\n        require(address(feeds[pair]) == address(0), 'PE');\r\n        bytes memory bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\r\n        bytes32 salt = keccak256(abi.encodePacked(pair));\r\n        assembly {\r\n            feed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n            if iszero(extcodesize(feed)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        feeds[pair] = Keep3rV2Oracle(feed);\r\n        _pairs.push(pair);\r\n    }\r\n\r\n    function work() external upkeep {\r\n        require(workable(), \"!W\");\r\n        for (uint i = 0; i < _pairs.length; i++) {\r\n            feeds[_pairs[i]].update();\r\n        }\r\n    }\r\n\r\n    function work(address pair) external upkeep {\r\n        require(feeds[pair].update(), \"!W\");\r\n    }\r\n\r\n    function workForFree() external {\r\n        for (uint i = 0; i < _pairs.length; i++) {\r\n            feeds[_pairs[i]].update();\r\n        }\r\n    }\r\n\r\n    function workForFree(address pair) external {\r\n        feeds[pair].update();\r\n    }\r\n\r\n    function cache(uint size) external {\r\n        for (uint i = 0; i < _pairs.length; i++) {\r\n            feeds[_pairs[i]].cache(size);\r\n        }\r\n    }\r\n\r\n    function cache(address pair, uint size) external {\r\n        feeds[pair].cache(size);\r\n    }\r\n\r\n    function workable() public view returns (bool canWork) {\r\n        canWork = true;\r\n        for (uint i = 0; i < _pairs.length; i++) {\r\n            if (!feeds[_pairs[i]].updateable()) {\r\n                canWork = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function workable(address pair) public view returns (bool) {\r\n        return feeds[pair].updateable();\r\n    }\r\n\r\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window, bool sushiswap) external view returns (uint[] memory prices, uint lastUpdatedAgo) {\r\n        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\r\n        return feeds[_pair].sample(tokenIn, amountIn, tokenOut, points, window);\r\n    }\r\n\r\n    function sample(address pair, address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint[] memory prices, uint lastUpdatedAgo) {\r\n        return feeds[pair].sample(tokenIn, amountIn, tokenOut, points, window);\r\n    }\r\n\r\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint points, bool sushiswap) external view returns (uint amountOut, uint lastUpdatedAgo) {\r\n        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\r\n        return feeds[_pair].quote(tokenIn, amountIn, tokenOut, points);\r\n    }\r\n\r\n    function quote(address pair, address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint amountOut, uint lastUpdatedAgo) {\r\n        return feeds[pair].quote(tokenIn, amountIn, tokenOut, points);\r\n    }\r\n\r\n    function current(address tokenIn, uint amountIn, address tokenOut, bool sushiswap) external view returns (uint amountOut, uint lastUpdatedAgo) {\r\n        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\r\n        return feeds[_pair].current(tokenIn, amountIn, tokenOut);\r\n    }\r\n\r\n    function current(address pair, address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut, uint lastUpdatedAgo) {\r\n        return feeds[pair].current(tokenIn, amountIn, tokenOut);\r\n    }\r\n}"}
{"address": "0x17e8ca1b4798b97602895f63206afcd1fc90ca5f", "attacktype": "Deployment mistake, Other unsafe DeFi protocol dependency", "sourcecode": "// File: localhost/contracts/lib/LibParam.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary LibParam {\r\n    bytes32 private constant STATIC_MASK =\r\n        0x0100000000000000000000000000000000000000000000000000000000000000;\r\n    bytes32 private constant PARAMS_MASK =\r\n        0x0000000000000000000000000000000000000000000000000000000000000001;\r\n    bytes32 private constant REFS_MASK =\r\n        0x00000000000000000000000000000000000000000000000000000000000000FF;\r\n    bytes32 private constant RETURN_NUM_MASK =\r\n        0x00FF000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    uint256 private constant REFS_LIMIT = 22;\r\n    uint256 private constant PARAMS_SIZE_LIMIT = 64;\r\n    uint256 private constant RETURN_NUM_OFFSET = 240;\r\n\r\n    function isStatic(bytes32 conf) internal pure returns (bool) {\r\n        if (conf & STATIC_MASK == 0) return true;\r\n        else return false;\r\n    }\r\n\r\n    function isReferenced(bytes32 conf) internal pure returns (bool) {\r\n        if (getReturnNum(conf) == 0) return false;\r\n        else return true;\r\n    }\r\n\r\n    function getReturnNum(bytes32 conf) internal pure returns (uint256 num) {\r\n        bytes32 temp = (conf & RETURN_NUM_MASK) >> RETURN_NUM_OFFSET;\r\n        num = uint256(temp);\r\n    }\r\n\r\n    function getParams(bytes32 conf)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory refs, uint256[] memory params)\r\n    {\r\n        require(!isStatic(conf), \"Static params\");\r\n        uint256 n = 0;\r\n        while (conf & REFS_MASK == REFS_MASK && n < REFS_LIMIT) {\r\n            n++;\r\n            conf = conf >> 8;\r\n        }\r\n        n = REFS_LIMIT - n;\r\n        require(n > 0, \"No dynamic param\");\r\n        refs = new uint256[](n);\r\n        params = new uint256[](n);\r\n        for (uint256 i = 0; i < n; i++) {\r\n            refs[i] = uint256(conf & REFS_MASK);\r\n            conf = conf >> 8;\r\n        }\r\n        uint256 i = 0;\r\n        for (uint256 k = 0; k < PARAMS_SIZE_LIMIT; k++) {\r\n            if (conf & PARAMS_MASK != 0) {\r\n                require(i < n, \"Location count exceeds ref count\");\r\n                params[i] = k * 32 + 4;\r\n                i++;\r\n            }\r\n            conf = conf >> 1;\r\n        }\r\n        require(i == n, \"Location count less than ref count\");\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/lib/LibStack.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary LibStack {\r\n    function setAddress(bytes32[] storage _stack, address _input) internal {\r\n        _stack.push(bytes32(uint256(uint160(_input))));\r\n    }\r\n\r\n    function set(bytes32[] storage _stack, bytes32 _input) internal {\r\n        _stack.push(_input);\r\n    }\r\n\r\n    function setHandlerType(bytes32[] storage _stack, uint256 _input) internal {\r\n        require(_input < uint96(-1), \"Invalid Handler Type\");\r\n        _stack.push(bytes12(uint96(_input)));\r\n    }\r\n\r\n    function getAddress(bytes32[] storage _stack)\r\n        internal\r\n        returns (address ret)\r\n    {\r\n        ret = address(uint160(uint256(peek(_stack))));\r\n        _stack.pop();\r\n    }\r\n\r\n    function getSig(bytes32[] storage _stack) internal returns (bytes4 ret) {\r\n        ret = bytes4(peek(_stack));\r\n        _stack.pop();\r\n    }\r\n\r\n    function get(bytes32[] storage _stack) internal returns (bytes32 ret) {\r\n        ret = peek(_stack);\r\n        _stack.pop();\r\n    }\r\n\r\n    function peek(bytes32[] storage _stack)\r\n        internal\r\n        view\r\n        returns (bytes32 ret)\r\n    {\r\n        require(_stack.length > 0, \"stack empty\");\r\n        ret = _stack[_stack.length - 1];\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/lib/LibCache.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary LibCache {\r\n    function set(\r\n        mapping(bytes32 => bytes32) storage _cache,\r\n        bytes32 _key,\r\n        bytes32 _value\r\n    ) internal {\r\n        _cache[_key] = _value;\r\n    }\r\n\r\n    function setAddress(\r\n        mapping(bytes32 => bytes32) storage _cache,\r\n        bytes32 _key,\r\n        address _value\r\n    ) internal {\r\n        _cache[_key] = bytes32(uint256(uint160(_value)));\r\n    }\r\n\r\n    function setUint256(\r\n        mapping(bytes32 => bytes32) storage _cache,\r\n        bytes32 _key,\r\n        uint256 _value\r\n    ) internal {\r\n        _cache[_key] = bytes32(_value);\r\n    }\r\n\r\n    function getAddress(\r\n        mapping(bytes32 => bytes32) storage _cache,\r\n        bytes32 _key\r\n    ) internal view returns (address ret) {\r\n        ret = address(uint160(uint256(_cache[_key])));\r\n    }\r\n\r\n    function getUint256(\r\n        mapping(bytes32 => bytes32) storage _cache,\r\n        bytes32 _key\r\n    ) internal view returns (uint256 ret) {\r\n        ret = uint256(_cache[_key]);\r\n    }\r\n\r\n    function get(mapping(bytes32 => bytes32) storage _cache, bytes32 _key)\r\n        internal\r\n        view\r\n        returns (bytes32 ret)\r\n    {\r\n        ret = _cache[_key];\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/Storage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/// @notice A cache structure composed by a bytes32 array\r\ncontract Storage {\r\n    using LibCache for mapping(bytes32 => bytes32);\r\n    using LibStack for bytes32[];\r\n\r\n    bytes32[] public stack;\r\n    mapping(bytes32 => bytes32) public cache;\r\n\r\n    // keccak256 hash of \"msg.sender\"\r\n    // prettier-ignore\r\n    bytes32 public constant MSG_SENDER_KEY = 0xb2f2618cecbbb6e7468cc0f2aa43858ad8d153e0280b22285e28e853bb9d453a;\r\n\r\n    // keccak256 hash of \"cube.counter\"\r\n    // prettier-ignore\r\n    bytes32 public constant CUBE_COUNTER_KEY = 0xf9543f11459ccccd21306c8881aaab675ff49d988c1162fd1dd9bbcdbe4446be;\r\n\r\n    modifier isStackEmpty() {\r\n        require(stack.length == 0, \"Stack not empty\");\r\n        _;\r\n    }\r\n\r\n    modifier isCubeCounterZero() {\r\n        require(_getCubeCounter() == 0, \"Cube counter not zero\");\r\n        _;\r\n    }\r\n\r\n    function _setSender() internal {\r\n        if (_getSender() == address(0))\r\n            cache.setAddress(MSG_SENDER_KEY, msg.sender);\r\n    }\r\n\r\n    function _resetSender() internal {\r\n        cache.setAddress(MSG_SENDER_KEY, address(0));\r\n    }\r\n\r\n    function _getSender() internal view returns (address) {\r\n        return cache.getAddress(MSG_SENDER_KEY);\r\n    }\r\n\r\n    function _addCubeCounter() internal {\r\n        cache.setUint256(CUBE_COUNTER_KEY, _getCubeCounter() + 1);\r\n    }\r\n\r\n    function _resetCubeCounter() internal {\r\n        cache.setUint256(CUBE_COUNTER_KEY, 0);\r\n    }\r\n\r\n    function _getCubeCounter() internal view returns (uint256) {\r\n        return cache.getUint256(CUBE_COUNTER_KEY);\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/Config.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract Config {\r\n    // function signature of \"postProcess()\"\r\n    bytes4 public constant POSTPROCESS_SIG = 0xc2722916;\r\n\r\n    // The base amount of percentage function\r\n    uint256 public constant PERCENTAGE_BASE = 1 ether;\r\n\r\n    // Handler post-process type. Others should not happen now.\r\n    enum HandlerType {Token, Custom, Others}\r\n}\r\n\r\n// File: localhost/contracts/interface/IRegistry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\ninterface IRegistry {\r\n    function infos(address) external view returns (bytes32);\r\n\r\n    function isValid(address handler) external view returns (bool result);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: localhost/contracts/Proxy.sol\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The entrance of Furucombo\r\n * @author Ben Huang\r\n */\r\ncontract Proxy is Storage, Config {\r\n    using Address for address;\r\n    using SafeERC20 for IERC20;\r\n    using LibParam for bytes32;\r\n\r\n    // keccak256 hash of \"furucombo.handler.registry\"\r\n    // prettier-ignore\r\n    bytes32 private constant HANDLER_REGISTRY = 0x6874162fd62902201ea0f4bf541086067b3b88bd802fac9e150fd2d1db584e19;\r\n\r\n    constructor(address registry) public {\r\n        bytes32 slot = HANDLER_REGISTRY;\r\n        assembly {\r\n            sstore(slot, registry)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Direct transfer from EOA should be reverted.\r\n     * @dev Callback function will be handled here.\r\n     */\r\n    fallback() external payable {\r\n        require(Address.isContract(msg.sender), \"Not allowed from EOA\");\r\n\r\n        // If triggered by a function call, caller should be registered in registry.\r\n        // The function call will then be forwarded to the location registered in\r\n        // registry.\r\n        if (msg.data.length != 0) {\r\n            require(_isValid(msg.sender), \"Invalid caller\");\r\n\r\n            address target =\r\n                address(bytes20(IRegistry(_getRegistry()).infos(msg.sender)));\r\n            bytes memory result = _exec(target, msg.data);\r\n\r\n            // return result for aave v2 flashloan()\r\n            uint256 size = result.length;\r\n            assembly {\r\n                let loc := add(result, 0x20)\r\n                return(loc, size)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Combo execution function. Including three phases: pre-process,\r\n     * exection and post-process.\r\n     * @param tos The handlers of combo.\r\n     * @param configs The configurations of executing cubes.\r\n     * @param datas The combo datas.\r\n     */\r\n    function batchExec(\r\n        address[] memory tos,\r\n        bytes32[] memory configs,\r\n        bytes[] memory datas\r\n    ) public payable {\r\n        _preProcess();\r\n        _execs(tos, configs, datas);\r\n        _postProcess();\r\n    }\r\n\r\n    /**\r\n     * @notice The execution interface for callback function to be executed.\r\n     * @dev This function can only be called through the handler, which makes\r\n     * the caller become proxy itself.\r\n     */\r\n    function execs(\r\n        address[] memory tos,\r\n        bytes32[] memory configs,\r\n        bytes[] memory datas\r\n    ) public payable {\r\n        require(msg.sender == address(this), \"Does not allow external calls\");\r\n        require(_getSender() != address(0), \"Sender should be initialized\");\r\n        _execs(tos, configs, datas);\r\n    }\r\n\r\n    /**\r\n     * @notice The execution phase.\r\n     * @param tos The handlers of combo.\r\n     * @param configs The configurations of executing cubes.\r\n     * @param datas The combo datas.\r\n     */\r\n    function _execs(\r\n        address[] memory tos,\r\n        bytes32[] memory configs,\r\n        bytes[] memory datas\r\n    ) internal {\r\n        bytes32[256] memory localStack;\r\n        uint256 index = 0;\r\n\r\n        require(\r\n            tos.length == datas.length,\r\n            \"Tos and datas length inconsistent\"\r\n        );\r\n        require(\r\n            tos.length == configs.length,\r\n            \"Tos and configs length inconsistent\"\r\n        );\r\n        for (uint256 i = 0; i < tos.length; i++) {\r\n            // Check if the data contains dynamic parameter\r\n            if (!configs[i].isStatic()) {\r\n                // If so, trim the exectution data base on the configuration and stack content\r\n                _trim(datas[i], configs[i], localStack, index);\r\n            }\r\n            // Check if the output will be referenced afterwards\r\n            if (configs[i].isReferenced()) {\r\n                // If so, parse the output and place it into local stack\r\n                uint256 num = configs[i].getReturnNum();\r\n                uint256 newIndex =\r\n                    _parse(localStack, _exec(tos[i], datas[i]), index);\r\n                require(\r\n                    newIndex == index + num,\r\n                    \"Return num and parsed return num not matched\"\r\n                );\r\n                index = newIndex;\r\n            } else {\r\n                _exec(tos[i], datas[i]);\r\n            }\r\n            // Setup the process to be triggered in the post-process phase\r\n            _setPostProcess(tos[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Trimming the execution data.\r\n     * @param data The execution data.\r\n     * @param config The configuration.\r\n     * @param localStack The stack the be referenced.\r\n     * @param index Current element count of localStack.\r\n     */\r\n    function _trim(\r\n        bytes memory data,\r\n        bytes32 config,\r\n        bytes32[256] memory localStack,\r\n        uint256 index\r\n    ) internal pure {\r\n        // Fetch the parameter configuration from config\r\n        (uint256[] memory refs, uint256[] memory params) = config.getParams();\r\n        // Trim the data with the reference and parameters\r\n        for (uint256 i = 0; i < refs.length; i++) {\r\n            require(refs[i] < index, \"Reference to out of localStack\");\r\n            bytes32 ref = localStack[refs[i]];\r\n            uint256 offset = params[i];\r\n            uint256 base = PERCENTAGE_BASE;\r\n            assembly {\r\n                let loc := add(add(data, 0x20), offset)\r\n                let m := mload(loc)\r\n                // Adjust the value by multiplier if a dynamic parameter is not zero\r\n                if iszero(iszero(m)) {\r\n                    // Assert no overflow first\r\n                    let p := mul(m, ref)\r\n                    if iszero(eq(div(p, m), ref)) {\r\n                        revert(0, 0)\r\n                    } // require(p / m == ref)\r\n                    ref := div(p, base)\r\n                }\r\n                mstore(loc, ref)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Parse the return data to the local stack.\r\n     * @param localStack The local stack to place the return values.\r\n     * @param ret The return data.\r\n     * @param index The current tail.\r\n     */\r\n    function _parse(\r\n        bytes32[256] memory localStack,\r\n        bytes memory ret,\r\n        uint256 index\r\n    ) internal pure returns (uint256 newIndex) {\r\n        uint256 len = ret.length;\r\n        // Estimate the tail after the process.\r\n        newIndex = index + len / 32;\r\n        require(newIndex <= 256, \"stack overflow\");\r\n        assembly {\r\n            let offset := shl(5, index)\r\n            // Store the data into localStack\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n                i := add(i, 0x20)\r\n            } {\r\n                mstore(\r\n                    add(localStack, add(i, offset)),\r\n                    mload(add(add(ret, i), 0x20))\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The execution of a single cube.\r\n     * @param _to The handler of cube.\r\n     * @param _data The cube execution data.\r\n     */\r\n    function _exec(address _to, bytes memory _data)\r\n        internal\r\n        returns (bytes memory result)\r\n    {\r\n        require(_isValid(_to), \"Invalid handler\");\r\n        _addCubeCounter();\r\n        assembly {\r\n            let succeeded := delegatecall(\r\n                sub(gas(), 5000),\r\n                _to,\r\n                add(_data, 0x20),\r\n                mload(_data),\r\n                0,\r\n                0\r\n            )\r\n            let size := returndatasize()\r\n\r\n            result := mload(0x40)\r\n            mstore(\r\n                0x40,\r\n                add(result, and(add(add(size, 0x20), 0x1f), not(0x1f)))\r\n            )\r\n            mstore(result, size)\r\n            returndatacopy(add(result, 0x20), 0, size)\r\n\r\n            switch iszero(succeeded)\r\n                case 1 {\r\n                    revert(add(result, 0x20), size)\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Setup the post-process.\r\n     * @param _to The handler of post-process.\r\n     */\r\n    function _setPostProcess(address _to) internal {\r\n        // If the stack length equals 0, just skip\r\n        // If the top is a custom post-process, replace it with the handler\r\n        // address.\r\n        if (stack.length == 0) {\r\n            return;\r\n        } else if (\r\n            stack.peek() == bytes32(bytes12(uint96(HandlerType.Custom)))\r\n        ) {\r\n            stack.pop();\r\n            // Check if the handler is already set.\r\n            if (bytes4(stack.peek()) != 0x00000000) stack.setAddress(_to);\r\n            stack.setHandlerType(uint256(HandlerType.Custom));\r\n        }\r\n    }\r\n\r\n    /// @notice The pre-process phase.\r\n    function _preProcess() internal virtual isStackEmpty isCubeCounterZero {\r\n        // Set the sender.\r\n        _setSender();\r\n    }\r\n\r\n    /// @notice The post-process phase.\r\n    function _postProcess() internal {\r\n        // If the top of stack is HandlerType.Custom (which makes it being zero\r\n        // address when `stack.getAddress()`), get the handler address and execute\r\n        // the handler with it and the post-process function selector.\r\n        // If not, use it as token address and send the token back to user.\r\n        while (stack.length > 0) {\r\n            address addr = stack.getAddress();\r\n            if (addr == address(0)) {\r\n                addr = stack.getAddress();\r\n                _exec(addr, abi.encodeWithSelector(POSTPROCESS_SIG));\r\n            } else {\r\n                uint256 amount = IERC20(addr).balanceOf(address(this));\r\n                if (amount > 0) IERC20(addr).safeTransfer(msg.sender, amount);\r\n            }\r\n        }\r\n\r\n        // Balance should also be returned to user\r\n        uint256 amount = address(this).balance;\r\n        if (amount > 0) msg.sender.transfer(amount);\r\n\r\n        // Reset the msg.sender and cube counter\r\n        _resetSender();\r\n        _resetCubeCounter();\r\n    }\r\n\r\n    /// @notice Get the registry contract address.\r\n    function _getRegistry() internal view returns (address registry) {\r\n        bytes32 slot = HANDLER_REGISTRY;\r\n        assembly {\r\n            registry := sload(slot)\r\n        }\r\n    }\r\n\r\n    /// @notice Check if the handler is valid in registry.\r\n    function _isValid(address handler) internal view returns (bool result) {\r\n        return IRegistry(_getRegistry()).isValid(handler);\r\n    }\r\n}"}
{"address": "0x923cab01e6a4639664aa64b76396eec0ea7d3a5f", "attacktype": "Visibility errors, including unrestricted action", "sourcecode": "// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {this;}\r\n    function symbol() public view returns (string) {this;}\r\n    function decimals() public view returns (uint8) {this;}\r\n    function totalSupply() public view returns (uint256) {this;}\r\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/IBancorNetwork.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract IBancorNetwork {\r\n    function convert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    function convertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public returns (uint256);\r\n}\r\n\r\n// File: contracts/IConversionPathFinder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Conversion Path Finder interface\r\n*/\r\ncontract IConversionPathFinder {\r\n    function findPath(address _sourceToken, address _targetToken) public view returns (address[] memory);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/utility/interfaces/ITokenHolder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/converter/interfaces/IConverterAnchor.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Converter Anchor interface\r\n*/\r\ncontract IConverterAnchor is IOwned, ITokenHolder {\r\n}\r\n\r\n// File: contracts/utility/interfaces/IWhitelist.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IConverter.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    Converter interface\r\n*/\r\ncontract IConverter is IOwned {\r\n    function converterType() public pure returns (uint16);\r\n    function anchor() public view returns (IConverterAnchor) {this;}\r\n    function isActive() public view returns (bool);\r\n\r\n    function rateAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256);\r\n    function convert(IERC20Token _sourceToken,\r\n                     IERC20Token _targetToken,\r\n                     uint256 _amount,\r\n                     address _trader,\r\n                     address _beneficiary) public payable returns (uint256);\r\n\r\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\r\n    function conversionFee() public view returns (uint32) {this;}\r\n    function maxConversionFee() public view returns (uint32) {this;}\r\n    function reserveBalance(IERC20Token _reserveToken) public view returns (uint256);\r\n    function() external payable;\r\n\r\n    function transferAnchorOwnership(address _newOwner) public;\r\n    function acceptAnchorOwnership() public;\r\n    function setConversionFee(uint32 _conversionFee) public;\r\n    function setConversionWhitelist(IWhitelist _whitelist) public;\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n    function withdrawETH(address _to) public;\r\n    function addReserve(IERC20Token _token, uint32 _ratio) public;\r\n\r\n    // deprecated, backward compatibility\r\n    function token() public view returns (IConverterAnchor);\r\n    function transferTokenOwnership(address _newOwner) public;\r\n    function acceptTokenOwnership() public;\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\r\n    function connectorTokenCount() public view returns (uint16);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorFormula.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ncontract IBancorFormula {\r\n    function purchaseRate(uint256 _supply,\r\n                          uint256 _reserveBalance,\r\n                          uint32 _reserveWeight,\r\n                          uint256 _amount)\r\n                          public view returns (uint256);\r\n\r\n    function saleRate(uint256 _supply,\r\n                      uint256 _reserveBalance,\r\n                      uint32 _reserveWeight,\r\n                      uint256 _amount)\r\n                      public view returns (uint256);\r\n\r\n    function crossReserveRate(uint256 _sourceReserveBalance,\r\n                              uint32 _sourceReserveWeight,\r\n                              uint256 _targetReserveBalance,\r\n                              uint32 _targetReserveWeight,\r\n                              uint256 _amount)\r\n                              public view returns (uint256);\r\n\r\n    function fundCost(uint256 _supply,\r\n                      uint256 _reserveBalance,\r\n                      uint32 _reserveRatio,\r\n                      uint256 _amount)\r\n                      public view returns (uint256);\r\n\r\n    function liquidateRate(uint256 _supply,\r\n                           uint256 _reserveBalance,\r\n                           uint32 _reserveRatio,\r\n                           uint256 _amount)\r\n                           public view returns (uint256);\r\n}\r\n\r\n// File: contracts/utility/Owned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Utils.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/utility/ContractRegistryClient.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/ReentrancyGuard.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev ReentrancyGuard\r\n  *\r\n  * The contract provides protection against re-entrancy - calling a function (directly or\r\n  * indirectly) from within itself.\r\n*/\r\ncontract ReentrancyGuard {\r\n    // true while protected code is being executed, false otherwise\r\n    bool private locked = false;\r\n\r\n    /**\r\n      * @dev ensures instantiation only by sub-contracts\r\n    */\r\n    constructor() internal {}\r\n\r\n    // protects a function against reentrancy attacks\r\n    modifier protected() {\r\n        _protected();\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _protected() internal view {\r\n        require(!locked, \"ERR_REENTRANCY\");\r\n    }\r\n}\r\n\r\n// File: contracts/utility/TokenHandler.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ncontract TokenHandler {\r\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n    */\r\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) public {\r\n       execute(_token, abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) public {\r\n       execute(_token, abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) public {\r\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\r\n    }\r\n\r\n    /**\r\n      * @dev executes a function on the ERC20 token and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _data    data to pass in to the token's contract for execution\r\n    */\r\n    function execute(IERC20Token _token, bytes memory _data) private {\r\n        uint256[1] memory ret = [uint256(1)];\r\n\r\n        assembly {\r\n            let success := call(\r\n                gas,            // gas remaining\r\n                _token,         // destination address\r\n                0,              // no ether\r\n                add(_data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\r\n                mload(_data),   // input length (loaded from the first 32 bytes in the `data` array)\r\n                ret,            // output buffer\r\n                32              // output length\r\n            )\r\n            if iszero(success) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        require(ret[0] != 0, \"ERR_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\n// File: contracts/utility/TokenHolder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/SafeMath.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/token/interfaces/IEtherToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Ether Token interface\r\n*/\r\ncontract IEtherToken is IERC20Token {\r\n    function deposit() public payable;\r\n    function withdraw(uint256 _amount) public;\r\n    function depositTo(address _to) public payable;\r\n    function withdrawTo(address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IConverterAnchor, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/bancorx/interfaces/IBancorX.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ncontract IBancorX {\r\n    function token() public view returns (IERC20Token) {this;}\r\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;\r\n    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/BancorNetwork.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// interface of older converters for backward compatibility\r\ncontract ILegacyConverter {\r\n    function change(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n}\r\n\r\n/**\r\n  * @dev The BancorNetwork contract is the main entry point for Bancor token conversions.\r\n  * It also allows for the conversion of any token in the Bancor Network to any other token in a single\r\n  * transaction by providing a conversion path.\r\n  *\r\n  * A note on Conversion Path: Conversion path is a data structure that is used when converting a token\r\n  * to another token in the Bancor Network, when the conversion cannot necessarily be done by a single\r\n  * converter and might require multiple 'hops'.\r\n  * The path defines which converters should be used and what kind of conversion should be done in each step.\r\n  *\r\n  * The path format doesn't include complex structure; instead, it is represented by a single array\r\n  * in which each 'hop' is represented by a 2-tuple - converter anchor & target token.\r\n  * In addition, the first element is always the source token.\r\n  * The converter anchor is only used as a pointer to a converter (since converter addresses are more\r\n  * likely to change as opposed to anchor addresses).\r\n  *\r\n  * Format:\r\n  * [source token, converter anchor, target token, converter anchor, target token...]\r\n*/\r\ncontract BancorNetwork is IBancorNetwork, TokenHolder, ContractRegistryClient, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant CONVERSION_FEE_RESOLUTION = 1000000;\r\n    uint256 private constant AFFILIATE_FEE_RESOLUTION = 1000000;\r\n    address private constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    struct ConversionStep {\r\n        IConverter converter;\r\n        IConverterAnchor anchor;\r\n        IERC20Token sourceToken;\r\n        IERC20Token targetToken;\r\n        address beneficiary;\r\n        bool isV28OrHigherConverter;\r\n        bool processAffiliateFee;\r\n    }\r\n\r\n    uint256 public maxAffiliateFee = 30000;     // maximum affiliate-fee\r\n\r\n    mapping (address => bool) public etherTokens;       // list of all supported ether tokens\r\n\r\n    /**\r\n      * @dev triggered when a conversion between two tokens occurs\r\n      *\r\n      * @param _smartToken  anchor governed by the converter\r\n      * @param _fromToken   source ERC20 token\r\n      * @param _toToken     target ERC20 token\r\n      * @param _fromAmount  amount converted, in the source token\r\n      * @param _toAmount    amount returned, minus conversion fee\r\n      * @param _trader      wallet that initiated the trade\r\n    */\r\n    event Conversion(\r\n        address indexed _smartToken,\r\n        address indexed _fromToken,\r\n        address indexed _toToken,\r\n        uint256 _fromAmount,\r\n        uint256 _toAmount,\r\n        address _trader\r\n    );\r\n\r\n    /**\r\n      * @dev initializes a new BancorNetwork instance\r\n      *\r\n      * @param _registry    address of a contract registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) ContractRegistryClient(_registry) public {\r\n        etherTokens[ETH_RESERVE_ADDRESS] = true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to update the maximum affiliate-fee\r\n      *\r\n      * @param _maxAffiliateFee   maximum affiliate-fee\r\n    */\r\n    function setMaxAffiliateFee(uint256 _maxAffiliateFee)\r\n        public\r\n        ownerOnly\r\n    {\r\n        require(_maxAffiliateFee <= AFFILIATE_FEE_RESOLUTION, \"ERR_INVALID_AFFILIATE_FEE\");\r\n        maxAffiliateFee = _maxAffiliateFee;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to register/unregister ether tokens\r\n      *\r\n      * @param _token       ether token contract address\r\n      * @param _register    true to register, false to unregister\r\n    */\r\n    function registerEtherToken(IEtherToken _token, bool _register)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        notThis(_token)\r\n    {\r\n        etherTokens[_token] = _register;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the conversion path between two tokens in the network\r\n      * note that this method is quite expensive in terms of gas and should generally be called off-chain\r\n      *\r\n      * @param _sourceToken source token address\r\n      * @param _targetToken target token address\r\n      *\r\n      * @return conversion path between the two tokens\r\n    */\r\n    function conversionPath(IERC20Token _sourceToken, IERC20Token _targetToken) public view returns (address[]) {\r\n        IConversionPathFinder pathFinder = IConversionPathFinder(addressOf(CONVERSION_PATH_FINDER));\r\n        return pathFinder.findPath(_sourceToken, _targetToken);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected rate of converting a given amount on a given path\r\n      * note that there is no support for circular paths\r\n      *\r\n      * @param _path        conversion path (see conversion path format above)\r\n      * @param _amount      amount of _path[0] tokens received from the sender\r\n      *\r\n      * @return expected rate\r\n    */\r\n    function rateByPath(IERC20Token[] _path, uint256 _amount) public view returns (uint256) {\r\n        uint256 amount;\r\n        uint256 fee;\r\n        uint256 supply;\r\n        uint256 balance;\r\n        uint32 weight;\r\n        IConverter converter;\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n\r\n        amount = _amount;\r\n\r\n        // verify that the number of elements is larger than 2 and odd\r\n        require(_path.length > 2 && _path.length % 2 == 1, \"ERR_INVALID_PATH\");\r\n\r\n        // iterate over the conversion path\r\n        for (uint256 i = 2; i < _path.length; i += 2) {\r\n            IERC20Token sourceToken = _path[i - 2];\r\n            IERC20Token anchor = _path[i - 1];\r\n            IERC20Token targetToken = _path[i];\r\n\r\n            if (targetToken == anchor) { // buy the smart token\r\n                // check if the current smart token has changed\r\n                if (i < 3 || anchor != _path[i - 3]) {\r\n                    supply = ISmartToken(anchor).totalSupply();\r\n                    converter = IConverter(IConverterAnchor(anchor).owner());\r\n                }\r\n\r\n                // get the amount & the conversion fee\r\n                balance = converter.getConnectorBalance(sourceToken);\r\n                (, weight, , , ) = converter.connectors(sourceToken);\r\n                amount = formula.purchaseRate(supply, balance, weight, amount);\r\n                fee = amount.mul(converter.conversionFee()).div(CONVERSION_FEE_RESOLUTION);\r\n                amount -= fee;\r\n\r\n                // update the smart token supply for the next iteration\r\n                supply = supply.add(amount);\r\n            }\r\n            else if (sourceToken == anchor) { // sell the smart token\r\n                // check if the current smart token has changed\r\n                if (i < 3 || anchor != _path[i - 3]) {\r\n                    supply = ISmartToken(anchor).totalSupply();\r\n                    converter = IConverter(IConverterAnchor(anchor).owner());\r\n                }\r\n\r\n                // get the amount & the conversion fee\r\n                balance = converter.getConnectorBalance(targetToken);\r\n                (, weight, , , ) = converter.connectors(targetToken);\r\n                amount = formula.saleRate(supply, balance, weight, amount);\r\n                fee = amount.mul(converter.conversionFee()).div(CONVERSION_FEE_RESOLUTION);\r\n                amount -= fee;\r\n\r\n                // update the smart token supply for the next iteration\r\n                supply = supply.sub(amount);\r\n            }\r\n            else { // cross reserve conversion\r\n                // check if the current smart token has changed\r\n                if (i < 3 || anchor != _path[i - 3]) {\r\n                    converter = IConverter(IConverterAnchor(anchor).owner());\r\n                }\r\n\r\n                (amount, fee) = getReturn(converter, sourceToken, targetToken, amount);\r\n            }\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev converts the token to any other token in the bancor network by following\r\n      * a predefined conversion path and transfers the result tokens to a target account\r\n      * affiliate account/fee can also be passed in to receive a conversion fee (on top of the liquidity provider fees)\r\n      * note that the network should already have been given allowance of the source token (if not ETH)\r\n      *\r\n      * @param _path                conversion path, see conversion path format above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _beneficiary         account that will receive the conversion result or 0x0 to send the result to the sender account\r\n      * @param _affiliateAccount    wallet address to receive the affiliate fee or 0x0 to disable affiliate fee\r\n      * @param _affiliateFee        affiliate fee in PPM or 0 to disable affiliate fee\r\n      *\r\n      * @return amount of tokens received from the conversion\r\n    */\r\n    function convertByPath(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _beneficiary, address _affiliateAccount, uint256 _affiliateFee)\r\n        public\r\n        payable\r\n        protected\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        // verify that the path contrains at least a single 'hop' and that the number of elements is odd\r\n        require(_path.length > 2 && _path.length % 2 == 1, \"ERR_INVALID_PATH\");\r\n\r\n        // validate msg.value and prepare the source token for the conversion\r\n        handleSourceToken(_path[0], IConverterAnchor(_path[1]), _amount);\r\n\r\n        // check if affiliate fee is enabled\r\n        bool affiliateFeeEnabled = false;\r\n        if (address(_affiliateAccount) == 0) {\r\n            require(_affiliateFee == 0, \"ERR_INVALID_AFFILIATE_FEE\");\r\n        }\r\n        else {\r\n            require(0 < _affiliateFee && _affiliateFee <= maxAffiliateFee, \"ERR_INVALID_AFFILIATE_FEE\");\r\n            affiliateFeeEnabled = true;\r\n        }\r\n\r\n        // check if beneficiary is set\r\n        address beneficiary = msg.sender;\r\n        if (_beneficiary != address(0))\r\n            beneficiary = _beneficiary;\r\n\r\n        // convert and get the resulting amount\r\n        ConversionStep[] memory data = createConversionData(_path, beneficiary, affiliateFeeEnabled);\r\n        uint256 amount = doConversion(data, _amount, _minReturn, _affiliateAccount, _affiliateFee);\r\n\r\n        // handle the conversion target tokens\r\n        handleTargetToken(data, amount, beneficiary);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev converts any other token to BNT in the bancor network by following\r\n      a predefined conversion path and transfers the result to an account on a different blockchain\r\n      * note that the network should already have been given allowance of the source token (if not ETH)\r\n      *\r\n      * @param _path                conversion path, see conversion path format above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _targetBlockchain    blockchain BNT will be issued on\r\n      * @param _targetAccount       address/account on the target blockchain to send the BNT to\r\n      * @param _conversionId        pre-determined unique (if non zero) id which refers to this transaction\r\n      *\r\n      * @return the amount of BNT received from this conversion\r\n    */\r\n    function xConvert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        bytes32 _targetBlockchain,\r\n        bytes32 _targetAccount,\r\n        uint256 _conversionId\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return xConvert2(_path, _amount, _minReturn, _targetBlockchain, _targetAccount, _conversionId, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev converts any other token to BNT in the bancor network by following\r\n      a predefined conversion path and transfers the result to an account on a different blockchain\r\n      * note that the network should already have been given allowance of the source token (if not ETH)\r\n      *\r\n      * @param _path                conversion path, see conversion path format above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _targetBlockchain    blockchain BNT will be issued on\r\n      * @param _targetAccount       address/account on the target blockchain to send the BNT to\r\n      * @param _conversionId        pre-determined unique (if non zero) id which refers to this transaction\r\n      * @param _affiliateAccount    affiliate account\r\n      * @param _affiliateFee        affiliate fee in PPM\r\n      *\r\n      * @return the amount of BNT received from this conversion\r\n    */\r\n    function xConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        bytes32 _targetBlockchain,\r\n        bytes32 _targetAccount,\r\n        uint256 _conversionId,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        payable\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        IERC20Token targetToken = _path[_path.length - 1];\r\n        IBancorX bancorX = IBancorX(addressOf(BANCOR_X));\r\n\r\n        // verify that the destination token is BNT\r\n        require(targetToken == addressOf(BNT_TOKEN), \"ERR_INVALID_TARGET_TOKEN\");\r\n\r\n        // convert and get the resulting amount\r\n        uint256 amount = convertByPath(_path, _amount, _minReturn, this, _affiliateAccount, _affiliateFee);\r\n\r\n        // grant BancorX allowance\r\n        ensureAllowance(targetToken, bancorX, amount);\r\n\r\n        // transfer the resulting amount to BancorX\r\n        bancorX.xTransfer(_targetBlockchain, _targetAccount, amount, _conversionId);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev allows a user to convert a token that was sent from another blockchain into any other\r\n      * token on the BancorNetwork\r\n      * ideally this transaction is created before the previous conversion is even complete, so\r\n      * so the input amount isn't known at that point - the amount is actually take from the\r\n      * BancorX contract directly by specifying the conversion id\r\n      *\r\n      * @param _path            conversion path\r\n      * @param _bancorX         address of the BancorX contract for the source token\r\n      * @param _conversionId    pre-determined unique (if non zero) id which refers to this conversion\r\n      * @param _minReturn       if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * @param _beneficiary     wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received from the conversion\r\n    */\r\n    function completeXConversion(IERC20Token[] _path, IBancorX _bancorX, uint256 _conversionId, uint256 _minReturn, address _beneficiary)\r\n        public returns (uint256)\r\n    {\r\n        // verify that the source token is the BancorX token\r\n        require(_path[0] == _bancorX.token(), \"ERR_INVALID_SOURCE_TOKEN\");\r\n\r\n        // get conversion amount from BancorX contract\r\n        uint256 amount = _bancorX.getXTransferAmount(_conversionId, msg.sender);\r\n\r\n        // perform the conversion\r\n        return convertByPath(_path, amount, _minReturn, _beneficiary, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev executes the actual conversion by following the conversion path\r\n      *\r\n      * @param _data                conversion data, see ConversionStep struct above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _affiliateAccount    affiliate account\r\n      * @param _affiliateFee        affiliate fee in PPM\r\n      *\r\n      * @return amount of tokens received from the conversion\r\n    */\r\n    function doConversion(\r\n        ConversionStep[] _data,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) private returns (uint256) {\r\n        uint256 toAmount;\r\n        uint256 fromAmount = _amount;\r\n\r\n        // iterate over the conversion data\r\n        for (uint256 i = 0; i < _data.length; i++) {\r\n            ConversionStep memory stepData = _data[i];\r\n\r\n            // newer converter\r\n            if (stepData.isV28OrHigherConverter) {\r\n                // transfer the tokens to the converter only if the network contract currently holds the tokens\r\n                // not needed with ETH or if it's the first conversion step\r\n                if (i != 0 && _data[i - 1].beneficiary == address(this) && !etherTokens[stepData.sourceToken])\r\n                    safeTransfer(stepData.sourceToken, stepData.converter, fromAmount);\r\n            }\r\n            // older converter\r\n            // if the source token is the smart token, no need to do any transfers as the converter controls it\r\n            else if (stepData.sourceToken != ISmartToken(stepData.anchor)) {\r\n                // grant allowance for it to transfer the tokens from the network contract\r\n                ensureAllowance(stepData.sourceToken, stepData.converter, fromAmount);\r\n            }\r\n\r\n            // do the conversion\r\n            if (!stepData.isV28OrHigherConverter)\r\n                toAmount = ILegacyConverter(stepData.converter).change(stepData.sourceToken, stepData.targetToken, fromAmount, 1);\r\n            else if (etherTokens[stepData.sourceToken])\r\n                toAmount = stepData.converter.convert.value(msg.value)(stepData.sourceToken, stepData.targetToken, fromAmount, msg.sender, stepData.beneficiary);\r\n            else\r\n                toAmount = stepData.converter.convert(stepData.sourceToken, stepData.targetToken, fromAmount, msg.sender, stepData.beneficiary);\r\n\r\n            // pay affiliate-fee if needed\r\n            if (stepData.processAffiliateFee) {\r\n                uint256 affiliateAmount = toAmount.mul(_affiliateFee).div(AFFILIATE_FEE_RESOLUTION);\r\n                require(stepData.targetToken.transfer(_affiliateAccount, affiliateAmount), \"ERR_FEE_TRANSFER_FAILED\");\r\n                toAmount -= affiliateAmount;\r\n            }\r\n\r\n            emit Conversion(stepData.anchor, stepData.sourceToken, stepData.targetToken, fromAmount, toAmount, msg.sender);\r\n            fromAmount = toAmount;\r\n        }\r\n\r\n        // ensure the trade meets the minimum requested amount\r\n        require(toAmount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\r\n\r\n        return toAmount;\r\n    }\r\n\r\n    /**\r\n      * @dev validates msg.value and prepares the conversion source token for the conversion\r\n      *\r\n      * @param _sourceToken source token of the first conversion step\r\n      * @param _anchor      converter anchor of the first conversion step\r\n      * @param _amount      amount to convert from, in the source token\r\n    */\r\n    function handleSourceToken(IERC20Token _sourceToken, IConverterAnchor _anchor, uint256 _amount) private {\r\n        IConverter firstConverter = IConverter(_anchor.owner());\r\n        bool isNewerConverter = isV28OrHigherConverter(firstConverter);\r\n\r\n        // ETH\r\n        if (msg.value > 0) {\r\n            // validate msg.value\r\n            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n\r\n            // EtherToken converter - deposit the ETH into the EtherToken\r\n            // note that it can still be a non ETH converter if the path is wrong\r\n            // but such conversion will simply revert\r\n            if (!isNewerConverter)\r\n                IEtherToken(getConverterEtherTokenAddress(firstConverter)).deposit.value(msg.value)();\r\n        }\r\n        // EtherToken\r\n        else if (etherTokens[_sourceToken]) {\r\n            // claim the tokens - if the source token is ETH reserve, this call will fail\r\n            // since in that case the transaction must be sent with msg.value\r\n            safeTransferFrom(_sourceToken, msg.sender, this, _amount);\r\n\r\n            // ETH converter - withdraw the ETH\r\n            if (isNewerConverter)\r\n                IEtherToken(_sourceToken).withdraw(_amount);\r\n        }\r\n        // other ERC20 token\r\n        else {\r\n            // newer converter - transfer the tokens from the sender directly to the converter\r\n            // otherwise claim the tokens\r\n            if (isNewerConverter)\r\n                safeTransferFrom(_sourceToken, msg.sender, firstConverter, _amount);\r\n            else\r\n                safeTransferFrom(_sourceToken, msg.sender, this, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev handles the conversion target token if the network still holds it at the end of the conversion\r\n      *\r\n      * @param _data        conversion data, see ConversionStep struct above\r\n      * @param _amount      conversion return amount, in the target token\r\n      * @param _beneficiary wallet to receive the conversion result\r\n    */\r\n    function handleTargetToken(ConversionStep[] _data, uint256 _amount, address _beneficiary) private {\r\n        ConversionStep memory stepData = _data[_data.length - 1];\r\n\r\n        // network contract doesn't hold the tokens, do nothing\r\n        if (stepData.beneficiary != address(this))\r\n            return;\r\n\r\n        IERC20Token targetToken = stepData.targetToken;\r\n\r\n        // ETH / EtherToken\r\n        if (etherTokens[targetToken]) {\r\n            // newer converter should send ETH directly to the beneficiary\r\n            assert(!stepData.isV28OrHigherConverter);\r\n\r\n            // EtherToken converter - withdraw the ETH and transfer to the beneficiary\r\n            IEtherToken(targetToken).withdrawTo(_beneficiary, _amount);\r\n        }\r\n        // other ERC20 token\r\n        else {\r\n            safeTransfer(targetToken, _beneficiary, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev creates a memory cache of all conversion steps data to minimize logic and external calls during conversions\r\n      *\r\n      * @param _conversionPath      conversion path, see conversion path format above\r\n      * @param _beneficiary         wallet to receive the conversion result\r\n      * @param _affiliateFeeEnabled true if affiliate fee was requested by the sender, false if not\r\n      *\r\n      * @return cached conversion data to be ingested later on by the conversion flow\r\n    */\r\n    function createConversionData(IERC20Token[] _conversionPath, address _beneficiary, bool _affiliateFeeEnabled) private view returns (ConversionStep[]) {\r\n        ConversionStep[] memory data = new ConversionStep[](_conversionPath.length / 2);\r\n\r\n        bool affiliateFeeProcessed = false;\r\n        address bntToken = addressOf(BNT_TOKEN);\r\n        // iterate the conversion path and create the conversion data for each step\r\n        uint256 i;\r\n        for (i = 0; i < _conversionPath.length - 1; i += 2) {\r\n            IConverterAnchor anchor = IConverterAnchor(_conversionPath[i + 1]);\r\n            IConverter converter = IConverter(anchor.owner());\r\n            IERC20Token targetToken = _conversionPath[i + 2];\r\n\r\n            // check if the affiliate fee should be processed in this step\r\n            bool processAffiliateFee = _affiliateFeeEnabled && !affiliateFeeProcessed && targetToken == bntToken;\r\n            if (processAffiliateFee)\r\n                affiliateFeeProcessed = true;\r\n\r\n            data[i / 2] = ConversionStep({\r\n                // set the converter anchor\r\n                anchor: anchor,\r\n\r\n                // set the converter\r\n                converter: converter,\r\n\r\n                // set the source/target tokens\r\n                sourceToken: _conversionPath[i],\r\n                targetToken: targetToken,\r\n\r\n                // requires knowledge about the next step, so initialize in the next phase\r\n                beneficiary: address(0),\r\n\r\n                // set flags\r\n                isV28OrHigherConverter: isV28OrHigherConverter(converter),\r\n                processAffiliateFee: processAffiliateFee\r\n            });\r\n        }\r\n\r\n        // ETH support\r\n        // source is ETH\r\n        ConversionStep memory stepData = data[0];\r\n        if (etherTokens[stepData.sourceToken]) {\r\n            // newer converter - replace the source token address with ETH reserve address\r\n            if (stepData.isV28OrHigherConverter)\r\n                stepData.sourceToken = IERC20Token(ETH_RESERVE_ADDRESS);\r\n            // older converter - replace the source token with the EtherToken address used by the converter\r\n            else\r\n                stepData.sourceToken = IERC20Token(getConverterEtherTokenAddress(stepData.converter));\r\n        }\r\n\r\n        // target is ETH\r\n        stepData = data[data.length - 1];\r\n        if (etherTokens[stepData.targetToken]) {\r\n            // newer converter - replace the target token address with ETH reserve address\r\n            if (stepData.isV28OrHigherConverter)\r\n                stepData.targetToken = IERC20Token(ETH_RESERVE_ADDRESS);\r\n            // older converter - replace the target token with the EtherToken address used by the converter\r\n            else\r\n                stepData.targetToken = IERC20Token(getConverterEtherTokenAddress(stepData.converter));\r\n        }\r\n\r\n        // set the beneficiary for each step\r\n        for (i = 0; i < data.length; i++) {\r\n            stepData = data[i];\r\n\r\n            // first check if the converter in this step is newer as older converters don't even support the beneficiary argument\r\n            if (stepData.isV28OrHigherConverter) {\r\n                // if affiliate fee is processed in this step, beneficiary is the network contract\r\n                if (stepData.processAffiliateFee)\r\n                    stepData.beneficiary = this;\r\n                // if it's the last step, beneficiary is the final beneficiary\r\n                else if (i == data.length - 1)\r\n                    stepData.beneficiary = _beneficiary;\r\n                // if the converter in the next step is newer, beneficiary is the next converter\r\n                else if (data[i + 1].isV28OrHigherConverter)\r\n                    stepData.beneficiary = data[i + 1].converter;\r\n                // the converter in the next step is older, beneficiary is the network contract\r\n                else\r\n                    stepData.beneficiary = this;\r\n            }\r\n            else {\r\n                // converter in this step is older, beneficiary is the network contract\r\n                stepData.beneficiary = this;\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n      * @dev utility, checks whether allowance for the given spender exists and approves one if it doesn't.\r\n      * Note that we use the non standard erc-20 interface in which `approve` has no return value so that\r\n      * this function will work for both standard and non standard tokens\r\n      *\r\n      * @param _token   token to check the allowance in\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n    */\r\n    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\r\n        uint256 allowance = _token.allowance(this, _spender);\r\n        if (allowance < _value) {\r\n            if (allowance > 0)\r\n                safeApprove(_token, _spender, 0);\r\n            safeApprove(_token, _spender, _value);\r\n        }\r\n    }\r\n\r\n    // legacy - returns the address of an EtherToken used by the converter\r\n    function getConverterEtherTokenAddress(IConverter _converter) private view returns (address) {\r\n        uint256 reserveCount = _converter.connectorTokenCount();\r\n        for (uint256 i = 0; i < reserveCount; i++) {\r\n            address reserveTokenAddress = _converter.connectorTokens(i);\r\n            if (etherTokens[reserveTokenAddress])\r\n                return reserveTokenAddress;\r\n        }\r\n\r\n        return ETH_RESERVE_ADDRESS;\r\n    }\r\n\r\n    bytes4 private constant GET_RETURN_FUNC_SELECTOR = bytes4(keccak256(\"getReturn(address,address,uint256)\"));\r\n\r\n    // using assembly code since older converter versions have different return values\r\n    function getReturn(address _dest, address _sourceToken, address _targetToken, uint256 _amount) internal view returns (uint256, uint256) {\r\n        uint256[2] memory ret;\r\n        bytes memory data = abi.encodeWithSelector(GET_RETURN_FUNC_SELECTOR, _sourceToken, _targetToken, _amount);\r\n\r\n        assembly {\r\n            let success := staticcall(\r\n                gas,           // gas remaining\r\n                _dest,         // destination address\r\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\r\n                mload(data),   // input length (loaded from the first 32 bytes in the `data` array)\r\n                ret,           // output buffer\r\n                64             // output length\r\n            )\r\n            if iszero(success) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        return (ret[0], ret[1]);\r\n    }\r\n\r\n    bytes4 private constant IS_V28_OR_HIGHER_FUNC_SELECTOR = bytes4(keccak256(\"isV28OrHigher()\"));\r\n\r\n    // using assembly code to identify converter version\r\n    // can't rely on the version number since the function had a different signature in older converters\r\n    function isV28OrHigherConverter(IConverter _converter) internal view returns (bool) {\r\n        bool success;\r\n        uint256[1] memory ret;\r\n        bytes memory data = abi.encodeWithSelector(IS_V28_OR_HIGHER_FUNC_SELECTOR);\r\n\r\n        assembly {\r\n            success := staticcall(\r\n                gas,           // gas remaining\r\n                _converter,    // destination address\r\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\r\n                mload(data),   // input length (loaded from the first 32 bytes in the `data` array)\r\n                ret,           // output buffer\r\n                32             // output length\r\n            )\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getReturnByPath(IERC20Token[] _path, uint256 _amount) public view returns (uint256, uint256) {\r\n        return (rateByPath(_path, _amount), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _beneficiary) public payable returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _beneficiary,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        payable\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _beneficiary) public returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _beneficiary,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, _affiliateAccount, _affiliateFee);\r\n    }\r\n}"}
{"address": "0xc1e088fc1323b20bcbee9bd1b9fc9546db5624c5", "attacktype": "Governance attack", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/farm/Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Authors: Nick Mudge (https://twitter.com/mudgen)\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\";\\nimport {DiamondCutFacet} from \\\"./facets/DiamondCutFacet.sol\\\";\\nimport {DiamondLoupeFacet} from \\\"./facets/DiamondLoupeFacet.sol\\\";\\nimport {OwnershipFacet} from \\\"./facets/OwnershipFacet.sol\\\";\\nimport {AppStorage} from \\\"./AppStorage.sol\\\";\\nimport {IERC165} from \\\"../interfaces/IERC165.sol\\\";\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport {IERC173} from \\\"../interfaces/IERC173.sol\\\";\\n\\ncontract Diamond {\\n    AppStorage internal s;\\n\\n    receive() external payable {}\\n\\n    constructor(address _contractOwner) {\\n        LibDiamond.setContractOwner(_contractOwner);\\n        LibDiamond.addDiamondFunctions(\\n            address(new DiamondCutFacet()),\\n            address(new DiamondLoupeFacet()),\\n            address(new OwnershipFacet())\\n        );\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n        require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT\\n*/\\n\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport {IERC165} from \\\"../interfaces/IERC165.sol\\\";\\nimport {IERC173} from \\\"../interfaces/IERC173.sol\\\";\\nimport {LibMeta} from \\\"./LibMeta.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(LibMeta.msgSender() == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    function addDiamondFunctions(\\n        address _diamondCutFacet,\\n        address _diamondLoupeFacet,\\n        address _ownershipFacet\\n    ) internal {\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors});\\n        functionSelectors = new bytes4[](5);\\n        functionSelectors[0] = IDiamondLoupe.facets.selector;\\n        functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\\n        functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\\n        functionSelectors[4] = IERC165.supportsInterface.selector;\\n        cut[1] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondLoupeFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        functionSelectors = new bytes4[](2);\\n        functionSelectors[0] = IERC173.transferOwnership.selector;\\n        functionSelectors[1] = IERC173.owner.selector;\\n        cut[2] = IDiamondCut.FacetCut({facetAddress: _ownershipFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors});\\n        diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet cant be address(0)\\\");\\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\\n            ds.facetAddresses.push(_facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Cant add function that already exists\\\");\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet cant be address(0)\\\");\\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\\n            ds.facetAddresses.push(_facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Cant replace function with same function\\\");\\n            removeFunction(oldFacetAddress, selector);\\n            // add function\\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Cant remove function that doesnt exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Cant remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (success == false) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize != 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/farm/facets/DiamondCutFacet.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT\\n*/\\n\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {IDiamondCut} from \\\"../../interfaces/IDiamondCut.sol\\\";\\nimport {LibDiamond} from \\\"../../libraries/LibDiamond.sol\\\";\\n\\ncontract DiamondCutFacet is IDiamondCut {\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/farm/facets/DiamondLoupeFacet.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT\\n*/\\n\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {LibDiamond} from \\\"../../libraries/LibDiamond.sol\\\";\\nimport {IDiamondLoupe} from \\\"../../interfaces/IDiamondLoupe.sol\\\";\\nimport {IERC165} from \\\"../../interfaces/IERC165.sol\\\";\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n    // Diamond Loupe Functions\\n    ////////////////////////////////////////////////////////////////////\\n    /// These functions are expected to be called frequently by tools.\\n    //\\n    // struct Facet {\\n    //     address facetAddress;\\n    //     bytes4[] functionSelectors;\\n    // }\\n\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external view override returns (Facet[] memory facets_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 numFacets = ds.facetAddresses.length;\\n        facets_ = new Facet[](numFacets);\\n        for (uint256 i; i < numFacets; i++) {\\n            address facetAddress_ = ds.facetAddresses[i];\\n            facets_[i].facetAddress = facetAddress_;\\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors provided by a facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        override\\n        returns (bytes4[] memory facetFunctionSelectors_)\\n    {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetAddresses_ = ds.facetAddresses;\\n    }\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        override\\n        returns (address facetAddress_)\\n        {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\\n    }\\n\\n    // This implements ERC-165.\\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        return ds.supportedInterfaces[_interfaceId];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/farm/facets/OwnershipFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC173} from \\\"../../interfaces/IERC173.sol\\\";\\nimport {LibDiamond} from \\\"../../libraries/LibDiamond.sol\\\";\\n\\ncontract OwnershipFacet is IERC173 {\\n    function transferOwnership(address _newOwner) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.setContractOwner(_newOwner);\\n    }\\n\\n    function owner() external view override returns (address owner_) {\\n        owner_ = LibDiamond.contractOwner();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/farm/AppStorage.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @author Publius\\n * @title App Storage defines the state object for Beanstalk.\\n**/\\ncontract Account {\\n\\n    struct Field {\\n        mapping(uint256 => uint256) plots;\\n        mapping(address => uint256) podAllowances;\\n    }\\n\\n    struct AssetSilo {\\n        mapping(uint32 => uint256) withdrawals;\\n        mapping(uint32 => uint256) deposits;\\n        mapping(uint32 => uint256) depositSeeds;\\n    }\\n\\n    struct Silo {\\n        uint256 stalk;\\n        uint256 seeds;\\n    }\\n\\n    struct SeasonOfPlenty {\\n        uint256 base;\\n        uint256 roots;\\n        uint256 basePerRoot;\\n    }\\n\\n    struct State {\\n        Field field;\\n        AssetSilo bean;\\n        AssetSilo lp;\\n        Silo s;\\n        uint32 lockedUntil;\\n        uint32 lastUpdate;\\n        uint32 lastSop;\\n        uint32 lastRain;\\n        SeasonOfPlenty sop;\\n        uint256 roots;\\n    }\\n}\\n\\ncontract Storage {\\n    struct Contracts {\\n        address bean;\\n        address pair;\\n        address pegPair;\\n        address weth;\\n    }\\n\\n    // Field\\n\\n    struct Field {\\n        uint256 soil;\\n        uint256 pods;\\n        uint256 harvested;\\n        uint256 harvestable;\\n    }\\n\\n    // Governance\\n\\n    struct Bip {\\n        address proposer;\\n        uint32 start;\\n        uint32 period;\\n        bool executed;\\n        int pauseOrUnpause;\\n        uint128 timestamp;\\n        uint256 roots;\\n        uint256 endTotalRoots;\\n    }\\n\\n    struct DiamondCut {\\n        IDiamondCut.FacetCut[] diamondCut;\\n        address initAddress;\\n        bytes initData;\\n    }\\n\\n    struct Governance {\\n        uint32[] activeBips;\\n        uint32 bipIndex;\\n        mapping(uint32 => DiamondCut) diamondCuts;\\n        mapping(uint32 => mapping(address => bool)) voted;\\n        mapping(uint32 => Bip) bips;\\n    }\\n\\n    // Silo\\n\\n    struct AssetSilo {\\n        uint256 deposited;\\n        uint256 withdrawn;\\n    }\\n\\n    struct IncreaseSilo {\\n        uint256 beans;\\n        uint256 stalk;\\n    }\\n\\n    struct SeasonOfPlenty {\\n        uint256 weth;\\n        uint256 base;\\n        uint32 last;\\n    }\\n\\n    struct Silo {\\n        uint256 stalk;\\n        uint256 seeds;\\n        uint256 roots;\\n    }\\n\\n    // Season\\n\\n    struct Oracle {\\n        bool initialized;\\n        uint256 cumulative;\\n        uint256 pegCumulative;\\n        uint32 timestamp;\\n        uint32 pegTimestamp;\\n    }\\n\\n    struct Rain {\\n        uint32 start;\\n        bool raining;\\n        uint256 pods;\\n        uint256 roots;\\n    }\\n\\n    struct Season {\\n        uint32 current;\\n        uint256 start;\\n        uint256 period;\\n        uint256 timestamp;\\n    }\\n\\n    struct Weather {\\n        uint256 startSoil;\\n        uint256 lastDSoil;\\n        uint96 lastSoilPercent;\\n        uint32 lastSowTime;\\n        uint32 nextSowTime;\\n        uint32 yield;\\n        bool didSowBelowMin;\\n        bool didSowFaster;\\n    }\\n}\\n\\nstruct AppStorage {\\n    uint8 index;\\n    int8[32] cases;\\n    bool paused;\\n    uint128 pausedAt;\\n    Storage.Season season;\\n    Storage.Contracts c;\\n    Storage.Field f;\\n    Storage.Governance g;\\n    Storage.Oracle o;\\n    Storage.Rain r;\\n    Storage.Silo s;\\n    uint256 depreciated1;\\n    Storage.Weather w;\\n    Storage.AssetSilo bean;\\n    Storage.AssetSilo lp;\\n    Storage.IncreaseSilo si;\\n    Storage.SeasonOfPlenty sop;\\n    uint256 depreciated2;\\n    uint256 depreciated3;\\n    uint256 depreciated4;\\n    uint256 depreciated5;\\n    uint256 depreciated6;\\n    mapping (uint32 => uint256) sops;\\n    mapping (address => Account.State) a;\\n    uint32 bip0Start;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibMeta.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT\\n*/\\n\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.6;\\n\\nlibrary LibMeta {\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\\\"));\\n\\n    function domainSeparator(string memory name, string memory version) internal view returns (bytes32 domainSeparator_) {\\n        domainSeparator_ = keccak256(\\n            abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), getChainID(), address(this))\\n        );\\n    }\\n\\n    function getChainID() internal pure returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function msgSender() internal view returns (address sender_) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender_ = msg.sender;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x88093840aad42d2621e1a452bf5d7076ff804d61", "attacktype": "Token standard incompatibility", "sourcecode": "// File: openzeppelin-eth/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: zos-lib/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n  address private _owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function initialize(address sender) public initializer {\r\n    _owner = sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(_owner);\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is Initializable, IERC20 {\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  function initialize(string name, string symbol, uint8 decimals) public initializer {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  /**\r\n   * @return the name of the token.\r\n   */\r\n  function name() public view returns(string) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @return the symbol of the token.\r\n   */\r\n  function symbol() public view returns(string) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @return the number of decimals of the token.\r\n   */\r\n  function decimals() public view returns(uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: uFragments/contracts/lib/SafeMathInt.sol\r\n\r\n/*\r\nMIT License\r\n\r\nCopyright (c) 2018 requestnetwork\r\nCopyright (c) 2018 Fragments, Inc.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMathInt\r\n * @dev Math operations for int256 with overflow safety checks.\r\n */\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    /**\r\n     * @dev Multiplies two int256 variables and fails on overflow.\r\n     */\r\n    function mul(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Division of two int256 variables and fails on overflow.\r\n     */\r\n    function div(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two int256 variables and fails on overflow.\r\n     */\r\n    function sub(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two int256 variables and fails on overflow.\r\n     */\r\n    function add(int256 a, int256 b)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts to absolute value, and fails on overflow.\r\n     */\r\n    function abs(int256 a)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n}\r\n\r\n// File: uFragments/contracts/UFragments.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title uFragments ERC20 token\r\n * @dev This is part of an implementation of the uFragments Ideal Money protocol.\r\n *      uFragments is a normal ERC20 token, but its supply can be adjusted by splitting and\r\n *      combining tokens proportionally across all wallets.\r\n *\r\n *      uFragment balances are internally represented with a hidden denomination, 'gons'.\r\n *      We support splitting the currency in expansion and combining the currency on contraction by\r\n *      changing the exchange rate between the hidden 'gons' and the public 'fragments'.\r\n */\r\ncontract UFragments is ERC20Detailed, Ownable {\r\n    // PLEASE READ BEFORE CHANGING ANY ACCOUNTING OR MATH\r\n    // Anytime there is division, there is a risk of numerical instability from rounding errors. In\r\n    // order to minimize this risk, we adhere to the following guidelines:\r\n    // 1) The conversion rate adopted is the number of gons that equals 1 fragment.\r\n    //    The inverse rate must not be used--TOTAL_GONS is always the numerator and _totalSupply is\r\n    //    always the denominator. (i.e. If you want to convert gons to fragments instead of\r\n    //    multiplying by the inverse rate, you should divide by the normal rate)\r\n    // 2) Gon balances converted into Fragments are always rounded down (truncated).\r\n    //\r\n    // We make the following guarantees:\r\n    // - If address 'A' transfers x Fragments to address 'B'. A's resulting external balance will\r\n    //   be decreased by precisely x Fragments, and B's external balance will be precisely\r\n    //   increased by x Fragments.\r\n    //\r\n    // We do not guarantee that the sum of all balances equals the result of calling totalSupply().\r\n    // This is because, for any conversion function 'f()' that has non-zero rounding error,\r\n    // f(x0) + f(x1) + ... + f(xn) is not always equal to f(x0 + x1 + ... xn).\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\r\n    event LogMonetaryPolicyUpdated(address monetaryPolicy);\r\n\r\n    // Used for authentication\r\n    address public monetaryPolicy;\r\n\r\n    modifier onlyMonetaryPolicy() {\r\n        require(msg.sender == monetaryPolicy);\r\n        _;\r\n    }\r\n\r\n    bool private rebasePausedDeprecated;\r\n    bool private tokenPausedDeprecated;\r\n\r\n    modifier validRecipient(address to) {\r\n        require(to != address(0x0));\r\n        require(to != address(this));\r\n        _;\r\n    }\r\n\r\n    uint256 private constant DECIMALS = 9;\r\n    uint256 private constant MAX_UINT256 = ~uint256(0);\r\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 6 * (10**4) * (10**DECIMALS);\r\n\r\n    // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\r\n    // Use the highest value that fits in a uint256 for max granularity.\r\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\r\n\r\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\r\n    uint256 private constant MAX_SUPPLY = ~uint128(0);  // (2^128) - 1\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 private _gonsPerFragment;\r\n    mapping(address => uint256) private _gonBalances;\r\n\r\n    // This is denominated in Fragments, because the gons-fragments conversion might change before\r\n    // it's fully paid.\r\n    mapping (address => mapping (address => uint256)) private _allowedFragments;\r\n\r\n    /**\r\n     * @param monetaryPolicy_ The address of the monetary policy contract to use for authentication.\r\n     */\r\n    function setMonetaryPolicy(address monetaryPolicy_)\r\n        external\r\n        onlyOwner\r\n    {\r\n        monetaryPolicy = monetaryPolicy_;\r\n        emit LogMonetaryPolicyUpdated(monetaryPolicy_);\r\n    }\r\n\r\n    /**\r\n     * @dev Notifies Fragments contract about a new rebase cycle.\r\n     * @param supplyDelta The number of new fragment tokens to add into circulation via expansion.\r\n     * @return The total number of fragments after the supply adjustment.\r\n     */\r\n    function rebase(uint256 epoch, int256 supplyDelta)\r\n        external\r\n        onlyMonetaryPolicy\r\n        returns (uint256)\r\n    {\r\n        if (supplyDelta == 0) {\r\n            emit LogRebase(epoch, _totalSupply);\r\n            return _totalSupply;\r\n        }\r\n\r\n        if (supplyDelta < 0) {\r\n            _totalSupply = _totalSupply.sub(uint256(supplyDelta.abs()));\r\n        } else {\r\n            _totalSupply = _totalSupply.add(uint256(supplyDelta));\r\n        }\r\n\r\n        if (_totalSupply > MAX_SUPPLY) {\r\n            _totalSupply = MAX_SUPPLY;\r\n        }\r\n\r\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\r\n\r\n        // From this point forward, _gonsPerFragment is taken as the source of truth.\r\n        // We recalculate a new _totalSupply to be in agreement with the _gonsPerFragment\r\n        // conversion rate.\r\n        // This means our applied supplyDelta can deviate from the requested supplyDelta,\r\n        // but this deviation is guaranteed to be < (_totalSupply^2)/(TOTAL_GONS - _totalSupply).\r\n        //\r\n        // In the case of _totalSupply <= MAX_UINT128 (our current supply cap), this\r\n        // deviation is guaranteed to be < 1, so we can omit this step. If the supply cap is\r\n        // ever increased, it must be re-included.\r\n        // _totalSupply = TOTAL_GONS.div(_gonsPerFragment)\r\n\r\n        emit LogRebase(epoch, _totalSupply);\r\n        return _totalSupply;\r\n    }\r\n\r\n    function initialize(address owner_)\r\n        public\r\n        initializer\r\n    {\r\n        ERC20Detailed.initialize(\"Soft Yearn Finance\", \"SYFI\", uint8(DECIMALS));\r\n        Ownable.initialize(owner_);\r\n\r\n        tokenPausedDeprecated = false;\r\n\r\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\r\n        _gonBalances[owner_] = TOTAL_GONS;\r\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\r\n\r\n        emit Transfer(address(0x0), owner_, _totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @return The total number of fragments.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @param who The address to query.\r\n     * @return The balance of the specified address.\r\n     */\r\n    function balanceOf(address who)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _gonBalances[who].div(_gonsPerFragment);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified address.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     * @return True on success, false otherwise.\r\n     */\r\n    function transfer(address to, uint256 value)\r\n        public\r\n        validRecipient(to)\r\n        returns (bool)\r\n    {\r\n        uint256 gonValue = value.mul(_gonsPerFragment);\r\n        _gonBalances[msg.sender] = _gonBalances[msg.sender].sub(gonValue);\r\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\r\n     * @param owner_ The address which owns the funds.\r\n     * @param spender The address which will spend the funds.\r\n     * @return The number of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner_, address spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowedFragments[owner_][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * @param from The address you want to send tokens from.\r\n     * @param to The address you want to transfer to.\r\n     * @param value The amount of tokens to be transferred.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public\r\n        validRecipient(to)\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\r\n\r\n        uint256 gonValue = value.mul(_gonsPerFragment);\r\n        _gonBalances[from] = _gonBalances[from].sub(gonValue);\r\n        _gonBalances[to] = _gonBalances[to].add(gonValue);\r\n        emit Transfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\r\n     * msg.sender. This method is included for ERC20 compatibility.\r\n     * increaseAllowance and decreaseAllowance should be used instead.\r\n     * Changing an allowance with this method brings the risk that someone may transfer both\r\n     * the old and the new allowance - if they are both greater than zero - if a transfer\r\n     * transaction is mined before the later approve() call is mined.\r\n     *\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\r\n     * This method should be used instead of approve() to avoid the double approval vulnerability\r\n     * described above.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] =\r\n            _allowedFragments[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\r\n     *\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowedFragments[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\r\n        return true;\r\n    }\r\n}"}
{"address": "0x3ec4a6cfe803ee84009ce6e1ecf419c9cb1e8af0", "attacktype": "On-chain oracle manipulation", "sourcecode": "/**\r\n *Submitted for verification at Etherscan.io on 2021-01-05\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Context {\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface Controller {\r\n    function withdraw(address, uint) external;\r\n    function balanceOf(address) external view returns (uint);\r\n    function earn(address, uint) external;\r\n}\r\n\r\ncontract bVault is ERC20, ERC20Detailed {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    IERC20 public token;\r\n\r\n    uint public depositWithdrawInterval = 60;\r\n\r\n    uint public min = 9500;\r\n    uint public constant max = 10000;\r\n    uint public earnLowerlimit;\r\n    \r\n    mapping(address => uint256) userDepoistTime;\r\n    address public feeAddress;\r\n    \r\n    uint public fee1 = 5;       //fee within 24 hours\r\n    uint public fee2 = 3;       //fee within 1 week\r\n    uint public fee3 = 1;       //fee without 1 week\r\n    uint public feeMax = 1000;\r\n    \r\n    address public governance;\r\n    address public controller;\r\n\taddress public timelock;\r\n\t\r\n\tbool public RestrictContractCall = true;\r\n\r\n     modifier onlyRestrictContractCall() {\r\n         address s = msg.sender;\r\n        require(!RestrictContractCall || !s.isContract(), \"Contract cannot call\");\r\n        _;\r\n    }\r\n    \r\n    constructor (address _token,uint _earnLowerlimit) public ERC20Detailed(\r\n        string(abi.encodePacked(\"bt:vault: \", ERC20Detailed(_token).name())),\r\n        string(abi.encodePacked(\"b\", ERC20Detailed(_token).symbol())),\r\n        ERC20Detailed(_token).decimals()\r\n    ) {\r\n        token = IERC20(_token);\r\n        governance = tx.origin;\r\n        controller = 0x03D2079c54967f463Fd6e89E76012F74EBC62615;\r\n        earnLowerlimit = _earnLowerlimit;\r\n        feeAddress = tx.origin;\r\n\t\ttimelock = tx.origin;\r\n    }\r\n    \r\n    function balance() public view returns (uint) {\r\n        return token.balanceOf(address(this))\r\n                .add(Controller(controller).balanceOf(address(token)));\r\n    }\r\n    \r\n    function setMin(uint _min) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        min = _min;\r\n    }\r\n    \r\n    function setGovernance(address _governance) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        governance = _governance;\r\n    }\r\n    \r\n    function setController(address _controller) public {\r\n        require(msg.sender == timelock, \"!timelock\");\r\n        controller = _controller;\r\n    }\r\n    function setEarnLowerlimit(uint256 _earnLowerlimit) public{\r\n      require(msg.sender == governance, \"!governance\");\r\n      earnLowerlimit = _earnLowerlimit;\r\n  }\r\n    \r\n    // Custom logic in here for how much the vault allows to be borrowed\r\n    // Sets minimum required on-hand to keep small withdrawals cheap\r\n    function available() public view returns (uint) {\r\n        return token.balanceOf(address(this)).mul(min).div(max);\r\n    }\r\n    \r\n    function earn() public {\r\n        uint _bal = available();\r\n        token.safeTransfer(controller, _bal);\r\n        Controller(controller).earn(address(token), _bal);\r\n    }\r\n    \r\n    function depositAll() external {\r\n        deposit(token.balanceOf(msg.sender));\r\n    }\r\n    \r\n    function deposit(uint _amount) public onlyRestrictContractCall {\r\n\t\trequire(_amount > 0, \"Cannot deposit 0\");\r\n        uint _pool = balance();\r\n        uint _before = token.balanceOf(address(this));\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint _after = token.balanceOf(address(this));\r\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\r\n        uint shares = 0;\r\n        if (totalSupply() == 0) {\r\n            shares = _amount;\r\n        } else {\r\n            shares = (_amount.mul(totalSupply())).div(_pool);\r\n        }\r\n        _mint(msg.sender, shares);\r\n        userDepoistTime[msg.sender] = now;\r\n        if (token.balanceOf(address(this))>earnLowerlimit){\r\n          earn();\r\n        }\r\n    }\r\n    \r\n    function withdrawAll() external {\r\n        withdraw(balanceOf(msg.sender));\r\n    }\r\n    \r\n    \r\n    \r\n    // No rebalance implementation for lower fees and faster swaps\r\n    function withdraw(uint _shares) public onlyRestrictContractCall {\r\n\t\trequire(_shares > 0, \"Cannot withdraw 0\");\r\n        require((now - userDepoistTime[msg.sender])>depositWithdrawInterval,\"Deposit and withdraw must be 60 seconds apart!\");\r\n\r\n        uint r = (balance().mul(_shares)).div(totalSupply());\r\n        _burn(msg.sender, _shares);\r\n        \r\n        // Check balance\r\n        uint b = token.balanceOf(address(this));\r\n        if (b < r) {\r\n            uint _withdraw = r.sub(b);\r\n            Controller(controller).withdraw(address(token), _withdraw);\r\n            uint _after = token.balanceOf(address(this));\r\n            uint _diff = _after.sub(b);\r\n            if (_diff < _withdraw) {\r\n                r = b.add(_diff);\r\n            }\r\n        }\r\n        uint feeRatio = getFeeRatio();\r\n        if(feeRatio>0){\r\n            uint fee = r.mul(feeRatio).div(feeMax);\r\n            r = r.sub(fee);\r\n            token.safeTransfer(feeAddress,fee);\r\n        }\r\n        token.safeTransfer(msg.sender, r);\r\n    }\r\n    \r\n    function getFeeRatio() internal view returns(uint)\r\n    {\r\n        uint256 t = now - userDepoistTime[msg.sender];\r\n        if(t > 604800) {//7*24*60*60\r\n            return fee3;\r\n        }\r\n        if(t>86400) {//24*60*60\r\n            return fee2;\r\n        }\r\n        return fee1;\r\n    }\r\n    \r\n    function getPricePerFullShare() public view returns (uint) {\r\n        if (totalSupply()==0) {\r\n            return 0;\r\n        }\r\n        return balance().mul(1e18).div(totalSupply());\r\n    }\r\n\r\n    function setFeeRatio(uint[3] memory fees) public\r\n    {\r\n        require(msg.sender == timelock, \"!timelock\");\r\n        require(fees[0]<feeMax&&fees[1]<feeMax&&fees[2]<feeMax,\"The fee is too high\");\r\n        fee1 = fees[0];\r\n        fee2 = fees[1];\r\n        fee3 = fees[2];\r\n    }\r\n    \r\n    function setFeeAddress(address fadd) public \r\n    {\r\n        require(msg.sender == timelock, \"!timelock\");\r\n        feeAddress = fadd;\r\n    }\r\n\t\r\n\tfunction setTimeLock(address _timelock) public \r\n    {\r\n        require(msg.sender == timelock, \"!timelock\");\r\n        timelock = _timelock;\r\n    }\r\n    \r\n    function setRestrictContractCall(bool enabled) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        RestrictContractCall = enabled;\r\n    }\r\n}"}
{"address": "0x33bf0bb8e1405dc440eccb97ffd92fef438c8a27", "attacktype": "Other fake contracts, Deployment mistake, Arithmetic mistakes", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/SafeBox.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/ERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/cryptography/MerkleProof.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\\nimport './Governable.sol';\\nimport '../interfaces/ICErc20.sol';\\n\\ncontract SafeBox is Governable, ERC20, ReentrancyGuard {\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n  event Claim(address user, uint amount);\\n\\n  ICErc20 public immutable cToken;\\n  IERC20 public immutable uToken;\\n\\n  address public relayer;\\n  bytes32 public root;\\n  mapping(address => uint) public claimed;\\n\\n  constructor(\\n    ICErc20 _cToken,\\n    string memory _name,\\n    string memory _symbol\\n  ) public ERC20(_name, _symbol) {\\n    _setupDecimals(_cToken.decimals());\\n    IERC20 _uToken = IERC20(_cToken.underlying());\\n    __Governable__init();\\n    cToken = _cToken;\\n    uToken = _uToken;\\n    relayer = msg.sender;\\n    _uToken.safeApprove(address(_cToken), uint(-1));\\n  }\\n\\n  function setRelayer(address _relayer) external onlyGov {\\n    relayer = _relayer;\\n  }\\n\\n  function updateRoot(bytes32 _root) external {\\n    require(msg.sender == relayer || msg.sender == governor, '!relayer');\\n    root = _root;\\n  }\\n\\n  function deposit(uint amount) external nonReentrant {\\n    uint uBalanceBefore = uToken.balanceOf(address(this));\\n    uToken.safeTransferFrom(msg.sender, address(this), amount);\\n    uint uBalanceAfter = uToken.balanceOf(address(this));\\n    uint cBalanceBefore = cToken.balanceOf(address(this));\\n    require(cToken.mint(uBalanceAfter.sub(uBalanceBefore)) == 0, '!mint');\\n    uint cBalanceAfter = cToken.balanceOf(address(this));\\n    _mint(msg.sender, cBalanceAfter.sub(cBalanceBefore));\\n  }\\n\\n  function withdraw(uint amount) public nonReentrant {\\n    _burn(msg.sender, amount);\\n    uint uBalanceBefore = uToken.balanceOf(address(this));\\n    require(cToken.redeem(amount) == 0, '!redeem');\\n    uint uBalanceAfter = uToken.balanceOf(address(this));\\n    uToken.safeTransfer(msg.sender, uBalanceAfter.sub(uBalanceBefore));\\n  }\\n\\n  function claim(uint totalReward, bytes32[] memory proof) public nonReentrant {\\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, totalReward));\\n    require(MerkleProof.verify(proof, root, leaf), '!proof');\\n    uint send = totalReward.sub(claimed[msg.sender]);\\n    claimed[msg.sender] = totalReward;\\n    uToken.safeTransfer(msg.sender, send);\\n    emit Claim(msg.sender, send);\\n  }\\n\\n  function adminClaim(uint amount) external onlyGov {\\n    uToken.safeTransfer(msg.sender, amount);\\n  }\\n\\n  function claimAndWithdraw(\\n    uint claimAmount,\\n    bytes32[] memory proof,\\n    uint withdrawAmount\\n  ) external {\\n    claim(claimAmount, proof);\\n    withdraw(withdrawAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/Governable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/proxy/Initializable.sol';\\n\\ncontract Governable is Initializable {\\n  address public governor; // The current governor.\\n  address public pendingGovernor; // The address pending to become the governor once accepted.\\n\\n  modifier onlyGov() {\\n    require(msg.sender == governor, 'not the governor');\\n    _;\\n  }\\n\\n  /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\\n  function __Governable__init() internal initializer {\\n    governor = msg.sender;\\n    pendingGovernor = address(0);\\n  }\\n\\n  /// @dev Set the pending governor, which will be the governor once accepted.\\n  /// @param _pendingGovernor The address to become the pending governor.\\n  function setPendingGovernor(address _pendingGovernor) external onlyGov {\\n    pendingGovernor = _pendingGovernor;\\n  }\\n\\n  /// @dev Accept to become the new governor. Must be called by the pending governor.\\n  function acceptGovernor() external {\\n    require(msg.sender == pendingGovernor, 'not the pending governor');\\n    pendingGovernor = address(0);\\n    governor = msg.sender;\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/ICErc20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface ICErc20 {\\n  function decimals() external returns (uint8);\\n\\n  function underlying() external returns (address);\\n\\n  function mint(uint mintAmount) external returns (uint);\\n\\n  function redeem(uint redeemTokens) external returns (uint);\\n\\n  function balanceOf(address user) external view returns (uint);\\n\\n  function borrowBalanceCurrent(address account) external returns (uint);\\n\\n  function borrowBalanceStored(address account) external view returns (uint);\\n\\n  function borrow(uint borrowAmount) external returns (uint);\\n\\n  function repayBorrow(uint repayAmount) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"./contracts/wrapper/WERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '../../interfaces/IWERC20.sol';\\n\\ncontract WERC20 is ERC1155('WERC20'), ReentrancyGuard, IWERC20 {\\n  using SafeERC20 for IERC20;\\n\\n  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\\n  function getUnderlyingToken(uint id) external view override returns (address) {\\n    address token = address(id);\\n    require(uint(token) == id, 'id overflow');\\n    return token;\\n  }\\n\\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\\n  function getUnderlyingRate(uint) external view override returns (uint) {\\n    return 2**112;\\n  }\\n\\n  /// @dev Return the underlying ERC20 balance for the user.\\n  function balanceOfERC20(address token, address user) external view override returns (uint) {\\n    return balanceOf(user, uint(token));\\n  }\\n\\n  /// @dev Mint ERC1155 token for the given ERC20 token.\\n  function mint(address token, uint amount) external override nonReentrant {\\n    uint balanceBefore = IERC20(token).balanceOf(address(this));\\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n    uint balanceAfter = IERC20(token).balanceOf(address(this));\\n    _mint(msg.sender, uint(token), balanceAfter.sub(balanceBefore), '');\\n  }\\n\\n  /// @dev Burn ERC1155 token to redeem ERC20 token back.\\n  function burn(address token, uint amount) external override nonReentrant {\\n    _burn(msg.sender, uint(token), amount);\\n    IERC20(token).safeTransfer(msg.sender, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IWERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155.sol';\\n\\nimport './IERC20Wrapper.sol';\\n\\ninterface IWERC20 is IERC1155, IERC20Wrapper {\\n  /// @dev Return the underlying ERC20 balance for the user.\\n  function balanceOfERC20(address token, address user) external view returns (uint);\\n\\n  /// @dev Mint ERC1155 token for the given ERC20 token.\\n  function mint(address token, uint amount) external;\\n\\n  /// @dev Burn ERC1155 token to redeem ERC20 token back.\\n  function burn(address token, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"./interfaces/IERC20Wrapper.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IERC20Wrapper {\\n  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\\n  function getUnderlyingToken(uint id) external view returns (address);\\n\\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\\n  function getUnderlyingRate(uint id) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"./contracts/wrapper/WStakingRewards.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/IERC20Wrapper.sol';\\nimport '../../interfaces/IStakingRewards.sol';\\n\\ncontract WStakingRewards is ERC1155('WStakingRewards'), ReentrancyGuard, IERC20Wrapper {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  address public immutable staking;\\n  address public immutable underlying;\\n  address public immutable reward;\\n\\n  constructor(\\n    address _staking,\\n    address _underlying,\\n    address _reward\\n  ) public {\\n    staking = _staking;\\n    underlying = _underlying;\\n    reward = _reward;\\n    IERC20(_underlying).approve(_staking, uint(-1));\\n  }\\n\\n  function getUnderlyingToken(uint) external view override returns (address) {\\n    return underlying;\\n  }\\n\\n  function getUnderlyingRate(uint) external view override returns (uint) {\\n    return 2**112;\\n  }\\n\\n  function mint(uint amount) external nonReentrant returns (uint) {\\n    IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\\n    IStakingRewards(staking).stake(amount);\\n    uint rewardPerToken = IStakingRewards(staking).rewardPerToken();\\n    _mint(msg.sender, rewardPerToken, amount, '');\\n    return rewardPerToken;\\n  }\\n\\n  function burn(uint id, uint amount) external nonReentrant returns (uint) {\\n    if (amount == uint(-1)) {\\n      amount = balanceOf(msg.sender, id);\\n    }\\n    _burn(msg.sender, id, amount);\\n    IStakingRewards(staking).withdraw(amount);\\n    IStakingRewards(staking).getReward();\\n    IERC20(underlying).safeTransfer(msg.sender, amount);\\n    uint stRewardPerToken = id;\\n    uint enRewardPerToken = IStakingRewards(staking).rewardPerToken();\\n    uint stReward = stRewardPerToken.mul(amount).divCeil(1e18);\\n    uint enReward = enRewardPerToken.mul(amount).div(1e18);\\n    if (enReward > stReward) {\\n      IERC20(reward).safeTransfer(msg.sender, enReward.sub(stReward));\\n    }\\n    return enRewardPerToken;\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/HomoraMath.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nlibrary HomoraMath {\\n  using SafeMath for uint;\\n\\n  function divCeil(uint lhs, uint rhs) internal pure returns (uint) {\\n    return lhs.add(rhs).sub(1) / rhs;\\n  }\\n\\n  function fmul(uint lhs, uint rhs) internal pure returns (uint) {\\n    return lhs.mul(rhs) / (2**112);\\n  }\\n\\n  function fdiv(uint lhs, uint rhs) internal pure returns (uint) {\\n    return lhs.mul(2**112) / rhs;\\n  }\\n\\n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\n  function sqrt(uint x) internal pure returns (uint) {\\n    if (x == 0) return 0;\\n    uint xx = x;\\n    uint r = 1;\\n\\n    if (xx >= 0x100000000000000000000000000000000) {\\n      xx >>= 128;\\n      r <<= 64;\\n    }\\n\\n    if (xx >= 0x10000000000000000) {\\n      xx >>= 64;\\n      r <<= 32;\\n    }\\n    if (xx >= 0x100000000) {\\n      xx >>= 32;\\n      r <<= 16;\\n    }\\n    if (xx >= 0x10000) {\\n      xx >>= 16;\\n      r <<= 8;\\n    }\\n    if (xx >= 0x100) {\\n      xx >>= 8;\\n      r <<= 4;\\n    }\\n    if (xx >= 0x10) {\\n      xx >>= 4;\\n      r <<= 2;\\n    }\\n    if (xx >= 0x8) {\\n      r <<= 1;\\n    }\\n\\n    r = (r + x / r) >> 1;\\n    r = (r + x / r) >> 1;\\n    r = (r + x / r) >> 1;\\n    r = (r + x / r) >> 1;\\n    r = (r + x / r) >> 1;\\n    r = (r + x / r) >> 1;\\n    r = (r + x / r) >> 1; // Seven iterations should be enough\\n    uint r1 = x / r;\\n    return (r < r1 ? r : r1);\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IStakingRewards.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IStakingRewards {\\n  function rewardPerToken() external view returns (uint);\\n\\n  function stake(uint amount) external;\\n\\n  function withdraw(uint amount) external;\\n\\n  function getReward() external;\\n}\\n\"\r\n    },\r\n    \"./contracts/wrapper/WLiquidityGauge.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '../Governable.sol';\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/IERC20Wrapper.sol';\\nimport '../../interfaces/ICurveRegistry.sol';\\nimport '../../interfaces/ILiquidityGauge.sol';\\n\\ninterface ILiquidityGaugeMinter {\\n  function mint(address gauge) external;\\n}\\n\\ncontract WLiquidityGauge is ERC1155('WLiquidityGauge'), ReentrancyGuard, IERC20Wrapper, Governable {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  struct GaugeInfo {\\n    ILiquidityGauge impl;\\n    uint accCrvPerShare;\\n  }\\n\\n  ICurveRegistry public immutable registry;\\n  IERC20 public immutable crv;\\n  mapping(uint => mapping(uint => GaugeInfo)) public gauges;\\n\\n  constructor(ICurveRegistry _registry, IERC20 _crv) public {\\n    __Governable__init();\\n    registry = _registry;\\n    crv = _crv;\\n  }\\n\\n  function encodeId(\\n    uint pid,\\n    uint gid,\\n    uint crvPerShare\\n  ) public pure returns (uint id) {\\n    require(pid < (1 << 8), 'bad pid');\\n    require(gid < (1 << 8), 'bad gid');\\n    require(crvPerShare < (1 << 240), 'bad crv per share');\\n    return (pid << 248) | (gid << 240) | crvPerShare;\\n  }\\n\\n  function decodeId(uint id)\\n    public\\n    pure\\n    returns (\\n      uint pid,\\n      uint gid,\\n      uint crvPerShare\\n    )\\n  {\\n    pid = id >> 248; // First 8 bits\\n    gid = (id >> 240) & (255); // Next 8 bits\\n    crvPerShare = id & ((1 << 240) - 1); // Last 240 bits\\n  }\\n\\n  function getUnderlyingToken(uint id) external view override returns (address) {\\n    (uint pid, uint gid, ) = decodeId(id);\\n    ILiquidityGauge impl = gauges[pid][gid].impl;\\n    require(address(impl) != address(0), 'no gauge');\\n    return impl.lp_token();\\n  }\\n\\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\\n  function getUnderlyingRate(uint) external view override returns (uint) {\\n    return 2**112;\\n  }\\n\\n  function registerGauge(uint pid, uint gid) external onlyGov {\\n    require(address(gauges[pid][gid].impl) == address(0), 'gauge already exists');\\n    address pool = registry.pool_list(pid);\\n    require(pool != address(0), 'no pool');\\n    (address[10] memory _gauges, ) = registry.get_gauges(pool);\\n    address gauge = _gauges[gid];\\n    require(gauge != address(0), 'no gauge');\\n    IERC20 lpToken = IERC20(ILiquidityGauge(gauge).lp_token());\\n    lpToken.approve(gauge, 0);\\n    lpToken.approve(gauge, uint(-1));\\n    gauges[pid][gid] = GaugeInfo({impl: ILiquidityGauge(gauge), accCrvPerShare: 0});\\n  }\\n\\n  function mint(\\n    uint pid,\\n    uint gid,\\n    uint amount\\n  ) external nonReentrant returns (uint) {\\n    GaugeInfo storage gauge = gauges[pid][gid];\\n    ILiquidityGauge impl = gauge.impl;\\n    require(address(impl) != address(0), 'gauge not registered');\\n    mintCrv(gauge);\\n    IERC20 lpToken = IERC20(impl.lp_token());\\n    lpToken.safeTransferFrom(msg.sender, address(this), amount);\\n    impl.deposit(amount);\\n    uint id = encodeId(pid, gid, gauge.accCrvPerShare);\\n    _mint(msg.sender, id, amount, '');\\n    return id;\\n  }\\n\\n  function burn(uint id, uint amount) external nonReentrant returns (uint) {\\n    if (amount == uint(-1)) {\\n      amount = balanceOf(msg.sender, id);\\n    }\\n    (uint pid, uint gid, uint stCrvPerShare) = decodeId(id);\\n    _burn(msg.sender, id, amount);\\n    GaugeInfo storage gauge = gauges[pid][gid];\\n    ILiquidityGauge impl = gauge.impl;\\n    require(address(impl) != address(0), 'gauge not registered');\\n    mintCrv(gauge);\\n    impl.withdraw(amount);\\n    IERC20(impl.lp_token()).safeTransfer(msg.sender, amount);\\n    uint stCrv = stCrvPerShare.mul(amount).divCeil(1e18);\\n    uint enCrv = gauge.accCrvPerShare.mul(amount).div(1e18);\\n    if (enCrv > stCrv) {\\n      crv.safeTransfer(msg.sender, enCrv.sub(stCrv));\\n    }\\n    return pid;\\n  }\\n\\n  function mintCrv(GaugeInfo storage gauge) internal {\\n    ILiquidityGauge impl = gauge.impl;\\n    uint balanceBefore = crv.balanceOf(address(this));\\n    ILiquidityGaugeMinter(impl.minter()).mint(address(impl));\\n    uint balanceAfter = crv.balanceOf(address(this));\\n    uint gain = balanceAfter.sub(balanceBefore);\\n    uint supply = impl.balanceOf(address(this));\\n    if (gain > 0 && supply > 0) {\\n      gauge.accCrvPerShare = gauge.accCrvPerShare.add(gain.mul(1e18).div(supply));\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/ICurveRegistry.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface ICurveRegistry {\\n  function get_n_coins(address lp) external view returns (uint);\\n\\n  function pool_list(uint id) external view returns (address);\\n\\n  function get_coins(address pool) external view returns (address[8] memory);\\n\\n  function get_gauges(address pool) external view returns (address[10] memory, uint128[10] memory);\\n\\n  function get_lp_token(address pool) external view returns (address);\\n\\n  function get_pool_from_lp_token(address lp) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"./interfaces/ILiquidityGauge.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface ILiquidityGauge {\\n  function minter() external view returns (address);\\n\\n  function crv_token() external view returns (address);\\n\\n  function lp_token() external view returns (address);\\n\\n  function balanceOf(address addr) external view returns (uint);\\n\\n  function deposit(uint value) external;\\n\\n  function withdraw(uint value) external;\\n}\\n\"\r\n    },\r\n    \"./contracts/wrapper/WMasterChef.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\\n\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/IERC20Wrapper.sol';\\nimport '../../interfaces/IMasterChef.sol';\\n\\ncontract WMasterChef is ERC1155('WMasterChef'), ReentrancyGuard, IERC20Wrapper {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  IMasterChef public immutable chef;\\n  IERC20 public immutable sushi;\\n\\n  constructor(IMasterChef _chef) public {\\n    chef = _chef;\\n    sushi = IERC20(_chef.sushi());\\n  }\\n\\n  function encodeId(uint pid, uint sushiPerShare) public pure returns (uint id) {\\n    require(pid < (1 << 16), 'bad pid');\\n    require(sushiPerShare < (1 << 240), 'bad sushi per share');\\n    return (pid << 240) | sushiPerShare;\\n  }\\n\\n  function decodeId(uint id) public pure returns (uint pid, uint sushiPerShare) {\\n    pid = id >> 240; // First 16 bits\\n    sushiPerShare = id & ((1 << 240) - 1); // Last 240 bits\\n  }\\n\\n  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\\n  function getUnderlyingToken(uint id) external view override returns (address) {\\n    (uint pid, ) = decodeId(id);\\n    (address lpToken, , , ) = chef.poolInfo(pid);\\n    return lpToken;\\n  }\\n\\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\\n  function getUnderlyingRate(uint) external view override returns (uint) {\\n    return 2**112;\\n  }\\n\\n  /// @dev Mint ERC1155 token for the given pool id.\\n  /// @return The token id that got minted.\\n  function mint(uint pid, uint amount) external nonReentrant returns (uint) {\\n    (address lpToken, , , ) = chef.poolInfo(pid);\\n    IERC20(lpToken).safeTransferFrom(msg.sender, address(this), amount);\\n    if (IERC20(lpToken).allowance(address(this), address(chef)) != uint(-1)) {\\n      // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\\n      IERC20(lpToken).approve(address(chef), uint(-1));\\n    }\\n    chef.deposit(pid, amount);\\n    (, , , uint sushiPerShare) = chef.poolInfo(pid);\\n    uint id = encodeId(pid, sushiPerShare);\\n    _mint(msg.sender, id, amount, '');\\n    return id;\\n  }\\n\\n  /// @dev Burn ERC1155 token to redeem LP ERC20 token back plus SUSHI rewards.\\n  /// @return The pool id that that you received LP token back.\\n  function burn(uint id, uint amount) external nonReentrant returns (uint) {\\n    if (amount == uint(-1)) {\\n      amount = balanceOf(msg.sender, id);\\n    }\\n    (uint pid, uint stSushiPerShare) = decodeId(id);\\n    _burn(msg.sender, id, amount);\\n    chef.withdraw(pid, amount);\\n    (address lpToken, , , uint enSushiPerShare) = chef.poolInfo(pid);\\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\\n    uint stSushi = stSushiPerShare.mul(amount).divCeil(1e12);\\n    uint enSushi = enSushiPerShare.mul(amount).div(1e12);\\n    if (enSushi > stSushi) {\\n      sushi.safeTransfer(msg.sender, enSushi.sub(stSushi));\\n    }\\n    return pid;\\n  }\\n\\n  /// @dev Burn ERC1155 token to redeem LP ERC20 token back without taking SUSHI rewards.\\n  /// @return The pool id that that you received LP token back.\\n  function emergencyBurn(uint id, uint amount) external nonReentrant returns (uint) {\\n    (uint pid, ) = decodeId(id);\\n    _burn(msg.sender, id, amount);\\n    chef.withdraw(pid, amount);\\n    (address lpToken, , , ) = chef.poolInfo(pid);\\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\\n    return pid;\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IMasterChef.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IMasterChef {\\n  function sushi() external view returns (address);\\n\\n  function poolInfo(uint pid)\\n    external\\n    view\\n    returns (\\n      address lpToken,\\n      uint allocPoint,\\n      uint lastRewardBlock,\\n      uint accSushiPerShare\\n    );\\n\\n  function deposit(uint pid, uint amount) external;\\n\\n  function withdraw(uint pid, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"./contracts/spell/UniswapV2SpellV1.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport './BasicSpell.sol';\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/IUniswapV2Factory.sol';\\nimport '../../interfaces/IUniswapV2Router02.sol';\\nimport '../../interfaces/IUniswapV2Pair.sol';\\nimport '../../interfaces/IWStakingRewards.sol';\\n\\ncontract UniswapV2SpellV1 is BasicSpell {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n\\n  IUniswapV2Factory public immutable factory;\\n  IUniswapV2Router02 public immutable router;\\n\\n  mapping(address => mapping(address => address)) public pairs;\\n\\n  constructor(\\n    IBank _bank,\\n    address _werc20,\\n    IUniswapV2Router02 _router\\n  ) public BasicSpell(_bank, _werc20, _router.WETH()) {\\n    router = _router;\\n    factory = IUniswapV2Factory(_router.factory());\\n  }\\n\\n  function getPair(address tokenA, address tokenB) public returns (address) {\\n    address lp = pairs[tokenA][tokenB];\\n    if (lp == address(0)) {\\n      lp = factory.getPair(tokenA, tokenB);\\n      require(lp != address(0), 'no lp token');\\n      ensureApprove(tokenA, address(router));\\n      ensureApprove(tokenB, address(router));\\n      ensureApprove(lp, address(router));\\n      pairs[tokenA][tokenB] = lp;\\n      pairs[tokenB][tokenA] = lp;\\n    }\\n    return lp;\\n  }\\n\\n  /// @dev Compute optimal deposit amount\\n  /// @param amtA amount of token A desired to deposit\\n  /// @param amtB amount of token B desired to deposit\\n  /// @param resA amount of token A in reserve\\n  /// @param resB amount of token B in reserve\\n  function optimalDeposit(\\n    uint amtA,\\n    uint amtB,\\n    uint resA,\\n    uint resB\\n  ) internal pure returns (uint swapAmt, bool isReversed) {\\n    if (amtA.mul(resB) >= amtB.mul(resA)) {\\n      swapAmt = _optimalDepositA(amtA, amtB, resA, resB);\\n      isReversed = false;\\n    } else {\\n      swapAmt = _optimalDepositA(amtB, amtA, resB, resA);\\n      isReversed = true;\\n    }\\n  }\\n\\n  /// @dev Compute optimal deposit amount helper.\\n  /// @param amtA amount of token A desired to deposit\\n  /// @param amtB amount of token B desired to deposit\\n  /// @param resA amount of token A in reserve\\n  /// @param resB amount of token B in reserve\\n  /// Formula: https://blog.alphafinance.io/byot/\\n  function _optimalDepositA(\\n    uint amtA,\\n    uint amtB,\\n    uint resA,\\n    uint resB\\n  ) internal pure returns (uint) {\\n    require(amtA.mul(resB) >= amtB.mul(resA), 'Reversed');\\n    uint a = 997;\\n    uint b = uint(1997).mul(resA);\\n    uint _c = (amtA.mul(resB)).sub(amtB.mul(resA));\\n    uint c = _c.mul(1000).div(amtB.add(resB)).mul(resA);\\n    uint d = a.mul(c).mul(4);\\n    uint e = HomoraMath.sqrt(b.mul(b).add(d));\\n    uint numerator = e.sub(b);\\n    uint denominator = a.mul(2);\\n    return numerator.div(denominator);\\n  }\\n\\n  struct Amounts {\\n    uint amtAUser;\\n    uint amtBUser;\\n    uint amtLPUser;\\n    uint amtABorrow;\\n    uint amtBBorrow;\\n    uint amtLPBorrow;\\n    uint amtAMin;\\n    uint amtBMin;\\n  }\\n\\n  function addLiquidityInternal(\\n    address tokenA,\\n    address tokenB,\\n    Amounts calldata amt\\n  ) internal {\\n    address lp = getPair(tokenA, tokenB);\\n\\n    // 1. Get user input amounts\\n    doTransmitETH();\\n    doTransmit(tokenA, amt.amtAUser);\\n    doTransmit(tokenB, amt.amtBUser);\\n    doTransmit(lp, amt.amtLPUser);\\n\\n    // 2. Borrow specified amounts\\n    doBorrow(tokenA, amt.amtABorrow);\\n    doBorrow(tokenB, amt.amtBBorrow);\\n    doBorrow(lp, amt.amtLPBorrow);\\n\\n    // 3. Calculate optimal swap amount\\n    uint swapAmt;\\n    bool isReversed;\\n    {\\n      uint amtA = IERC20(tokenA).balanceOf(address(this));\\n      uint amtB = IERC20(tokenB).balanceOf(address(this));\\n      uint resA;\\n      uint resB;\\n      if (IUniswapV2Pair(lp).token0() == tokenA) {\\n        (resA, resB, ) = IUniswapV2Pair(lp).getReserves();\\n      } else {\\n        (resB, resA, ) = IUniswapV2Pair(lp).getReserves();\\n      }\\n      (swapAmt, isReversed) = optimalDeposit(amtA, amtB, resA, resB);\\n    }\\n\\n    // 4. Swap optimal amount\\n    {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = isReversed ? (tokenB, tokenA) : (tokenA, tokenB);\\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), now);\\n    }\\n\\n    // 5. Add liquidity\\n    router.addLiquidity(\\n      tokenA,\\n      tokenB,\\n      IERC20(tokenA).balanceOf(address(this)),\\n      IERC20(tokenB).balanceOf(address(this)),\\n      amt.amtAMin,\\n      amt.amtBMin,\\n      address(this),\\n      now\\n    );\\n  }\\n\\n  function addLiquidityWERC20(\\n    address tokenA,\\n    address tokenB,\\n    Amounts calldata amt\\n  ) external payable {\\n    address lp = getPair(tokenA, tokenB);\\n    // 1-5. add liquidity\\n    addLiquidityInternal(tokenA, tokenB, amt);\\n\\n    // 6. Put collateral\\n    doPutCollateral(lp, IERC20(lp).balanceOf(address(this)));\\n\\n    // 7. Refund leftovers to users\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n  }\\n\\n  function addLiquidityWStakingRewards(\\n    address tokenA,\\n    address tokenB,\\n    Amounts calldata amt,\\n    address wstaking\\n  ) external payable {\\n    address lp = getPair(tokenA, tokenB);\\n    address reward = IWStakingRewards(wstaking).reward();\\n\\n    // 1-5. add liquidity\\n    addLiquidityInternal(tokenA, tokenB, amt);\\n\\n    // 6. Take out collateral\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, uint collSize) = bank.getPositionInfo(positionId);\\n    if (collSize > 0) {\\n      require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n      bank.takeCollateral(wstaking, collId, collSize);\\n      IWStakingRewards(wstaking).burn(collId, collSize);\\n    }\\n\\n    // 7. Put collateral\\n    ensureApprove(lp, wstaking);\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    uint id = IWStakingRewards(wstaking).mint(amount);\\n    if (!IWStakingRewards(wstaking).isApprovedForAll(address(this), address(bank))) {\\n      IWStakingRewards(wstaking).setApprovalForAll(address(bank), true);\\n    }\\n    bank.putCollateral(address(wstaking), id, amount);\\n\\n    // 8. Refund leftovers to users\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n\\n    // 9. Refund reward\\n    doRefund(reward);\\n  }\\n\\n  struct RepayAmounts {\\n    uint amtLPTake;\\n    uint amtLPWithdraw;\\n    uint amtARepay;\\n    uint amtBRepay;\\n    uint amtLPRepay;\\n    uint amtAMin;\\n    uint amtBMin;\\n  }\\n\\n  function removeLiquidityInternal(\\n    address tokenA,\\n    address tokenB,\\n    RepayAmounts calldata amt\\n  ) internal {\\n    address lp = getPair(tokenA, tokenB);\\n    uint positionId = bank.POSITION_ID();\\n\\n    uint amtARepay = amt.amtARepay;\\n    uint amtBRepay = amt.amtBRepay;\\n    uint amtLPRepay = amt.amtLPRepay;\\n\\n    // 2. Compute repay amount if MAX_INT is supplied (max debt)\\n    if (amtARepay == uint(-1)) {\\n      amtARepay = bank.borrowBalanceCurrent(positionId, tokenA);\\n    }\\n    if (amtBRepay == uint(-1)) {\\n      amtBRepay = bank.borrowBalanceCurrent(positionId, tokenB);\\n    }\\n    if (amtLPRepay == uint(-1)) {\\n      amtLPRepay = bank.borrowBalanceCurrent(positionId, lp);\\n    }\\n\\n    // 3. Compute amount to actually remove\\n    uint amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amt.amtLPWithdraw);\\n\\n    // 4. Remove liquidity\\n    (uint amtA, uint amtB) =\\n      router.removeLiquidity(tokenA, tokenB, amtLPToRemove, 0, 0, address(this), now);\\n\\n    // 5. MinimizeTrading\\n    uint amtADesired = amtARepay.add(amt.amtAMin);\\n    uint amtBDesired = amtBRepay.add(amt.amtBMin);\\n\\n    if (amtA < amtADesired && amtB >= amtBDesired) {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = (tokenB, tokenA);\\n      router.swapTokensForExactTokens(\\n        amtADesired.sub(amtA),\\n        amtB.sub(amtBDesired),\\n        path,\\n        address(this),\\n        now\\n      );\\n    } else if (amtA >= amtADesired && amtB < amtBDesired) {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = (tokenA, tokenB);\\n      router.swapTokensForExactTokens(\\n        amtBDesired.sub(amtB),\\n        amtA.sub(amtADesired),\\n        path,\\n        address(this),\\n        now\\n      );\\n    }\\n\\n    // 6. Repay\\n    doRepay(tokenA, amtARepay);\\n    doRepay(tokenB, amtBRepay);\\n    doRepay(lp, amtLPRepay);\\n\\n    // 7. Slippage control\\n    require(IERC20(tokenA).balanceOf(address(this)) >= amt.amtAMin);\\n    require(IERC20(tokenB).balanceOf(address(this)) >= amt.amtBMin);\\n    require(IERC20(lp).balanceOf(address(this)) >= amt.amtLPWithdraw);\\n\\n    // 8. Refund leftover\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n    doRefund(lp);\\n  }\\n\\n  function removeLiquidityWERC20(\\n    address tokenA,\\n    address tokenB,\\n    RepayAmounts calldata amt\\n  ) external {\\n    address lp = getPair(tokenA, tokenB);\\n\\n    // 1. Take out collateral\\n    doTakeCollateral(lp, amt.amtLPTake);\\n\\n    // 2-8. remove liquidity\\n    removeLiquidityInternal(tokenA, tokenB, amt);\\n  }\\n\\n  function removeLiquidityWStakingRewards(\\n    address tokenA,\\n    address tokenB,\\n    RepayAmounts calldata amt,\\n    address wstaking\\n  ) external {\\n    address lp = getPair(tokenA, tokenB);\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\\n    address reward = IWStakingRewards(wstaking).reward();\\n\\n    // 1. Take out collateral\\n    require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n    bank.takeCollateral(wstaking, collId, amt.amtLPTake);\\n    IWStakingRewards(wstaking).burn(collId, amt.amtLPTake);\\n\\n    // 2-8. remove liquidity\\n    removeLiquidityInternal(tokenA, tokenB, amt);\\n\\n    // 9. Refund reward\\n    doRefund(reward);\\n  }\\n\\n  function harvestWStakingRewards(address wstaking) external {\\n    address reward = IWStakingRewards(wstaking).reward();\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, ) = bank.getPositionInfo(positionId);\\n    address lp = IWStakingRewards(wstaking).getUnderlyingToken(collId);\\n\\n    // 1. Take out collateral\\n    bank.takeCollateral(wstaking, collId, uint(-1));\\n    IWStakingRewards(wstaking).burn(collId, uint(-1));\\n\\n    // 2. put collateral\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    ensureApprove(lp, wstaking);\\n    uint id = IWStakingRewards(wstaking).mint(amount);\\n    bank.putCollateral(wstaking, id, amount);\\n\\n    // 3. Refund reward\\n    doRefund(reward);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/spell/BasicSpell.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\n\\nimport '../utils/ERC1155NaiveReceiver.sol';\\nimport '../../interfaces/IBank.sol';\\nimport '../../interfaces/IWERC20.sol';\\nimport '../../interfaces/IWETH.sol';\\n\\ncontract BasicSpell is ERC1155NaiveReceiver {\\n  using SafeERC20 for IERC20;\\n\\n  IBank public immutable bank;\\n  IWERC20 public immutable werc20;\\n  address public immutable weth;\\n\\n  mapping(address => mapping(address => bool)) public approved;\\n\\n  constructor(\\n    IBank _bank,\\n    address _werc20,\\n    address _weth\\n  ) public {\\n    bank = _bank;\\n    werc20 = IWERC20(_werc20);\\n    weth = _weth;\\n    ensureApprove(_weth, address(_bank));\\n    IWERC20(_werc20).setApprovalForAll(address(_bank), true);\\n  }\\n\\n  /// @dev Ensure that the spell approve the given spender to spend all of its tokens.\\n  /// @param token The token to approve.\\n  /// @param spender The spender to allow spending.\\n  /// NOTE: This is safe because spell is never built to hold fund custody.\\n  function ensureApprove(address token, address spender) public {\\n    if (!approved[token][spender]) {\\n      IERC20(token).safeApprove(spender, uint(-1));\\n      approved[token][spender] = true;\\n    }\\n  }\\n\\n  /// @dev Internal call to convert msg.value ETH to WETH inside the contract.\\n  function doTransmitETH() internal {\\n    if (msg.value > 0) {\\n      IWETH(weth).deposit{value: msg.value}();\\n    }\\n  }\\n\\n  /// @dev Internal call to transmit tokens from the bank if amount is positive.\\n  /// @param token The token to perform the transmit action.\\n  /// @param amount The amount to transmit.\\n  function doTransmit(address token, uint amount) internal {\\n    if (amount > 0) {\\n      bank.transmit(token, amount);\\n    }\\n  }\\n\\n  /// @dev Internal call to refund tokens to the current bank executor.\\n  /// @param token The token to perform the refund action.\\n  function doRefund(address token) internal {\\n    uint balance = IERC20(token).balanceOf(address(this));\\n    if (balance > 0) {\\n      IERC20(token).safeTransfer(bank.EXECUTOR(), balance);\\n    }\\n  }\\n\\n  /// @dev Internal call to refund all WETH to the current executor as native ETH.\\n  function doRefundETH() internal {\\n    uint balance = IWETH(weth).balanceOf(address(this));\\n    if (balance > 0) {\\n      IWETH(weth).withdraw(balance);\\n      (bool success, ) = bank.EXECUTOR().call{value: balance}(new bytes(0));\\n      require(success, 'refund ETH failed');\\n    }\\n  }\\n\\n  /// @dev Internal call to borrow tokens from the bank on behalf of the current executor.\\n  /// @param token The token to borrow from the bank.\\n  /// @param amount The amount to borrow.\\n  function doBorrow(address token, uint amount) internal {\\n    if (amount > 0) {\\n      bank.borrow(token, amount);\\n    }\\n  }\\n\\n  /// @dev Internal call to repay tokens to the bank on behalf of the current executor.\\n  /// @param token The token to repay to the bank.\\n  /// @param amount The amount to repay.\\n  function doRepay(address token, uint amount) internal {\\n    if (amount > 0) {\\n      ensureApprove(token, address(bank));\\n      bank.repay(token, amount);\\n    }\\n  }\\n\\n  /// @dev Internal call to put collateral tokens to the bank.\\n  /// @param token The token to put to the bank.\\n  /// @param amount The amount to put to the bank.\\n  function doPutCollateral(address token, uint amount) internal {\\n    if (amount > 0) {\\n      ensureApprove(token, address(werc20));\\n      werc20.mint(token, amount);\\n      bank.putCollateral(address(werc20), uint(token), amount);\\n    }\\n  }\\n\\n  /// @dev Internal call to take collateral tokens from the bank.\\n  /// @param token The token to take back.\\n  /// @param amount The amount to take back.\\n  function doTakeCollateral(address token, uint amount) internal {\\n    if (amount > 0) {\\n      if (amount == uint(-1)) {\\n        (, , , amount) = bank.getPositionInfo(bank.POSITION_ID());\\n      }\\n      bank.takeCollateral(address(werc20), uint(token), amount);\\n      werc20.burn(token, amount);\\n    }\\n  }\\n\\n  receive() external payable {\\n    require(msg.sender == weth, 'ETH must come from WETH');\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/ERC1155NaiveReceiver.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155Receiver.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155Receiver.sol';\\n\\ncontract ERC1155NaiveReceiver is ERC1155Receiver {\\n  function onERC1155Received(\\n    address operator,\\n    address from,\\n    uint id,\\n    uint value,\\n    bytes calldata data\\n  ) external override returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(\\n    address operator,\\n    address from,\\n    uint[] calldata ids,\\n    uint[] calldata values,\\n    bytes calldata data\\n  ) external override returns (bytes4) {\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IBank.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IBank {\\n  /// The governor adds a new bank gets added to the system.\\n  event AddBank(address token, address cToken);\\n  /// The governor sets the address of the oracle smart contract.\\n  event SetOracle(address oracle);\\n  /// The governor sets the basis point fee of the bank.\\n  event SetFeeBps(uint feeBps);\\n  /// The governor withdraw tokens from the reserve of a bank.\\n  event WithdrawReserve(address user, address token, uint amount);\\n  /// Someone borrows tokens from a bank via a spell caller.\\n  event Borrow(uint positionId, address caller, address token, uint amount, uint share);\\n  /// Someone repays tokens to a bank via a spell caller.\\n  event Repay(uint positionId, address caller, address token, uint amount, uint share);\\n  /// Someone puts tokens as collateral via a spell caller.\\n  event PutCollateral(uint positionId, address caller, address token, uint id, uint amount);\\n  /// Someone takes tokens from collateral via a spell caller.\\n  event TakeCollateral(uint positionId, address caller, address token, uint id, uint amount);\\n  /// Someone calls liquidatation on a position, paying debt and taking collateral tokens.\\n  event Liquidate(\\n    uint positionId,\\n    address liquidator,\\n    address debtToken,\\n    uint amount,\\n    uint share,\\n    uint bounty\\n  );\\n\\n  /// @dev Return the current position while under execution.\\n  function POSITION_ID() external view returns (uint);\\n\\n  /// @dev Return the current target while under execution.\\n  function SPELL() external view returns (address);\\n\\n  /// @dev Return the current executor (the owner of the current position).\\n  function EXECUTOR() external view returns (address);\\n\\n  /// @dev Return bank information for the given token.\\n  function getBankInfo(address token)\\n    external\\n    view\\n    returns (\\n      bool isListed,\\n      address cToken,\\n      uint reserve,\\n      uint totalDebt,\\n      uint totalShare\\n    );\\n\\n  /// @dev Return position information for the given position id.\\n  function getPositionInfo(uint positionId)\\n    external\\n    view\\n    returns (\\n      address owner,\\n      address collToken,\\n      uint collId,\\n      uint collateralSize\\n    );\\n\\n  /// @dev Return the borrow balance for given positon and token without trigger interest accrual.\\n  function borrowBalanceStored(uint positionId, address token) external view returns (uint);\\n\\n  /// @dev Trigger interest accrual and return the current borrow balance.\\n  function borrowBalanceCurrent(uint positionId, address token) external returns (uint);\\n\\n  /// @dev Borrow tokens from the bank.\\n  function borrow(address token, uint amount) external;\\n\\n  /// @dev Repays tokens to the bank.\\n  function repay(address token, uint amountCall) external;\\n\\n  /// @dev Transmit user assets to the spell.\\n  function transmit(address token, uint amount) external;\\n\\n  /// @dev Put more collateral for users.\\n  function putCollateral(\\n    address collToken,\\n    uint collId,\\n    uint amountCall\\n  ) external;\\n\\n  /// @dev Take some collateral back.\\n  function takeCollateral(\\n    address collToken,\\n    uint collId,\\n    uint amount\\n  ) external;\\n\\n  /// @dev Liquidate a position.\\n  function liquidate(\\n    uint positionId,\\n    address debtToken,\\n    uint amountCall\\n  ) external;\\n\\n  function getBorrowETHValue(uint positionId) external view returns (uint);\\n\\n  function accrue(address token) external;\\n\\n  function nextPositionId() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"./interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IWETH {\\n  function balanceOf(address user) external returns (uint);\\n\\n  function approve(address to, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"./interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n// https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Factory.sol\\n\\ninterface IUniswapV2Factory {\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n  function feeTo() external view returns (address);\\n\\n  function feeToSetter() external view returns (address);\\n\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n  function allPairs(uint) external view returns (address pair);\\n\\n  function allPairsLength() external view returns (uint);\\n\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n  function setFeeTo(address) external;\\n\\n  function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"./interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"./interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol\\n\\ninterface IUniswapV2Router01 {\\n  function factory() external pure returns (address);\\n\\n  function WETH() external pure returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    returns (\\n      uint amountA,\\n      uint amountB,\\n      uint liquidity\\n    );\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    payable\\n    returns (\\n      uint amountToken,\\n      uint amountETH,\\n      uint liquidity\\n    );\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n  ) external pure returns (uint amountB);\\n\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountOut);\\n\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountIn);\\n\\n  function getAmountsOut(uint amountIn, address[] calldata path)\\n    external\\n    view\\n    returns (uint[] memory amounts);\\n\\n  function getAmountsIn(uint amountOut, address[] calldata path)\\n    external\\n    view\\n    returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"./interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n// https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Pair.sol\\n\\ninterface IUniswapV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function price0CumulativeLast() external view returns (uint);\\n\\n  function price1CumulativeLast() external view returns (uint);\\n\\n  function kLast() external view returns (uint);\\n\\n  function mint(address to) external returns (uint liquidity);\\n\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n\\n  function swap(\\n    uint amount0Out,\\n    uint amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n\\n  function skim(address to) external;\\n\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"./interfaces/IWStakingRewards.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155.sol';\\n\\nimport './IERC20Wrapper.sol';\\n\\ninterface IWStakingRewards is IERC1155, IERC20Wrapper {\\n  /// @dev Mint ERC1155 token for the given ERC20 token.\\n  function mint(uint amount) external returns (uint id);\\n\\n  /// @dev Burn ERC1155 token to redeem ERC20 token back.\\n  function burn(uint id, uint amount) external returns (uint);\\n\\n  function reward() external returns (address);\\n}\\n\"\r\n    },\r\n    \"./contracts/spell/CurveSpellV1.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport './BasicSpell.sol';\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/ICurvePool.sol';\\nimport '../../interfaces/ICurveRegistry.sol';\\nimport '../../interfaces/IWLiquidityGauge.sol';\\nimport '../../interfaces/IWERC20.sol';\\n\\ncontract CurveSpellV1 is BasicSpell {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n\\n  ICurveRegistry public immutable registry;\\n  IWLiquidityGauge public immutable wgauge;\\n  address public immutable crv;\\n  mapping(address => address[]) public ulTokens; // lpToken -> underlying token array\\n  mapping(address => address) public poolOf; // lpToken -> pool\\n\\n  constructor(\\n    IBank _bank,\\n    address _werc20,\\n    address _weth,\\n    address _wgauge\\n  ) public BasicSpell(_bank, _werc20, _weth) {\\n    wgauge = IWLiquidityGauge(_wgauge);\\n    IWLiquidityGauge(_wgauge).setApprovalForAll(address(_bank), true);\\n    registry = IWLiquidityGauge(_wgauge).registry();\\n    crv = address(IWLiquidityGauge(_wgauge).crv());\\n  }\\n\\n  /// @dev Return pool address given LP token and update pool info if not exist.\\n  /// @param lp LP token to find the corresponding pool.\\n  function getPool(address lp) public returns (address) {\\n    address pool = poolOf[lp];\\n    if (pool == address(0)) {\\n      require(lp != address(0), 'no lp token');\\n      pool = registry.get_pool_from_lp_token(lp);\\n      require(pool != address(0), 'no corresponding pool for lp token');\\n      poolOf[lp] = pool;\\n      uint n = registry.get_n_coins(pool);\\n      address[8] memory tokens = registry.get_coins(pool);\\n      ulTokens[lp] = new address[](n);\\n      for (uint i = 0; i < n; i++) {\\n        ulTokens[lp][i] = tokens[i];\\n      }\\n    }\\n    return pool;\\n  }\\n\\n  function ensureApproveN(address lp, uint n) public {\\n    require(ulTokens[lp].length == n, 'incorrect pool length');\\n    address pool = poolOf[lp];\\n    address[] memory tokens = ulTokens[lp];\\n    for (uint idx = 0; idx < n; idx++) {\\n      ensureApprove(tokens[idx], pool);\\n    }\\n  }\\n\\n  /// @dev add liquidity for pools with 2 underlying tokens\\n  function addLiquidity2(\\n    address lp,\\n    uint[2] calldata amtsUser,\\n    uint amtLPUser,\\n    uint[2] calldata amtsBorrow,\\n    uint amtLPBorrow,\\n    uint minLPMint,\\n    uint pid,\\n    uint gid\\n  ) external {\\n    address pool = getPool(lp);\\n    require(ulTokens[lp].length == 2, 'incorrect pool length');\\n    require(wgauge.getUnderlyingToken(wgauge.encodeId(pid, gid, 0)) == lp, 'incorrect underlying');\\n    address[] memory tokens = ulTokens[lp];\\n\\n    // 0. Take out collateral\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\\n    if (collSize > 0) {\\n      (uint decodedPid, uint decodedGid, ) = wgauge.decodeId(collId);\\n      require(decodedPid == pid && decodedGid == gid, 'incorrect coll id');\\n      bank.takeCollateral(address(wgauge), collId, collSize);\\n      wgauge.burn(collId, collSize);\\n    }\\n\\n    // 1. Ensure approve 2 underlying tokens\\n    ensureApproveN(lp, 2);\\n\\n    // 2. Get user input amounts\\n    for (uint i = 0; i < 2; i++) doTransmit(tokens[i], amtsUser[i]);\\n    doTransmit(lp, amtLPUser);\\n\\n    // 3. Borrow specified amounts\\n    for (uint i = 0; i < 2; i++) doBorrow(tokens[i], amtsBorrow[i]);\\n    doBorrow(lp, amtLPBorrow);\\n\\n    // 4. add liquidity\\n    uint[2] memory suppliedAmts;\\n    for (uint i = 0; i < 2; i++) {\\n      suppliedAmts[i] = IERC20(tokens[i]).balanceOf(address(this));\\n    }\\n    ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\\n\\n    // 5. Put collateral\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    ensureApprove(lp, address(wgauge));\\n    uint id = wgauge.mint(pid, gid, amount);\\n    bank.putCollateral(address(wgauge), id, amount);\\n\\n    // 6. Refund\\n    for (uint i = 0; i < 2; i++) doRefund(tokens[i]);\\n\\n    // 7. Refund crv\\n    doRefund(crv);\\n  }\\n\\n  /// @dev add liquidity for pools with 3 underlying tokens\\n  function addLiquidity3(\\n    address lp,\\n    uint[3] calldata amtsUser,\\n    uint amtLPUser,\\n    uint[3] calldata amtsBorrow,\\n    uint amtLPBorrow,\\n    uint minLPMint,\\n    uint pid,\\n    uint gid\\n  ) external {\\n    address pool = getPool(lp);\\n    require(ulTokens[lp].length == 3, 'incorrect pool length');\\n    require(wgauge.getUnderlyingToken(wgauge.encodeId(pid, gid, 0)) == lp, 'incorrect underlying');\\n    address[] memory tokens = ulTokens[lp];\\n\\n    // 0. take out collateral\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\\n    if (collSize > 0) {\\n      (uint decodedPid, uint decodedGid, ) = wgauge.decodeId(collId);\\n      require(decodedPid == pid && decodedGid == gid, 'incorrect coll id');\\n      bank.takeCollateral(address(wgauge), collId, collSize);\\n      wgauge.burn(collId, collSize);\\n    }\\n\\n    // 1. Ensure approve 3 underlying tokens\\n    ensureApproveN(lp, 3);\\n\\n    // 2. Get user input amounts\\n    for (uint i = 0; i < 3; i++) doTransmit(tokens[i], amtsUser[i]);\\n    doTransmit(lp, amtLPUser);\\n\\n    // 3. Borrow specified amounts\\n    for (uint i = 0; i < 3; i++) doBorrow(tokens[i], amtsBorrow[i]);\\n    doBorrow(lp, amtLPBorrow);\\n\\n    // 4. add liquidity\\n    uint[3] memory suppliedAmts;\\n    for (uint i = 0; i < 3; i++) {\\n      suppliedAmts[i] = IERC20(tokens[i]).balanceOf(address(this));\\n    }\\n    ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\\n\\n    // 5. put collateral\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    ensureApprove(lp, address(wgauge));\\n    uint id = wgauge.mint(pid, gid, amount);\\n    bank.putCollateral(address(wgauge), id, amount);\\n\\n    // 6. Refund\\n    for (uint i = 0; i < 3; i++) doRefund(tokens[i]);\\n\\n    // 7. Refund crv\\n    doRefund(crv);\\n  }\\n\\n  /// @dev add liquidity for pools with 4 underlying tokens\\n  function addLiquidity4(\\n    address lp,\\n    uint[4] calldata amtsUser,\\n    uint amtLPUser,\\n    uint[4] calldata amtsBorrow,\\n    uint amtLPBorrow,\\n    uint minLPMint,\\n    uint pid,\\n    uint gid\\n  ) external {\\n    address pool = getPool(lp);\\n    require(ulTokens[lp].length == 4, 'incorrect pool length');\\n    require(wgauge.getUnderlyingToken(wgauge.encodeId(pid, gid, 0)) == lp, 'incorrect underlying');\\n    address[] memory tokens = ulTokens[lp];\\n\\n    // 0. Take out collateral\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\\n    if (collSize > 0) {\\n      (uint decodedPid, uint decodedGid, ) = wgauge.decodeId(collId);\\n      require(decodedPid == pid && decodedGid == gid, 'incorrect coll id');\\n      bank.takeCollateral(address(wgauge), collId, collSize);\\n      wgauge.burn(collId, collSize);\\n    }\\n\\n    // 1. Ensure approve 4 underlying tokens\\n    ensureApproveN(lp, 4);\\n\\n    // 2. Get user input amounts\\n    for (uint i = 0; i < 4; i++) doTransmit(tokens[i], amtsUser[i]);\\n    doTransmit(lp, amtLPUser);\\n\\n    // 3. Borrow specified amounts\\n    for (uint i = 0; i < 4; i++) doBorrow(tokens[i], amtsBorrow[i]);\\n    doBorrow(lp, amtLPBorrow);\\n\\n    // 4. add liquidity\\n    uint[4] memory suppliedAmts;\\n    for (uint i = 0; i < 4; i++) {\\n      suppliedAmts[i] = IERC20(tokens[i]).balanceOf(address(this));\\n    }\\n    ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\\n\\n    // 5. Put collateral\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    ensureApprove(lp, address(wgauge));\\n    uint id = wgauge.mint(pid, gid, amount);\\n    bank.putCollateral(address(wgauge), id, amount);\\n\\n    // 6. Refund\\n    for (uint i = 0; i < 4; i++) doRefund(tokens[i]);\\n\\n    // 7. Refund crv\\n    doRefund(crv);\\n  }\\n\\n  function removeLiquidity2(\\n    address lp,\\n    uint amtLPTake,\\n    uint amtLPWithdraw,\\n    uint[2] calldata amtsRepay,\\n    uint amtLPRepay,\\n    uint[2] calldata amtsMin\\n  ) external {\\n    address pool = getPool(lp);\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\\n    require(IWLiquidityGauge(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n    address[] memory tokens = ulTokens[lp];\\n\\n    // 0. Ensure approve\\n    ensureApproveN(lp, 2);\\n\\n    // 1. Compute repay amount if MAX_INT is supplied (max debt)\\n    uint[2] memory actualAmtsRepay;\\n    for (uint i = 0; i < 2; i++) {\\n      actualAmtsRepay[i] = amtsRepay[i] == uint(-1)\\n        ? bank.borrowBalanceCurrent(positionId, tokens[i])\\n        : amtsRepay[i];\\n    }\\n    uint[2] memory amtsDesired;\\n    for (uint i = 0; i < 2; i++) {\\n      amtsDesired[i] = actualAmtsRepay[i].add(amtsMin[i]); // repay amt + slippage control\\n    }\\n\\n    // 2. Take out collateral\\n    bank.takeCollateral(address(wgauge), collId, amtLPTake);\\n    wgauge.burn(collId, amtLPTake);\\n\\n    // 3. Compute amount to actually remove. Remove to repay just enough\\n    uint amtLPToRemove;\\n    if (amtsDesired[0] > 0 || amtsDesired[1] > 0) {\\n      amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\\n      ICurvePool(pool).remove_liquidity_imbalance(amtsDesired, amtLPToRemove);\\n    }\\n\\n    // 4. Compute leftover amount to remove. Remove balancedly.\\n    amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\\n    uint[2] memory mins;\\n    ICurvePool(pool).remove_liquidity(amtLPToRemove, mins);\\n\\n    // 5. Repay\\n    for (uint i = 0; i < 2; i++) {\\n      doRepay(tokens[i], actualAmtsRepay[i]);\\n    }\\n    doRepay(lp, amtLPRepay);\\n\\n    // 6. Refund\\n    for (uint i = 0; i < 2; i++) {\\n      doRefund(tokens[i]);\\n    }\\n    doRefund(lp);\\n\\n    // 7. Refund crv\\n    doRefund(crv);\\n  }\\n\\n  function removeLiquidity3(\\n    address lp,\\n    uint amtLPTake,\\n    uint amtLPWithdraw,\\n    uint[3] calldata amtsRepay,\\n    uint amtLPRepay,\\n    uint[3] calldata amtsMin\\n  ) external {\\n    address pool = getPool(lp);\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\\n    require(IWLiquidityGauge(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n    address[] memory tokens = ulTokens[lp];\\n\\n    // 0. Ensure approve\\n    ensureApproveN(lp, 3);\\n\\n    // 1. Compute repay amount if MAX_INT is supplied (max debt)\\n    uint[3] memory actualAmtsRepay;\\n    for (uint i = 0; i < 3; i++) {\\n      actualAmtsRepay[i] = amtsRepay[i] == uint(-1)\\n        ? bank.borrowBalanceCurrent(positionId, tokens[i])\\n        : amtsRepay[i];\\n    }\\n    uint[3] memory amtsDesired;\\n    for (uint i = 0; i < 3; i++) {\\n      amtsDesired[i] = actualAmtsRepay[i].add(amtsMin[i]); // repay amt + slippage control\\n    }\\n\\n    // 2. Take out collateral\\n    bank.takeCollateral(address(wgauge), collId, amtLPTake);\\n    wgauge.burn(collId, amtLPTake);\\n\\n    // 3. Compute amount to actually remove. Remove to repay just enough\\n    uint amtLPToRemove;\\n    if (amtsDesired[0] > 0 || amtsDesired[1] > 0 || amtsDesired[2] > 0) {\\n      amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\\n      ICurvePool(pool).remove_liquidity_imbalance(amtsDesired, amtLPToRemove);\\n    }\\n\\n    // 4. Compute leftover amount to remove. Remove balancedly.\\n    amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\\n    uint[3] memory mins;\\n    ICurvePool(pool).remove_liquidity(amtLPToRemove, mins);\\n\\n    // 5. Repay\\n    for (uint i = 0; i < 3; i++) {\\n      doRepay(tokens[i], actualAmtsRepay[i]);\\n    }\\n    doRepay(lp, amtLPRepay);\\n\\n    // 6. Refund\\n    for (uint i = 0; i < 3; i++) {\\n      doRefund(tokens[i]);\\n    }\\n    doRefund(lp);\\n\\n    // 7. Refund crv\\n    doRefund(crv);\\n  }\\n\\n  function removeLiquidity4(\\n    address lp,\\n    uint amtLPTake,\\n    uint amtLPWithdraw,\\n    uint[4] calldata amtsRepay,\\n    uint amtLPRepay,\\n    uint[4] calldata amtsMin\\n  ) external {\\n    address pool = getPool(lp);\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\\n    require(IWLiquidityGauge(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n    address[] memory tokens = ulTokens[lp];\\n\\n    // 0. Ensure approve\\n    ensureApproveN(lp, 4);\\n\\n    // 1. Compute repay amount if MAX_INT is supplied (max debt)\\n    uint[4] memory actualAmtsRepay;\\n    for (uint i = 0; i < 4; i++) {\\n      actualAmtsRepay[i] = amtsRepay[i] == uint(-1)\\n        ? bank.borrowBalanceCurrent(positionId, tokens[i])\\n        : amtsRepay[i];\\n    }\\n    uint[4] memory amtsDesired;\\n    for (uint i = 0; i < 4; i++) {\\n      amtsDesired[i] = actualAmtsRepay[i].add(amtsMin[i]); // repay amt + slippage control\\n    }\\n\\n    // 2. Take out collateral\\n    bank.takeCollateral(address(wgauge), collId, amtLPTake);\\n    wgauge.burn(collId, amtLPTake);\\n\\n    // 3. Compute amount to actually remove. Remove to repay just enough\\n    uint amtLPToRemove;\\n    if (amtsDesired[0] > 0 || amtsDesired[1] > 0 || amtsDesired[2] > 0 || amtsDesired[3] > 0) {\\n      amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\\n      ICurvePool(pool).remove_liquidity_imbalance(amtsDesired, amtLPToRemove);\\n    }\\n\\n    // 4. Compute leftover amount to remove. Remove balancedly.\\n    amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\\n    uint[4] memory mins;\\n    ICurvePool(pool).remove_liquidity(amtLPToRemove, mins);\\n\\n    // 5. Repay\\n    for (uint i = 0; i < 4; i++) {\\n      doRepay(tokens[i], actualAmtsRepay[i]);\\n    }\\n    doRepay(lp, amtLPRepay);\\n\\n    // 6. Refund\\n    for (uint i = 0; i < 4; i++) {\\n      doRefund(tokens[i]);\\n    }\\n    doRefund(lp);\\n\\n    // 7. Refund crv\\n    doRefund(crv);\\n  }\\n\\n  function harvest() external {\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\\n    (uint pid, uint gid, ) = wgauge.decodeId(collId);\\n    address lp = wgauge.getUnderlyingToken(collId);\\n\\n    // 1. Take out collateral\\n    bank.takeCollateral(address(wgauge), collId, collSize);\\n    wgauge.burn(collId, collSize);\\n\\n    // 2. Put collateral\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    ensureApprove(lp, address(wgauge));\\n    uint id = wgauge.mint(pid, gid, amount);\\n    bank.putCollateral(address(wgauge), id, amount);\\n\\n    // 3. Refund crv\\n    doRefund(crv);\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/ICurvePool.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface ICurvePool {\\n  function add_liquidity(uint[2] calldata, uint) external;\\n\\n  function add_liquidity(uint[3] calldata, uint) external;\\n\\n  function add_liquidity(uint[4] calldata, uint) external;\\n\\n  function remove_liquidity(uint, uint[2] calldata) external;\\n\\n  function remove_liquidity(uint, uint[3] calldata) external;\\n\\n  function remove_liquidity(uint, uint[4] calldata) external;\\n\\n  function remove_liquidity_imbalance(uint[2] calldata, uint) external;\\n\\n  function remove_liquidity_imbalance(uint[3] calldata, uint) external;\\n\\n  function remove_liquidity_imbalance(uint[4] calldata, uint) external;\\n\\n  function remove_liquidity_one_coin(\\n    uint,\\n    int128,\\n    uint\\n  ) external;\\n\\n  function get_virtual_price() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"./interfaces/IWLiquidityGauge.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\n\\nimport './IERC20Wrapper.sol';\\nimport './ICurveRegistry.sol';\\nimport './ILiquidityGauge.sol';\\n\\ninterface IWLiquidityGauge is IERC1155, IERC20Wrapper {\\n  /// @dev Mint ERC1155 token for the given ERC20 token.\\n  function mint(\\n    uint pid,\\n    uint gid,\\n    uint amount\\n  ) external returns (uint id);\\n\\n  /// @dev Burn ERC1155 token to redeem ERC20 token back.\\n  function burn(uint id, uint amount) external returns (uint pid);\\n\\n  function crv() external returns (IERC20);\\n\\n  function registry() external returns (ICurveRegistry);\\n\\n  function encodeId(\\n    uint,\\n    uint,\\n    uint\\n  ) external pure returns (uint);\\n\\n  function decodeId(uint id)\\n    external\\n    pure\\n    returns (\\n      uint,\\n      uint,\\n      uint\\n    );\\n}\\n\"\r\n    },\r\n    \"./contracts/spell/SushiswapSpellV1.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport './BasicSpell.sol';\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/IUniswapV2Factory.sol';\\nimport '../../interfaces/IUniswapV2Router02.sol';\\nimport '../../interfaces/IUniswapV2Pair.sol';\\nimport '../../interfaces/IWMasterChef.sol';\\n\\ncontract SushiswapSpellV1 is BasicSpell {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n\\n  IUniswapV2Factory public immutable factory;\\n  IUniswapV2Router02 public immutable router;\\n\\n  mapping(address => mapping(address => address)) public pairs;\\n\\n  IWMasterChef public immutable wmasterchef;\\n\\n  address public immutable sushi;\\n\\n  constructor(\\n    IBank _bank,\\n    address _werc20,\\n    IUniswapV2Router02 _router,\\n    address _wmasterchef\\n  ) public BasicSpell(_bank, _werc20, _router.WETH()) {\\n    router = _router;\\n    factory = IUniswapV2Factory(_router.factory());\\n    wmasterchef = IWMasterChef(_wmasterchef);\\n    IWMasterChef(_wmasterchef).setApprovalForAll(address(_bank), true);\\n    sushi = address(IWMasterChef(_wmasterchef).sushi());\\n  }\\n\\n  function getPair(address tokenA, address tokenB) public returns (address) {\\n    address lp = pairs[tokenA][tokenB];\\n    if (lp == address(0)) {\\n      lp = factory.getPair(tokenA, tokenB);\\n      require(lp != address(0), 'no lp token');\\n      ensureApprove(tokenA, address(router));\\n      ensureApprove(tokenB, address(router));\\n      ensureApprove(lp, address(router));\\n      pairs[tokenA][tokenB] = lp;\\n      pairs[tokenB][tokenA] = lp;\\n    }\\n    return lp;\\n  }\\n\\n  /// @dev Compute optimal deposit amount\\n  /// @param amtA amount of token A desired to deposit\\n  /// @param amtB amount of token B desired to deposit\\n  /// @param resA amount of token A in reserve\\n  /// @param resB amount of token B in reserve\\n  function optimalDeposit(\\n    uint amtA,\\n    uint amtB,\\n    uint resA,\\n    uint resB\\n  ) internal pure returns (uint swapAmt, bool isReversed) {\\n    if (amtA.mul(resB) >= amtB.mul(resA)) {\\n      swapAmt = _optimalDepositA(amtA, amtB, resA, resB);\\n      isReversed = false;\\n    } else {\\n      swapAmt = _optimalDepositA(amtB, amtA, resB, resA);\\n      isReversed = true;\\n    }\\n  }\\n\\n  /// @dev Compute optimal deposit amount helper.\\n  /// @param amtA amount of token A desired to deposit\\n  /// @param amtB amount of token B desired to deposit\\n  /// @param resA amount of token A in reserve\\n  /// @param resB amount of token B in reserve\\n  /// Formula: https://blog.alphafinance.io/byot/\\n  function _optimalDepositA(\\n    uint amtA,\\n    uint amtB,\\n    uint resA,\\n    uint resB\\n  ) internal pure returns (uint) {\\n    require(amtA.mul(resB) >= amtB.mul(resA), 'Reversed');\\n    uint a = 997;\\n    uint b = uint(1997).mul(resA);\\n    uint _c = (amtA.mul(resB)).sub(amtB.mul(resA));\\n    uint c = _c.mul(1000).div(amtB.add(resB)).mul(resA);\\n    uint d = a.mul(c).mul(4);\\n    uint e = HomoraMath.sqrt(b.mul(b).add(d));\\n    uint numerator = e.sub(b);\\n    uint denominator = a.mul(2);\\n    return numerator.div(denominator);\\n  }\\n\\n  struct Amounts {\\n    uint amtAUser;\\n    uint amtBUser;\\n    uint amtLPUser;\\n    uint amtABorrow;\\n    uint amtBBorrow;\\n    uint amtLPBorrow;\\n    uint amtAMin;\\n    uint amtBMin;\\n  }\\n\\n  function addLiquidityInternal(\\n    address tokenA,\\n    address tokenB,\\n    Amounts calldata amt\\n  ) internal {\\n    address lp = getPair(tokenA, tokenB);\\n\\n    // 1. Get user input amounts\\n    doTransmitETH();\\n    doTransmit(tokenA, amt.amtAUser);\\n    doTransmit(tokenB, amt.amtBUser);\\n    doTransmit(lp, amt.amtLPUser);\\n\\n    // 2. Borrow specified amounts\\n    doBorrow(tokenA, amt.amtABorrow);\\n    doBorrow(tokenB, amt.amtBBorrow);\\n    doBorrow(lp, amt.amtLPBorrow);\\n\\n    // 3. Calculate optimal swap amount\\n    uint swapAmt;\\n    bool isReversed;\\n    {\\n      uint amtA = IERC20(tokenA).balanceOf(address(this));\\n      uint amtB = IERC20(tokenB).balanceOf(address(this));\\n      uint resA;\\n      uint resB;\\n      if (IUniswapV2Pair(lp).token0() == tokenA) {\\n        (resA, resB, ) = IUniswapV2Pair(lp).getReserves();\\n      } else {\\n        (resB, resA, ) = IUniswapV2Pair(lp).getReserves();\\n      }\\n      (swapAmt, isReversed) = optimalDeposit(amtA, amtB, resA, resB);\\n    }\\n\\n    // 4. Swap optimal amount\\n    {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = isReversed ? (tokenB, tokenA) : (tokenA, tokenB);\\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), now);\\n    }\\n\\n    // 5. Add liquidity\\n    router.addLiquidity(\\n      tokenA,\\n      tokenB,\\n      IERC20(tokenA).balanceOf(address(this)),\\n      IERC20(tokenB).balanceOf(address(this)),\\n      amt.amtAMin,\\n      amt.amtBMin,\\n      address(this),\\n      now\\n    );\\n  }\\n\\n  function addLiquidityWERC20(\\n    address tokenA,\\n    address tokenB,\\n    Amounts calldata amt\\n  ) external payable {\\n    address lp = getPair(tokenA, tokenB);\\n    // 1-5. add liquidity\\n    addLiquidityInternal(tokenA, tokenB, amt);\\n\\n    // 6. Put collateral\\n    doPutCollateral(lp, IERC20(lp).balanceOf(address(this)));\\n\\n    // 7. Refund leftovers to users\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n  }\\n\\n  function addLiquidityWMasterChef(\\n    address tokenA,\\n    address tokenB,\\n    Amounts calldata amt,\\n    uint pid\\n  ) external payable {\\n    address lp = getPair(tokenA, tokenB);\\n    (address lpToken, , , ) = wmasterchef.chef().poolInfo(pid);\\n    require(lpToken == lp, 'incorrect lp token');\\n\\n    // 1-5. add liquidity\\n    addLiquidityInternal(tokenA, tokenB, amt);\\n\\n    // 6. Take out collateral\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\\n    if (collSize > 0) {\\n      (uint decodedPid, ) = wmasterchef.decodeId(collId);\\n      require(pid == decodedPid, 'incorrect pid');\\n      bank.takeCollateral(address(wmasterchef), collId, collSize);\\n      wmasterchef.burn(collId, collSize);\\n    }\\n\\n    // 7. Put collateral\\n    ensureApprove(lp, address(wmasterchef));\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    uint id = wmasterchef.mint(pid, amount);\\n    bank.putCollateral(address(wmasterchef), id, amount);\\n\\n    // 8. Refund leftovers to users\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n\\n    // 9. Refund sushi\\n    doRefund(sushi);\\n  }\\n\\n  struct RepayAmounts {\\n    uint amtLPTake;\\n    uint amtLPWithdraw;\\n    uint amtARepay;\\n    uint amtBRepay;\\n    uint amtLPRepay;\\n    uint amtAMin;\\n    uint amtBMin;\\n  }\\n\\n  function removeLiquidityInternal(\\n    address tokenA,\\n    address tokenB,\\n    RepayAmounts calldata amt\\n  ) internal {\\n    address lp = getPair(tokenA, tokenB);\\n    uint positionId = bank.POSITION_ID();\\n\\n    uint amtARepay = amt.amtARepay;\\n    uint amtBRepay = amt.amtBRepay;\\n    uint amtLPRepay = amt.amtLPRepay;\\n\\n    // 2. Compute repay amount if MAX_INT is supplied (max debt)\\n    if (amtARepay == uint(-1)) {\\n      amtARepay = bank.borrowBalanceCurrent(positionId, tokenA);\\n    }\\n    if (amtBRepay == uint(-1)) {\\n      amtBRepay = bank.borrowBalanceCurrent(positionId, tokenB);\\n    }\\n    if (amtLPRepay == uint(-1)) {\\n      amtLPRepay = bank.borrowBalanceCurrent(positionId, lp);\\n    }\\n\\n    // 3. Compute amount to actually remove\\n    uint amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amt.amtLPWithdraw);\\n\\n    // 4. Remove liquidity\\n    (uint amtA, uint amtB) =\\n      router.removeLiquidity(tokenA, tokenB, amtLPToRemove, 0, 0, address(this), now);\\n\\n    // 5. MinimizeTrading\\n    uint amtADesired = amtARepay.add(amt.amtAMin);\\n    uint amtBDesired = amtBRepay.add(amt.amtBMin);\\n\\n    if (amtA < amtADesired && amtB >= amtBDesired) {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = (tokenB, tokenA);\\n      router.swapTokensForExactTokens(\\n        amtADesired.sub(amtA),\\n        amtB.sub(amtBDesired),\\n        path,\\n        address(this),\\n        now\\n      );\\n    } else if (amtA >= amtADesired && amtB < amtBDesired) {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = (tokenA, tokenB);\\n      router.swapTokensForExactTokens(\\n        amtBDesired.sub(amtB),\\n        amtA.sub(amtADesired),\\n        path,\\n        address(this),\\n        now\\n      );\\n    }\\n\\n    // 6. Repay\\n    doRepay(tokenA, amtARepay);\\n    doRepay(tokenB, amtBRepay);\\n    doRepay(lp, amtLPRepay);\\n\\n    // 7. Slippage control\\n    require(IERC20(tokenA).balanceOf(address(this)) >= amt.amtAMin);\\n    require(IERC20(tokenB).balanceOf(address(this)) >= amt.amtBMin);\\n    require(IERC20(lp).balanceOf(address(this)) >= amt.amtLPWithdraw);\\n\\n    // 8. Refund leftover\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n    doRefund(lp);\\n  }\\n\\n  function removeLiquidityWERC20(\\n    address tokenA,\\n    address tokenB,\\n    RepayAmounts calldata amt\\n  ) external {\\n    address lp = getPair(tokenA, tokenB);\\n\\n    // 1. Take out collateral\\n    doTakeCollateral(lp, amt.amtLPTake);\\n\\n    // 2-8. remove liquidity\\n    removeLiquidityInternal(tokenA, tokenB, amt);\\n  }\\n\\n  function removeLiquidityWMasterChef(\\n    address tokenA,\\n    address tokenB,\\n    RepayAmounts calldata amt\\n  ) external {\\n    address lp = getPair(tokenA, tokenB);\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\\n    require(IWMasterChef(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n\\n    // 1. Take out collateral\\n    bank.takeCollateral(address(wmasterchef), collId, amt.amtLPTake);\\n    wmasterchef.burn(collId, amt.amtLPTake);\\n\\n    // 2-8. remove liquidity\\n    removeLiquidityInternal(tokenA, tokenB, amt);\\n\\n    // 9. Refund sushi\\n    doRefund(sushi);\\n  }\\n\\n  function harvestWMasterChef() external {\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, ) = bank.getPositionInfo(positionId);\\n    (uint pid, ) = wmasterchef.decodeId(collId);\\n    address lp = wmasterchef.getUnderlyingToken(collId);\\n\\n    // 1. Take out collateral\\n    bank.takeCollateral(address(wmasterchef), collId, uint(-1));\\n    wmasterchef.burn(collId, uint(-1));\\n\\n    // 2. put collateral\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    ensureApprove(lp, address(wmasterchef));\\n    uint id = wmasterchef.mint(pid, amount);\\n    bank.putCollateral(address(wmasterchef), id, amount);\\n\\n    // 3. Refund sushi\\n    doRefund(sushi);\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IWMasterChef.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\n\\nimport './IERC20Wrapper.sol';\\nimport './IMasterChef.sol';\\n\\ninterface IWMasterChef is IERC1155, IERC20Wrapper {\\n  /// @dev Mint ERC1155 token for the given ERC20 token.\\n  function mint(uint pid, uint amount) external returns (uint id);\\n\\n  /// @dev Burn ERC1155 token to redeem ERC20 token back.\\n  function burn(uint id, uint amount) external returns (uint pid);\\n\\n  function sushi() external returns (IERC20);\\n\\n  function decodeId(uint id) external pure returns (uint, uint);\\n\\n  function chef() external view returns (IMasterChef);\\n}\\n\"\r\n    },\r\n    \"./contracts/spell/BalancerSpellV1.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport './BasicSpell.sol';\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/IBalancerPool.sol';\\nimport '../../interfaces/IWStakingRewards.sol';\\n\\ncontract BalancerSpellV1 is BasicSpell {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n\\n  mapping(address => address[2]) pairs; // mapping from lp token to underlying token (only pairs)\\n\\n  constructor(\\n    IBank _bank,\\n    address _werc20,\\n    address _weth\\n  ) public BasicSpell(_bank, _werc20, _weth) {}\\n\\n  function getPair(address lp) public returns (address tokenA, address tokenB) {\\n    address[2] memory ulTokens = pairs[lp];\\n    tokenA = ulTokens[0];\\n    tokenB = ulTokens[1];\\n    if (tokenA == address(0) || tokenB == address(0)) {\\n      address[] memory tokens = IBalancerPool(lp).getFinalTokens();\\n      require(tokens.length == 2, 'underlying tokens not 2');\\n      tokenA = tokens[0];\\n      tokenB = tokens[1];\\n      ensureApprove(tokenA, lp);\\n      ensureApprove(tokenB, lp);\\n    }\\n  }\\n\\n  struct Amounts {\\n    uint amtAUser;\\n    uint amtBUser;\\n    uint amtLPUser;\\n    uint amtABorrow;\\n    uint amtBBorrow;\\n    uint amtLPBorrow;\\n    uint amtLPDesired;\\n  }\\n\\n  function addLiquidityInternal(address lp, Amounts calldata amt) internal {\\n    (address tokenA, address tokenB) = getPair(lp);\\n\\n    // 1. Get user input amounts\\n    doTransmitETH();\\n    doTransmit(tokenA, amt.amtAUser);\\n    doTransmit(tokenB, amt.amtBUser);\\n    doTransmit(lp, amt.amtLPUser);\\n\\n    // 2. Borrow specified amounts\\n    doBorrow(tokenA, amt.amtABorrow);\\n    doBorrow(tokenB, amt.amtBBorrow);\\n    doBorrow(lp, amt.amtLPBorrow);\\n\\n    // 3.1 Add Liquidity using equal value two side to minimize swap fee\\n    uint[] memory maxAmountsIn = new uint[](2);\\n    maxAmountsIn[0] = amt.amtAUser.add(amt.amtABorrow);\\n    maxAmountsIn[1] = amt.amtBUser.add(amt.amtBBorrow);\\n    uint totalLPSupply = IBalancerPool(lp).totalSupply();\\n    uint poolAmountFromA =\\n      maxAmountsIn[0].mul(1e18).div(IBalancerPool(lp).getBalance(tokenA)).mul(totalLPSupply).div(\\n        1e18\\n      ); // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\\n    uint poolAmountFromB =\\n      maxAmountsIn[1].mul(1e18).div(IBalancerPool(lp).getBalance(tokenB)).mul(totalLPSupply).div(\\n        1e18\\n      ); // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\\n\\n    uint poolAmountOut = poolAmountFromA > poolAmountFromB ? poolAmountFromB : poolAmountFromA;\\n    if (poolAmountOut > 0) IBalancerPool(lp).joinPool(poolAmountOut, maxAmountsIn);\\n\\n    // 3.2 Add Liquidity leftover for each token\\n    uint ABal = IERC20(tokenA).balanceOf(address(this));\\n    uint BBal = IERC20(tokenB).balanceOf(address(this));\\n    if (ABal > 0) IBalancerPool(lp).joinswapExternAmountIn(tokenA, ABal, 0);\\n    if (BBal > 0) IBalancerPool(lp).joinswapExternAmountIn(tokenB, BBal, 0);\\n\\n    // 4. Slippage control\\n    uint lpBalance = IERC20(lp).balanceOf(address(this));\\n    require(lpBalance >= amt.amtLPDesired, 'lp desired not met');\\n  }\\n\\n  /// @dev Add liquidity to Balancer pool (with 2 underlying tokens)\\n  function addLiquidityWERC20(address lp, Amounts calldata amt) external payable {\\n    // 1-4. add liquidity\\n    addLiquidityInternal(lp, amt);\\n\\n    // 5. Put collateral\\n    doPutCollateral(lp, IERC20(lp).balanceOf(address(this)));\\n\\n    // 6. Refund leftovers to users\\n    (address tokenA, address tokenB) = getPair(lp);\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n  }\\n\\n  /// @dev Add liquidity to Balancer pool (with 2 underlying tokens)\\n  function addLiquidityWStakingRewards(\\n    address lp,\\n    Amounts calldata amt,\\n    address wstaking\\n  ) external payable {\\n    // 1-4. add liquidity\\n    addLiquidityInternal(lp, amt);\\n\\n    // 5. Take out collateral\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, uint collSize) = bank.getPositionInfo(positionId);\\n    if (collSize > 0) {\\n      require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n      bank.takeCollateral(wstaking, collId, collSize);\\n      IWStakingRewards(wstaking).burn(collId, collSize);\\n    }\\n\\n    // 6. Put collateral\\n    ensureApprove(lp, wstaking);\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    uint id = IWStakingRewards(wstaking).mint(amount);\\n    if (!IWStakingRewards(wstaking).isApprovedForAll(address(this), address(bank))) {\\n      IWStakingRewards(wstaking).setApprovalForAll(address(bank), true);\\n    }\\n    bank.putCollateral(address(wstaking), id, amount);\\n\\n    // 7. Refund leftovers to users\\n    (address tokenA, address tokenB) = getPair(lp);\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n\\n    // 8. Refund reward\\n    doRefund(IWStakingRewards(wstaking).reward());\\n  }\\n\\n  struct RepayAmounts {\\n    uint amtLPTake;\\n    uint amtLPWithdraw;\\n    uint amtARepay;\\n    uint amtBRepay;\\n    uint amtLPRepay;\\n    uint amtAMin;\\n    uint amtBMin;\\n  }\\n\\n  function removeLiquidityInternal(address lp, RepayAmounts calldata amt) internal {\\n    (address tokenA, address tokenB) = getPair(lp);\\n    uint amtARepay = amt.amtARepay;\\n    uint amtBRepay = amt.amtBRepay;\\n    uint amtLPRepay = amt.amtLPRepay;\\n\\n    // 2. Compute repay amount if MAX_INT is supplied (max debt)\\n    {\\n      uint positionId = bank.POSITION_ID();\\n      if (amtARepay == uint(-1)) {\\n        amtARepay = bank.borrowBalanceCurrent(positionId, tokenA);\\n      }\\n      if (amtBRepay == uint(-1)) {\\n        amtBRepay = bank.borrowBalanceCurrent(positionId, tokenB);\\n      }\\n      if (amtLPRepay == uint(-1)) {\\n        amtLPRepay = bank.borrowBalanceCurrent(positionId, lp);\\n      }\\n    }\\n\\n    // 3.1 Remove liquidity 2 sides\\n    uint amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amt.amtLPWithdraw);\\n\\n    uint[] memory minAmountsOut = new uint[](2);\\n    IBalancerPool(lp).exitPool(amtLPToRemove, minAmountsOut);\\n\\n    // 3.2 Minimize trading\\n    uint amtADesired = amtARepay.add(amt.amtAMin);\\n    uint amtBDesired = amtBRepay.add(amt.amtBMin);\\n\\n    uint amtA = IERC20(tokenA).balanceOf(address(this));\\n    uint amtB = IERC20(tokenB).balanceOf(address(this));\\n\\n    if (amtA < amtADesired && amtB >= amtBDesired) {\\n      IBalancerPool(lp).swapExactAmountOut(\\n        tokenB,\\n        amtB.sub(amtBDesired),\\n        tokenA,\\n        amtADesired.sub(amtA),\\n        uint(-1)\\n      );\\n    } else if (amtA >= amtADesired && amtB < amtBDesired) {\\n      IBalancerPool(lp).swapExactAmountOut(\\n        tokenA,\\n        amtA.sub(amtADesired),\\n        tokenB,\\n        amtBDesired.sub(amtB),\\n        uint(-1)\\n      );\\n    }\\n\\n    // 4. Repay\\n    doRepay(tokenA, amtARepay);\\n    doRepay(tokenB, amtBRepay);\\n    doRepay(lp, amtLPRepay);\\n\\n    // 5. Slippage control\\n    require(IERC20(tokenA).balanceOf(address(this)) >= amt.amtAMin);\\n    require(IERC20(tokenB).balanceOf(address(this)) >= amt.amtBMin);\\n    require(IERC20(lp).balanceOf(address(this)) >= amt.amtLPWithdraw);\\n\\n    // 6. Refund leftover\\n    doRefundETH();\\n    doRefund(tokenA);\\n    doRefund(tokenB);\\n    doRefund(lp);\\n  }\\n\\n  function removeLiquidityWERC20(address lp, RepayAmounts calldata amt) external {\\n    // 1. Take out collateral\\n    doTakeCollateral(lp, amt.amtLPTake);\\n\\n    // 2-6. remove liquidity\\n    removeLiquidityInternal(lp, amt);\\n  }\\n\\n  function removeLiquidityWStakingRewards(\\n    address lp,\\n    RepayAmounts calldata amt,\\n    address wstaking\\n  ) external {\\n    uint positionId = bank.POSITION_ID();\\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\\n\\n    // 1. Take out collateral\\n    require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\\n    bank.takeCollateral(wstaking, collId, amt.amtLPTake);\\n    IWStakingRewards(wstaking).burn(collId, amt.amtLPTake);\\n\\n    // 2-6. remove liquidity\\n    removeLiquidityInternal(lp, amt);\\n\\n    // 7. Refund reward\\n    doRefund(IWStakingRewards(wstaking).reward());\\n  }\\n\\n  function harvestWStakingRewards(address wstaking) external {\\n    uint positionId = bank.POSITION_ID();\\n    (, , uint collId, ) = bank.getPositionInfo(positionId);\\n    address lp = IWStakingRewards(wstaking).getUnderlyingToken(collId);\\n\\n    // 1. Take out collateral\\n    bank.takeCollateral(wstaking, collId, uint(-1));\\n    IWStakingRewards(wstaking).burn(collId, uint(-1));\\n\\n    // 2. put collateral\\n    uint amount = IERC20(lp).balanceOf(address(this));\\n    ensureApprove(lp, wstaking);\\n    uint id = IWStakingRewards(wstaking).mint(amount);\\n    bank.putCollateral(wstaking, id, amount);\\n\\n    // 3. Refund reward\\n    doRefund(IWStakingRewards(wstaking).reward());\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IBalancerPool.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IBalancerPool {\\n  function getFinalTokens() external view returns (address[] memory);\\n\\n  function getNormalizedWeight(address token) external view returns (uint);\\n\\n  function getSwapFee() external view returns (uint);\\n\\n  function getNumTokens() external view returns (uint);\\n\\n  function getBalance(address token) external view returns (uint);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\\n\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint maxAmountIn,\\n    address tokenOut,\\n    uint tokenAmountOut,\\n    uint maxPrice\\n  ) external returns (uint tokenAmountIn, uint spotPriceAfter);\\n\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint tokenAmountIn,\\n    uint minPoolAmountOut\\n  ) external returns (uint poolAmountOut);\\n\\n  function exitPool(uint poolAmoutnIn, uint[] calldata minAmountsOut) external;\\n\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint tokenAmountOut,\\n    uint maxPoolAmountIn\\n  ) external returns (uint poolAmountIn);\\n}\\n\"\r\n    },\r\n    \"./contracts/spell/HouseHoldSpell.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\n\\nimport './BasicSpell.sol';\\nimport '../../interfaces/IBank.sol';\\nimport '../../interfaces/IWETH.sol';\\n\\ncontract HouseHoldSpell is BasicSpell {\\n  constructor(\\n    IBank _bank,\\n    address _werc20,\\n    address _weth\\n  ) public BasicSpell(_bank, _werc20, _weth) {}\\n\\n  function borrowETH(uint amount) external {\\n    doBorrow(weth, amount);\\n    doRefundETH();\\n  }\\n\\n  function borrow(address token, uint amount) external {\\n    doBorrow(token, amount);\\n    doRefund(token);\\n  }\\n\\n  function repayETH(uint amount) external payable {\\n    doTransmitETH();\\n    doRepay(weth, amount);\\n    doRefundETH();\\n  }\\n\\n  function repay(address token, uint amount) external {\\n    doTransmit(token, amount);\\n    doRepay(token, IERC20(token).balanceOf(address(this)));\\n  }\\n\\n  function putCollateral(address token, uint amount) external {\\n    doTransmit(token, amount);\\n    doPutCollateral(token, IERC20(token).balanceOf(address(this)));\\n  }\\n\\n  function takeCollateral(address token, uint amount) external {\\n    doTakeCollateral(token, amount);\\n    doRefund(token);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/mock/MockUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface MockUniswapV2FactoryIUniswapV2Factory {\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n  function feeTo() external view returns (address);\\n\\n  function feeToSetter() external view returns (address);\\n\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n  function allPairs(uint) external view returns (address pair);\\n\\n  function allPairsLength() external view returns (uint);\\n\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n  function setFeeTo(address) external;\\n\\n  function setFeeToSetter(address) external;\\n}\\n\\ninterface MockUniswapV2FactoryIUniswapV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function price0CumulativeLast() external view returns (uint);\\n\\n  function price1CumulativeLast() external view returns (uint);\\n\\n  function kLast() external view returns (uint);\\n\\n  function mint(address to) external returns (uint liquidity);\\n\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n\\n  function swap(\\n    uint amount0Out,\\n    uint amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n\\n  function skim(address to) external;\\n\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\\n\\ninterface MockUniswapV2FactoryIUniswapV2ERC20 {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n}\\n\\ninterface MockUniswapV2FactoryIERC20 {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool);\\n}\\n\\ninterface IUniswapV2Callee {\\n  function uniswapV2Call(\\n    address sender,\\n    uint amount0,\\n    uint amount1,\\n    bytes calldata data\\n  ) external;\\n}\\n\\ncontract UniswapV2ERC20 {\\n  using MockUniswapV2FactorySafeMath for uint;\\n\\n  string public constant name = 'Uniswap V2';\\n  string public constant symbol = 'UNI-V2';\\n  uint8 public constant decimals = 18;\\n  uint public totalSupply;\\n  mapping(address => uint) public balanceOf;\\n  mapping(address => mapping(address => uint)) public allowance;\\n\\n  bytes32 public DOMAIN_SEPARATOR;\\n  // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  bytes32 public constant PERMIT_TYPEHASH =\\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n  mapping(address => uint) public nonces;\\n\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  constructor() public {\\n    uint chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\n          'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n        ),\\n        keccak256(bytes(name)),\\n        keccak256(bytes('1')),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  function _mint(address to, uint value) internal {\\n    totalSupply = totalSupply.add(value);\\n    balanceOf[to] = balanceOf[to].add(value);\\n    emit Transfer(address(0), to, value);\\n  }\\n\\n  function _burn(address from, uint value) internal {\\n    balanceOf[from] = balanceOf[from].sub(value);\\n    totalSupply = totalSupply.sub(value);\\n    emit Transfer(from, address(0), value);\\n  }\\n\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint value\\n  ) private {\\n    allowance[owner][spender] = value;\\n    emit Approval(owner, spender, value);\\n  }\\n\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint value\\n  ) private {\\n    balanceOf[from] = balanceOf[from].sub(value);\\n    balanceOf[to] = balanceOf[to].add(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  function approve(address spender, uint value) external returns (bool) {\\n    _approve(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  function transfer(address to, uint value) external returns (bool) {\\n    _transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool) {\\n    if (allowance[from][msg.sender] != uint(-1)) {\\n      allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n    }\\n    _transfer(from, to, value);\\n    return true;\\n  }\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\\n    bytes32 digest =\\n      keccak256(\\n        abi.encodePacked(\\n          '\\\\x19\\\\x01',\\n          DOMAIN_SEPARATOR,\\n          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n        )\\n      );\\n    address recoveredAddress = ecrecover(digest, v, r, s);\\n    require(\\n      recoveredAddress != address(0) && recoveredAddress == owner,\\n      'UniswapV2: INVALID_SIGNATURE'\\n    );\\n    _approve(owner, spender, value);\\n  }\\n}\\n\\ncontract MockUniswapV2FactoryUniswapV2Pair is UniswapV2ERC20 {\\n  using MockUniswapV2FactorySafeMath for uint;\\n  using UQ112x112 for uint224;\\n\\n  uint public constant MINIMUM_LIQUIDITY = 10**3;\\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\n  address public factory;\\n  address public token0;\\n  address public token1;\\n\\n  uint112 private reserve0; // uses single storage slot, accessible via getReserves\\n  uint112 private reserve1; // uses single storage slot, accessible via getReserves\\n  uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n  uint public price0CumulativeLast;\\n  uint public price1CumulativeLast;\\n  uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n  uint private unlocked = 1;\\n  modifier lock() {\\n    require(unlocked == 1, 'UniswapV2: LOCKED');\\n    unlocked = 0;\\n    _;\\n    unlocked = 1;\\n  }\\n\\n  function getReserves()\\n    public\\n    view\\n    returns (\\n      uint112 _reserve0,\\n      uint112 _reserve1,\\n      uint32 _blockTimestampLast\\n    )\\n  {\\n    _reserve0 = reserve0;\\n    _reserve1 = reserve1;\\n    _blockTimestampLast = blockTimestampLast;\\n  }\\n\\n  function _safeTransfer(\\n    address token,\\n    address to,\\n    uint value\\n  ) private {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      'UniswapV2: TRANSFER_FAILED'\\n    );\\n  }\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  constructor() public {\\n    factory = msg.sender;\\n  }\\n\\n  // called once by the factory at time of deployment\\n  function initialize(address _token0, address _token1) external {\\n    require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\\n    token0 = _token0;\\n    token1 = _token1;\\n  }\\n\\n  // update reserves and, on the first call per block, price accumulators\\n  function _update(\\n    uint balance0,\\n    uint balance1,\\n    uint112 _reserve0,\\n    uint112 _reserve1\\n  ) private {\\n    require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\\n    uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n      // * never overflows, and + overflow is desired\\n      price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n      price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n    }\\n    reserve0 = uint112(balance0);\\n    reserve1 = uint112(balance1);\\n    blockTimestampLast = blockTimestamp;\\n    emit Sync(reserve0, reserve1);\\n  }\\n\\n  // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n  function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\\n    address feeTo = MockUniswapV2FactoryIUniswapV2Factory(factory).feeTo();\\n    feeOn = feeTo != address(0);\\n    uint _kLast = kLast; // gas savings\\n    if (feeOn) {\\n      if (_kLast != 0) {\\n        uint rootK = MockUniswapV2FactoryMah.sqrt(uint(_reserve0).mul(_reserve1));\\n        uint rootKLast = MockUniswapV2FactoryMah.sqrt(_kLast);\\n        if (rootK > rootKLast) {\\n          uint numerator = totalSupply.mul(rootK.sub(rootKLast));\\n          uint denominator = rootK.mul(5).add(rootKLast);\\n          uint liquidity = numerator / denominator;\\n          if (liquidity > 0) _mint(feeTo, liquidity);\\n        }\\n      }\\n    } else if (_kLast != 0) {\\n      kLast = 0;\\n    }\\n  }\\n\\n  // this low-level function should be called from a contract which performs important safety checks\\n  function mint(address to) external lock returns (uint liquidity) {\\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n    uint balance0 = MockUniswapV2FactoryIERC20(token0).balanceOf(address(this));\\n    uint balance1 = MockUniswapV2FactoryIERC20(token1).balanceOf(address(this));\\n    uint amount0 = balance0.sub(_reserve0);\\n    uint amount1 = balance1.sub(_reserve1);\\n\\n    bool feeOn = _mintFee(_reserve0, _reserve1);\\n    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n    if (_totalSupply == 0) {\\n      liquidity = MockUniswapV2FactoryMah.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n      _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n    } else {\\n      liquidity = MockUniswapV2FactoryMah.min(\\n        amount0.mul(_totalSupply) / _reserve0,\\n        amount1.mul(_totalSupply) / _reserve1\\n      );\\n    }\\n    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\\n    _mint(to, liquidity);\\n\\n    _update(balance0, balance1, _reserve0, _reserve1);\\n    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n    emit Mint(msg.sender, amount0, amount1);\\n  }\\n\\n  // this low-level function should be called from a contract which performs important safety checks\\n  function burn(address to) external lock returns (uint amount0, uint amount1) {\\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n    address _token0 = token0; // gas savings\\n    address _token1 = token1; // gas savings\\n    uint balance0 = MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this));\\n    uint balance1 = MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this));\\n    uint liquidity = balanceOf[address(this)];\\n\\n    bool feeOn = _mintFee(_reserve0, _reserve1);\\n    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n    require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\\n    _burn(address(this), liquidity);\\n    _safeTransfer(_token0, to, amount0);\\n    _safeTransfer(_token1, to, amount1);\\n    balance0 = MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this));\\n    balance1 = MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this));\\n\\n    _update(balance0, balance1, _reserve0, _reserve1);\\n    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n    emit Burn(msg.sender, amount0, amount1, to);\\n  }\\n\\n  // this low-level function should be called from a contract which performs important safety checks\\n  function swap(\\n    uint amount0Out,\\n    uint amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external lock {\\n    require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\\n\\n    uint balance0;\\n    uint balance1;\\n    {\\n      // scope for _token{0,1}, avoids stack too deep errors\\n      address _token0 = token0;\\n      address _token1 = token1;\\n      require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n      if (data.length > 0)\\n        IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\\n      balance0 = MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this));\\n      balance1 = MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this));\\n    }\\n    uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n    uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n    require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\\n    {\\n      // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n      uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\\n      uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\\n      require(\\n        balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2),\\n        'UniswapV2: K'\\n      );\\n    }\\n\\n    _update(balance0, balance1, _reserve0, _reserve1);\\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n  }\\n\\n  // force balances to match reserves\\n  function skim(address to) external lock {\\n    address _token0 = token0; // gas savings\\n    address _token1 = token1; // gas savings\\n    _safeTransfer(\\n      _token0,\\n      to,\\n      MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this)).sub(reserve0)\\n    );\\n    _safeTransfer(\\n      _token1,\\n      to,\\n      MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this)).sub(reserve1)\\n    );\\n  }\\n\\n  // force reserves to match balances\\n  function sync() external lock {\\n    _update(\\n      MockUniswapV2FactoryIERC20(token0).balanceOf(address(this)),\\n      MockUniswapV2FactoryIERC20(token1).balanceOf(address(this)),\\n      reserve0,\\n      reserve1\\n    );\\n  }\\n}\\n\\ncontract MockUniswapV2Factory {\\n  address public feeTo;\\n  address public feeToSetter;\\n\\n  mapping(address => mapping(address => address)) public getPair;\\n  address[] public allPairs;\\n\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n  constructor(address _feeToSetter) public {\\n    feeToSetter = _feeToSetter;\\n  }\\n\\n  function allPairsLength() external view returns (uint) {\\n    return allPairs.length;\\n  }\\n\\n  function createPair(address tokenA, address tokenB) external returns (address pair) {\\n    require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\\n    require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\\n    bytes memory bytecode = type(MockUniswapV2FactoryUniswapV2Pair).creationCode;\\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n    assembly {\\n      pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n    }\\n    MockUniswapV2FactoryIUniswapV2Pair(pair).initialize(token0, token1);\\n    getPair[token0][token1] = pair;\\n    getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n    allPairs.push(pair);\\n    emit PairCreated(token0, token1, pair, allPairs.length);\\n  }\\n\\n  function setFeeTo(address _feeTo) external {\\n    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n    feeTo = _feeTo;\\n  }\\n\\n  function setFeeToSetter(address _feeToSetter) external {\\n    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n    feeToSetter = _feeToSetter;\\n  }\\n}\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary MockUniswapV2FactorySafeMath {\\n  function add(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x + y) >= x, 'ds-math-add-overflow');\\n  }\\n\\n  function sub(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x - y) <= x, 'ds-math-sub-underflow');\\n  }\\n\\n  function mul(uint x, uint y) internal pure returns (uint z) {\\n    require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n  }\\n}\\n\\n// a library for performing various math operations\\n\\nlibrary MockUniswapV2FactoryMah {\\n  function min(uint x, uint y) internal pure returns (uint z) {\\n    z = x < y ? x : y;\\n  }\\n\\n  // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n  function sqrt(uint y) internal pure returns (uint z) {\\n    if (y > 3) {\\n      z = y;\\n      uint x = y / 2 + 1;\\n      while (x < z) {\\n        z = x;\\n        x = (y / x + x) / 2;\\n      }\\n    } else if (y != 0) {\\n      z = 1;\\n    }\\n  }\\n}\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n  uint224 constant Q112 = 2**112;\\n\\n  // encode a uint112 as a UQ112x112\\n  function encode(uint112 y) internal pure returns (uint224 z) {\\n    z = uint224(y) * Q112; // never overflows\\n  }\\n\\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n    z = x / uint224(y);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/mock/MockERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/ERC20.sol';\\n\\ncontract MockERC20 is ERC20 {\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    uint8 decimals\\n  ) public ERC20(name, symbol) {\\n    _setupDecimals(decimals);\\n  }\\n\\n  function mint(address to, uint amount) public {\\n    _mint(to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/mock/MockCErc20_2.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\n// import 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport '../../interfaces/ICErc20_2.sol';\\n\\ncontract MockCErc20_2 is ICErc20_2 {\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  IERC20 public token;\\n  uint public mintRate = 1e18;\\n  uint public totalSupply = 0;\\n  mapping(address => uint) public override balanceOf;\\n\\n  constructor(IERC20 _token) public {\\n    token = _token;\\n  }\\n\\n  function setMintRate(uint _mintRate) external override {\\n    mintRate = _mintRate;\\n  }\\n\\n  function underlying() external override returns (address) {\\n    return address(token);\\n  }\\n\\n  function mint(uint mintAmount) external override returns (uint) {\\n    uint amountIn = mintAmount.mul(mintRate).div(1e18);\\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\\n    totalSupply = totalSupply.add(mintAmount);\\n    balanceOf[msg.sender] = balanceOf[msg.sender].add(mintAmount);\\n    return 0;\\n  }\\n\\n  function redeem(uint redeemAmount) external override returns (uint) {\\n    uint amountOut = redeemAmount.mul(1e18).div(mintRate);\\n    IERC20(token).safeTransfer(msg.sender, amountOut);\\n    totalSupply = totalSupply.sub(redeemAmount);\\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(redeemAmount);\\n    return 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/ICErc20_2.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface ICErc20_2 {\\n  function underlying() external returns (address);\\n\\n  function mint(uint mintAmount) external returns (uint);\\n\\n  function redeem(uint redeemTokens) external returns (uint);\\n\\n  function balanceOf(address user) external view returns (uint);\\n\\n  function setMintRate(uint mintRate) external;\\n}\\n\"\r\n    },\r\n    \"./contracts/mock/MockUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface MockUniswapV2Router02IUniswapV2Factory {\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n  function feeTo() external view returns (address);\\n\\n  function feeToSetter() external view returns (address);\\n\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n  function allPairs(uint) external view returns (address pair);\\n\\n  function allPairsLength() external view returns (uint);\\n\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n  function setFeeTo(address) external;\\n\\n  function setFeeToSetter(address) external;\\n}\\n\\ninterface MockUniswapV2Router02IUniswapV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function price0CumulativeLast() external view returns (uint);\\n\\n  function price1CumulativeLast() external view returns (uint);\\n\\n  function kLast() external view returns (uint);\\n\\n  function mint(address to) external returns (uint liquidity);\\n\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n\\n  function swap(\\n    uint amount0Out,\\n    uint amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n\\n  function skim(address to) external;\\n\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\\n\\ninterface MockUniswapV2Router02IUniswapV2Router01 {\\n  function factory() external pure returns (address);\\n\\n  function WETH() external pure returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    returns (\\n      uint amountA,\\n      uint amountB,\\n      uint liquidity\\n    );\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    payable\\n    returns (\\n      uint amountToken,\\n      uint amountETH,\\n      uint liquidity\\n    );\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n  ) external pure returns (uint amountB);\\n\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountOut);\\n\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountIn);\\n\\n  function getAmountsOut(uint amountIn, address[] calldata path)\\n    external\\n    view\\n    returns (uint[] memory amounts);\\n\\n  function getAmountsIn(uint amountOut, address[] calldata path)\\n    external\\n    view\\n    returns (uint[] memory amounts);\\n}\\n\\ninterface MockUniswapV2Router02IUniswapV2Router02 is MockUniswapV2Router02IUniswapV2Router01 {\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\\n\\ninterface IERC20 {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool);\\n}\\n\\ninterface MockUniswapV2Router02IWETH {\\n  function deposit() external payable;\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function withdraw(uint) external;\\n}\\n\\ncontract MockUniswapV2Router02 is MockUniswapV2Router02IUniswapV2Router02 {\\n  using MockUniswapV2Router02SafeMath for uint;\\n\\n  address public immutable override factory;\\n  address public immutable override WETH;\\n\\n  modifier ensure(uint deadline) {\\n    require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\\n    _;\\n  }\\n\\n  constructor(address _factory, address _WETH) public {\\n    factory = _factory;\\n    WETH = _WETH;\\n  }\\n\\n  receive() external payable {\\n    assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n  }\\n\\n  // **** ADD LIQUIDITY ****\\n  function _addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin\\n  ) internal virtual returns (uint amountA, uint amountB) {\\n    // create the pair if it doesn't exist yet\\n    if (MockUniswapV2Router02IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\\n      MockUniswapV2Router02IUniswapV2Factory(factory).createPair(tokenA, tokenB);\\n    }\\n    (uint reserveA, uint reserveB) =\\n      MockUniswapV2Router02UniswapV2Library.getReserves(factory, tokenA, tokenB);\\n    if (reserveA == 0 && reserveB == 0) {\\n      (amountA, amountB) = (amountADesired, amountBDesired);\\n    } else {\\n      uint amountBOptimal =\\n        MockUniswapV2Router02UniswapV2Library.quote(amountADesired, reserveA, reserveB);\\n      if (amountBOptimal <= amountBDesired) {\\n        require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\\n        (amountA, amountB) = (amountADesired, amountBOptimal);\\n      } else {\\n        uint amountAOptimal =\\n          MockUniswapV2Router02UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\\n        assert(amountAOptimal <= amountADesired);\\n        require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\\n        (amountA, amountB) = (amountAOptimal, amountBDesired);\\n      }\\n    }\\n  }\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (\\n      uint amountA,\\n      uint amountB,\\n      uint liquidity\\n    )\\n  {\\n    (amountA, amountB) = _addLiquidity(\\n      tokenA,\\n      tokenB,\\n      amountADesired,\\n      amountBDesired,\\n      amountAMin,\\n      amountBMin\\n    );\\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n    liquidity = MockUniswapV2Router02IUniswapV2Pair(pair).mint(to);\\n  }\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    payable\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (\\n      uint amountToken,\\n      uint amountETH,\\n      uint liquidity\\n    )\\n  {\\n    (amountToken, amountETH) = _addLiquidity(\\n      token,\\n      WETH,\\n      amountTokenDesired,\\n      msg.value,\\n      amountTokenMin,\\n      amountETHMin\\n    );\\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, token, WETH);\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amountETH}();\\n    assert(MockUniswapV2Router02IWETH(WETH).transfer(pair, amountETH));\\n    liquidity = MockUniswapV2Router02IUniswapV2Pair(pair).mint(to);\\n    // refund dust eth, if any\\n    if (msg.value > amountETH)\\n      MockUniswapV2Router02TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n  }\\n\\n  // **** REMOVE LIQUIDITY ****\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n    MockUniswapV2Router02IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n    (uint amount0, uint amount1) = MockUniswapV2Router02IUniswapV2Pair(pair).burn(to);\\n    (address token0, ) = MockUniswapV2Router02UniswapV2Library.sortTokens(tokenA, tokenB);\\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\\n    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\\n  }\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\\n    (amountToken, amountETH) = removeLiquidity(\\n      token,\\n      WETH,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      address(this),\\n      deadline\\n    );\\n    MockUniswapV2Router02TransferHelper.safeTransfer(token, to, amountToken);\\n    MockUniswapV2Router02IWETH(WETH).withdraw(amountETH);\\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amountETH);\\n  }\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual override returns (uint amountA, uint amountB) {\\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n    uint value = approveMax ? uint(-1) : liquidity;\\n    MockUniswapV2Router02IUniswapV2Pair(pair).permit(\\n      msg.sender,\\n      address(this),\\n      value,\\n      deadline,\\n      v,\\n      r,\\n      s\\n    );\\n    (amountA, amountB) = removeLiquidity(\\n      tokenA,\\n      tokenB,\\n      liquidity,\\n      amountAMin,\\n      amountBMin,\\n      to,\\n      deadline\\n    );\\n  }\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual override returns (uint amountToken, uint amountETH) {\\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, token, WETH);\\n    uint value = approveMax ? uint(-1) : liquidity;\\n    MockUniswapV2Router02IUniswapV2Pair(pair).permit(\\n      msg.sender,\\n      address(this),\\n      value,\\n      deadline,\\n      v,\\n      r,\\n      s\\n    );\\n    (amountToken, amountETH) = removeLiquidityETH(\\n      token,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      to,\\n      deadline\\n    );\\n  }\\n\\n  // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) public virtual override ensure(deadline) returns (uint amountETH) {\\n    (, amountETH) = removeLiquidity(\\n      token,\\n      WETH,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      address(this),\\n      deadline\\n    );\\n    MockUniswapV2Router02TransferHelper.safeTransfer(\\n      token,\\n      to,\\n      IERC20(token).balanceOf(address(this))\\n    );\\n    MockUniswapV2Router02IWETH(WETH).withdraw(amountETH);\\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amountETH);\\n  }\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual override returns (uint amountETH) {\\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, token, WETH);\\n    uint value = approveMax ? uint(-1) : liquidity;\\n    MockUniswapV2Router02IUniswapV2Pair(pair).permit(\\n      msg.sender,\\n      address(this),\\n      value,\\n      deadline,\\n      v,\\n      r,\\n      s\\n    );\\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n      token,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      to,\\n      deadline\\n    );\\n  }\\n\\n  // **** SWAP ****\\n  // requires the initial amount to have already been sent to the first pair\\n  function _swap(\\n    uint[] memory amounts,\\n    address[] memory path,\\n    address _to\\n  ) internal virtual {\\n    for (uint i; i < path.length - 1; i++) {\\n      (address input, address output) = (path[i], path[i + 1]);\\n      (address token0, ) = MockUniswapV2Router02UniswapV2Library.sortTokens(input, output);\\n      uint amountOut = amounts[i + 1];\\n      (uint amount0Out, uint amount1Out) =\\n        input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n      address to =\\n        i < path.length - 2\\n          ? MockUniswapV2Router02UniswapV2Library.pairFor(factory, output, path[i + 2])\\n          : _to;\\n      MockUniswapV2Router02IUniswapV2Pair(\\n        MockUniswapV2Router02UniswapV2Library.pairFor(factory, input, output)\\n      )\\n        .swap(amount0Out, amount1Out, to, new bytes(0));\\n    }\\n  }\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n    require(\\n      amounts[amounts.length - 1] >= amountOutMin,\\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n    );\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n  }\\n\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n    require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n  }\\n\\n  function swapExactETHForTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, msg.value, path);\\n    require(\\n      amounts[amounts.length - 1] >= amountOutMin,\\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n    );\\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amounts[0]}();\\n    assert(\\n      MockUniswapV2Router02IWETH(WETH).transfer(\\n        MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n        amounts[0]\\n      )\\n    );\\n    _swap(amounts, path, to);\\n  }\\n\\n  function swapTokensForExactETH(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n    require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    MockUniswapV2Router02IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n  }\\n\\n  function swapExactTokensForETH(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n    require(\\n      amounts[amounts.length - 1] >= amountOutMin,\\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n    );\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    MockUniswapV2Router02IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n  }\\n\\n  function swapETHForExactTokens(\\n    uint amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n    require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amounts[0]}();\\n    assert(\\n      MockUniswapV2Router02IWETH(WETH).transfer(\\n        MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n        amounts[0]\\n      )\\n    );\\n    _swap(amounts, path, to);\\n    // refund dust eth, if any\\n    if (msg.value > amounts[0])\\n      MockUniswapV2Router02TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n  }\\n\\n  // **** SWAP (supporting fee-on-transfer tokens) ****\\n  // requires the initial amount to have already been sent to the first pair\\n  function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\\n    for (uint i; i < path.length - 1; i++) {\\n      (address input, address output) = (path[i], path[i + 1]);\\n      (address token0, ) = MockUniswapV2Router02UniswapV2Library.sortTokens(input, output);\\n      MockUniswapV2Router02IUniswapV2Pair pair =\\n        MockUniswapV2Router02IUniswapV2Pair(\\n          MockUniswapV2Router02UniswapV2Library.pairFor(factory, input, output)\\n        );\\n      uint amountInput;\\n      uint amountOutput;\\n      {\\n        // scope to avoid stack too deep errors\\n        (uint reserve0, uint reserve1, ) = pair.getReserves();\\n        (uint reserveInput, uint reserveOutput) =\\n          input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n        amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\\n        amountOutput = MockUniswapV2Router02UniswapV2Library.getAmountOut(\\n          amountInput,\\n          reserveInput,\\n          reserveOutput\\n        );\\n      }\\n      (uint amount0Out, uint amount1Out) =\\n        input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\\n      address to =\\n        i < path.length - 2\\n          ? MockUniswapV2Router02UniswapV2Library.pairFor(factory, output, path[i + 2])\\n          : _to;\\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n    }\\n  }\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) {\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n      amountIn\\n    );\\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n    _swapSupportingFeeOnTransferTokens(path, to);\\n    require(\\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n    );\\n  }\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable virtual override ensure(deadline) {\\n    require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\\n    uint amountIn = msg.value;\\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amountIn}();\\n    assert(\\n      MockUniswapV2Router02IWETH(WETH).transfer(\\n        MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n        amountIn\\n      )\\n    );\\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n    _swapSupportingFeeOnTransferTokens(path, to);\\n    require(\\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n    );\\n  }\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) {\\n    require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\\n      amountIn\\n    );\\n    _swapSupportingFeeOnTransferTokens(path, address(this));\\n    uint amountOut = IERC20(WETH).balanceOf(address(this));\\n    require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n    MockUniswapV2Router02IWETH(WETH).withdraw(amountOut);\\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amountOut);\\n  }\\n\\n  // **** LIBRARY FUNCTIONS ****\\n  function quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n  ) public pure virtual override returns (uint amountB) {\\n    return MockUniswapV2Router02UniswapV2Library.quote(amountA, reserveA, reserveB);\\n  }\\n\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) public pure virtual override returns (uint amountOut) {\\n    return MockUniswapV2Router02UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\\n  }\\n\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) public pure virtual override returns (uint amountIn) {\\n    return MockUniswapV2Router02UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\\n  }\\n\\n  function getAmountsOut(uint amountIn, address[] memory path)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint[] memory amounts)\\n  {\\n    return MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n  }\\n\\n  function getAmountsIn(uint amountOut, address[] memory path)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint[] memory amounts)\\n  {\\n    return MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n  }\\n}\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary MockUniswapV2Router02SafeMath {\\n  function add(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x + y) >= x, 'ds-math-add-overflow');\\n  }\\n\\n  function sub(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x - y) <= x, 'ds-math-sub-underflow');\\n  }\\n\\n  function mul(uint x, uint y) internal pure returns (uint z) {\\n    require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n  }\\n}\\n\\nlibrary MockUniswapV2Router02UniswapV2Library {\\n  using MockUniswapV2Router02SafeMath for uint;\\n\\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n  function sortTokens(address tokenA, address tokenB)\\n    internal\\n    pure\\n    returns (address token0, address token1)\\n  {\\n    require(tokenA != tokenB, 'MockUniswapV2Router02UniswapV2Library: IDENTICAL_ADDRESSES');\\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), 'MockUniswapV2Router02UniswapV2Library: ZERO_ADDRESS');\\n  }\\n\\n  // calculates the CREATE2 address for a pair without making any external calls\\n  function pairFor(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal view returns (address pair) {\\n    return MockUniswapV2Router02IUniswapV2Factory(factory).getPair(tokenA, tokenB);\\n  }\\n\\n  // fetches and sorts the reserves for a pair\\n  function getReserves(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal view returns (uint reserveA, uint reserveB) {\\n    (address token0, ) = sortTokens(tokenA, tokenB);\\n    (uint reserve0, uint reserve1, ) =\\n      MockUniswapV2Router02IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n  }\\n\\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n  function quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n  ) internal pure returns (uint amountB) {\\n    require(amountA > 0, 'MockUniswapV2Router02UniswapV2Library: INSUFFICIENT_AMOUNT');\\n    require(\\n      reserveA > 0 && reserveB > 0,\\n      'MockUniswapV2Router02UniswapV2Library: INSUFFICIENT_LIQUIDITY'\\n    );\\n    amountB = amountA.mul(reserveB) / reserveA;\\n  }\\n\\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) internal pure returns (uint amountOut) {\\n    require(amountIn > 0, 'MockUniswapV2Router02UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n    require(\\n      reserveIn > 0 && reserveOut > 0,\\n      'MockUniswapV2Router02UniswapV2Library: INSUFFICIENT_LIQUIDITY'\\n    );\\n    uint amountInWithFee = amountIn.mul(997);\\n    uint numerator = amountInWithFee.mul(reserveOut);\\n    uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n    amountOut = numerator / denominator;\\n  }\\n\\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) internal pure returns (uint amountIn) {\\n    require(amountOut > 0, 'MockUniswapV2Router02UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\n    require(\\n      reserveIn > 0 && reserveOut > 0,\\n      'MockUniswapV2Router02UniswapV2Library: INSUFFICIENT_LIQUIDITY'\\n    );\\n    uint numerator = reserveIn.mul(amountOut).mul(1000);\\n    uint denominator = reserveOut.sub(amountOut).mul(997);\\n    amountIn = (numerator / denominator).add(1);\\n  }\\n\\n  // performs chained getAmountOut calculations on any number of pairs\\n  function getAmountsOut(\\n    address factory,\\n    uint amountIn,\\n    address[] memory path\\n  ) internal view returns (uint[] memory amounts) {\\n    require(path.length >= 2, 'MockUniswapV2Router02UniswapV2Library: INVALID_PATH');\\n    amounts = new uint[](path.length);\\n    amounts[0] = amountIn;\\n    for (uint i; i < path.length - 1; i++) {\\n      (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n\\n  // performs chained getAmountIn calculations on any number of pairs\\n  function getAmountsIn(\\n    address factory,\\n    uint amountOut,\\n    address[] memory path\\n  ) internal view returns (uint[] memory amounts) {\\n    require(path.length >= 2, 'MockUniswapV2Router02UniswapV2Library: INVALID_PATH');\\n    amounts = new uint[](path.length);\\n    amounts[amounts.length - 1] = amountOut;\\n    for (uint i = path.length - 1; i > 0; i--) {\\n      (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n}\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary MockUniswapV2Router02TransferHelper {\\n  function safeApprove(\\n    address token,\\n    address to,\\n    uint value\\n  ) internal {\\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      'MockUniswapV2Router02TransferHelper: APPROVE_FAILED'\\n    );\\n  }\\n\\n  function safeTransfer(\\n    address token,\\n    address to,\\n    uint value\\n  ) internal {\\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      'MockUniswapV2Router02TransferHelper: TRANSFER_FAILED'\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    address token,\\n    address from,\\n    address to,\\n    uint value\\n  ) internal {\\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n    (bool success, bytes memory data) =\\n      token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      'MockUniswapV2Router02TransferHelper: TRANSFER_FROM_FAILED'\\n    );\\n  }\\n\\n  function safeTransferETH(address to, uint value) internal {\\n    (bool success, ) = to.call{value: value}(new bytes(0));\\n    require(success, 'MockUniswapV2Router02TransferHelper: ETH_TRANSFER_FAILED');\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/mock/MockCErc20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport '../../interfaces/ICErc20.sol';\\n\\ncontract MockCErc20 is ICErc20 {\\n  using SafeMath for uint;\\n\\n  IERC20 public token;\\n  uint public interestPerYear = 10e16; // 10% per year\\n\\n  mapping(address => uint) public borrows;\\n  mapping(address => uint) public lastBlock;\\n\\n  constructor(IERC20 _token) public {\\n    token = _token;\\n  }\\n\\n  function decimals() external override returns (uint8) {\\n    return 8;\\n  }\\n\\n  function underlying() external override returns (address) {\\n    return address(token);\\n  }\\n\\n  function mint(uint mintAmount) external override returns (uint) {\\n    // Not implemented\\n    return 0;\\n  }\\n\\n  function redeem(uint redeemTokens) external override returns (uint) {\\n    // Not implemented\\n    return 0;\\n  }\\n\\n  function balanceOf(address user) external view override returns (uint) {\\n    // Not implemented\\n    return 0;\\n  }\\n\\n  function borrowBalanceCurrent(address account) public override returns (uint) {\\n    uint timePast = now - lastBlock[account];\\n    if (timePast > 0) {\\n      uint interest = borrows[account].mul(interestPerYear).div(100e16).mul(timePast).div(365 days);\\n      borrows[account] = borrows[account].add(interest);\\n      lastBlock[account] = now;\\n    }\\n    return borrows[account];\\n  }\\n\\n  function borrowBalanceStored(address account) external view override returns (uint) {\\n    return borrows[account];\\n  }\\n\\n  function borrow(uint borrowAmount) external override returns (uint) {\\n    borrowBalanceCurrent(msg.sender);\\n    token.transfer(msg.sender, borrowAmount);\\n    borrows[msg.sender] = borrows[msg.sender].add(borrowAmount);\\n    return 0;\\n  }\\n\\n  function repayBorrow(uint repayAmount) external override returns (uint) {\\n    borrowBalanceCurrent(msg.sender);\\n    token.transferFrom(msg.sender, address(this), repayAmount);\\n    borrows[msg.sender] = borrows[msg.sender].sub(repayAmount);\\n    return 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/mock/MockWETH.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ncontract MockWETH {\\n  string public name = 'Wrapped Ether';\\n  string public symbol = 'WETH';\\n  uint8 public decimals = 18;\\n\\n  event Approval(address indexed src, address indexed guy, uint wad);\\n  event Transfer(address indexed src, address indexed dst, uint wad);\\n  event Deposit(address indexed dst, uint wad);\\n  event Withdrawal(address indexed src, uint wad);\\n\\n  mapping(address => uint) public balanceOf;\\n  mapping(address => mapping(address => uint)) public allowance;\\n\\n  receive() external payable {\\n    deposit();\\n  }\\n\\n  function deposit() public payable {\\n    balanceOf[msg.sender] += msg.value;\\n    emit Deposit(msg.sender, msg.value);\\n  }\\n\\n  function withdraw(uint wad) public {\\n    require(balanceOf[msg.sender] >= wad);\\n    balanceOf[msg.sender] -= wad;\\n    msg.sender.transfer(wad);\\n    emit Withdrawal(msg.sender, wad);\\n  }\\n\\n  function totalSupply() public view returns (uint) {\\n    return address(this).balance;\\n  }\\n\\n  function approve(address guy, uint wad) public returns (bool) {\\n    allowance[msg.sender][guy] = wad;\\n    emit Approval(msg.sender, guy, wad);\\n    return true;\\n  }\\n\\n  function transfer(address dst, uint wad) public returns (bool) {\\n    return transferFrom(msg.sender, dst, wad);\\n  }\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint wad\\n  ) public returns (bool) {\\n    require(balanceOf[src] >= wad);\\n\\n    if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\\n      require(allowance[src][msg.sender] >= wad);\\n      allowance[src][msg.sender] -= wad;\\n    }\\n\\n    balanceOf[src] -= wad;\\n    balanceOf[dst] += wad;\\n\\n    emit Transfer(src, dst, wad);\\n\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/UsingBaseOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport '../../interfaces/IBaseOracle.sol';\\n\\ncontract UsingBaseOracle {\\n  IBaseOracle public immutable base;\\n\\n  constructor(IBaseOracle _base) public {\\n    base = _base;\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IBaseOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IBaseOracle {\\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\\n  /// @param token The ERC-20 token to check the value.\\n  function getETHPx(address token) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/SimpleOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport '../Governable.sol';\\nimport '../../interfaces/IBaseOracle.sol';\\n\\ncontract SimpleOracle is IBaseOracle, Governable {\\n  mapping(address => uint) public prices; // Mapping from token to price in ETH (times 2**112).\\n\\n  /// The governor sets oracle price for a token.\\n  event SetETHPx(address token, uint px);\\n\\n  /// @dev Create the contract and initialize the first governor.\\n  constructor() public {\\n    __Governable__init();\\n  }\\n\\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\\n  /// @param token The ERC-20 token to check the value.\\n  function getETHPx(address token) external view override returns (uint) {\\n    uint px = prices[token];\\n    require(px != 0, 'no px');\\n    return px;\\n  }\\n\\n  /// @dev Set the prices of the given token addresses.\\n  /// @param tokens The token addresses to set the prices.\\n  /// @param pxs The price data points, representing token value in ETH times 2**112.\\n  function setETHPx(address[] memory tokens, uint[] memory pxs) external onlyGov {\\n    require(tokens.length == pxs.length, 'inconsistent length');\\n    for (uint idx = 0; idx < tokens.length; idx++) {\\n      prices[tokens[idx]] = pxs[idx];\\n      emit SetETHPx(tokens[idx], pxs[idx]);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/BandAdapterOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport '../Governable.sol';\\nimport '../../interfaces/IBaseOracle.sol';\\n\\ninterface IStdReference {\\n  /// A structure returned whenever someone requests for standard reference data.\\n  struct ReferenceData {\\n    uint rate; // base/quote exchange rate, multiplied by 1e18.\\n    uint lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\\n    uint lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\\n  }\\n\\n  /// Returns the price data for the given base/quote pair. Revert if not available.\\n  function getReferenceData(string memory _base, string memory _quote)\\n    external\\n    view\\n    returns (ReferenceData memory);\\n\\n  /// Similar to getReferenceData, but with multiple base/quote pairs at once.\\n  function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes)\\n    external\\n    view\\n    returns (ReferenceData[] memory);\\n}\\n\\ninterface BandDetailedERC20 {\\n  function decimals() external view returns (uint8);\\n}\\n\\ncontract BandAdapterOracle is IBaseOracle, Governable {\\n  using SafeMath for uint;\\n  string public constant ETH = 'ETH';\\n\\n  IStdReference public ref;\\n  uint public maxDelayTime;\\n\\n  mapping(address => string) public symbols;\\n\\n  constructor(IStdReference _ref, uint _maxDelayTime) public {\\n    __Governable__init();\\n    ref = _ref;\\n    maxDelayTime = _maxDelayTime;\\n  }\\n\\n  function setSymbols(string[] memory syms, address[] memory tokens) external onlyGov {\\n    require(syms.length == tokens.length, 'inconsistent length');\\n    for (uint idx = 0; idx < syms.length; idx++) {\\n      symbols[tokens[idx]] = syms[idx];\\n    }\\n  }\\n\\n  function setRef(IStdReference _ref) external onlyGov {\\n    ref = _ref;\\n  }\\n\\n  function setMaxDelayTime(uint _maxDelayTime) external onlyGov {\\n    maxDelayTime = _maxDelayTime;\\n  }\\n\\n  function getETHPx(address token) external view override returns (uint) {\\n    string memory sym = symbols[token];\\n    require(bytes(sym).length != 0, 'no mapping');\\n    uint8 decimals = BandDetailedERC20(token).decimals();\\n    IStdReference.ReferenceData memory data = ref.getReferenceData(sym, ETH);\\n    require(data.lastUpdatedBase >= block.timestamp.sub(maxDelayTime), 'delayed base data');\\n    require(data.lastUpdatedQuote >= block.timestamp.sub(maxDelayTime), 'delayed quote data');\\n    return data.rate.mul(2**112).div(10**decimals);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/UniswapV2Oracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport './UsingBaseOracle.sol';\\nimport '../utils/HomoraMath.sol';\\nimport '../../interfaces/IBaseOracle.sol';\\nimport '../../interfaces/IUniswapV2Pair.sol';\\n\\ncontract UniswapV2Oracle is UsingBaseOracle, IBaseOracle {\\n  using SafeMath for uint;\\n  using HomoraMath for uint;\\n\\n  constructor(IBaseOracle _base) public UsingBaseOracle(_base) {}\\n\\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\\n  /// @param pair The Uniswap pair to check the value.\\n  function getETHPx(address pair) external view override returns (uint) {\\n    address token0 = IUniswapV2Pair(pair).token0();\\n    address token1 = IUniswapV2Pair(pair).token1();\\n    uint totalSupply = IUniswapV2Pair(pair).totalSupply();\\n    (uint r0, uint r1, ) = IUniswapV2Pair(pair).getReserves();\\n    uint sqrtK = HomoraMath.sqrt(r0.mul(r1)).fdiv(totalSupply); // in 2**112\\n    uint px0 = base.getETHPx(token0);\\n    uint px1 = base.getETHPx(token1);\\n    return sqrtK.mul(2).mul(HomoraMath.sqrt(px0)).div(2**56).mul(HomoraMath.sqrt(px1)).div(2**56);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/BalancerPairOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport './UsingBaseOracle.sol';\\nimport '../utils/BNum.sol';\\nimport '../../interfaces/IBaseOracle.sol';\\nimport '../../interfaces/IBalancerPool.sol';\\n\\ncontract BalancerPairOracle is UsingBaseOracle, IBaseOracle, BNum {\\n  using SafeMath for uint;\\n\\n  constructor(IBaseOracle _base) public UsingBaseOracle(_base) {}\\n\\n  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\\n  /// @param resA Reserve of the first asset\\n  /// @param resB Reserev of the second asset\\n  /// @param wA Weight of the first asset\\n  /// @param wB Weight of the second asset\\n  /// @param pxA Fair price of the first asset\\n  /// @param pxB Fair price of the second asset\\n  function computeFairReserves(\\n    uint resA,\\n    uint resB,\\n    uint wA,\\n    uint wB,\\n    uint pxA,\\n    uint pxB\\n  ) internal pure returns (uint fairResA, uint fairResB) {\\n    uint r0 = bdiv(resA, resB);\\n    uint r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\\n    // fairResA = resA * (r1 / r0) ^ wB\\n    // fairResB = resB * (r0 / r1) ^ wA\\n    if (r0 > r1) {\\n      uint ratio = bdiv(r1, r0);\\n      fairResA = bmul(resA, bpow(ratio, wB));\\n      fairResB = bdiv(resB, bpow(ratio, wA));\\n    } else {\\n      uint ratio = bdiv(r0, r1);\\n      fairResA = bdiv(resA, bpow(ratio, wB));\\n      fairResB = bmul(resB, bpow(ratio, wA));\\n    }\\n  }\\n\\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\\n  /// @param token The ERC-20 token to check the value.\\n  function getETHPx(address token) external view override returns (uint) {\\n    IBalancerPool pool = IBalancerPool(token);\\n    require(pool.getNumTokens() == 2, 'num tokens must be 2');\\n    address[] memory tokens = pool.getFinalTokens();\\n    address tokenA = tokens[0];\\n    address tokenB = tokens[1];\\n    uint pxA = base.getETHPx(tokenA);\\n    uint pxB = base.getETHPx(tokenB);\\n    (uint fairResA, uint fairResB) =\\n      computeFairReserves(\\n        pool.getBalance(tokenA),\\n        pool.getBalance(tokenB),\\n        pool.getNormalizedWeight(tokenA),\\n        pool.getNormalizedWeight(tokenB),\\n        pxA,\\n        pxB\\n      );\\n    return fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/BNum.sol\": {\r\n      \"content\": \"// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport './BConst.sol';\\n\\ncontract BNum is BConst {\\n  function btoi(uint a) internal pure returns (uint) {\\n    return a / BONE;\\n  }\\n\\n  function bfloor(uint a) internal pure returns (uint) {\\n    return btoi(a) * BONE;\\n  }\\n\\n  function badd(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    require(c >= a, 'ERR_ADD_OVERFLOW');\\n    return c;\\n  }\\n\\n  function bsub(uint a, uint b) internal pure returns (uint) {\\n    (uint c, bool flag) = bsubSign(a, b);\\n    require(!flag, 'ERR_SUB_UNDERFLOW');\\n    return c;\\n  }\\n\\n  function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\\n    if (a >= b) {\\n      return (a - b, false);\\n    } else {\\n      return (b - a, true);\\n    }\\n  }\\n\\n  function bmul(uint a, uint b) internal pure returns (uint) {\\n    uint c0 = a * b;\\n    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\\n    uint c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\\n    uint c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  function bdiv(uint a, uint b) internal pure returns (uint) {\\n    require(b != 0, 'ERR_DIV_ZERO');\\n    uint c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\\n    uint c1 = c0 + (b / 2);\\n    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\\n    uint c2 = c1 / b;\\n    return c2;\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint a, uint n) internal pure returns (uint) {\\n    uint z = n % 2 != 0 ? a : BONE;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      a = bmul(a, a);\\n\\n      if (n % 2 != 0) {\\n        z = bmul(z, a);\\n      }\\n    }\\n    return z;\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint base, uint exp) internal pure returns (uint) {\\n    require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\\n    require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\\n\\n    uint whole = bfloor(exp);\\n    uint remain = bsub(exp, whole);\\n\\n    uint wholePow = bpowi(base, btoi(whole));\\n\\n    if (remain == 0) {\\n      return wholePow;\\n    }\\n\\n    uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n    return bmul(wholePow, partialResult);\\n  }\\n\\n  function bpowApprox(\\n    uint base,\\n    uint exp,\\n    uint precision\\n  ) internal pure returns (uint) {\\n    // term 0:\\n    uint a = exp;\\n    (uint x, bool xneg) = bsubSign(base, BONE);\\n    uint term = BONE;\\n    uint sum = term;\\n    bool negative = false;\\n\\n    // term(k) = numer / denom\\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\\n    // continue until term is less than precision\\n    for (uint i = 1; term >= precision; i++) {\\n      uint bigK = i * BONE;\\n      (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n      term = bmul(term, bmul(c, x));\\n      term = bdiv(term, bigK);\\n      if (term == 0) break;\\n\\n      if (xneg) negative = !negative;\\n      if (cneg) negative = !negative;\\n      if (negative) {\\n        sum = bsub(sum, term);\\n      } else {\\n        sum = badd(sum, term);\\n      }\\n    }\\n\\n    return sum;\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/BConst.sol\": {\r\n      \"content\": \"// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\ncontract BConst {\\n  uint public constant BONE = 10**18;\\n\\n  uint public constant MIN_BOUND_TOKENS = 2;\\n  uint public constant MAX_BOUND_TOKENS = 8;\\n\\n  uint public constant MIN_FEE = BONE / 10**6;\\n  uint public constant MAX_FEE = BONE / 10;\\n  uint public constant EXIT_FEE = 0;\\n\\n  uint public constant MIN_WEIGHT = BONE;\\n  uint public constant MAX_WEIGHT = BONE * 50;\\n  uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\\n  uint public constant MIN_BALANCE = BONE / 10**12;\\n\\n  uint public constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n  uint public constant MIN_BPOW_BASE = 1 wei;\\n  uint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  uint public constant BPOW_PRECISION = BONE / 10**10;\\n\\n  uint public constant MAX_IN_RATIO = BONE / 2;\\n  uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/CurveOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport './UsingBaseOracle.sol';\\nimport '../../interfaces/IBaseOracle.sol';\\nimport '../../interfaces/ICurvePool.sol';\\nimport '../../interfaces/ICurveRegistry.sol';\\n\\ninterface IERC20Decimal {\\n  function decimals() external view returns (uint8);\\n}\\n\\ncontract CurveOracle is UsingBaseOracle, IBaseOracle {\\n  using SafeMath for uint;\\n\\n  ICurveRegistry public immutable registry;\\n\\n  struct UnderlyingToken {\\n    uint8 decimals; // token decimals\\n    address token; // token address\\n  }\\n\\n  mapping(address => UnderlyingToken[]) public ulTokens; // lpToken -> underlying tokens array\\n  mapping(address => address) public poolOf; // lpToken -> pool\\n\\n  constructor(IBaseOracle _base, ICurveRegistry _registry) public UsingBaseOracle(_base) {\\n    registry = _registry;\\n  }\\n\\n  /// @dev Register the pool given LP token address and set the pool info.\\n  /// @param lp LP token to find the corresponding pool.\\n  function registerPool(address lp) external {\\n    address pool = poolOf[lp];\\n    require(pool == address(0), 'lp is already registered');\\n    pool = registry.get_pool_from_lp_token(lp);\\n    require(pool != address(0), 'no corresponding pool for lp token');\\n    poolOf[lp] = pool;\\n    uint n = registry.get_n_coins(pool);\\n    address[8] memory tokens = registry.get_coins(pool);\\n    for (uint i = 0; i < n; i++) {\\n      ulTokens[lp].push(\\n        UnderlyingToken({token: tokens[i], decimals: IERC20Decimal(tokens[i]).decimals()})\\n      );\\n    }\\n  }\\n\\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\\n  /// @param lp The ERC-20 LP token to check the value.\\n  function getETHPx(address lp) external view override returns (uint) {\\n    address pool = poolOf[lp];\\n    require(pool != address(0), 'lp is not registered');\\n    UnderlyingToken[] memory tokens = ulTokens[lp];\\n    uint minPx = uint(-1);\\n    uint n = tokens.length;\\n    for (uint idx = 0; idx < n; idx++) {\\n      UnderlyingToken memory ulToken = tokens[idx];\\n      uint tokenPx = base.getETHPx(ulToken.token);\\n      if (ulToken.decimals < 18) tokenPx = tokenPx.div(10**(18 - uint(ulToken.decimals)));\\n      if (ulToken.decimals > 18) tokenPx = tokenPx.mul(10**(uint(ulToken.decimals) - 18));\\n      if (tokenPx < minPx) minPx = tokenPx;\\n    }\\n    require(minPx != uint(-1), 'no min px');\\n    return minPx.mul(ICurvePool(pool).get_virtual_price()).div(1e18);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/ERC20KP3ROracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport './BaseKP3ROracle.sol';\\nimport '../../interfaces/IBaseOracle.sol';\\nimport '../../interfaces/IKeep3rV1Oracle.sol';\\nimport '../../interfaces/IUniswapV2Factory.sol';\\n\\ncontract ERC20KP3ROracle is IBaseOracle, BaseKP3ROracle {\\n  constructor(IKeep3rV1Oracle _kp3r) public BaseKP3ROracle(_kp3r) {}\\n\\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\\n  /// @param token The ERC-20 token to check the value.\\n  function getETHPx(address token) external view override returns (uint) {\\n    if (token == weth || token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n      return 2**112;\\n    }\\n    address pair = IUniswapV2Factory(factory).getPair(token, weth);\\n    if (token < weth) {\\n      return price0TWAP(pair);\\n    } else {\\n      return price1TWAP(pair);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/BaseKP3ROracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/proxy/Initializable.sol';\\n\\nimport '../../interfaces/IKeep3rV1Oracle.sol';\\nimport '../../interfaces/IUniswapV2Pair.sol';\\n\\ncontract BaseKP3ROracle is Initializable {\\n  uint public constant MIN_TWAP_TIME = 15 minutes;\\n  uint public constant MAX_TWAP_TIME = 60 minutes;\\n\\n  IKeep3rV1Oracle public immutable kp3r;\\n  address public immutable factory;\\n  address public immutable weth;\\n\\n  constructor(IKeep3rV1Oracle _kp3r) public {\\n    kp3r = _kp3r;\\n    factory = _kp3r.factory();\\n    weth = _kp3r.WETH();\\n  }\\n\\n  /// @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\\n  /// @param pair The pair to query for price0.\\n  function price0TWAP(address pair) public view returns (uint) {\\n    uint length = kp3r.observationLength(pair);\\n    require(length > 0, 'no length-1 observation');\\n    (uint lastTime, uint lastPx0Cumu, ) = kp3r.observations(pair, length - 1);\\n    if (lastTime > now - MIN_TWAP_TIME) {\\n      require(length > 1, 'no length-2 observation');\\n      (lastTime, lastPx0Cumu, ) = kp3r.observations(pair, length - 2);\\n    }\\n    uint elapsedTime = now - lastTime;\\n    require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\\n    uint currPx0Cumu = currentPx0Cumu(pair);\\n    return (currPx0Cumu - lastPx0Cumu) / (now - lastTime); // overflow is desired\\n  }\\n\\n  /// @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\\n  /// @param pair The pair to query for price1.\\n  function price1TWAP(address pair) public view returns (uint) {\\n    uint length = kp3r.observationLength(pair);\\n    require(length > 0, 'no length-1 observation');\\n    (uint lastTime, , uint lastPx1Cumu) = kp3r.observations(pair, length - 1);\\n    if (lastTime > now - MIN_TWAP_TIME) {\\n      require(length > 1, 'no length-2 observation');\\n      (lastTime, , lastPx1Cumu) = kp3r.observations(pair, length - 2);\\n    }\\n    uint elapsedTime = now - lastTime;\\n    require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\\n    uint currPx1Cumu = currentPx1Cumu(pair);\\n    return (currPx1Cumu - lastPx1Cumu) / (now - lastTime); // overflow is desired\\n  }\\n\\n  /// @dev Return the current price0 cumulative value on uniswap.\\n  /// @param pair The uniswap pair to query for price0 cumulative value.\\n  function currentPx0Cumu(address pair) public view returns (uint px0Cumu) {\\n    uint32 currTime = uint32(now);\\n    px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\\n    if (lastTime != now) {\\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\\n      px0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\\n    }\\n  }\\n\\n  /// @dev Return the current price1 cumulative value on uniswap.\\n  /// @param pair The uniswap pair to query for price1 cumulative value.\\n  function currentPx1Cumu(address pair) public view returns (uint px1Cumu) {\\n    uint32 currTime = uint32(now);\\n    px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\\n    if (lastTime != currTime) {\\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\\n      px1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IKeep3rV1Oracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nabstract contract IKeep3rV1Oracle {\\n  struct Observation {\\n    uint timestamp;\\n    uint price0Cumulative;\\n    uint price1Cumulative;\\n  }\\n\\n  function WETH() external pure virtual returns (address);\\n\\n  function factory() external pure virtual returns (address);\\n\\n  mapping(address => Observation[]) public observations;\\n\\n  function observationLength(address pair) external view virtual returns (uint);\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/ProxyOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\n\\nimport '../Governable.sol';\\nimport '../../interfaces/IOracle.sol';\\nimport '../../interfaces/IBaseOracle.sol';\\nimport '../../interfaces/IERC20Wrapper.sol';\\n\\ncontract ProxyOracle is IOracle, Governable {\\n  using SafeMath for uint;\\n\\n  /// The governor sets oracle information for a token.\\n  event SetOracle(address token, Oracle info);\\n  /// The governor unsets oracle information for a token.\\n  event UnsetOracle(address token);\\n  /// The governor sets token whitelist for an ERC1155 token.\\n  event SetWhitelist(address token, bool ok);\\n\\n  struct Oracle {\\n    uint16 borrowFactor; // The borrow factor for this token, multiplied by 1e4.\\n    uint16 collateralFactor; // The collateral factor for this token, multiplied by 1e4.\\n    uint16 liqIncentive; // The liquidation incentive, multiplied by 1e4.\\n  }\\n\\n  IBaseOracle public immutable source;\\n  mapping(address => Oracle) public oracles; // Mapping from token address to oracle info.\\n  mapping(address => bool) public whitelistERC1155;\\n\\n  /// @dev Create the contract and initialize the first governor.\\n  constructor(IBaseOracle _source) public {\\n    source = _source;\\n    __Governable__init();\\n  }\\n\\n  /// @dev Set oracle information for the given list of token addresses.\\n  function setOracles(address[] memory tokens, Oracle[] memory info) external onlyGov {\\n    require(tokens.length == info.length, 'inconsistent length');\\n    for (uint idx = 0; idx < tokens.length; idx++) {\\n      require(info[idx].borrowFactor >= 10000, 'borrow factor must be at least 100%');\\n      require(info[idx].collateralFactor <= 10000, 'collateral factor must be at most 100%');\\n      require(info[idx].liqIncentive >= 10000, 'incentive must be at least 100%');\\n      require(info[idx].liqIncentive <= 20000, 'incentive must be at most 200%');\\n      oracles[tokens[idx]] = info[idx];\\n      emit SetOracle(tokens[idx], info[idx]);\\n    }\\n  }\\n\\n  function unsetOracles(address[] memory tokens) external onlyGov {\\n    for (uint idx = 0; idx < tokens.length; idx++) {\\n      oracles[tokens[idx]] = Oracle(0, 0, 0);\\n      emit UnsetOracle(tokens[idx]);\\n    }\\n  }\\n\\n  /// @dev Set whitelist status for the given list of token addresses.\\n  function setWhitelistERC1155(address[] memory tokens, bool ok) external onlyGov {\\n    for (uint idx = 0; idx < tokens.length; idx++) {\\n      whitelistERC1155[tokens[idx]] = ok;\\n      emit SetWhitelist(tokens[idx], ok);\\n    }\\n  }\\n\\n  /// @dev Return whether the oracle supports evaluating collateral value of the given token.\\n  function support(address token, uint id) external view override returns (bool) {\\n    if (!whitelistERC1155[token]) return false;\\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\\n    return oracles[tokenUnderlying].liqIncentive != 0;\\n  }\\n\\n  /// @dev Return the amount of token out as liquidation reward for liquidating token in.\\n  function convertForLiquidation(\\n    address tokenIn,\\n    address tokenOut,\\n    uint tokenOutId,\\n    uint amountIn\\n  ) external view override returns (uint) {\\n    require(whitelistERC1155[tokenOut], 'bad token');\\n    address tokenOutUnderlying = IERC20Wrapper(tokenOut).getUnderlyingToken(tokenOutId);\\n    uint rateUnderlying = IERC20Wrapper(tokenOut).getUnderlyingRate(tokenOutId);\\n    Oracle memory oracleIn = oracles[tokenIn];\\n    Oracle memory oracleOut = oracles[tokenOutUnderlying];\\n    require(oracleIn.liqIncentive != 0, 'bad underlying in');\\n    require(oracleOut.liqIncentive != 0, 'bad underlying out');\\n    uint pxIn = source.getETHPx(tokenIn);\\n    uint pxOut = source.getETHPx(tokenOutUnderlying);\\n    uint amountOut = amountIn.mul(pxIn).div(pxOut);\\n    amountOut = amountOut.mul(2**112).div(rateUnderlying);\\n    return amountOut.mul(oracleIn.liqIncentive).mul(oracleOut.liqIncentive).div(10000 * 10000);\\n  }\\n\\n  /// @dev Return the value of the given input as ETH for collateral purpose.\\n  function asETHCollateral(\\n    address token,\\n    uint id,\\n    uint amount,\\n    address owner\\n  ) external view override returns (uint) {\\n    require(whitelistERC1155[token], 'bad token');\\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\\n    uint rateUnderlying = IERC20Wrapper(token).getUnderlyingRate(id);\\n    uint amountUnderlying = amount.mul(rateUnderlying).div(2**112);\\n    Oracle memory oracle = oracles[tokenUnderlying];\\n    require(oracle.liqIncentive != 0, 'bad underlying collateral');\\n    uint ethValue = source.getETHPx(tokenUnderlying).mul(amountUnderlying).div(2**112);\\n    return ethValue.mul(oracle.collateralFactor).div(10000);\\n  }\\n\\n  /// @dev Return the value of the given input as ETH for borrow purpose.\\n  function asETHBorrow(\\n    address token,\\n    uint amount,\\n    address owner\\n  ) external view override returns (uint) {\\n    Oracle memory oracle = oracles[token];\\n    require(oracle.liqIncentive != 0, 'bad underlying borrow');\\n    uint ethValue = source.getETHPx(token).mul(amount).div(2**112);\\n    return ethValue.mul(oracle.borrowFactor).div(10000);\\n  }\\n}\\n\"\r\n    },\r\n    \"./interfaces/IOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IOracle {\\n  /// @dev Return whether the oracle supports evaluating collateral value of the given address.\\n  /// @param token The ERC-1155 token to check the acceptence.\\n  /// @param id The token id to check the acceptance.\\n  function support(address token, uint id) external view returns (bool);\\n\\n  /// @dev Return the amount of token out as liquidation reward for liquidating token in.\\n  /// @param tokenIn The ERC-20 token that gets liquidated.\\n  /// @param tokenOut The ERC-1155 token to pay as reward.\\n  /// @param tokenOutId The id of the token to pay as reward.\\n  /// @param amountIn The amount of liquidating tokens.\\n  function convertForLiquidation(\\n    address tokenIn,\\n    address tokenOut,\\n    uint tokenOutId,\\n    uint amountIn\\n  ) external view returns (uint);\\n\\n  /// @dev Return the value of the given input as ETH for collateral purpose.\\n  /// @param token The ERC-1155 token to check the value.\\n  /// @param id The id of the token to check the value.\\n  /// @param amount The amount of tokens to check the value.\\n  /// @param owner The owner of the token to check for collateral credit.\\n  function asETHCollateral(\\n    address token,\\n    uint id,\\n    uint amount,\\n    address owner\\n  ) external view returns (uint);\\n\\n  /// @dev Return the value of the given input as ETH for borrow purpose.\\n  /// @param token The ERC-20 token to check the value.\\n  /// @param amount The amount of tokens to check the value.\\n  /// @param owner The owner of the token to check for borrow credit.\\n  function asETHBorrow(\\n    address token,\\n    uint amount,\\n    address owner\\n  ) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"./contracts/oracle/CoreOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport '../../interfaces/IBaseOracle.sol';\\nimport '../Governable.sol';\\n\\ncontract CoreOracle is IBaseOracle, Governable {\\n  event SetRoute(address token, address route);\\n  mapping(address => address) public routes;\\n\\n  constructor() public {\\n    __Governable__init();\\n  }\\n\\n  function setRoute(address[] calldata tokens, address[] calldata targets) external onlyGov {\\n    require(tokens.length == targets.length, 'inconsistent length');\\n    for (uint idx = 0; idx < tokens.length; idx++) {\\n      routes[tokens[idx]] = targets[idx];\\n      emit SetRoute(tokens[idx], targets[idx]);\\n    }\\n  }\\n\\n  function getETHPx(address token) external view override returns (uint) {\\n    uint px = IBaseOracle(routes[token]).getETHPx(token);\\n    require(px != 0, 'no px');\\n    return px;\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/IbETHRouterV2.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport './utils/HomoraMath.sol';\\n\\ninterface IbETHRouterV2IbETHv2 is IERC20 {\\n  function deposit() external payable;\\n\\n  function withdraw(uint amount) external;\\n}\\n\\ninterface IbETHRouterV2UniswapPair is IERC20 {\\n  function token0() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint,\\n      uint,\\n      uint\\n    );\\n}\\n\\ninterface IbETHRouterV2UniswapRouter {\\n  function factory() external view returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    returns (\\n      uint amountA,\\n      uint amountB,\\n      uint liquidity\\n    );\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n}\\n\\ninterface IbETHRouterV2UniswapFactory {\\n  function getPair(address tokenA, address tokenB) external view returns (address);\\n}\\n\\ncontract IbETHRouterV2 {\\n  using SafeMath for uint;\\n\\n  IERC20 public immutable alpha;\\n  IbETHRouterV2IbETHv2 public immutable ibETHv2;\\n  IbETHRouterV2UniswapPair public immutable lpToken;\\n  IbETHRouterV2UniswapRouter public immutable router;\\n\\n  constructor(\\n    IERC20 _alpha,\\n    IbETHRouterV2IbETHv2 _ibETHv2,\\n    IbETHRouterV2UniswapRouter _router\\n  ) public {\\n    IbETHRouterV2UniswapPair _lpToken =\\n      IbETHRouterV2UniswapPair(\\n        IbETHRouterV2UniswapFactory(_router.factory()).getPair(address(_alpha), address(_ibETHv2))\\n      );\\n    alpha = _alpha;\\n    ibETHv2 = _ibETHv2;\\n    lpToken = _lpToken;\\n    router = _router;\\n    require(_alpha.approve(address(_router), uint(-1)));\\n    require(_ibETHv2.approve(address(_router), uint(-1)));\\n    require(_lpToken.approve(address(_router), uint(-1)));\\n  }\\n\\n  function optimalDeposit(\\n    uint amtA,\\n    uint amtB,\\n    uint resA,\\n    uint resB\\n  ) internal pure returns (uint swapAmt, bool isReversed) {\\n    if (amtA.mul(resB) >= amtB.mul(resA)) {\\n      swapAmt = _optimalDepositA(amtA, amtB, resA, resB);\\n      isReversed = false;\\n    } else {\\n      swapAmt = _optimalDepositA(amtB, amtA, resB, resA);\\n      isReversed = true;\\n    }\\n  }\\n\\n  function _optimalDepositA(\\n    uint amtA,\\n    uint amtB,\\n    uint resA,\\n    uint resB\\n  ) internal pure returns (uint) {\\n    require(amtA.mul(resB) >= amtB.mul(resA), 'Reversed');\\n    uint a = 997;\\n    uint b = uint(1997).mul(resA);\\n    uint _c = (amtA.mul(resB)).sub(amtB.mul(resA));\\n    uint c = _c.mul(1000).div(amtB.add(resB)).mul(resA);\\n    uint d = a.mul(c).mul(4);\\n    uint e = HomoraMath.sqrt(b.mul(b).add(d));\\n    uint numerator = e.sub(b);\\n    uint denominator = a.mul(2);\\n    return numerator.div(denominator);\\n  }\\n\\n  function swapExactETHToAlpha(\\n    uint amountOutMin,\\n    address to,\\n    uint deadline\\n  ) external payable {\\n    ibETHv2.deposit{value: msg.value}();\\n    address[] memory path = new address[](2);\\n    path[0] = address(ibETHv2);\\n    path[1] = address(alpha);\\n    router.swapExactTokensForTokens(\\n      ibETHv2.balanceOf(address(this)),\\n      amountOutMin,\\n      path,\\n      to,\\n      deadline\\n    );\\n  }\\n\\n  function swapExactAlphaToETH(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address to,\\n    uint deadline\\n  ) external {\\n    alpha.transferFrom(msg.sender, address(this), amountIn);\\n    address[] memory path = new address[](2);\\n    path[0] = address(alpha);\\n    path[1] = address(ibETHv2);\\n    router.swapExactTokensForTokens(amountIn, 0, path, address(this), deadline);\\n    ibETHv2.withdraw(ibETHv2.balanceOf(address(this)));\\n    uint ethBalance = address(this).balance;\\n    require(ethBalance >= amountOutMin, '!amountOutMin');\\n    (bool success, ) = to.call{value: ethBalance}(new bytes(0));\\n    require(success, '!eth');\\n  }\\n\\n  function addLiquidityETHAlphaOptimal(\\n    uint amountAlpha,\\n    uint minLp,\\n    address to,\\n    uint deadline\\n  ) external payable {\\n    if (amountAlpha > 0) alpha.transferFrom(msg.sender, address(this), amountAlpha);\\n    ibETHv2.deposit{value: msg.value}();\\n    uint amountIbETHv2 = ibETHv2.balanceOf(address(this));\\n    uint swapAmt;\\n    bool isReversed;\\n    {\\n      (uint r0, uint r1, ) = lpToken.getReserves();\\n      (uint ibETHv2Reserve, uint alphaReserve) =\\n        lpToken.token0() == address(ibETHv2) ? (r0, r1) : (r1, r0);\\n      (swapAmt, isReversed) = optimalDeposit(\\n        amountIbETHv2,\\n        amountAlpha,\\n        ibETHv2Reserve,\\n        alphaReserve\\n      );\\n    }\\n    if (swapAmt > 0) {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = isReversed\\n        ? (address(alpha), address(ibETHv2))\\n        : (address(ibETHv2), address(alpha));\\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), deadline);\\n    }\\n    (, , uint liquidity) =\\n      router.addLiquidity(\\n        address(alpha),\\n        address(ibETHv2),\\n        alpha.balanceOf(address(this)),\\n        ibETHv2.balanceOf(address(this)),\\n        0,\\n        0,\\n        to,\\n        deadline\\n      );\\n    require(liquidity >= minLp, '!minLP');\\n  }\\n\\n  function addLiquidityIbETHv2AlphaOptimal(\\n    uint amountIbETHv2,\\n    uint amountAlpha,\\n    uint minLp,\\n    address to,\\n    uint deadline\\n  ) external {\\n    if (amountAlpha > 0) alpha.transferFrom(msg.sender, address(this), amountAlpha);\\n    if (amountIbETHv2 > 0) ibETHv2.transferFrom(msg.sender, address(this), amountIbETHv2);\\n    uint swapAmt;\\n    bool isReversed;\\n    {\\n      (uint r0, uint r1, ) = lpToken.getReserves();\\n      (uint ibETHv2Reserve, uint alphaReserve) =\\n        lpToken.token0() == address(ibETHv2) ? (r0, r1) : (r1, r0);\\n      (swapAmt, isReversed) = optimalDeposit(\\n        amountIbETHv2,\\n        amountAlpha,\\n        ibETHv2Reserve,\\n        alphaReserve\\n      );\\n    }\\n    if (swapAmt > 0) {\\n      address[] memory path = new address[](2);\\n      (path[0], path[1]) = isReversed\\n        ? (address(alpha), address(ibETHv2))\\n        : (address(ibETHv2), address(alpha));\\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), deadline);\\n    }\\n    (, , uint liquidity) =\\n      router.addLiquidity(\\n        address(alpha),\\n        address(ibETHv2),\\n        alpha.balanceOf(address(this)),\\n        ibETHv2.balanceOf(address(this)),\\n        0,\\n        0,\\n        to,\\n        deadline\\n      );\\n    require(liquidity >= minLp, '!minLP');\\n  }\\n\\n  function removeLiquidityETHAlpha(\\n    uint liquidity,\\n    uint minETH,\\n    uint minAlpha,\\n    address to,\\n    uint deadline\\n  ) external {\\n    lpToken.transferFrom(msg.sender, address(this), liquidity);\\n    router.removeLiquidity(\\n      address(alpha),\\n      address(ibETHv2),\\n      liquidity,\\n      minAlpha,\\n      0,\\n      address(this),\\n      deadline\\n    );\\n    alpha.transfer(msg.sender, alpha.balanceOf(address(this)));\\n    ibETHv2.withdraw(ibETHv2.balanceOf(address(this)));\\n    uint ethBalance = address(this).balance;\\n    require(ethBalance >= minETH, '!minETH');\\n    (bool success, ) = to.call{value: ethBalance}(new bytes(0));\\n    require(success, '!eth');\\n  }\\n\\n  function removeLiquidityAlphaOnly(\\n    uint liquidity,\\n    uint minAlpha,\\n    address to,\\n    uint deadline\\n  ) external {\\n    lpToken.transferFrom(msg.sender, address(this), liquidity);\\n    router.removeLiquidity(\\n      address(alpha),\\n      address(ibETHv2),\\n      liquidity,\\n      0,\\n      0,\\n      address(this),\\n      deadline\\n    );\\n    address[] memory path = new address[](2);\\n    path[0] = address(ibETHv2);\\n    path[1] = address(alpha);\\n    router.swapExactTokensForTokens(\\n      ibETHv2.balanceOf(address(this)),\\n      0,\\n      path,\\n      address(this),\\n      deadline\\n    );\\n    uint alphaBalance = alpha.balanceOf(address(this));\\n    require(alphaBalance >= minAlpha, '!minAlpha');\\n    alpha.transfer(to, alphaBalance);\\n  }\\n\\n  receive() external payable {\\n    require(msg.sender == address(ibETHv2), '!ibETHv2');\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/HomoraBank.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/Math.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/proxy/Initializable.sol';\\n\\nimport './Governable.sol';\\nimport './utils/ERC1155NaiveReceiver.sol';\\nimport '../interfaces/IBank.sol';\\nimport '../interfaces/ICErc20.sol';\\nimport '../interfaces/IOracle.sol';\\n\\ncontract HomoraCaster {\\n  /// @dev Call to the target using the given data.\\n  /// @param target The address target to call.\\n  /// @param data The data used in the call.\\n  function cast(address target, bytes calldata data) external payable {\\n    (bool ok, bytes memory returndata) = target.call{value: msg.value}(data);\\n    if (!ok) {\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert('bad cast call');\\n      }\\n    }\\n  }\\n}\\n\\ncontract HomoraBank is Initializable, Governable, ERC1155NaiveReceiver, IBank {\\n  using SafeMath for uint;\\n  using SafeERC20 for IERC20;\\n\\n  uint private constant _NOT_ENTERED = 1;\\n  uint private constant _ENTERED = 2;\\n  uint private constant _NO_ID = uint(-1);\\n  address private constant _NO_ADDRESS = address(1);\\n\\n  struct Bank {\\n    bool isListed; // Whether this market exists.\\n    uint8 index; // Reverse look up index for this bank.\\n    address cToken; // The CToken to draw liquidity from.\\n    uint reserve; // The reserve portion allocated to Homora protocol.\\n    uint pendingReserve; // The pending reserve portion waiting to be resolve.\\n    uint totalDebt; // The last recorded total debt since last action.\\n    uint totalShare; // The total debt share count across all open positions.\\n  }\\n\\n  struct Position {\\n    address owner; // The owner of this position.\\n    address collToken; // The ERC1155 token used as collateral for this position.\\n    uint collId; // The token id used as collateral.\\n    uint collateralSize; // The size of collateral token for this position.\\n    uint debtMap; // Bitmap of nonzero debt. i^th bit is set iff debt share of i^th bank is nonzero.\\n    mapping(address => uint) debtShareOf; // The debt share for each token.\\n  }\\n\\n  uint public _GENERAL_LOCK; // TEMPORARY: re-entrancy lock guard.\\n  uint public _IN_EXEC_LOCK; // TEMPORARY: exec lock guard.\\n  uint public override POSITION_ID; // TEMPORARY: position ID currently under execution.\\n  address public override SPELL; // TEMPORARY: spell currently under execution.\\n\\n  address public caster; // The caster address for untrusted execution.\\n  IOracle public oracle; // The oracle address for determining prices.\\n  uint public feeBps; // The fee collected as protocol reserve in basis point from interest.\\n  uint public override nextPositionId; // Next available position ID, starting from 1 (see initialize).\\n\\n  address[] public allBanks; // The list of all listed banks.\\n  mapping(address => Bank) public banks; // Mapping from token to bank data.\\n  mapping(address => bool) public cTokenInBank; // Mapping from cToken to its existence in bank.\\n  mapping(uint => Position) public positions; // Mapping from position ID to position data.\\n\\n  modifier onlyEOA() {\\n    require(msg.sender == tx.origin, 'not eoa');\\n    _;\\n  }\\n\\n  /// @dev Reentrancy lock guard.\\n  modifier lock() {\\n    require(_GENERAL_LOCK == _NOT_ENTERED, 'general lock');\\n    _GENERAL_LOCK = _ENTERED;\\n    _;\\n    _GENERAL_LOCK = _NOT_ENTERED;\\n  }\\n\\n  /// @dev Ensure that the function is called from within the execution scope.\\n  modifier inExec() {\\n    require(POSITION_ID != _NO_ID, 'not within execution');\\n    require(SPELL == msg.sender, 'not from spell');\\n    require(_IN_EXEC_LOCK == _NOT_ENTERED, 'in exec lock');\\n    _IN_EXEC_LOCK = _ENTERED;\\n    _;\\n    _IN_EXEC_LOCK = _NOT_ENTERED;\\n  }\\n\\n  /// @dev Ensure that the interest rate of the given token is accrued.\\n  modifier poke(address token) {\\n    accrue(token);\\n    _;\\n  }\\n\\n  /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\\n  /// @param _oracle The oracle smart contract address.\\n  /// @param _feeBps The fee collected to Homora bank.\\n  function initialize(IOracle _oracle, uint _feeBps) external initializer {\\n    __Governable__init();\\n    _GENERAL_LOCK = _NOT_ENTERED;\\n    _IN_EXEC_LOCK = _NOT_ENTERED;\\n    POSITION_ID = _NO_ID;\\n    SPELL = _NO_ADDRESS;\\n    caster = address(new HomoraCaster());\\n    oracle = _oracle;\\n    require(address(_oracle) != address(0), 'bad oracle address');\\n    feeBps = _feeBps;\\n    nextPositionId = 1;\\n    emit SetOracle(address(_oracle));\\n    emit SetFeeBps(_feeBps);\\n  }\\n\\n  /// @dev Return the current executor (the owner of the current position).\\n  function EXECUTOR() external view override returns (address) {\\n    uint positionId = POSITION_ID;\\n    require(positionId != _NO_ID, 'not under execution');\\n    return positions[positionId].owner;\\n  }\\n\\n  /// @dev Trigger interest accrual for the given bank.\\n  /// @param token The underlying token to trigger the interest accrual.\\n  function accrue(address token) public override {\\n    Bank storage bank = banks[token];\\n    require(bank.isListed, 'bank not exists');\\n    uint totalDebt = bank.totalDebt;\\n    uint debt = ICErc20(bank.cToken).borrowBalanceCurrent(address(this));\\n    if (debt > totalDebt) {\\n      uint fee = debt.sub(totalDebt).mul(feeBps).div(10000);\\n      bank.totalDebt = debt;\\n      bank.pendingReserve = bank.pendingReserve.add(fee);\\n    } else if (totalDebt != debt) {\\n      // We should never reach here because CREAMv2 does not support *repayBorrowBehalf*\\n      // functionality. We set bank.totalDebt = debt nonetheless to ensure consistency. But do\\n      // note that if *repayBorrowBehalf* exists, an attacker can maliciously deflate debt\\n      // share value and potentially make this contract stop working due to math overflow.\\n      bank.totalDebt = debt;\\n    }\\n  }\\n\\n  /// @dev Convenient function to trigger interest accrual for a list of banks.\\n  /// @param tokens The list of banks to trigger interest accrual.\\n  function accrueAll(address[] memory tokens) external {\\n    for (uint idx = 0; idx < tokens.length; idx++) {\\n      accrue(tokens[idx]);\\n    }\\n  }\\n\\n  /// @dev Trigger reserve resolve by borrowing the pending amount for reserve.\\n  /// @param token The underlying token to trigger reserve resolve.\\n  function resolveReserve(address token) public lock poke(token) {\\n    Bank storage bank = banks[token];\\n    require(bank.isListed, 'bank not exists');\\n    uint pendingReserve = bank.pendingReserve;\\n    bank.pendingReserve = 0;\\n    bank.reserve = bank.reserve.add(doBorrow(token, pendingReserve));\\n  }\\n\\n  /// @dev Convenient function to trigger reserve resolve for the list of banks.\\n  /// @param tokens The list of banks to trigger reserve resolve.\\n  function resolveReserveAll(address[] memory tokens) external {\\n    for (uint idx = 0; idx < tokens.length; idx++) {\\n      resolveReserve(tokens[idx]);\\n    }\\n  }\\n\\n  /// @dev Return the borrow balance for given positon and token without trigger interest accrual.\\n  /// @param positionId The position to query for borrow balance.\\n  /// @param token The token to query for borrow balance.\\n  function borrowBalanceStored(uint positionId, address token) public view override returns (uint) {\\n    uint totalDebt = banks[token].totalDebt;\\n    uint totalShare = banks[token].totalShare;\\n    uint share = positions[positionId].debtShareOf[token];\\n    if (share == 0 || totalDebt == 0) {\\n      return 0;\\n    } else {\\n      return share.mul(totalDebt).div(totalShare);\\n    }\\n  }\\n\\n  /// @dev Trigger interest accrual and return the current borrow balance.\\n  /// @param positionId The position to query for borrow balance.\\n  /// @param token The token to query for borrow balance.\\n  function borrowBalanceCurrent(uint positionId, address token) external override returns (uint) {\\n    accrue(token);\\n    return borrowBalanceStored(positionId, token);\\n  }\\n\\n  /// @dev Return bank information for the given token.\\n  /// @param token The token address to query for bank information.\\n  function getBankInfo(address token)\\n    external\\n    view\\n    override\\n    returns (\\n      bool isListed,\\n      address cToken,\\n      uint reserve,\\n      uint totalDebt,\\n      uint totalShare\\n    )\\n  {\\n    Bank storage bank = banks[token];\\n    return (bank.isListed, bank.cToken, bank.reserve, bank.totalDebt, bank.totalShare);\\n  }\\n\\n  /// @dev Return position information for the given position id.\\n  /// @param positionId The position id to query for position information.\\n  function getPositionInfo(uint positionId)\\n    external\\n    view\\n    override\\n    returns (\\n      address owner,\\n      address collToken,\\n      uint collId,\\n      uint collateralSize\\n    )\\n  {\\n    Position storage pos = positions[positionId];\\n    return (pos.owner, pos.collToken, pos.collId, pos.collateralSize);\\n  }\\n\\n  /// @dev Return the debt share of the given bank token for the given position id.\\n  function getPositionDebtShareOf(uint positionId, address token) external view returns (uint) {\\n    return positions[positionId].debtShareOf[token];\\n  }\\n\\n  /// @dev Return the list of all debts for the given position id.\\n  function getPositionDebts(uint positionId)\\n    external\\n    view\\n    returns (address[] memory tokens, uint[] memory debts)\\n  {\\n    Position storage pos = positions[positionId];\\n    uint count = 0;\\n    uint bitMap = pos.debtMap;\\n    while (bitMap > 0) {\\n      if ((bitMap & 1) != 0) {\\n        count++;\\n      }\\n      bitMap >>= 1;\\n    }\\n    tokens = new address[](count);\\n    debts = new uint[](count);\\n    bitMap = pos.debtMap;\\n    count = 0;\\n    uint idx = 0;\\n    while (bitMap > 0) {\\n      if ((bitMap & 1) != 0) {\\n        address token = allBanks[idx];\\n        Bank storage bank = banks[token];\\n        tokens[count] = token;\\n        debts[count] = pos.debtShareOf[token].mul(bank.totalDebt).div(bank.totalShare);\\n        count++;\\n      }\\n      idx++;\\n      bitMap >>= 1;\\n    }\\n  }\\n\\n  /// @dev Return the total collateral value of the given position in ETH.\\n  /// @param positionId The position ID to query for the collateral value.\\n  function getCollateralETHValue(uint positionId) public view returns (uint) {\\n    Position storage pos = positions[positionId];\\n    uint size = pos.collateralSize;\\n    if (size == 0) {\\n      return 0;\\n    } else {\\n      require(pos.collToken != address(0), 'bad collateral token');\\n      return oracle.asETHCollateral(pos.collToken, pos.collId, size, pos.owner);\\n    }\\n  }\\n\\n  /// @dev Return the total borrow value of the given position in ETH.\\n  /// @param positionId The position ID to query for the borrow value.\\n  function getBorrowETHValue(uint positionId) public view override returns (uint) {\\n    uint value = 0;\\n    Position storage pos = positions[positionId];\\n    address owner = pos.owner;\\n    uint bitMap = pos.debtMap;\\n    uint idx = 0;\\n    while (bitMap > 0) {\\n      if ((bitMap & 1) != 0) {\\n        address token = allBanks[idx];\\n        uint share = pos.debtShareOf[token];\\n        Bank storage bank = banks[token];\\n        uint debt = share.mul(bank.totalDebt).div(bank.totalShare);\\n        value = value.add(oracle.asETHBorrow(token, debt, owner));\\n      }\\n      idx++;\\n      bitMap >>= 1;\\n    }\\n    return value;\\n  }\\n\\n  /// @dev Add a new bank to the ecosystem.\\n  /// @param token The underlying token for the bank.\\n  /// @param cToken The address of the cToken smart contract.\\n  function addBank(address token, address cToken) external onlyGov {\\n    Bank storage bank = banks[token];\\n    require(!cTokenInBank[cToken], 'cToken already exists');\\n    require(!bank.isListed, 'bank already exists');\\n    cTokenInBank[cToken] = true;\\n    bank.isListed = true;\\n    require(allBanks.length < 256, 'reach bank limit');\\n    bank.index = uint8(allBanks.length);\\n    bank.cToken = cToken;\\n    IERC20(token).safeApprove(cToken, 0);\\n    IERC20(token).safeApprove(cToken, uint(-1));\\n    allBanks.push(token);\\n    emit AddBank(token, cToken);\\n  }\\n\\n  /// @dev Set the oracle smart contract address.\\n  /// @param _oracle The new oracle smart contract address.\\n  function setOracle(IOracle _oracle) external onlyGov {\\n    oracle = _oracle;\\n    emit SetOracle(address(_oracle));\\n  }\\n\\n  /// @dev Set the fee bps value that Homora bank charges.\\n  /// @param _feeBps The new fee bps value.\\n  function setFeeBps(uint _feeBps) external onlyGov {\\n    require(_feeBps <= 10000, 'fee too high');\\n    feeBps = _feeBps;\\n    emit SetFeeBps(_feeBps);\\n  }\\n\\n  /// @dev Withdraw the reserve portion of the bank.\\n  /// @param amount The amount of tokens to withdraw.\\n  function withdrawReserve(address token, uint amount) external onlyGov lock {\\n    Bank storage bank = banks[token];\\n    require(bank.isListed, 'bank not exists');\\n    bank.reserve = bank.reserve.sub(amount);\\n    IERC20(token).safeTransfer(msg.sender, amount);\\n    emit WithdrawReserve(msg.sender, token, amount);\\n  }\\n\\n  /// @dev Liquidate a position. Pay debt for its owner and take the collateral.\\n  /// @param positionId The position ID to liquidate.\\n  /// @param debtToken The debt token to repay.\\n  /// @param amountCall The amount to repay when doing transferFrom call.\\n  function liquidate(\\n    uint positionId,\\n    address debtToken,\\n    uint amountCall\\n  ) external override lock poke(debtToken) {\\n    uint collateralValue = getCollateralETHValue(positionId);\\n    uint borrowValue = getBorrowETHValue(positionId);\\n    require(collateralValue < borrowValue, 'position still healthy');\\n    Position storage pos = positions[positionId];\\n    (uint amountPaid, uint share) = repayInternal(positionId, debtToken, amountCall);\\n    require(pos.collToken != address(0), 'bad collateral token');\\n    uint bounty =\\n      Math.min(\\n        oracle.convertForLiquidation(debtToken, pos.collToken, pos.collId, amountPaid),\\n        pos.collateralSize\\n      );\\n    pos.collateralSize = pos.collateralSize.sub(bounty);\\n    IERC1155(pos.collToken).safeTransferFrom(address(this), msg.sender, pos.collId, bounty, '');\\n    emit Liquidate(positionId, msg.sender, debtToken, amountPaid, share, bounty);\\n  }\\n\\n  /// @dev Execute the action via HomoraCaster, calling its function with the supplied data.\\n  /// @param positionId The position ID to execute the action, or zero for new position.\\n  /// @param spell The target spell to invoke the execution via HomoraCaster.\\n  /// @param data Extra data to pass to the target for the execution.\\n  function execute(\\n    uint positionId,\\n    address spell,\\n    bytes memory data\\n  ) external payable lock onlyEOA returns (uint) {\\n    if (positionId == 0) {\\n      positionId = nextPositionId++;\\n      positions[positionId].owner = msg.sender;\\n    } else {\\n      require(positionId < nextPositionId, 'position id not exists');\\n      require(msg.sender == positions[positionId].owner, 'not position owner');\\n    }\\n    POSITION_ID = positionId;\\n    SPELL = spell;\\n    HomoraCaster(caster).cast{value: msg.value}(spell, data);\\n    uint collateralValue = getCollateralETHValue(positionId);\\n    uint borrowValue = getBorrowETHValue(positionId);\\n    require(collateralValue >= borrowValue, 'insufficient collateral');\\n    POSITION_ID = _NO_ID;\\n    SPELL = _NO_ADDRESS;\\n    return positionId;\\n  }\\n\\n  /// @dev Borrow tokens from that bank. Must only be called while under execution.\\n  /// @param token The token to borrow from the bank.\\n  /// @param amount The amount of tokens to borrow.\\n  function borrow(address token, uint amount) external override inExec poke(token) {\\n    Bank storage bank = banks[token];\\n    require(bank.isListed, 'bank not exists');\\n    Position storage pos = positions[POSITION_ID];\\n    uint totalShare = bank.totalShare;\\n    uint totalDebt = bank.totalDebt;\\n    uint share = totalShare == 0 ? amount : amount.mul(totalShare).div(totalDebt);\\n    bank.totalShare = bank.totalShare.add(share);\\n    uint newShare = pos.debtShareOf[token].add(share);\\n    pos.debtShareOf[token] = newShare;\\n    if (newShare > 0) {\\n      pos.debtMap |= (1 << uint(bank.index));\\n    }\\n    IERC20(token).safeTransfer(msg.sender, doBorrow(token, amount));\\n    emit Borrow(POSITION_ID, msg.sender, token, amount, share);\\n  }\\n\\n  /// @dev Repay tokens to the bank. Must only be called while under execution.\\n  /// @param token The token to repay to the bank.\\n  /// @param amountCall The amount of tokens to repay via transferFrom.\\n  function repay(address token, uint amountCall) external override inExec poke(token) {\\n    (uint amount, uint share) = repayInternal(POSITION_ID, token, amountCall);\\n    emit Repay(POSITION_ID, msg.sender, token, amount, share);\\n  }\\n\\n  /// @dev Perform repay action. Return the amount actually taken and the debt share reduced.\\n  /// @param positionId The position ID to repay the debt.\\n  /// @param token The bank token to pay the debt.\\n  /// @param amountCall The amount to repay by calling transferFrom, or -1 for debt size.\\n  function repayInternal(\\n    uint positionId,\\n    address token,\\n    uint amountCall\\n  ) internal returns (uint, uint) {\\n    Bank storage bank = banks[token];\\n    require(bank.isListed, 'bank not exists');\\n    Position storage pos = positions[positionId];\\n    uint totalShare = bank.totalShare;\\n    uint totalDebt = bank.totalDebt;\\n    uint oldShare = pos.debtShareOf[token];\\n    uint oldDebt = oldShare.mul(totalDebt).div(totalShare);\\n    if (amountCall == uint(-1)) {\\n      amountCall = oldDebt;\\n    }\\n    uint paid = doRepay(token, doERC20TransferIn(token, amountCall));\\n    require(paid <= oldDebt, 'paid exceeds debt'); // prevent share overflow attack\\n    uint lessShare = paid == oldDebt ? oldShare : paid.mul(totalShare).div(totalDebt);\\n    bank.totalShare = totalShare.sub(lessShare);\\n    uint newShare = oldShare.sub(lessShare);\\n    pos.debtShareOf[token] = newShare;\\n    if (newShare == 0) {\\n      pos.debtMap &= ~(1 << uint(bank.index));\\n    }\\n    return (paid, lessShare);\\n  }\\n\\n  /// @dev Transmit user assets to the caller, so users only need to approve Bank for spending.\\n  /// @param token The token to transfer from user to the caller.\\n  /// @param amount The amount to transfer.\\n  function transmit(address token, uint amount) external override inExec {\\n    Position storage pos = positions[POSITION_ID];\\n    IERC20(token).safeTransferFrom(pos.owner, msg.sender, amount);\\n  }\\n\\n  /// @dev Put more collateral for users. Must only be called during execution.\\n  /// @param collToken The ERC1155 token to collateral.\\n  /// @param collId The token id to collateral.\\n  /// @param amountCall The amount of tokens to put via transferFrom.\\n  function putCollateral(\\n    address collToken,\\n    uint collId,\\n    uint amountCall\\n  ) external override inExec {\\n    Position storage pos = positions[POSITION_ID];\\n    if (pos.collToken != collToken || pos.collId != collId) {\\n      require(oracle.support(collToken, collId), 'collateral not supported');\\n      require(pos.collateralSize == 0, 'another type of collateral already exists');\\n      pos.collToken = collToken;\\n      pos.collId = collId;\\n    }\\n    uint amount = doERC1155TransferIn(collToken, collId, amountCall);\\n    pos.collateralSize = pos.collateralSize.add(amount);\\n    emit PutCollateral(POSITION_ID, msg.sender, collToken, collId, amount);\\n  }\\n\\n  /// @dev Take some collateral back. Must only be called during execution.\\n  /// @param collToken The ERC1155 token to take back.\\n  /// @param collId The token id to take back.\\n  /// @param amount The amount of tokens to take back via transfer.\\n  function takeCollateral(\\n    address collToken,\\n    uint collId,\\n    uint amount\\n  ) external override inExec {\\n    Position storage pos = positions[POSITION_ID];\\n    require(collToken == pos.collToken, 'invalid collateral token');\\n    require(collId == pos.collId, 'invalid collateral token');\\n    if (amount == uint(-1)) {\\n      amount = pos.collateralSize;\\n    }\\n    pos.collateralSize = pos.collateralSize.sub(amount);\\n    IERC1155(collToken).safeTransferFrom(address(this), msg.sender, collId, amount, '');\\n    emit TakeCollateral(POSITION_ID, msg.sender, collToken, collId, amount);\\n  }\\n\\n  /// @dev Internal function to perform borrow from the bank and return the amount received.\\n  /// @param token The token to perform borrow action.\\n  /// @param amountCall The amount use in the transferFrom call.\\n  /// NOTE: Caller must ensure that cToken interest was already accrued up to this block.\\n  function doBorrow(address token, uint amountCall) internal returns (uint) {\\n    Bank storage bank = banks[token]; // assume the input is already sanity checked.\\n    uint balanceBefore = IERC20(token).balanceOf(address(this));\\n    require(ICErc20(bank.cToken).borrow(amountCall) == 0, 'bad borrow');\\n    uint balanceAfter = IERC20(token).balanceOf(address(this));\\n    bank.totalDebt = bank.totalDebt.add(amountCall);\\n    return balanceAfter.sub(balanceBefore);\\n  }\\n\\n  /// @dev Internal function to perform repay to the bank and return the amount actually repaid.\\n  /// @param token The token to perform repay action.\\n  /// @param amountCall The amount to use in the repay call.\\n  /// NOTE: Caller must ensure that cToken interest was already accrued up to this block.\\n  function doRepay(address token, uint amountCall) internal returns (uint) {\\n    Bank storage bank = banks[token]; // assume the input is already sanity checked.\\n    ICErc20 cToken = ICErc20(bank.cToken);\\n    uint oldDebt = bank.totalDebt;\\n    require(cToken.repayBorrow(amountCall) == 0, 'bad repay');\\n    uint newDebt = cToken.borrowBalanceStored(address(this));\\n    bank.totalDebt = newDebt;\\n    return oldDebt.sub(newDebt);\\n  }\\n\\n  /// @dev Internal function to perform ERC20 transfer in and return amount actually received.\\n  /// @param token The token to perform transferFrom action.\\n  /// @param amountCall The amount use in the transferFrom call.\\n  function doERC20TransferIn(address token, uint amountCall) internal returns (uint) {\\n    uint balanceBefore = IERC20(token).balanceOf(address(this));\\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amountCall);\\n    uint balanceAfter = IERC20(token).balanceOf(address(this));\\n    return balanceAfter.sub(balanceBefore);\\n  }\\n\\n  /// @dev Internal function to perform ERC1155 transfer in and return amount actually received.\\n  /// @param token The token to perform transferFrom action.\\n  /// @param id The id to perform transferFrom action.\\n  /// @param amountCall The amount use in the transferFrom call.\\n  function doERC1155TransferIn(\\n    address token,\\n    uint id,\\n    uint amountCall\\n  ) internal returns (uint) {\\n    uint balanceBefore = IERC1155(token).balanceOf(address(this), id);\\n    IERC1155(token).safeTransferFrom(msg.sender, address(this), id, amountCall, '');\\n    uint balanceAfter = IERC1155(token).balanceOf(address(this), id);\\n    return balanceAfter.sub(balanceBefore);\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/SafeBoxETH.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/ERC20.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/cryptography/MerkleProof.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\\nimport './Governable.sol';\\nimport '../interfaces/ICErc20.sol';\\nimport '../interfaces/IWETH.sol';\\n\\ncontract SafeBoxETH is Governable, ERC20, ReentrancyGuard {\\n  using SafeMath for uint;\\n  event Claim(address user, uint amount);\\n\\n  ICErc20 public immutable cToken;\\n  IWETH public immutable weth;\\n\\n  address public relayer;\\n  bytes32 public root;\\n  mapping(address => uint) public claimed;\\n\\n  constructor(\\n    ICErc20 _cToken,\\n    string memory _name,\\n    string memory _symbol\\n  ) public ERC20(_name, _symbol) {\\n    _setupDecimals(_cToken.decimals());\\n    IWETH _weth = IWETH(_cToken.underlying());\\n    __Governable__init();\\n    cToken = _cToken;\\n    weth = _weth;\\n    relayer = msg.sender;\\n    _weth.approve(address(_cToken), uint(-1));\\n  }\\n\\n  function setRelayer(address _relayer) external onlyGov {\\n    relayer = _relayer;\\n  }\\n\\n  function updateRoot(bytes32 _root) external {\\n    require(msg.sender == relayer || msg.sender == governor, '!relayer');\\n    root = _root;\\n  }\\n\\n  function deposit() external payable nonReentrant {\\n    weth.deposit{value: msg.value}();\\n    uint cBalanceBefore = cToken.balanceOf(address(this));\\n    require(cToken.mint(msg.value) == 0, '!mint');\\n    uint cBalanceAfter = cToken.balanceOf(address(this));\\n    _mint(msg.sender, cBalanceAfter.sub(cBalanceBefore));\\n  }\\n\\n  function withdraw(uint amount) public nonReentrant {\\n    _burn(msg.sender, amount);\\n    uint wethBalanceBefore = weth.balanceOf(address(this));\\n    require(cToken.redeem(amount) == 0, '!redeem');\\n    uint wethBalanceAfter = weth.balanceOf(address(this));\\n    uint wethAmount = wethBalanceAfter.sub(wethBalanceBefore);\\n    weth.withdraw(wethAmount);\\n    (bool success, ) = msg.sender.call{value: wethAmount}(new bytes(0));\\n    require(success, '!withdraw');\\n  }\\n\\n  function claim(uint totalReward, bytes32[] memory proof) public nonReentrant {\\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, totalReward));\\n    require(MerkleProof.verify(proof, root, leaf), '!proof');\\n    uint send = totalReward.sub(claimed[msg.sender]);\\n    claimed[msg.sender] = totalReward;\\n    weth.withdraw(send);\\n    (bool success, ) = msg.sender.call{value: send}(new bytes(0));\\n    require(success, '!claim');\\n    emit Claim(msg.sender, send);\\n  }\\n\\n  function adminClaim(uint amount) external onlyGov {\\n    weth.withdraw(amount);\\n    (bool success, ) = msg.sender.call{value: amount}(new bytes(0));\\n    require(success, '!adminClaim');\\n  }\\n\\n  function claimAndWithdraw(\\n    uint claimAmount,\\n    bytes32[] memory proof,\\n    uint withdrawAmount\\n  ) external {\\n    claim(claimAmount, proof);\\n    withdraw(withdrawAmount);\\n  }\\n\\n  receive() external payable {\\n    require(msg.sender == address(weth), '!weth');\\n  }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n * \\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n * \\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri) public {\\n        _setURI(uri);\\n\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) external view override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            require(accounts[i] != address(0), \\\"ERC1155: batch balance query for the zero address\\\");\\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        _balances[id][account] = _balances[id][account].sub(\\n            amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\\n                amounts[i],\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\nimport \\\"./IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    constructor() public {\\n        _registerInterface(\\n            ERC1155Receiver(0).onERC1155Received.selector ^\\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"}
{"address": "0x25a5feb5ac6533fe3c4e8e8e2a55f9e1f1f8e5f0", "attacktype": "Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DInterest.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"./libs/DecMath.sol\\\";\\nimport \\\"./moneymarkets/IMoneyMarket.sol\\\";\\nimport \\\"./models/fee/IFeeModel.sol\\\";\\nimport \\\"./models/interest/IInterestModel.sol\\\";\\nimport \\\"./NFT.sol\\\";\\nimport \\\"./rewards/MPHMinter.sol\\\";\\nimport \\\"./models/interest-oracle/IInterestOracle.sol\\\";\\n\\n// DeLorean Interest -- It's coming back from the future!\\n// EL PSY CONGROO\\n// Author: Zefram Lou\\n// Contact: zefram@baconlabs.dev\\ncontract DInterest is ReentrancyGuard, Ownable {\\n    using SafeMath for uint256;\\n    using DecMath for uint256;\\n    using SafeERC20 for ERC20;\\n    using Address for address;\\n\\n    // Constants\\n    uint256 internal constant PRECISION = 10**18;\\n    uint256 internal constant ONE = 10**18;\\n\\n    // User deposit data\\n    // Each deposit has an ID used in the depositNFT, which is equal to its index in `deposits` plus 1\\n    struct Deposit {\\n        uint256 amount; // Amount of stablecoin deposited\\n        uint256 maturationTimestamp; // Unix timestamp after which the deposit may be withdrawn, in seconds\\n        uint256 interestOwed; // Deficit incurred to the pool at time of deposit\\n        uint256 initialMoneyMarketIncomeIndex; // Money market's income index at time of deposit\\n        bool active; // True if not yet withdrawn, false if withdrawn\\n        bool finalSurplusIsNegative;\\n        uint256 finalSurplusAmount; // Surplus remaining after withdrawal\\n        uint256 mintMPHAmount; // Amount of MPH minted to user\\n    }\\n    Deposit[] internal deposits;\\n    uint256 public latestFundedDepositID; // the ID of the most recently created deposit that was funded\\n    uint256 public unfundedUserDepositAmount; // the deposited stablecoin amount whose deficit hasn't been funded\\n\\n    // Funding data\\n    // Each funding has an ID used in the fundingNFT, which is equal to its index in `fundingList` plus 1\\n    struct Funding {\\n        // deposits with fromDepositID < ID <= toDepositID are funded\\n        uint256 fromDepositID;\\n        uint256 toDepositID;\\n        uint256 recordedFundedDepositAmount;\\n        uint256 recordedMoneyMarketIncomeIndex;\\n    }\\n    Funding[] internal fundingList;\\n\\n    // Params\\n    uint256 public MinDepositPeriod; // Minimum deposit period, in seconds\\n    uint256 public MaxDepositPeriod; // Maximum deposit period, in seconds\\n    uint256 public MinDepositAmount; // Minimum deposit amount for each deposit, in stablecoins\\n    uint256 public MaxDepositAmount; // Maximum deposit amount for each deposit, in stablecoins\\n\\n    // Instance variables\\n    uint256 public totalDeposit;\\n    uint256 public totalInterestOwed;\\n\\n    // External smart contracts\\n    IMoneyMarket public moneyMarket;\\n    ERC20 public stablecoin;\\n    IFeeModel public feeModel;\\n    IInterestModel public interestModel;\\n    IInterestOracle public interestOracle;\\n    NFT public depositNFT;\\n    NFT public fundingNFT;\\n    MPHMinter public mphMinter;\\n\\n    // Events\\n    event EDeposit(\\n        address indexed sender,\\n        uint256 indexed depositID,\\n        uint256 amount,\\n        uint256 maturationTimestamp,\\n        uint256 interestAmount,\\n        uint256 mintMPHAmount\\n    );\\n    event EWithdraw(\\n        address indexed sender,\\n        uint256 indexed depositID,\\n        uint256 indexed fundingID,\\n        bool early,\\n        uint256 takeBackMPHAmount\\n    );\\n    event EFund(\\n        address indexed sender,\\n        uint256 indexed fundingID,\\n        uint256 deficitAmount,\\n        uint256 mintMPHAmount\\n    );\\n    event ESetParamAddress(\\n        address indexed sender,\\n        string indexed paramName,\\n        address newValue\\n    );\\n    event ESetParamUint(\\n        address indexed sender,\\n        string indexed paramName,\\n        uint256 newValue\\n    );\\n\\n    struct DepositLimit {\\n        uint256 MinDepositPeriod;\\n        uint256 MaxDepositPeriod;\\n        uint256 MinDepositAmount;\\n        uint256 MaxDepositAmount;\\n    }\\n\\n    constructor(\\n        DepositLimit memory _depositLimit,\\n        address _moneyMarket, // Address of IMoneyMarket that's used for generating interest (owner must be set to this DInterest contract)\\n        address _stablecoin, // Address of the stablecoin used to store funds\\n        address _feeModel, // Address of the FeeModel contract that determines how fees are charged\\n        address _interestModel, // Address of the InterestModel contract that determines how much interest to offer\\n        address _interestOracle, // Address of the InterestOracle contract that provides the average interest rate\\n        address _depositNFT, // Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\\n        address _fundingNFT, // Address of the NFT representing ownership of fundings (owner must be set to this DInterest contract)\\n        address _mphMinter // Address of the contract for handling minting MPH to users\\n    ) public {\\n        // Verify input addresses\\n        require(\\n            _moneyMarket.isContract() &&\\n                _stablecoin.isContract() &&\\n                _feeModel.isContract() &&\\n                _interestModel.isContract() &&\\n                _interestOracle.isContract() &&\\n                _depositNFT.isContract() &&\\n                _fundingNFT.isContract() &&\\n                _mphMinter.isContract(),\\n            \\\"DInterest: An input address is not a contract\\\"\\n        );\\n\\n        moneyMarket = IMoneyMarket(_moneyMarket);\\n        stablecoin = ERC20(_stablecoin);\\n        feeModel = IFeeModel(_feeModel);\\n        interestModel = IInterestModel(_interestModel);\\n        interestOracle = IInterestOracle(_interestOracle);\\n        depositNFT = NFT(_depositNFT);\\n        fundingNFT = NFT(_fundingNFT);\\n        mphMinter = MPHMinter(_mphMinter);\\n\\n        // Ensure moneyMarket uses the same stablecoin\\n        require(\\n            moneyMarket.stablecoin() == _stablecoin,\\n            \\\"DInterest: moneyMarket.stablecoin() != _stablecoin\\\"\\n        );\\n\\n        // Ensure interestOracle uses the same moneyMarket\\n        require(\\n            interestOracle.moneyMarket() == _moneyMarket,\\n            \\\"DInterest: interestOracle.moneyMarket() != _moneyMarket\\\"\\n        );\\n\\n        // Verify input uint256 parameters\\n        require(\\n            _depositLimit.MaxDepositPeriod > 0 &&\\n                _depositLimit.MaxDepositAmount > 0,\\n            \\\"DInterest: An input uint256 is 0\\\"\\n        );\\n        require(\\n            _depositLimit.MinDepositPeriod <= _depositLimit.MaxDepositPeriod,\\n            \\\"DInterest: Invalid DepositPeriod range\\\"\\n        );\\n        require(\\n            _depositLimit.MinDepositAmount <= _depositLimit.MaxDepositAmount,\\n            \\\"DInterest: Invalid DepositAmount range\\\"\\n        );\\n\\n        MinDepositPeriod = _depositLimit.MinDepositPeriod;\\n        MaxDepositPeriod = _depositLimit.MaxDepositPeriod;\\n        MinDepositAmount = _depositLimit.MinDepositAmount;\\n        MaxDepositAmount = _depositLimit.MaxDepositAmount;\\n        totalDeposit = 0;\\n    }\\n\\n    /**\\n        Public actions\\n     */\\n\\n    function deposit(uint256 amount, uint256 maturationTimestamp)\\n        external\\n        nonReentrant\\n    {\\n        _deposit(amount, maturationTimestamp);\\n    }\\n\\n    function withdraw(uint256 depositID, uint256 fundingID)\\n        external\\n        nonReentrant\\n    {\\n        _withdraw(depositID, fundingID, false);\\n    }\\n\\n    function earlyWithdraw(uint256 depositID, uint256 fundingID)\\n        external\\n        nonReentrant\\n    {\\n        _withdraw(depositID, fundingID, true);\\n    }\\n\\n    function multiDeposit(\\n        uint256[] calldata amountList,\\n        uint256[] calldata maturationTimestampList\\n    ) external nonReentrant {\\n        require(\\n            amountList.length == maturationTimestampList.length,\\n            \\\"DInterest: List lengths unequal\\\"\\n        );\\n        for (uint256 i = 0; i < amountList.length; i = i.add(1)) {\\n            _deposit(amountList[i], maturationTimestampList[i]);\\n        }\\n    }\\n\\n    function multiWithdraw(\\n        uint256[] calldata depositIDList,\\n        uint256[] calldata fundingIDList\\n    ) external nonReentrant {\\n        require(\\n            depositIDList.length == fundingIDList.length,\\n            \\\"DInterest: List lengths unequal\\\"\\n        );\\n        for (uint256 i = 0; i < depositIDList.length; i = i.add(1)) {\\n            _withdraw(depositIDList[i], fundingIDList[i], false);\\n        }\\n    }\\n\\n    function multiEarlyWithdraw(\\n        uint256[] calldata depositIDList,\\n        uint256[] calldata fundingIDList\\n    ) external nonReentrant {\\n        require(\\n            depositIDList.length == fundingIDList.length,\\n            \\\"DInterest: List lengths unequal\\\"\\n        );\\n        for (uint256 i = 0; i < depositIDList.length; i = i.add(1)) {\\n            _withdraw(depositIDList[i], fundingIDList[i], true);\\n        }\\n    }\\n\\n    /**\\n        Deficit funding\\n     */\\n\\n    function fundAll() external nonReentrant {\\n        // Calculate current deficit\\n        (bool isNegative, uint256 deficit) = surplus();\\n        require(isNegative, \\\"DInterest: No deficit available\\\");\\n        require(\\n            !depositIsFunded(deposits.length),\\n            \\\"DInterest: All deposits funded\\\"\\n        );\\n\\n        // Create funding struct\\n        uint256 incomeIndex = moneyMarket.incomeIndex();\\n        require(incomeIndex > 0, \\\"DInterest: incomeIndex == 0\\\");\\n        fundingList.push(\\n            Funding({\\n                fromDepositID: latestFundedDepositID,\\n                toDepositID: deposits.length,\\n                recordedFundedDepositAmount: unfundedUserDepositAmount,\\n                recordedMoneyMarketIncomeIndex: incomeIndex\\n            })\\n        );\\n\\n        // Update relevant values\\n        latestFundedDepositID = deposits.length;\\n        unfundedUserDepositAmount = 0;\\n\\n        _fund(deficit);\\n    }\\n\\n    function fundMultiple(uint256 toDepositID) external nonReentrant {\\n        require(\\n            toDepositID > latestFundedDepositID,\\n            \\\"DInterest: Deposits already funded\\\"\\n        );\\n        require(\\n            toDepositID <= deposits.length,\\n            \\\"DInterest: Invalid toDepositID\\\"\\n        );\\n\\n        (bool isNegative, uint256 surplus) = surplus();\\n        require(isNegative, \\\"DInterest: No deficit available\\\");\\n\\n        uint256 totalDeficit = 0;\\n        uint256 totalSurplus = 0;\\n        uint256 totalDepositToFund = 0;\\n        // Deposits with ID [latestFundedDepositID+1, toDepositID] will be funded\\n        for (\\n            uint256 id = latestFundedDepositID.add(1);\\n            id <= toDepositID;\\n            id = id.add(1)\\n        ) {\\n            Deposit storage depositEntry = _getDeposit(id);\\n            if (depositEntry.active) {\\n                // Deposit still active, use current surplus\\n                (isNegative, surplus) = surplusOfDeposit(id);\\n            } else {\\n                // Deposit has been withdrawn, use recorded final surplus\\n                (isNegative, surplus) = (\\n                    depositEntry.finalSurplusIsNegative,\\n                    depositEntry.finalSurplusAmount\\n                );\\n            }\\n\\n            if (isNegative) {\\n                // Add on deficit to total\\n                totalDeficit = totalDeficit.add(surplus);\\n            } else {\\n                // Has surplus\\n                totalSurplus = totalSurplus.add(surplus);\\n            }\\n\\n            if (depositEntry.active) {\\n                totalDepositToFund = totalDepositToFund.add(\\n                    depositEntry.amount\\n                );\\n            }\\n        }\\n        if (totalSurplus >= totalDeficit) {\\n            // Deposits selected have a surplus as a whole, revert\\n            revert(\\\"DInterest: Selected deposits in surplus\\\");\\n        } else {\\n            // Deduct surplus from totalDeficit\\n            totalDeficit = totalDeficit.sub(totalSurplus);\\n        }\\n\\n        // Create funding struct\\n        uint256 incomeIndex = moneyMarket.incomeIndex();\\n        require(incomeIndex > 0, \\\"DInterest: incomeIndex == 0\\\");\\n        fundingList.push(\\n            Funding({\\n                fromDepositID: latestFundedDepositID,\\n                toDepositID: toDepositID,\\n                recordedFundedDepositAmount: totalDepositToFund,\\n                recordedMoneyMarketIncomeIndex: incomeIndex\\n            })\\n        );\\n\\n        // Update relevant values\\n        latestFundedDepositID = toDepositID;\\n        unfundedUserDepositAmount = unfundedUserDepositAmount.sub(\\n            totalDepositToFund\\n        );\\n\\n        _fund(totalDeficit);\\n    }\\n\\n    /**\\n        Public getters\\n     */\\n\\n    function calculateInterestAmount(\\n        uint256 depositAmount,\\n        uint256 depositPeriodInSeconds\\n    ) public returns (uint256 interestAmount) {\\n        (, uint256 moneyMarketInterestRatePerSecond) = interestOracle\\n            .updateAndQuery();\\n        (bool surplusIsNegative, uint256 surplusAmount) = surplus();\\n\\n        return\\n            interestModel.calculateInterestAmount(\\n                depositAmount,\\n                depositPeriodInSeconds,\\n                moneyMarketInterestRatePerSecond,\\n                surplusIsNegative,\\n                surplusAmount\\n            );\\n    }\\n\\n    function surplus() public returns (bool isNegative, uint256 surplusAmount) {\\n        uint256 totalValue = moneyMarket.totalValue();\\n        uint256 totalOwed = totalDeposit.add(totalInterestOwed);\\n        if (totalValue >= totalOwed) {\\n            // Locked value more than owed deposits, positive surplus\\n            isNegative = false;\\n            surplusAmount = totalValue.sub(totalOwed);\\n        } else {\\n            // Locked value less than owed deposits, negative surplus\\n            isNegative = true;\\n            surplusAmount = totalOwed.sub(totalValue);\\n        }\\n    }\\n\\n    function surplusOfDeposit(uint256 depositID)\\n        public\\n        returns (bool isNegative, uint256 surplusAmount)\\n    {\\n        Deposit storage depositEntry = _getDeposit(depositID);\\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\\n        uint256 currentDepositValue = depositEntry\\n            .amount\\n            .mul(currentMoneyMarketIncomeIndex)\\n            .div(depositEntry.initialMoneyMarketIncomeIndex);\\n        uint256 owed = depositEntry.amount.add(depositEntry.interestOwed);\\n        if (currentDepositValue >= owed) {\\n            // Locked value more than owed deposits, positive surplus\\n            isNegative = false;\\n            surplusAmount = currentDepositValue.sub(owed);\\n        } else {\\n            // Locked value less than owed deposits, negative surplus\\n            isNegative = true;\\n            surplusAmount = owed.sub(currentDepositValue);\\n        }\\n    }\\n\\n    function depositIsFunded(uint256 id) public view returns (bool) {\\n        return (id <= latestFundedDepositID);\\n    }\\n\\n    function depositsLength() external view returns (uint256) {\\n        return deposits.length;\\n    }\\n\\n    function fundingListLength() external view returns (uint256) {\\n        return fundingList.length;\\n    }\\n\\n    function getDeposit(uint256 depositID)\\n        external\\n        view\\n        returns (Deposit memory)\\n    {\\n        return deposits[depositID.sub(1)];\\n    }\\n\\n    function getFunding(uint256 fundingID)\\n        external\\n        view\\n        returns (Funding memory)\\n    {\\n        return fundingList[fundingID.sub(1)];\\n    }\\n\\n    function moneyMarketIncomeIndex() external returns (uint256) {\\n        return moneyMarket.incomeIndex();\\n    }\\n\\n    /**\\n        Param setters\\n     */\\n    function setFeeModel(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: not contract\\\");\\n        feeModel = IFeeModel(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"feeModel\\\", newValue);\\n    }\\n\\n    function setInterestModel(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: not contract\\\");\\n        interestModel = IInterestModel(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"interestModel\\\", newValue);\\n    }\\n\\n    function setInterestOracle(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: not contract\\\");\\n        interestOracle = IInterestOracle(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"interestOracle\\\", newValue);\\n    }\\n\\n    function setRewards(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"DInterest: not contract\\\");\\n        moneyMarket.setRewards(newValue);\\n        emit ESetParamAddress(msg.sender, \\\"moneyMarket.rewards\\\", newValue);\\n    }\\n\\n    function setMinDepositPeriod(uint256 newValue) external onlyOwner {\\n        require(newValue <= MaxDepositPeriod, \\\"DInterest: invalid value\\\");\\n        MinDepositPeriod = newValue;\\n        emit ESetParamUint(msg.sender, \\\"MinDepositPeriod\\\", newValue);\\n    }\\n\\n    function setMaxDepositPeriod(uint256 newValue) external onlyOwner {\\n        require(\\n            newValue >= MinDepositPeriod && newValue > 0,\\n            \\\"DInterest: invalid value\\\"\\n        );\\n        MaxDepositPeriod = newValue;\\n        emit ESetParamUint(msg.sender, \\\"MaxDepositPeriod\\\", newValue);\\n    }\\n\\n    function setMinDepositAmount(uint256 newValue) external onlyOwner {\\n        require(newValue <= MaxDepositAmount, \\\"DInterest: invalid value\\\");\\n        MinDepositAmount = newValue;\\n        emit ESetParamUint(msg.sender, \\\"MinDepositAmount\\\", newValue);\\n    }\\n\\n    function setMaxDepositAmount(uint256 newValue) external onlyOwner {\\n        require(\\n            newValue >= MinDepositAmount && newValue > 0,\\n            \\\"DInterest: invalid value\\\"\\n        );\\n        MaxDepositAmount = newValue;\\n        emit ESetParamUint(msg.sender, \\\"MaxDepositAmount\\\", newValue);\\n    }\\n\\n    function setDepositNFTTokenURI(uint256 tokenId, string calldata newURI)\\n        external\\n        onlyOwner\\n    {\\n        depositNFT.setTokenURI(tokenId, newURI);\\n    }\\n\\n    function setDepositNFTBaseURI(string calldata newURI) external onlyOwner {\\n        depositNFT.setBaseURI(newURI);\\n    }\\n\\n    function setDepositNFTContractURI(string calldata newURI)\\n        external\\n        onlyOwner\\n    {\\n        depositNFT.setContractURI(newURI);\\n    }\\n\\n    function setFundingNFTTokenURI(uint256 tokenId, string calldata newURI)\\n        external\\n        onlyOwner\\n    {\\n        fundingNFT.setTokenURI(tokenId, newURI);\\n    }\\n\\n    function setFundingNFTBaseURI(string calldata newURI) external onlyOwner {\\n        fundingNFT.setBaseURI(newURI);\\n    }\\n\\n    function setFundingNFTContractURI(string calldata newURI)\\n        external\\n        onlyOwner\\n    {\\n        fundingNFT.setContractURI(newURI);\\n    }\\n\\n    /**\\n        Internal getters\\n     */\\n\\n    function _getDeposit(uint256 depositID)\\n        internal\\n        view\\n        returns (Deposit storage)\\n    {\\n        return deposits[depositID.sub(1)];\\n    }\\n\\n    function _getFunding(uint256 fundingID)\\n        internal\\n        view\\n        returns (Funding storage)\\n    {\\n        return fundingList[fundingID.sub(1)];\\n    }\\n\\n    /**\\n        Internals\\n     */\\n\\n    function _deposit(uint256 amount, uint256 maturationTimestamp) internal {\\n        // Cannot deposit 0\\n        require(amount > 0, \\\"DInterest: Deposit amount is 0\\\");\\n\\n        // Ensure deposit amount is not more than maximum\\n        require(\\n            amount >= MinDepositAmount && amount <= MaxDepositAmount,\\n            \\\"DInterest: Deposit amount out of range\\\"\\n        );\\n\\n        // Ensure deposit period is at least MinDepositPeriod\\n        uint256 depositPeriod = maturationTimestamp.sub(now);\\n        require(\\n            depositPeriod >= MinDepositPeriod &&\\n                depositPeriod <= MaxDepositPeriod,\\n            \\\"DInterest: Deposit period out of range\\\"\\n        );\\n\\n        // Update totalDeposit\\n        totalDeposit = totalDeposit.add(amount);\\n\\n        // Update funding related data\\n        uint256 id = deposits.length.add(1);\\n        unfundedUserDepositAmount = unfundedUserDepositAmount.add(amount);\\n\\n        // Calculate interest\\n        uint256 interestAmount = calculateInterestAmount(amount, depositPeriod);\\n        require(interestAmount > 0, \\\"DInterest: interestAmount == 0\\\");\\n\\n        // Update totalInterestOwed\\n        totalInterestOwed = totalInterestOwed.add(interestAmount);\\n\\n        // Mint MPH for msg.sender\\n        uint256 mintMPHAmount = mphMinter.mintDepositorReward(\\n            msg.sender,\\n            interestAmount\\n        );\\n\\n        // Record deposit data for `msg.sender`\\n        deposits.push(\\n            Deposit({\\n                amount: amount,\\n                maturationTimestamp: maturationTimestamp,\\n                interestOwed: interestAmount,\\n                initialMoneyMarketIncomeIndex: moneyMarket.incomeIndex(),\\n                active: true,\\n                finalSurplusIsNegative: false,\\n                finalSurplusAmount: 0,\\n                mintMPHAmount: mintMPHAmount\\n            })\\n        );\\n\\n        // Transfer `amount` stablecoin to DInterest\\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // Lend `amount` stablecoin to money market\\n        stablecoin.safeIncreaseAllowance(address(moneyMarket), amount);\\n        moneyMarket.deposit(amount);\\n\\n        // Mint depositNFT\\n        depositNFT.mint(msg.sender, id);\\n\\n        // Emit event\\n        emit EDeposit(\\n            msg.sender,\\n            id,\\n            amount,\\n            maturationTimestamp,\\n            interestAmount,\\n            mintMPHAmount\\n        );\\n    }\\n\\n    function _withdraw(\\n        uint256 depositID,\\n        uint256 fundingID,\\n        bool early\\n    ) internal {\\n        Deposit storage depositEntry = _getDeposit(depositID);\\n\\n        // Verify deposit is active and set to inactive\\n        require(depositEntry.active, \\\"DInterest: Deposit not active\\\");\\n        depositEntry.active = false;\\n\\n        if (early) {\\n            // Verify `now < depositEntry.maturationTimestamp`\\n            require(\\n                now < depositEntry.maturationTimestamp,\\n                \\\"DInterest: Deposit mature, use withdraw() instead\\\"\\n            );\\n        } else {\\n            // Verify `now >= depositEntry.maturationTimestamp`\\n            require(\\n                now >= depositEntry.maturationTimestamp,\\n                \\\"DInterest: Deposit not mature\\\"\\n            );\\n        }\\n\\n        // Verify msg.sender owns the depositNFT\\n        require(\\n            depositNFT.ownerOf(depositID) == msg.sender,\\n            \\\"DInterest: Sender doesn't own depositNFT\\\"\\n        );\\n\\n        // Take back MPH\\n        uint256 takeBackMPHAmount = mphMinter.takeBackDepositorReward(\\n            msg.sender,\\n            depositEntry.mintMPHAmount,\\n            early\\n        );\\n\\n        // Update totalDeposit\\n        totalDeposit = totalDeposit.sub(depositEntry.amount);\\n\\n        // Update totalInterestOwed\\n        totalInterestOwed = totalInterestOwed.sub(depositEntry.interestOwed);\\n\\n        // Burn depositNFT\\n        depositNFT.burn(depositID);\\n\\n        uint256 feeAmount;\\n        uint256 withdrawAmount;\\n        if (early) {\\n            // Withdraw the principal of the deposit from money market\\n            withdrawAmount = depositEntry.amount;\\n        } else {\\n            // Withdraw the principal & the interest from money market\\n            feeAmount = feeModel.getFee(depositEntry.interestOwed);\\n            withdrawAmount = depositEntry.amount.add(depositEntry.interestOwed);\\n        }\\n        withdrawAmount = moneyMarket.withdraw(withdrawAmount);\\n\\n        (bool depositIsNegative, uint256 depositSurplus) = surplusOfDeposit(\\n            depositID\\n        );\\n\\n        // If deposit was funded, payout interest to funder\\n        if (depositIsFunded(depositID)) {\\n            Funding storage f = _getFunding(fundingID);\\n            require(\\n                depositID > f.fromDepositID && depositID <= f.toDepositID,\\n                \\\"DInterest: Deposit not funded by fundingID\\\"\\n            );\\n            uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\\n            require(\\n                currentMoneyMarketIncomeIndex > 0,\\n                \\\"DInterest: currentMoneyMarketIncomeIndex == 0\\\"\\n            );\\n            uint256 interestAmount = f\\n                .recordedFundedDepositAmount\\n                .mul(currentMoneyMarketIncomeIndex)\\n                .div(f.recordedMoneyMarketIncomeIndex)\\n                .sub(f.recordedFundedDepositAmount);\\n\\n            // Update funding values\\n            f.recordedFundedDepositAmount = f.recordedFundedDepositAmount.sub(\\n                depositEntry.amount\\n            );\\n            f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\\n\\n            // Send interest to funder\\n            uint256 transferToFunderAmount = (early && depositIsNegative)\\n                ? interestAmount.add(depositSurplus)\\n                : interestAmount;\\n            if (transferToFunderAmount > 0) {\\n                transferToFunderAmount = moneyMarket.withdraw(\\n                    transferToFunderAmount\\n                );\\n                stablecoin.safeTransfer(\\n                    fundingNFT.ownerOf(fundingID),\\n                    transferToFunderAmount\\n                );\\n            }\\n        } else {\\n            // Remove deposit from future deficit fundings\\n            unfundedUserDepositAmount = unfundedUserDepositAmount.sub(\\n                depositEntry.amount\\n            );\\n\\n            // Record remaining surplus\\n            depositEntry.finalSurplusIsNegative = depositIsNegative;\\n            depositEntry.finalSurplusAmount = depositSurplus;\\n        }\\n\\n        // Send `withdrawAmount - feeAmount` stablecoin to `msg.sender`\\n        stablecoin.safeTransfer(msg.sender, withdrawAmount.sub(feeAmount));\\n\\n        // Send `feeAmount` stablecoin to feeModel beneficiary\\n        stablecoin.safeTransfer(feeModel.beneficiary(), feeAmount);\\n\\n        // Emit event\\n        emit EWithdraw(\\n            msg.sender,\\n            depositID,\\n            fundingID,\\n            early,\\n            takeBackMPHAmount\\n        );\\n    }\\n\\n    function _fund(uint256 totalDeficit) internal {\\n        // Transfer `totalDeficit` stablecoins from msg.sender\\n        stablecoin.safeTransferFrom(msg.sender, address(this), totalDeficit);\\n\\n        // Deposit `totalDeficit` stablecoins into moneyMarket\\n        stablecoin.safeIncreaseAllowance(address(moneyMarket), totalDeficit);\\n        moneyMarket.deposit(totalDeficit);\\n\\n        // Mint fundingNFT\\n        fundingNFT.mint(msg.sender, fundingList.length);\\n\\n        // Mint MPH for msg.sender\\n        uint256 mintMPHAmount = mphMinter.mintFunderReward(\\n            msg.sender,\\n            totalDeficit\\n        );\\n\\n        // Emit event\\n        uint256 fundingID = fundingList.length;\\n        emit EFund(msg.sender, fundingID, totalDeficit, mintMPHAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/DecMath.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n// Decimal math library\\nlibrary DecMath {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    function decmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a.mul(b).div(PRECISION);\\n    }\\n\\n    function decdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a.mul(PRECISION).div(b);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/IMoneyMarket.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n// Interface for money market protocols (Compound, Aave, bZx, etc.)\\ninterface IMoneyMarket {\\n    function deposit(uint256 amount) external;\\n\\n    function withdraw(uint256 amountInUnderlying)\\n        external\\n        returns (uint256 actualAmountWithdrawn);\\n\\n    function claimRewards() external; // Claims farmed tokens (e.g. COMP, CRV) and sends it to the rewards pool\\n\\n    function totalValue() external returns (uint256); // The total value locked in the money market, in terms of the underlying stablecoin\\n\\n    function incomeIndex() external returns (uint256); // Used for calculating the interest generated (e.g. cDai's price for the Compound market)\\n\\n    function stablecoin() external view returns (address);\\n\\n    function setRewards(address newValue) external;\\n\\n    event ESetParamAddress(\\n        address indexed sender,\\n        string indexed paramName,\\n        address newValue\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/models/fee/IFeeModel.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\ninterface IFeeModel {\\n    function beneficiary() external view returns (address payable);\\n\\n    function getFee(uint256 _txAmount)\\n        external\\n        pure\\n        returns (uint256 _feeAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/models/interest/IInterestModel.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\ninterface IInterestModel {\\n    function calculateInterestAmount(\\n        uint256 depositAmount,\\n        uint256 depositPeriodInSeconds,\\n        uint256 moneyMarketInterestRatePerSecond,\\n        bool surplusIsNegative,\\n        uint256 surplusAmount\\n    ) external view returns (uint256 interestAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/NFT.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\n\\ncontract NFT is ERC721Metadata, Ownable {\\n    string internal _contractURI;\\n\\n    constructor(string memory name, string memory symbol)\\n        public\\n        ERC721Metadata(name, symbol)\\n    {}\\n\\n    function contractURI() external view returns (string memory) {\\n        return _contractURI;\\n    }\\n\\n    function mint(address to, uint256 tokenId) external onlyOwner {\\n        _safeMint(to, tokenId);\\n    }\\n\\n    function burn(uint256 tokenId) external onlyOwner {\\n        _burn(tokenId);\\n    }\\n\\n    function setContractURI(string calldata newURI) external onlyOwner {\\n        _contractURI = newURI;\\n    }\\n\\n    function setTokenURI(uint256 tokenId, string calldata newURI)\\n        external\\n        onlyOwner\\n    {\\n        _setTokenURI(tokenId, newURI);\\n    }\\n\\n    function setBaseURI(string calldata newURI) external onlyOwner {\\n        _setBaseURI(newURI);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURIs;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n    }\\n\\n    /**\\n     * @dev Gets the token name.\\n     * @return string representing the token name\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Gets the token symbol.\\n     * @return string representing the token symbol\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the URI for a given token ID. May return an empty string.\\n     *\\n     * If the token's URI is non-empty and a base URI was set (via\\n     * {_setBaseURI}), it will be added to the token ID's URI as a prefix.\\n     *\\n     * Reverts if the token ID does not exist.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\\n        if (bytes(_tokenURI).length == 0) {\\n            return \\\"\\\";\\n        } else {\\n            // abi.encodePacked is being used to concatenate strings\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token.\\n     *\\n     * Reverts if the token ID does not exist.\\n     *\\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\\n     * it and save gas.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI}.\\n     *\\n     * _Available since v2.5.0._\\n     */\\n    function _setBaseURI(string memory baseURI) internal {\\n        _baseURI = baseURI;\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a preffix in {tokenURI} to each token's URI, when\\n    * they are non-empty.\\n    *\\n    * _Available since v2.5.0._\\n    */\\n    function baseURI() external view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * Deprecated, use _burn(uint256) instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        super._burn(owner, tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../drafts/Counters.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using Counters for Counters.Counter;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from token ID to owner\\n    mapping (uint256 => address) private _tokenOwner;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to number of owned token\\n    mapping (address => Counters.Counter) private _ownedTokensCount;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    constructor () public {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner address to query the balance of\\n     * @return uint256 representing the amount owned by the passed address\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _ownedTokensCount[owner].current();\\n    }\\n\\n    /**\\n     * @dev Gets the owner of the specified token ID.\\n     * @param tokenId uint256 ID of the token to query the owner of\\n     * @return address currently marked as the owner of the given token ID\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _tokenOwner[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Approves another address to transfer the given token ID\\n     * The zero address indicates there is no approved address.\\n     * There can only be one approved address per token at a given time.\\n     * Can only be called by the token owner or an approved operator.\\n     * @param to address to be approved for the given token ID\\n     * @param tokenId uint256 ID of the token to be approved\\n     */\\n    function approve(address to, uint256 tokenId) public {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the approved address for a token ID, or zero if no address set\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to query the approval of\\n     * @return address currently approved for the given token ID\\n     */\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Sets or unsets the approval of a given operator\\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\\n     * @param to operator address to set the approval\\n     * @param approved representing the status of the approval to be set\\n     */\\n    function setApprovalForAll(address to, bool approved) public {\\n        require(to != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][to] = approved;\\n        emit ApprovalForAll(_msgSender(), to, approved);\\n    }\\n\\n    /**\\n     * @dev Tells whether an operator is approved by a given owner.\\n     * @param owner owner address which you want to query the approval of\\n     * @param operator operator address which you want to query the approval of\\n     * @return bool whether the given operator is approved by the given owner\\n     */\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Transfers the ownership of a given token ID to another address.\\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     * Requires the msg.sender to be the owner, approved, or operator.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the _msgSender() to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransferFrom(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\\n        _transferFrom(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether the specified token exists.\\n     * @param tokenId uint256 ID of the token to query the existence of\\n     * @return bool whether the token exists\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        address owner = _tokenOwner[tokenId];\\n        return owner != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether the given spender can transfer a given token ID.\\n     * @param spender address of the spender to query\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @return bool whether the msg.sender is approved for the given token ID,\\n     * is an operator of the owner, or is the owner of the token\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Internal function to safely mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to safely mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _tokenOwner[tokenId] = to;\\n        _ownedTokensCount[to].increment();\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * Deprecated, use {_burn} instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == owner, \\\"ERC721: burn of token that is not own\\\");\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[owner].decrement();\\n        _tokenOwner[tokenId] = address(0);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        _burn(ownerOf(tokenId), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[from].decrement();\\n        _ownedTokensCount[to].increment();\\n\\n        _tokenOwner[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        internal returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ));\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n            }\\n        } else {\\n            bytes4 retval = abi.decode(returndata, (bytes4));\\n            return (retval == _ERC721_RECEIVED);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to clear current approval of a given token ID.\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _clearApproval(uint256 tokenId) private {\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            _tokenApprovals[tokenId] = address(0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of NFTs in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract IERC721Receiver {\\n    /**\\n     * @notice Handle the receipt of an NFT\\n     * @dev The ERC721 smart contract calls this function on the recipient\\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\\n     * otherwise the caller will revert the transaction. The selector to be\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\n     * function MAY throw to revert and reject the transfer.\\n     * Note: the ERC721 contract address is always the message sender.\\n     * @param operator The address which called `safeTransferFrom` function\\n     * @param from The address which previously owned the token\\n     * @param tokenId The NFT identifier which is being transferred\\n     * @param data Additional data with no specified format\\n     * @return bytes4 `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\n    public returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/drafts/Counters.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract IERC721Metadata is IERC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/MPHMinter.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../libs/DecMath.sol\\\";\\nimport \\\"./MPHToken.sol\\\";\\n\\ncontract MPHMinter is Ownable {\\n    using Address for address;\\n    using DecMath for uint256;\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    /**\\n        @notice The multiplier applied to the interest generated by a pool when minting MPH\\n     */\\n    mapping(address => uint256) public poolMintingMultiplier;\\n    /**\\n        @notice The multiplier applied to the interest generated by a pool when letting depositors keep MPH\\n     */\\n    mapping(address => uint256) public poolDepositorRewardMultiplier;\\n    /**\\n        @notice The multiplier applied to the interest generated by a pool when letting deficit funders keep MPH\\n     */\\n    mapping(address => uint256) public poolFunderRewardMultiplier;\\n    /**\\n        @notice Multiplier used for calculating dev reward\\n     */\\n    uint256 public devRewardMultiplier;\\n\\n    event ESetParamAddress(\\n        address indexed sender,\\n        string indexed paramName,\\n        address newValue\\n    );\\n    event ESetParamUint(\\n        address indexed sender,\\n        string indexed paramName,\\n        uint256 newValue\\n    );\\n\\n    /**\\n        External contracts\\n     */\\n    MPHToken public mph;\\n    address public govTreasury;\\n    address public devWallet;\\n\\n    constructor(\\n        address _mph,\\n        address _govTreasury,\\n        address _devWallet,\\n        uint256 _devRewardMultiplier\\n    ) public {\\n        mph = MPHToken(_mph);\\n        govTreasury = _govTreasury;\\n        devWallet = _devWallet;\\n        devRewardMultiplier = _devRewardMultiplier;\\n    }\\n\\n    function mintDepositorReward(address to, uint256 interestAmount)\\n        external\\n        returns (uint256)\\n    {\\n        uint256 multiplier = poolMintingMultiplier[msg.sender];\\n        uint256 mintAmount = interestAmount.decmul(multiplier);\\n        if (mintAmount == 0) {\\n            // sender is not a pool/has been deactivated\\n            return 0;\\n        }\\n\\n        mph.ownerMint(to, mintAmount);\\n        mph.ownerMint(devWallet, mintAmount.decmul(devRewardMultiplier));\\n        return mintAmount;\\n    }\\n\\n    function mintFunderReward(address to, uint256 interestAmount)\\n        external\\n        returns (uint256)\\n    {\\n        uint256 multiplier = poolMintingMultiplier[msg.sender].decmul(\\n            poolFunderRewardMultiplier[msg.sender]\\n        );\\n        uint256 mintAmount = interestAmount.decmul(multiplier);\\n        if (mintAmount == 0) {\\n            // sender is not a pool/has been deactivated\\n            return 0;\\n        }\\n\\n        mph.ownerMint(to, mintAmount);\\n        mph.ownerMint(devWallet, mintAmount.decmul(devRewardMultiplier));\\n        return mintAmount;\\n    }\\n\\n    function takeBackDepositorReward(\\n        address from,\\n        uint256 mintMPHAmount,\\n        bool early\\n    ) external returns (uint256) {\\n        uint256 takeBackAmount = early\\n            ? mintMPHAmount\\n            : mintMPHAmount.decmul(\\n                PRECISION.sub(poolDepositorRewardMultiplier[msg.sender])\\n            );\\n        if (takeBackAmount == 0) {\\n            // sender is not a pool/has been deactivated\\n            return 0;\\n        }\\n\\n        mph.ownerTransfer(from, govTreasury, takeBackAmount);\\n        return takeBackAmount;\\n    }\\n\\n    /**\\n        Param setters\\n     */\\n    function setGovTreasury(address newValue) external onlyOwner {\\n        require(newValue != address(0), \\\"MPHMinter: 0 address\\\");\\n        govTreasury = newValue;\\n        emit ESetParamAddress(msg.sender, \\\"govTreasury\\\", newValue);\\n    }\\n\\n    function setDevWallet(address newValue) external onlyOwner {\\n        require(newValue != address(0), \\\"MPHMinter: 0 address\\\");\\n        devWallet = newValue;\\n        emit ESetParamAddress(msg.sender, \\\"devWallet\\\", newValue);\\n    }\\n\\n    function setPoolMintingMultiplier(address pool, uint256 newMultiplier)\\n        external\\n        onlyOwner\\n    {\\n        require(pool.isContract(), \\\"MPHMinter: pool not contract\\\");\\n        poolMintingMultiplier[pool] = newMultiplier;\\n        emit ESetParamUint(msg.sender, \\\"poolMintingMultiplier\\\", newMultiplier);\\n    }\\n\\n    function setPoolDepositorRewardMultiplier(\\n        address pool,\\n        uint256 newMultiplier\\n    ) external onlyOwner {\\n        require(pool.isContract(), \\\"MPHMinter: pool not contract\\\");\\n        require(newMultiplier <= PRECISION, \\\"MPHMinter: invalid multiplier\\\");\\n        poolDepositorRewardMultiplier[pool] = newMultiplier;\\n        emit ESetParamUint(\\n            msg.sender,\\n            \\\"poolDepositorRewardMultiplier\\\",\\n            newMultiplier\\n        );\\n    }\\n\\n    function setPoolFunderRewardMultiplier(address pool, uint256 newMultiplier)\\n        external\\n        onlyOwner\\n    {\\n        require(pool.isContract(), \\\"MPHMinter: pool not contract\\\");\\n        poolFunderRewardMultiplier[pool] = newMultiplier;\\n        emit ESetParamUint(\\n            msg.sender,\\n            \\\"poolFunderRewardMultiplier\\\",\\n            newMultiplier\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/MPHToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\n\\ncontract MPHToken is ERC20, ERC20Detailed, Ownable {\\n    constructor() public ERC20Detailed(\\\"88mph.app\\\", \\\"MPH\\\", 18) {}\\n\\n    function ownerMint(address account, uint256 amount)\\n        public\\n        onlyOwner\\n        returns (bool)\\n    {\\n        _mint(account, amount);\\n        return true;\\n    }\\n\\n    function ownerTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public onlyOwner returns (bool) {\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/models/interest-oracle/IInterestOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\ninterface IInterestOracle {\\n    function updateAndQuery() external returns (bool updated, uint256 value);\\n\\n    function query() external view returns (uint256 value);\\n\\n    function moneyMarket() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ATokenMock.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libs/DecMath.sol\\\";\\n\\ncontract ATokenMock is ERC20, ERC20Detailed {\\n    using SafeMath for uint256;\\n    using DecMath for uint256;\\n\\n    uint256 internal constant YEAR = 31556952; // Number of seconds in one Gregorian calendar year (365.2425 days)\\n\\n    ERC20 public dai;\\n    uint256 public liquidityRate;\\n    uint256 public normalizedIncome;\\n    address[] public users;\\n    mapping(address => bool) public isUser;\\n\\n    constructor(address _dai)\\n        public\\n        ERC20Detailed(\\\"aDAI\\\", \\\"aDAI\\\", 18)\\n    {\\n        dai = ERC20(_dai);\\n\\n        liquidityRate = 10 ** 26; // 10% APY\\n        normalizedIncome = 10 ** 27;\\n    }\\n\\n    function redeem(uint256 _amount) external {\\n        _burn(msg.sender, _amount);\\n        dai.transfer(msg.sender, _amount);\\n    }\\n\\n    function mint(address _user, uint256 _amount) external {\\n        _mint(_user, _amount);\\n        if (!isUser[_user]) {\\n            users.push(_user);\\n            isUser[_user] = true;\\n        }\\n    }\\n\\n    function mintInterest(uint256 _seconds) external {\\n        uint256 interest;\\n        address user;\\n        for (uint256 i = 0; i < users.length; i++) {\\n            user = users[i];\\n            interest = balanceOf(user).mul(_seconds).mul(liquidityRate).div(YEAR.mul(10**27));\\n            _mint(user, interest);\\n        }\\n        normalizedIncome = normalizedIncome.mul(_seconds).mul(liquidityRate).div(YEAR.mul(10**27)).add(normalizedIncome);\\n    }\\n\\n    function setLiquidityRate(uint256 _liquidityRate) external {\\n        liquidityRate = _liquidityRate;\\n    }\\n}\"\r\n    },\r\n    \"contracts/mocks/CERC20Mock.sol\": {\r\n      \"content\": \"/**\\n    Modified from https://github.com/bugduino/idle-contracts/blob/master/contracts/mocks/cDAIMock.sol\\n    at commit b85dafa8e55e053cb2d403fc4b28cfe86f2116d4\\n\\n    Original license:\\n    Copyright 2020 Idle Labs Inc.\\n\\n    Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n    you may not use this file except in compliance with the License.\\n    You may obtain a copy of the License at\\n\\n        http://www.apache.org/licenses/LICENSE-2.0\\n\\n    Unless required by applicable law or agreed to in writing, software\\n    distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n    See the License for the specific language governing permissions and\\n    limitations under the License.\\n */\\n\\npragma solidity 0.5.17;\\n\\n// interfaces\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\n\\n\\ncontract CERC20Mock is ERC20, ERC20Detailed {\\n    address public dai;\\n\\n    uint256 internal _supplyRate;\\n    uint256 internal _exchangeRate;\\n\\n    constructor(address _dai) public ERC20Detailed(\\\"cDAI\\\", \\\"cDAI\\\", 8) {\\n        dai = _dai;\\n        uint256 daiDecimals = ERC20Detailed(_dai).decimals();\\n        _exchangeRate = 2 * (10**(daiDecimals + 8)); // 1 cDAI = 0.02 DAI\\n        _supplyRate = 45290900000; // 10% supply rate per year\\n    }\\n\\n    function mint(uint256 amount) external returns (uint256) {\\n        require(\\n            ERC20(dai).transferFrom(msg.sender, address(this), amount),\\n            \\\"Error during transferFrom\\\"\\n        ); // 1 DAI\\n        _mint(msg.sender, (amount * 10**18) / _exchangeRate);\\n        return 0;\\n    }\\n\\n    function redeemUnderlying(uint256 amount) external returns (uint256) {\\n        _burn(msg.sender, (amount * 10**18) / _exchangeRate);\\n        require(\\n            ERC20(dai).transfer(msg.sender, amount),\\n            \\\"Error during transfer\\\"\\n        ); // 1 DAI\\n        return 0;\\n    }\\n\\n    function exchangeRateStored() external view returns (uint256) {\\n        return _exchangeRate;\\n    }\\n\\n    function exchangeRateCurrent() external view returns (uint256) {\\n        return _exchangeRate;\\n    }\\n\\n    function _setExchangeRateStored(uint256 _rate) external returns (uint256) {\\n        _exchangeRate = _rate;\\n    }\\n\\n    function supplyRatePerBlock() external view returns (uint256) {\\n        return _supplyRate;\\n    }\\n\\n    function _setSupplyRatePerBlock(uint256 _rate) external {\\n        _supplyRate = _rate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ComptrollerMock.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n// interfaces\\nimport \\\"./ERC20Mock.sol\\\";\\n\\ncontract ComptrollerMock {\\n    uint256 public constant CLAIM_AMOUNT = 10**18;\\n    ERC20Mock public comp;\\n\\n    constructor (address _comp) public {\\n        comp = ERC20Mock(_comp);\\n    }\\n\\n    function claimComp(address holder) external {\\n        comp.mint(holder, CLAIM_AMOUNT);\\n    }\\n\\n    function getCompAddress() external view returns (address) {\\n        return address(comp);\\n    }\\n}\"\r\n    },\r\n    \"contracts/mocks/ERC20Mock.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\n\\ncontract ERC20Mock is ERC20, ERC20Detailed(\\\"\\\", \\\"\\\", 6) {\\n    function mint(address to, uint256 amount) public {\\n        _mint(to, amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/mocks/LendingPoolAddressesProviderMock.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\ncontract LendingPoolAddressesProviderMock {\\n    address internal pool;\\n    address internal core;\\n\\n    function getLendingPool() external view returns (address) {\\n        return pool;\\n    }\\n\\n    function setLendingPoolImpl(address _pool) external {\\n        pool = _pool;\\n    }\\n\\n    function getLendingPoolCore() external view returns (address) {\\n        return core;\\n    }\\n\\n    function setLendingPoolCoreImpl(address _pool) external {\\n        core = _pool;\\n    }\\n}\"\r\n    },\r\n    \"contracts/mocks/LendingPoolCoreMock.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./ATokenMock.sol\\\";\\nimport \\\"./LendingPoolMock.sol\\\";\\n\\ncontract LendingPoolCoreMock {\\n    LendingPoolMock internal lendingPool;\\n\\n    function setLendingPool(address lendingPoolAddress) public {\\n        lendingPool = LendingPoolMock(lendingPoolAddress);\\n    }\\n\\n    function bounceTransfer(address _reserve, address _sender, uint256 _amount)\\n        external\\n    {\\n        ERC20 token = ERC20(_reserve);\\n        token.transferFrom(_sender, address(this), _amount);\\n\\n        token.transfer(msg.sender, _amount);\\n    }\\n\\n    // The equivalent of exchangeRateStored() for Compound cTokens\\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\\n        (, , , , , , , , , , , address aTokenAddress, ) = lendingPool\\n            .getReserveData(_reserve);\\n        ATokenMock aToken = ATokenMock(aTokenAddress);\\n        return aToken.normalizedIncome();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/LendingPoolMock.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./ATokenMock.sol\\\";\\nimport \\\"./LendingPoolCoreMock.sol\\\";\\n\\ncontract LendingPoolMock {\\n    mapping(address => address) internal reserveAToken;\\n    LendingPoolCoreMock public core;\\n\\n    constructor(address _core) public {\\n        core = LendingPoolCoreMock(_core);\\n    }\\n\\n    function setReserveAToken(address _reserve, address _aTokenAddress) external {\\n        reserveAToken[_reserve] = _aTokenAddress;\\n    }\\n\\n    function deposit(address _reserve, uint256 _amount, uint16)\\n        external\\n    {\\n        ERC20 token = ERC20(_reserve);\\n        core.bounceTransfer(_reserve, msg.sender, _amount);\\n\\n        // Mint aTokens\\n        address aTokenAddress = reserveAToken[_reserve];\\n        ATokenMock aToken = ATokenMock(aTokenAddress);\\n        aToken.mint(msg.sender, _amount);\\n        token.transfer(aTokenAddress, _amount);\\n    }\\n\\n    function getReserveData(address _reserve)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256 liquidityRate,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            address aTokenAddress,\\n            uint40\\n        )\\n    {\\n        aTokenAddress = reserveAToken[_reserve];\\n        ATokenMock aToken = ATokenMock(aTokenAddress);\\n        liquidityRate = aToken.liquidityRate();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/VaultMock.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libs/DecMath.sol\\\";\\n\\ncontract VaultMock is ERC20, ERC20Detailed {\\n    using SafeMath for uint256;\\n    using DecMath for uint256;\\n\\n    ERC20 public underlying;\\n\\n    constructor(address _underlying) public ERC20Detailed(\\\"yUSD\\\", \\\"yUSD\\\", 18) {\\n        underlying = ERC20(_underlying);\\n    }\\n\\n    function deposit(uint256 tokenAmount) public {\\n        uint256 sharePrice = getPricePerFullShare();\\n        _mint(msg.sender, tokenAmount.decdiv(sharePrice));\\n\\n        underlying.transferFrom(msg.sender, address(this), tokenAmount);\\n    }\\n\\n    function withdraw(uint256 sharesAmount) public {\\n        uint256 sharePrice = getPricePerFullShare();\\n        uint256 underlyingAmount = sharesAmount.decmul(sharePrice);\\n        _burn(msg.sender, sharesAmount);\\n\\n        underlying.transfer(msg.sender, underlyingAmount);\\n    }\\n\\n    function getPricePerFullShare() public view returns (uint256) {\\n        uint256 _totalSupply = totalSupply();\\n        if (_totalSupply == 0) {\\n            return 10**18;\\n        }\\n        return underlying.balanceOf(address(this)).decdiv(_totalSupply);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/models/fee/PercentageFeeModel.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./IFeeModel.sol\\\";\\n\\ncontract PercentageFeeModel is IFeeModel {\\n    using SafeMath for uint256;\\n\\n    address payable public beneficiary;\\n\\n    constructor(address payable _beneficiary) public {\\n        beneficiary = _beneficiary;\\n    }\\n\\n    function getFee(uint256 _txAmount)\\n        external\\n        pure\\n        returns (uint256 _feeAmount)\\n    {\\n        _feeAmount = _txAmount.div(10); // Precision is decreased by 1 decimal place\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/models/interest-oracle/EMAOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../moneymarkets/IMoneyMarket.sol\\\";\\nimport \\\"../../libs/DecMath.sol\\\";\\nimport \\\"./IInterestOracle.sol\\\";\\n\\ncontract EMAOracle is IInterestOracle {\\n    using SafeMath for uint256;\\n    using DecMath for uint256;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    /**\\n        Immutable parameters\\n     */\\n    uint256 public UPDATE_INTERVAL;\\n    uint256 public UPDATE_MULTIPLIER;\\n    uint256 public ONE_MINUS_UPDATE_MULTIPLIER;\\n\\n    /**\\n        Public variables\\n     */\\n    uint256 public emaStored;\\n    uint256 public lastIncomeIndex;\\n    uint256 public lastUpdateTimestamp;\\n\\n    /**\\n        External contracts\\n     */\\n    IMoneyMarket public moneyMarket;\\n\\n    constructor(\\n        uint256 _emaInitial,\\n        uint256 _updateInterval,\\n        uint256 _smoothingFactor,\\n        uint256 _averageWindowInIntervals,\\n        address _moneyMarket\\n    ) public {\\n        emaStored = _emaInitial;\\n        UPDATE_INTERVAL = _updateInterval;\\n        lastUpdateTimestamp = now;\\n\\n        uint256 updateMultiplier = _smoothingFactor.div(_averageWindowInIntervals.add(1));\\n        UPDATE_MULTIPLIER = updateMultiplier;\\n        ONE_MINUS_UPDATE_MULTIPLIER = PRECISION.sub(updateMultiplier);\\n\\n        moneyMarket = IMoneyMarket(_moneyMarket);\\n        lastIncomeIndex = moneyMarket.incomeIndex();\\n    }\\n\\n    function updateAndQuery() public returns (bool updated, uint256 value) {\\n        uint256 timeElapsed = now - lastUpdateTimestamp;\\n        if (timeElapsed < UPDATE_INTERVAL) {\\n            return (false, emaStored);\\n        }\\n\\n        // save gas by loading storage variables to memory\\n        uint256 _lastIncomeIndex = lastIncomeIndex;\\n        uint256 _emaStored = emaStored;\\n\\n        uint256 newIncomeIndex = moneyMarket.incomeIndex();\\n        uint256 incomingValue = newIncomeIndex.sub(_lastIncomeIndex).decdiv(_lastIncomeIndex).div(timeElapsed);\\n\\n        updated = true;\\n        value = incomingValue.mul(UPDATE_MULTIPLIER).add(_emaStored.mul(ONE_MINUS_UPDATE_MULTIPLIER)).div(PRECISION);\\n        emaStored = value;\\n        lastIncomeIndex = newIncomeIndex;\\n        lastUpdateTimestamp = now;\\n    }\\n\\n    function query() public view returns (uint256 value) {\\n        return emaStored;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/models/interest/LinearInterestModel.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../libs/DecMath.sol\\\";\\n\\ncontract LinearInterestModel {\\n    using SafeMath for uint256;\\n    using DecMath for uint256;\\n\\n    uint256 public constant PRECISION = 10**18;\\n    uint256 public IRMultiplier;\\n\\n    constructor(uint256 _IRMultiplier) public {\\n        IRMultiplier = _IRMultiplier;\\n    }\\n\\n    function calculateInterestAmount(\\n        uint256 depositAmount,\\n        uint256 depositPeriodInSeconds,\\n        uint256 moneyMarketInterestRatePerSecond,\\n        bool, /*surplusIsNegative*/\\n        uint256 /*surplusAmount*/\\n    ) external view returns (uint256 interestAmount) {\\n        // interestAmount = depositAmount * moneyMarketInterestRatePerSecond * IRMultiplier * depositPeriodInSeconds\\n        interestAmount = depositAmount\\n            .mul(PRECISION)\\n            .decmul(moneyMarketInterestRatePerSecond)\\n            .decmul(IRMultiplier)\\n            .mul(depositPeriodInSeconds)\\n            .div(PRECISION);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/aave/AaveMarket.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../IMoneyMarket.sol\\\";\\nimport \\\"./imports/IAToken.sol\\\";\\nimport \\\"./imports/ILendingPool.sol\\\";\\nimport \\\"./imports/ILendingPoolAddressesProvider.sol\\\";\\nimport \\\"./imports/ILendingPoolCore.sol\\\";\\n\\ncontract AaveMarket is IMoneyMarket, Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for ERC20;\\n    using Address for address;\\n\\n    uint16 internal constant REFERRALCODE = 20; // Aave referral program code\\n\\n    ILendingPoolAddressesProvider public provider; // Used for fetching the current address of LendingPool\\n    ERC20 public stablecoin;\\n\\n    constructor(address _provider, address _stablecoin) public {\\n        // Verify input addresses\\n        require(\\n            _provider != address(0) && _stablecoin != address(0),\\n            \\\"AaveMarket: An input address is 0\\\"\\n        );\\n        require(\\n            _provider.isContract() && _stablecoin.isContract(),\\n            \\\"AaveMarket: An input address is not a contract\\\"\\n        );\\n\\n        provider = ILendingPoolAddressesProvider(_provider);\\n        stablecoin = ERC20(_stablecoin);\\n    }\\n\\n    function deposit(uint256 amount) external onlyOwner {\\n        require(amount > 0, \\\"AaveMarket: amount is 0\\\");\\n\\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\\n        address lendingPoolCore = provider.getLendingPoolCore();\\n\\n        // Transfer `amount` stablecoin from `msg.sender`\\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // Approve `amount` stablecoin to lendingPool\\n        stablecoin.safeIncreaseAllowance(lendingPoolCore, amount);\\n\\n        // Deposit `amount` stablecoin to lendingPool\\n        lendingPool.deposit(address(stablecoin), amount, REFERRALCODE);\\n    }\\n\\n    function withdraw(uint256 amountInUnderlying)\\n        external\\n        onlyOwner\\n        returns (uint256 actualAmountWithdrawn)\\n    {\\n        require(amountInUnderlying > 0, \\\"AaveMarket: amountInUnderlying is 0\\\");\\n\\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\\n\\n        // Initialize aToken\\n        (, , , , , , , , , , , address aTokenAddress, ) = lendingPool\\n            .getReserveData(address(stablecoin));\\n        IAToken aToken = IAToken(aTokenAddress);\\n\\n        // Redeem `amountInUnderlying` aToken, since 1 aToken = 1 stablecoin\\n        aToken.redeem(amountInUnderlying);\\n\\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\\n\\n        return amountInUnderlying;\\n    }\\n\\n    function claimRewards() external {}\\n\\n    function totalValue() external returns (uint256) {\\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\\n\\n        // Initialize aToken\\n        (, , , , , , , , , , , address aTokenAddress, ) = lendingPool\\n            .getReserveData(address(stablecoin));\\n        IAToken aToken = IAToken(aTokenAddress);\\n\\n        return aToken.balanceOf(address(this));\\n    }\\n\\n    function incomeIndex() external returns (uint256) {\\n        ILendingPoolCore lendingPoolCore = ILendingPoolCore(\\n            provider.getLendingPoolCore()\\n        );\\n        return lendingPoolCore.getReserveNormalizedIncome(address(stablecoin));\\n    }\\n\\n    function setRewards(address newValue) external {}\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/aave/imports/IAToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\n// Aave aToken interface\\n// Documentation: https://docs.aave.com/developers/developing-on-aave/the-protocol/atokens\\ninterface IAToken {\\n    function redeem(uint256 _amount) external;\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/aave/imports/ILendingPool.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\n// Aave lending pool interface\\n// Documentation: https://docs.aave.com/developers/developing-on-aave/the-protocol/lendingpool\\ninterface ILendingPool {\\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\\n        external;\\n\\n    function getReserveData(address _reserve)\\n        external\\n        view\\n        returns (\\n            uint256 totalLiquidity,\\n            uint256 availableLiquidity,\\n            uint256 totalBorrowsStable,\\n            uint256 totalBorrowsVariable,\\n            uint256 liquidityRate,\\n            uint256 variableBorrowRate,\\n            uint256 stableBorrowRate,\\n            uint256 averageStableBorrowRate,\\n            uint256 utilizationRate,\\n            uint256 liquidityIndex,\\n            uint256 variableBorrowIndex,\\n            address aTokenAddress,\\n            uint40 lastUpdateTimestamp\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/aave/imports/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\n// Aave lending pool addresses provider interface\\n// Documentation: https://docs.aave.com/developers/developing-on-aave/the-protocol/lendingpooladdressesprovider\\ninterface ILendingPoolAddressesProvider {\\n    function getLendingPool() external view returns (address);\\n\\n    function setLendingPoolImpl(address _pool) external;\\n\\n    function getLendingPoolCore() external view returns (address payable);\\n\\n    function setLendingPoolCoreImpl(address _lendingPoolCore) external;\\n\\n    function getLendingPoolConfigurator() external view returns (address);\\n\\n    function setLendingPoolConfiguratorImpl(address _configurator) external;\\n\\n    function getLendingPoolDataProvider() external view returns (address);\\n\\n    function setLendingPoolDataProviderImpl(address _provider) external;\\n\\n    function getLendingPoolParametersProvider() external view returns (address);\\n\\n    function setLendingPoolParametersProviderImpl(address _parametersProvider)\\n        external;\\n\\n    function getTokenDistributor() external view returns (address);\\n\\n    function setTokenDistributor(address _tokenDistributor) external;\\n\\n    function getFeeProvider() external view returns (address);\\n\\n    function setFeeProviderImpl(address _feeProvider) external;\\n\\n    function getLendingPoolLiquidationManager() external view returns (address);\\n\\n    function setLendingPoolLiquidationManager(address _manager) external;\\n\\n    function getLendingPoolManager() external view returns (address);\\n\\n    function setLendingPoolManager(address _lendingPoolManager) external;\\n\\n    function getPriceOracle() external view returns (address);\\n\\n    function setPriceOracle(address _priceOracle) external;\\n\\n    function getLendingRateOracle() external view returns (address);\\n\\n    function setLendingRateOracle(address _lendingRateOracle) external;\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/aave/imports/ILendingPoolCore.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\n// Aave lending pool core interface\\n// Documentation: https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPoolCore.sol#L615\\ninterface ILendingPoolCore {\\n    // The equivalent of exchangeRateStored() for Compound cTokens\\n    function getReserveNormalizedIncome(address _reserve)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/compound/CompoundERC20Market.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../IMoneyMarket.sol\\\";\\nimport \\\"../../libs/DecMath.sol\\\";\\nimport \\\"./imports/ICERC20.sol\\\";\\nimport \\\"./imports/IComptroller.sol\\\";\\n\\ncontract CompoundERC20Market is IMoneyMarket, Ownable {\\n    using DecMath for uint256;\\n    using SafeERC20 for ERC20;\\n    using Address for address;\\n\\n    uint256 internal constant ERRCODE_OK = 0;\\n\\n    ICERC20 public cToken;\\n    IComptroller public comptroller;\\n    address public rewards;\\n    ERC20 public stablecoin;\\n\\n    constructor(\\n        address _cToken,\\n        address _comptroller,\\n        address _rewards,\\n        address _stablecoin\\n    ) public {\\n        // Verify input addresses\\n        require(\\n            _cToken != address(0) &&\\n                _comptroller != address(0) &&\\n                _rewards != address(0) &&\\n                _stablecoin != address(0),\\n            \\\"CompoundERC20Market: An input address is 0\\\"\\n        );\\n        require(\\n            _cToken.isContract() &&\\n                _comptroller.isContract() &&\\n                _rewards.isContract() &&\\n                _stablecoin.isContract(),\\n            \\\"CompoundERC20Market: An input address is not a contract\\\"\\n        );\\n\\n        cToken = ICERC20(_cToken);\\n        comptroller = IComptroller(_comptroller);\\n        rewards = _rewards;\\n        stablecoin = ERC20(_stablecoin);\\n    }\\n\\n    function deposit(uint256 amount) external onlyOwner {\\n        require(amount > 0, \\\"CompoundERC20Market: amount is 0\\\");\\n\\n        // Transfer `amount` stablecoin from `msg.sender`\\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // Deposit `amount` stablecoin into cToken\\n        stablecoin.safeIncreaseAllowance(address(cToken), amount);\\n        require(\\n            cToken.mint(amount) == ERRCODE_OK,\\n            \\\"CompoundERC20Market: Failed to mint cTokens\\\"\\n        );\\n    }\\n\\n    function withdraw(uint256 amountInUnderlying)\\n        external\\n        onlyOwner\\n        returns (uint256 actualAmountWithdrawn)\\n    {\\n        require(\\n            amountInUnderlying > 0,\\n            \\\"CompoundERC20Market: amountInUnderlying is 0\\\"\\n        );\\n\\n        // Withdraw `amountInUnderlying` stablecoin from cToken\\n        require(\\n            cToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\\n            \\\"CompoundERC20Market: Failed to redeem\\\"\\n        );\\n\\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\\n\\n        return amountInUnderlying;\\n    }\\n\\n    function claimRewards() external {\\n        comptroller.claimComp(address(this));\\n        ERC20 comp = ERC20(comptroller.getCompAddress());\\n        comp.safeTransfer(rewards, comp.balanceOf(address(this)));\\n    }\\n\\n    function totalValue() external returns (uint256) {\\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\\n        // Amount of stablecoin units that 1 unit of cToken can be exchanged for, scaled by 10^18\\n        uint256 cTokenPrice = cToken.exchangeRateCurrent();\\n        return cTokenBalance.decmul(cTokenPrice);\\n    }\\n\\n    function incomeIndex() external returns (uint256) {\\n        return cToken.exchangeRateCurrent();\\n    }\\n\\n    /**\\n        Param setters\\n     */\\n    function setRewards(address newValue) external onlyOwner {\\n        require(newValue.isContract(), \\\"CompoundERC20Market: not contract\\\");\\n        rewards = newValue;\\n        emit ESetParamAddress(msg.sender, \\\"rewards\\\", newValue);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/compound/imports/ICERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\n// Compound finance ERC20 market interface\\n// Documentation: https://compound.finance/docs/ctokens\\ninterface ICERC20 {\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external returns (uint256);\\n\\n    function getAccountSnapshot(address account)\\n        external\\n        view\\n        returns (uint256, uint256, uint256, uint256);\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    function supplyRatePerBlock() external view returns (uint256);\\n\\n    function totalBorrowsCurrent() external returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external returns (uint256);\\n\\n    function borrowBalanceStored(address account)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function getCash() external view returns (uint256);\\n\\n    function accrueInterest() external returns (uint256);\\n\\n    function seize(address liquidator, address borrower, uint256 seizeTokens)\\n        external\\n        returns (uint256);\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\\n        external\\n        returns (uint256);\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        address cTokenCollateral\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/compound/imports/IComptroller.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n\\n// Compound finance Comptroller interface\\n// Documentation: https://compound.finance/docs/comptroller\\ninterface IComptroller {\\n    function claimComp(address holder) external;\\n    function getCompAddress() external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/moneymarkets/yvault/imports/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.17;\\n\\ninterface Vault {\\n    function deposit(uint256) external;\\n\\n    function withdraw(uint256) external;\\n\\n    function getPricePerFullShare() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/moneymarkets/yvault/YVaultMarket.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../IMoneyMarket.sol\\\";\\nimport \\\"../../libs/DecMath.sol\\\";\\nimport \\\"./imports/Vault.sol\\\";\\n\\ncontract YVaultMarket is IMoneyMarket, Ownable {\\n    using SafeMath for uint256;\\n    using DecMath for uint256;\\n    using SafeERC20 for ERC20;\\n    using Address for address;\\n\\n    Vault public vault;\\n    ERC20 public stablecoin;\\n\\n    constructor(address _vault, address _stablecoin) public {\\n        // Verify input addresses\\n        require(\\n            _vault != address(0) && _stablecoin != address(0),\\n            \\\"YVaultMarket: An input address is 0\\\"\\n        );\\n        require(\\n            _vault.isContract() && _stablecoin.isContract(),\\n            \\\"YVaultMarket: An input address is not a contract\\\"\\n        );\\n\\n        vault = Vault(_vault);\\n        stablecoin = ERC20(_stablecoin);\\n    }\\n\\n    function deposit(uint256 amount) external onlyOwner {\\n        require(amount > 0, \\\"YVaultMarket: amount is 0\\\");\\n\\n        // Transfer `amount` stablecoin from `msg.sender`\\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // Approve `amount` stablecoin to vault\\n        stablecoin.safeIncreaseAllowance(address(vault), amount);\\n\\n        // Deposit `amount` stablecoin to vault\\n        vault.deposit(amount);\\n    }\\n\\n    function withdraw(uint256 amountInUnderlying)\\n        external\\n        onlyOwner\\n        returns (uint256 actualAmountWithdrawn)\\n    {\\n        require(\\n            amountInUnderlying > 0,\\n            \\\"YVaultMarket: amountInUnderlying is 0\\\"\\n        );\\n\\n        // Withdraw `amountInShares` shares from vault\\n        uint256 sharePrice = vault.getPricePerFullShare();\\n        uint256 amountInShares = amountInUnderlying.decdiv(sharePrice);\\n        vault.withdraw(amountInShares);\\n\\n        // Transfer stablecoin to `msg.sender`\\n        actualAmountWithdrawn = stablecoin.balanceOf(address(this));\\n        stablecoin.safeTransfer(msg.sender, actualAmountWithdrawn);\\n    }\\n\\n    function claimRewards() external {}\\n\\n    function totalValue() external returns (uint256) {\\n        uint256 sharePrice = vault.getPricePerFullShare();\\n        uint256 shareBalance = vault.balanceOf(address(this));\\n        return shareBalance.decmul(sharePrice);\\n    }\\n\\n    function incomeIndex() external returns (uint256) {\\n        return vault.getPricePerFullShare();\\n    }\\n\\n    function setRewards(address newValue) external {}\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/IRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.5.17;\\n\\ninterface IRewards {\\n    function notifyRewardAmount(uint256 reward) external;\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/OneSplitAudit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.17;\\n\\ninterface OneSplitAudit {\\n    function swap(\\n        address fromToken,\\n        address destToken,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] calldata distribution,\\n        uint256 flags\\n    ) external payable returns (uint256 returnAmount);\\n\\n    function getExpectedReturn(\\n        address fromToken,\\n        address destToken,\\n        uint256 amount,\\n        uint256 parts,\\n        uint256 flags // See constants in IOneSplit.sol\\n    )\\n        external\\n        view\\n        returns (uint256 returnAmount, uint256[] memory distribution);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/Rewards.sol\": {\r\n      \"content\": \"/*\\n   ____            __   __        __   _\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\n     /___/\\n* Synthetix: Rewards.sol\\n*\\n* Docs: https://docs.synthetix.io/\\n*\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2020 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\n\\npragma solidity 0.5.17;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./OneSplitAudit.sol\\\";\\n\\ncontract IRewardDistributionRecipient is Ownable {\\n    address rewardDistribution;\\n\\n    function notifyRewardAmount(uint256 reward) external;\\n\\n    modifier onlyRewardDistribution() {\\n        require(\\n            _msgSender() == rewardDistribution,\\n            \\\"Caller is not reward distribution\\\"\\n        );\\n        _;\\n    }\\n\\n    function setRewardDistribution(address _rewardDistribution)\\n        external\\n        onlyOwner\\n    {\\n        rewardDistribution = _rewardDistribution;\\n    }\\n}\\n\\ncontract LPTokenWrapper {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public stakeToken;\\n\\n    uint256 private _totalSupply;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    constructor(address _stakeToken) public {\\n        stakeToken = IERC20(_stakeToken);\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function stake(uint256 amount) public {\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        stakeToken.safeTransferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function withdraw(uint256 amount) public {\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        stakeToken.safeTransfer(msg.sender, amount);\\n    }\\n}\\n\\ncontract Rewards is LPTokenWrapper, IRewardDistributionRecipient {\\n    IERC20 public rewardToken;\\n    OneSplitAudit public oneSplit;\\n    uint256 public constant DURATION = 7 days;\\n\\n    uint256 public starttime;\\n    uint256 public periodFinish = 0;\\n    uint256 public rewardRate = 0;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n\\n    bool public initialized = false;\\n\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    modifier checkStart {\\n        require(block.timestamp >= starttime, \\\"Rewards: not start\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _stakeToken,\\n        address _rewardToken,\\n        address _oneSplit,\\n        uint256 _starttime\\n    ) public LPTokenWrapper(_stakeToken) {\\n        rewardToken = IERC20(_rewardToken);\\n        oneSplit = OneSplitAudit(_oneSplit);\\n        starttime = _starttime;\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return Math.min(block.timestamp, periodFinish);\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (totalSupply() == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored.add(\\n                lastTimeRewardApplicable()\\n                    .sub(lastUpdateTime)\\n                    .mul(rewardRate)\\n                    .mul(1e18)\\n                    .div(totalSupply())\\n            );\\n    }\\n\\n    function earned(address account) public view returns (uint256) {\\n        return\\n            balanceOf(account)\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n                .div(1e18)\\n                .add(rewards[account]);\\n    }\\n\\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\\n        require(amount > 0, \\\"Rewards: cannot stake 0\\\");\\n        super.stake(amount);\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    function withdraw(uint256 amount)\\n        public\\n        updateReward(msg.sender)\\n        checkStart\\n    {\\n        require(amount > 0, \\\"Rewards: cannot withdraw 0\\\");\\n        super.withdraw(amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function exit() external {\\n        withdraw(balanceOf(msg.sender));\\n        getReward();\\n    }\\n\\n    function getReward() public updateReward(msg.sender) checkStart {\\n        uint256 reward = earned(msg.sender);\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n            rewardToken.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function notifyRewardAmount(uint256 reward)\\n        external\\n        onlyRewardDistribution\\n        updateReward(address(0))\\n    {\\n        _notifyRewardAmount(reward);\\n    }\\n\\n    function dump(address token, uint256 parts) external {\\n        require(token != address(stakeToken), \\\"Rewards: no dump stakeToken\\\");\\n        require(token != address(rewardToken), \\\"Rewards: no dump rewardToken\\\");\\n\\n        // dump token for rewardToken\\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\\n        (uint256 returnAmount, uint256[] memory distribution) = oneSplit\\n            .getExpectedReturn(\\n            token,\\n            address(rewardToken),\\n            tokenBalance,\\n            parts,\\n            0\\n        );\\n        uint256 receivedRewardTokenAmount = oneSplit.swap(\\n            token,\\n            address(rewardToken),\\n            tokenBalance,\\n            returnAmount,\\n            distribution,\\n            0\\n        );\\n\\n        // notify reward\\n        _notifyRewardAmount(receivedRewardTokenAmount);\\n    }\\n\\n    function _notifyRewardAmount(uint256 reward) internal {\\n        // https://sips.synthetix.io/sips/sip-77\\n        require(\\n            reward < uint256(-1) / 10**18,\\n            \\\"Rewards: rewards too large, would lock\\\"\\n        );\\n        if (block.timestamp > starttime) {\\n            if (block.timestamp >= periodFinish) {\\n                rewardRate = reward.div(DURATION);\\n            } else {\\n                uint256 remaining = periodFinish.sub(block.timestamp);\\n                uint256 leftover = remaining.mul(rewardRate);\\n                rewardRate = reward.add(leftover).div(DURATION);\\n            }\\n            lastUpdateTime = block.timestamp;\\n            periodFinish = block.timestamp.add(DURATION);\\n            emit RewardAdded(reward);\\n        } else {\\n            rewardRate = reward.div(DURATION);\\n            lastUpdateTime = starttime;\\n            periodFinish = starttime.add(DURATION);\\n            emit RewardAdded(reward);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"}
{"address": "0x951d51baefb72319d9fbe941e1615938d89abfe2", "attacktype": "Absence of code logic or sanity check", "sourcecode": "// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\n// File: contracts/lib/CompoundOracleInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n// AT MAINNET ADDRESS: 0x02557a5E05DeFeFFD4cAe6D83eA3d173B272c904\r\n\r\ncontract CompoundOracleInterface {\r\n    // returns asset:eth -- to get USDC:eth, have to do 10**24/result,\r\n\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n  * @notice retrieves price of an asset\r\n  * @dev function to get price for an asset\r\n  * @param asset Asset for which to get the price\r\n  * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\r\n  */\r\n    function getPrice(address asset) public view returns (uint);\r\n    function getUnderlyingPrice(ERC20 cToken) public view returns (uint);\r\n    // function getPrice(address asset) public view returns (uint) {\r\n    //     return 527557000000000;\r\n    // }\r\n\r\n}\r\n\r\n// File: contracts/lib/UniswapExchangeInterface.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n// Solidity Interface\r\ncontract UniswapExchangeInterface {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n// File: contracts/lib/UniswapFactoryInterface.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n// Solidity Interface\r\ncontract UniswapFactoryInterface {\r\n    // Public Variables\r\n    address public exchangeTemplate;\r\n    uint256 public tokenCount;\r\n    // // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n    // function createExchange(address token) external returns (address exchange) {\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n    // // Get Exchange and Token Info\r\n    // function getExchange(address token) external view returns (address exchange){\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n    // function getToken(address exchange) external view returns (address token) {\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n    // function getTokenWithId(uint256 tokenId) external view returns (address token) {\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n}\r\n\r\n// File: contracts/OptionsUtils.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\ncontract OptionsUtils {\r\n    // defauls are for mainnet\r\n    UniswapFactoryInterface public UNISWAP_FACTORY;\r\n\r\n    CompoundOracleInterface public COMPOUND_ORACLE;\r\n\r\n    constructor(address _uniswapFactory, address _compoundOracle) public {\r\n        UNISWAP_FACTORY = UniswapFactoryInterface(_uniswapFactory);\r\n        COMPOUND_ORACLE = CompoundOracleInterface(_compoundOracle);\r\n    }\r\n\r\n    // TODO: for now gets Uniswap, later update to get other exchanges\r\n    function getExchange(address _token)\r\n        public\r\n        view\r\n        returns (UniswapExchangeInterface)\r\n    {\r\n        if (address(UNISWAP_FACTORY.getExchange(_token)) == address(0)) {\r\n            revert(\"No payout exchange\");\r\n        }\r\n\r\n        UniswapExchangeInterface exchange = UniswapExchangeInterface(\r\n            UNISWAP_FACTORY.getExchange(_token)\r\n        );\r\n\r\n        return exchange;\r\n    }\r\n\r\n    function isETH(IERC20 _ierc20) public pure returns (bool) {\r\n        return _ierc20 == IERC20(0);\r\n    }\r\n}\r\n\r\n// File: contracts/OptionsExchange.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OptionsExchange {\r\n    uint256 constant LARGE_BLOCK_SIZE = 1651753129000;\r\n    uint256 constant LARGE_APPROVAL_NUMBER = 10**30;\r\n\r\n    UniswapFactoryInterface public UNISWAP_FACTORY;\r\n\r\n    constructor(address _uniswapFactory) public {\r\n        UNISWAP_FACTORY = UniswapFactoryInterface(_uniswapFactory);\r\n    }\r\n\r\n    /*** Events ***/\r\n    event SellOTokens(\r\n        address seller,\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address payoutTokenAddress,\r\n        uint256 oTokensToSell,\r\n        uint256 payoutTokensReceived\r\n    );\r\n    event BuyOTokens(\r\n        address buyer,\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address paymentTokenAddress,\r\n        uint256 oTokensToBuy,\r\n        uint256 premiumPaid\r\n    );\r\n\r\n    /**\r\n    * @notice This function sells oTokens on Uniswap and sends back payoutTokens to the receiver\r\n    * @param receiver The address to send the payout tokens back to\r\n    * @param oTokenAddress The address of the oToken to sell\r\n    * @param payoutTokenAddress The address of the token to receive the premiums in\r\n    * @param oTokensToSell The number of oTokens to sell\r\n    */\r\n    function sellOTokens(\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address payoutTokenAddress,\r\n        uint256 oTokensToSell\r\n    ) public {\r\n        // @note: first need to bootstrap the uniswap exchange to get the address.\r\n        IERC20 oToken = IERC20(oTokenAddress);\r\n        IERC20 payoutToken = IERC20(payoutTokenAddress);\r\n        oToken.transferFrom(msg.sender, address(this), oTokensToSell);\r\n        uint256 payoutTokensReceived = uniswapSellOToken(\r\n            oToken,\r\n            payoutToken,\r\n            oTokensToSell,\r\n            receiver\r\n        );\r\n\r\n        emit SellOTokens(\r\n            msg.sender,\r\n            receiver,\r\n            oTokenAddress,\r\n            payoutTokenAddress,\r\n            oTokensToSell,\r\n            payoutTokensReceived\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice This function buys oTokens on Uniswap and using paymentTokens from the receiver\r\n    * @param receiver The address to send the oTokens back to\r\n    * @param oTokenAddress The address of the oToken to buy\r\n    * @param paymentTokenAddress The address of the token to pay the premiums in\r\n    * @param oTokensToBuy The number of oTokens to buy\r\n    */\r\n    function buyOTokens(\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address paymentTokenAddress,\r\n        uint256 oTokensToBuy\r\n    ) public payable {\r\n        IERC20 oToken = IERC20(oTokenAddress);\r\n        IERC20 paymentToken = IERC20(paymentTokenAddress);\r\n        uniswapBuyOToken(paymentToken, oToken, oTokensToBuy, receiver);\r\n    }\r\n\r\n    /**\r\n    * @notice This function calculates the amount of premiums that the seller\r\n    * will receive if they sold oTokens on Uniswap\r\n    * @param oTokenAddress The address of the oToken to sell\r\n    * @param payoutTokenAddress The address of the token to receive the premiums in\r\n    * @param oTokensToSell The number of oTokens to sell\r\n    */\r\n    function premiumReceived(\r\n        address oTokenAddress,\r\n        address payoutTokenAddress,\r\n        uint256 oTokensToSell\r\n    ) public view returns (uint256) {\r\n        // get the amount of ETH that will be paid out if oTokensToSell is sold.\r\n        UniswapExchangeInterface oTokenExchange = getExchange(oTokenAddress);\r\n        uint256 ethReceived = oTokenExchange.getTokenToEthInputPrice(\r\n            oTokensToSell\r\n        );\r\n\r\n        if (!isETH(IERC20(payoutTokenAddress))) {\r\n            // get the amount of payout tokens that will be received if the ethRecieved is sold.\r\n            UniswapExchangeInterface payoutExchange = getExchange(\r\n                payoutTokenAddress\r\n            );\r\n            return payoutExchange.getEthToTokenInputPrice(ethReceived);\r\n        }\r\n        return ethReceived;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice This function calculates the premiums to be paid if a buyer wants to\r\n    * buy oTokens on Uniswap\r\n    * @param oTokenAddress The address of the oToken to buy\r\n    * @param paymentTokenAddress The address of the token to pay the premiums in\r\n    * @param oTokensToBuy The number of oTokens to buy\r\n    */\r\n    function premiumToPay(\r\n        address oTokenAddress,\r\n        address paymentTokenAddress,\r\n        uint256 oTokensToBuy\r\n    ) public view returns (uint256) {\r\n        // get the amount of ETH that needs to be paid for oTokensToBuy.\r\n        UniswapExchangeInterface oTokenExchange = getExchange(oTokenAddress);\r\n        uint256 ethToPay = oTokenExchange.getEthToTokenOutputPrice(\r\n            oTokensToBuy\r\n        );\r\n\r\n        if (!isETH(IERC20(paymentTokenAddress))) {\r\n            // get the amount of paymentTokens that needs to be paid to get the desired ethToPay.\r\n            UniswapExchangeInterface paymentTokenExchange = getExchange(\r\n                paymentTokenAddress\r\n            );\r\n            return paymentTokenExchange.getTokenToEthOutputPrice(ethToPay);\r\n        }\r\n\r\n        return ethToPay;\r\n    }\r\n\r\n    function uniswapSellOToken(\r\n        IERC20 oToken,\r\n        IERC20 payoutToken,\r\n        uint256 _amt,\r\n        address payable _transferTo\r\n    ) internal returns (uint256) {\r\n        require(!isETH(oToken), \"Can only sell oTokens\");\r\n        UniswapExchangeInterface exchange = getExchange(address(oToken));\r\n\r\n        if (isETH(payoutToken)) {\r\n            //Token to ETH\r\n            oToken.approve(address(exchange), _amt);\r\n            return\r\n                exchange.tokenToEthTransferInput(\r\n                    _amt,\r\n                    1,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo\r\n                );\r\n        } else {\r\n            //Token to Token\r\n            oToken.approve(address(exchange), _amt);\r\n            return\r\n                exchange.tokenToTokenTransferInput(\r\n                    _amt,\r\n                    1,\r\n                    1,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo,\r\n                    address(payoutToken)\r\n                );\r\n        }\r\n    }\r\n\r\n    function uniswapBuyOToken(\r\n        IERC20 paymentToken,\r\n        IERC20 oToken,\r\n        uint256 _amt,\r\n        address payable _transferTo\r\n    ) public returns (uint256) {\r\n        require(!isETH(oToken), \"Can only buy oTokens\");\r\n\r\n        if (!isETH(paymentToken)) {\r\n            UniswapExchangeInterface exchange = getExchange(\r\n                address(paymentToken)\r\n            );\r\n\r\n            uint256 paymentTokensToTransfer = premiumToPay(\r\n                address(oToken),\r\n                address(paymentToken),\r\n                _amt\r\n            );\r\n            paymentToken.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                paymentTokensToTransfer\r\n            );\r\n\r\n            // Token to Token\r\n            paymentToken.approve(address(exchange), LARGE_APPROVAL_NUMBER);\r\n\r\n            emit BuyOTokens(\r\n                msg.sender,\r\n                _transferTo,\r\n                address(oToken),\r\n                address(paymentToken),\r\n                _amt,\r\n                paymentTokensToTransfer\r\n            );\r\n\r\n            return\r\n                exchange.tokenToTokenTransferInput(\r\n                    paymentTokensToTransfer,\r\n                    1,\r\n                    1,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo,\r\n                    address(oToken)\r\n                );\r\n        } else {\r\n            // ETH to Token\r\n            UniswapExchangeInterface exchange = UniswapExchangeInterface(\r\n                UNISWAP_FACTORY.getExchange(address(oToken))\r\n            );\r\n\r\n            uint256 ethToTransfer = exchange.getEthToTokenOutputPrice(_amt);\r\n\r\n            emit BuyOTokens(\r\n                msg.sender,\r\n                _transferTo,\r\n                address(oToken),\r\n                address(paymentToken),\r\n                _amt,\r\n                ethToTransfer\r\n            );\r\n\r\n            return\r\n                exchange.ethToTokenTransferOutput.value(ethToTransfer)(\r\n                    _amt,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo\r\n                );\r\n        }\r\n    }\r\n\r\n    function getExchange(address _token)\r\n        internal\r\n        view\r\n        returns (UniswapExchangeInterface)\r\n    {\r\n        UniswapExchangeInterface exchange = UniswapExchangeInterface(\r\n            UNISWAP_FACTORY.getExchange(_token)\r\n        );\r\n\r\n        if (address(exchange) == address(0)) {\r\n            revert(\"No payout exchange\");\r\n        }\r\n\r\n        return exchange;\r\n    }\r\n\r\n    function isETH(IERC20 _ierc20) internal pure returns (bool) {\r\n        return _ierc20 == IERC20(0);\r\n    }\r\n\r\n    function() external payable {\r\n        // to get ether from uniswap exchanges\r\n    }\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/OptionsContract.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Opyn's Options Contract\r\n * @author Opyn\r\n */\r\ncontract OptionsContract is Ownable, ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    /* represents floting point numbers, where number = value * 10 ** exponent\r\n    i.e 0.1 = 10 * 10 ** -3 */\r\n    struct Number {\r\n        uint256 value;\r\n        int32 exponent;\r\n    }\r\n\r\n    // Keeps track of the weighted collateral and weighted debt for each vault.\r\n    struct Vault {\r\n        uint256 collateral;\r\n        uint256 oTokensIssued;\r\n        uint256 underlying;\r\n        bool owned;\r\n    }\r\n\r\n    OptionsExchange public optionsExchange;\r\n\r\n    mapping(address => Vault) internal vaults;\r\n\r\n    address payable[] internal vaultOwners;\r\n\r\n    // 10 is 0.01 i.e. 1% incentive.\r\n    Number public liquidationIncentive = Number(10, -3);\r\n\r\n    // 100 is egs. 0.1 i.e. 10%.\r\n    Number public transactionFee = Number(0, -3);\r\n\r\n    /* 500 is 0.5. Max amount that a Vault can be liquidated by i.e.\r\n    max collateral that can be taken in one function call */\r\n    Number public liquidationFactor = Number(500, -3);\r\n\r\n    /* 16 means 1.6. The minimum ratio of a Vault's collateral to insurance promised.\r\n    The ratio is calculated as below:\r\n    vault.collateral / (Vault.oTokensIssued * strikePrice) */\r\n    Number public minCollateralizationRatio = Number(16, -1);\r\n\r\n    // The amount of insurance promised per oToken\r\n    Number public strikePrice;\r\n\r\n    // The amount of underlying that 1 oToken protects.\r\n    Number public oTokenExchangeRate;\r\n\r\n    /* UNIX time.\r\n    Exercise period starts at `(expiry - windowSize)` and ends at `expiry` */\r\n    uint256 internal windowSize;\r\n\r\n    /* The total fees accumulated in the contract any time liquidate or exercise is called */\r\n    uint256 internal totalFee;\r\n\r\n    // The time of expiry of the options contract\r\n    uint256 public expiry;\r\n\r\n    // The precision of the collateral\r\n    int32 public collateralExp = -18;\r\n\r\n    // The precision of the underlying\r\n    int32 public underlyingExp = -18;\r\n\r\n    // The collateral asset\r\n    IERC20 public collateral;\r\n\r\n    // The asset being protected by the insurance\r\n    IERC20 public underlying;\r\n\r\n    // The asset in which insurance is denominated in.\r\n    IERC20 public strike;\r\n\r\n    // The Oracle used for the contract\r\n    CompoundOracleInterface public COMPOUND_ORACLE;\r\n\r\n    // The name of  the contract\r\n    string public name;\r\n\r\n    // The symbol of  the contract\r\n    string public symbol;\r\n\r\n    // The number of decimals of the contract\r\n    uint8 public decimals;\r\n\r\n    /**\r\n    * @param _collateral The collateral asset\r\n    * @param _collExp The precision of the collateral (-18 if ETH)\r\n    * @param _underlying The asset that is being protected\r\n    * @param _underlyingExp The precision of the underlying asset\r\n    * @param _oTokenExchangeExp The precision of the `amount of underlying` that 1 oToken protects\r\n    * @param _strikePrice The amount of strike asset that will be paid out per oToken\r\n    * @param _strikeExp The precision of the strike price.\r\n    * @param _strike The asset in which the insurance is calculated\r\n    * @param _expiry The time at which the insurance expires\r\n    * @param _optionsExchange The contract which interfaces with the exchange + oracle\r\n    * @param _oracleAddress The address of the oracle\r\n    * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\r\n    */\r\n    constructor(\r\n        IERC20 _collateral,\r\n        int32 _collExp,\r\n        IERC20 _underlying,\r\n        int32 _underlyingExp,\r\n        int32 _oTokenExchangeExp,\r\n        uint256 _strikePrice,\r\n        int32 _strikeExp,\r\n        IERC20 _strike,\r\n        uint256 _expiry,\r\n        OptionsExchange _optionsExchange,\r\n        address _oracleAddress,\r\n        uint256 _windowSize\r\n    ) public {\r\n        require(block.timestamp < _expiry, \"Can't deploy an expired contract\");\r\n        require(\r\n            _windowSize <= _expiry,\r\n            \"Exercise window can't be longer than the contract's lifespan\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_collExp),\r\n            \"collateral exponent not within expected range\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_underlyingExp),\r\n            \"underlying exponent not within expected range\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_strikeExp),\r\n            \"strike price exponent not within expected range\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_oTokenExchangeExp),\r\n            \"oToken exchange rate exponent not within expected range\"\r\n        );\r\n\r\n        collateral = _collateral;\r\n        collateralExp = _collExp;\r\n\r\n        underlying = _underlying;\r\n        underlyingExp = _underlyingExp;\r\n        oTokenExchangeRate = Number(1, _oTokenExchangeExp);\r\n\r\n        strikePrice = Number(_strikePrice, _strikeExp);\r\n        strike = _strike;\r\n\r\n        expiry = _expiry;\r\n        COMPOUND_ORACLE = CompoundOracleInterface(_oracleAddress);\r\n        optionsExchange = _optionsExchange;\r\n        windowSize = _windowSize;\r\n    }\r\n\r\n    /*** Events ***/\r\n    event VaultOpened(address payable vaultOwner);\r\n    event ETHCollateralAdded(\r\n        address payable vaultOwner,\r\n        uint256 amount,\r\n        address payer\r\n    );\r\n    event ERC20CollateralAdded(\r\n        address payable vaultOwner,\r\n        uint256 amount,\r\n        address payer\r\n    );\r\n    event IssuedOTokens(\r\n        address issuedTo,\r\n        uint256 oTokensIssued,\r\n        address payable vaultOwner\r\n    );\r\n    event Liquidate(\r\n        uint256 amtCollateralToPay,\r\n        address payable vaultOwner,\r\n        address payable liquidator\r\n    );\r\n    event Exercise(\r\n        uint256 amtUnderlyingToPay,\r\n        uint256 amtCollateralToPay,\r\n        address payable exerciser,\r\n        address payable vaultExercisedFrom\r\n    );\r\n    event RedeemVaultBalance(\r\n        uint256 amtCollateralRedeemed,\r\n        uint256 amtUnderlyingRedeemed,\r\n        address payable vaultOwner\r\n    );\r\n    event BurnOTokens(address payable vaultOwner, uint256 oTokensBurned);\r\n    event RemoveCollateral(uint256 amtRemoved, address payable vaultOwner);\r\n    event UpdateParameters(\r\n        uint256 liquidationIncentive,\r\n        uint256 liquidationFactor,\r\n        uint256 transactionFee,\r\n        uint256 minCollateralizationRatio,\r\n        address owner\r\n    );\r\n    event TransferFee(address payable to, uint256 fees);\r\n    event RemoveUnderlying(\r\n        uint256 amountUnderlying,\r\n        address payable vaultOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Throws if called Options contract is expired.\r\n     */\r\n    modifier notExpired() {\r\n        require(!hasExpired(), \"Options contract expired\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This function gets the array of vaultOwners\r\n     */\r\n    function getVaultOwners() public view returns (address payable[] memory) {\r\n        address payable[] memory owners;\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < vaultOwners.length; i++) {\r\n            if (hasVault(vaultOwners[i])) {\r\n                owners[index] = vaultOwners[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return owners;\r\n    }\r\n\r\n    /**\r\n     * @notice Can only be called by owner. Used to update the fees, minminCollateralizationRatio, etc\r\n     * @param _liquidationIncentive The incentive paid to liquidator. 10 is 0.01 i.e. 1% incentive.\r\n     * @param _liquidationFactor Max amount that a Vault can be liquidated by. 500 is 0.5.\r\n     * @param _transactionFee The fees paid to our protocol every time a execution happens. 100 is egs. 0.1 i.e. 10%.\r\n     * @param _minCollateralizationRatio The minimum ratio of a Vault's collateral to insurance promised. 16 means 1.6.\r\n     */\r\n    function updateParameters(\r\n        uint256 _liquidationIncentive,\r\n        uint256 _liquidationFactor,\r\n        uint256 _transactionFee,\r\n        uint256 _minCollateralizationRatio\r\n    ) public onlyOwner {\r\n        require(\r\n            _liquidationIncentive <= 200,\r\n            \"Can't have >20% liquidation incentive\"\r\n        );\r\n        require(\r\n            _liquidationFactor <= 1000,\r\n            \"Can't liquidate more than 100% of the vault\"\r\n        );\r\n        require(_transactionFee <= 100, \"Can't have transaction fee > 10%\");\r\n        require(\r\n            _minCollateralizationRatio >= 10,\r\n            \"Can't have minCollateralizationRatio < 1\"\r\n        );\r\n\r\n        liquidationIncentive.value = _liquidationIncentive;\r\n        liquidationFactor.value = _liquidationFactor;\r\n        transactionFee.value = _transactionFee;\r\n        minCollateralizationRatio.value = _minCollateralizationRatio;\r\n\r\n        emit UpdateParameters(\r\n            _liquidationIncentive,\r\n            _liquidationFactor,\r\n            _transactionFee,\r\n            _minCollateralizationRatio,\r\n            owner()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Can only be called by owner. Used to set the name, symbol and decimals of the contract\r\n     * @param _name The name of the contract\r\n     * @param _symbol The symbol of the contract\r\n     */\r\n    function setDetails(string memory _name, string memory _symbol)\r\n        public\r\n        onlyOwner\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = uint8(-1 * oTokenExchangeRate.exponent);\r\n        require(\r\n            decimals >= 0,\r\n            \"1 oToken cannot protect less than the smallest unit of the asset\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Can only be called by owner. Used to take out the protocol fees from the contract.\r\n     * @param _address The address to send the fee to.\r\n     */\r\n    function transferFee(address payable _address) public onlyOwner {\r\n        uint256 fees = totalFee;\r\n        totalFee = 0;\r\n        transferCollateral(_address, fees);\r\n\r\n        emit TransferFee(_address, fees);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a `owner` has already created a Vault\r\n     * @param owner The address of the supposed owner\r\n     * @return true or false\r\n     */\r\n    function hasVault(address payable owner) public view returns (bool) {\r\n        return vaults[owner].owned;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new empty Vault and sets the owner of the vault to be the msg.sender.\r\n     */\r\n    function openVault() public notExpired returns (bool) {\r\n        require(!hasVault(msg.sender), \"Vault already created\");\r\n\r\n        vaults[msg.sender] = Vault(0, 0, 0, true);\r\n        vaultOwners.push(msg.sender);\r\n\r\n        emit VaultOpened(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice If the collateral type is ETH, anyone can call this function any time before\r\n     * expiry to increase the amount of collateral in a Vault. Will fail if ETH is not the\r\n     * collateral asset.\r\n     * Remember that adding ETH collateral even if no oTokens have been created can put the owner at a\r\n     * risk of losing the collateral if an exercise event happens.\r\n     * Ensure that you issue and immediately sell oTokens to allow the owner to earn premiums.\r\n     * (Either call the createAndSell function in the oToken contract or batch the\r\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\r\n     * the end user).\r\n     * @param vaultOwner the index of the Vault to which collateral will be added.\r\n     */\r\n    function addETHCollateral(address payable vaultOwner)\r\n        public\r\n        payable\r\n        notExpired\r\n        returns (uint256)\r\n    {\r\n        require(isETH(collateral), \"ETH is not the specified collateral type\");\r\n        require(hasVault(vaultOwner), \"Vault does not exist\");\r\n\r\n        emit ETHCollateralAdded(vaultOwner, msg.value, msg.sender);\r\n        return _addCollateral(vaultOwner, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice If the collateral type is any ERC20, anyone can call this function any time before\r\n     * expiry to increase the amount of collateral in a Vault. Can only transfer in the collateral asset.\r\n     * Will fail if ETH is the collateral asset.\r\n     * The user has to allow the contract to handle their ERC20 tokens on his behalf before these\r\n     * functions are called.\r\n     * Remember that adding ERC20 collateral even if no oTokens have been created can put the owner at a\r\n     * risk of losing the collateral. Ensure that you issue and immediately sell the oTokens!\r\n     * (Either call the createAndSell function in the oToken contract or batch the\r\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\r\n     * the end user).\r\n     * @param vaultOwner the index of the Vault to which collateral will be added.\r\n     * @param amt the amount of collateral to be transferred in.\r\n     */\r\n    function addERC20Collateral(address payable vaultOwner, uint256 amt)\r\n        public\r\n        notExpired\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            collateral.transferFrom(msg.sender, address(this), amt),\r\n            \"Could not transfer in collateral tokens\"\r\n        );\r\n        require(hasVault(vaultOwner), \"Vault does not exist\");\r\n\r\n        emit ERC20CollateralAdded(vaultOwner, amt, msg.sender);\r\n        return _addCollateral(vaultOwner, amt);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of underlying to be transferred during an exercise call\r\n     */\r\n    function underlyingRequiredToExercise(uint256 oTokensToExercise)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint64 underlyingPerOTokenExp = uint64(\r\n            oTokenExchangeRate.exponent - underlyingExp\r\n        );\r\n        return oTokensToExercise.mul(10**underlyingPerOTokenExp);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if exercise can be called\r\n     */\r\n    function isExerciseWindow() public view returns (bool) {\r\n        return ((block.timestamp >= expiry.sub(windowSize)) &&\r\n            (block.timestamp < expiry));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the oToken contract has expired\r\n     */\r\n    function hasExpired() public view returns (bool) {\r\n        return (block.timestamp >= expiry);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by anyone holding the oTokens and underlying during the\r\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\r\n     * transfers in their oTokens and corresponding amount of underlying and gets\r\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\r\n     * the each vault owner starting with the first and iterating until the oTokens to exercise\r\n     * are found.\r\n     * NOTE: This uses a for loop and hence could run out of gas if the array passed in is too big!\r\n     * @param oTokensToExercise the number of oTokens being exercised.\r\n     * @param vaultsToExerciseFrom the array of vaults to exercise from.\r\n     */\r\n    function exercise(\r\n        uint256 oTokensToExercise,\r\n        address payable[] memory vaultsToExerciseFrom\r\n    ) public payable {\r\n        for (uint256 i = 0; i < vaultsToExerciseFrom.length; i++) {\r\n            address payable vaultOwner = vaultsToExerciseFrom[i];\r\n            require(\r\n                hasVault(vaultOwner),\r\n                \"Cannot exercise from a vault that doesn't exist\"\r\n            );\r\n            Vault storage vault = vaults[vaultOwner];\r\n            if (oTokensToExercise == 0) {\r\n                return;\r\n            } else if (vault.oTokensIssued >= oTokensToExercise) {\r\n                _exercise(oTokensToExercise, vaultOwner);\r\n                return;\r\n            } else {\r\n                oTokensToExercise = oTokensToExercise.sub(vault.oTokensIssued);\r\n                _exercise(vault.oTokensIssued, vaultOwner);\r\n            }\r\n        }\r\n        require(\r\n            oTokensToExercise == 0,\r\n            \"Specified vaults have insufficient collateral\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This function allows the vault owner to remove their share of underlying after an exercise\r\n     */\r\n    function removeUnderlying() public {\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        require(vault.underlying > 0, \"No underlying balance\");\r\n\r\n        uint256 underlyingToTransfer = vault.underlying;\r\n        vault.underlying = 0;\r\n\r\n        transferUnderlying(msg.sender, underlyingToTransfer);\r\n        emit RemoveUnderlying(underlyingToTransfer, msg.sender);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called to issue the option tokens. Remember that issuing oTokens even if they\r\n     * haven't been sold can put the owner at a risk of not making premiums on the oTokens. Ensure that you\r\n     * issue and immidiately sell the oTokens! (Either call the createAndSell function in the oToken contract\r\n     * of batch the issueOTokens transaction with a sell transaction and ensure it happens atomically).\r\n     * @dev The owner of a Vault should only be able to have a max of\r\n     * repo.collateral * collateralToStrike / (minminCollateralizationRatio * strikePrice) tokens issued.\r\n     * @param oTokensToIssue The number of o tokens to issue\r\n     * @param receiver The address to send the oTokens to\r\n     */\r\n    function issueOTokens(uint256 oTokensToIssue, address receiver)\r\n        public\r\n        notExpired\r\n    {\r\n        //check that we're properly collateralized to mint this number, then call _mint(address account, uint256 amount)\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        // checks that the vault is sufficiently collateralized\r\n        uint256 newOTokensBalance = vault.oTokensIssued.add(oTokensToIssue);\r\n        require(isSafe(vault.collateral, newOTokensBalance), \"unsafe to mint\");\r\n\r\n        // issue the oTokens\r\n        vault.oTokensIssued = newOTokensBalance;\r\n        _mint(receiver, oTokensToIssue);\r\n\r\n        emit IssuedOTokens(receiver, oTokensToIssue, msg.sender);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the vault for a given address\r\n     * @param vaultOwner the owner of the Vault to return\r\n     */\r\n    function getVault(address payable vaultOwner)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256, bool)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        return (\r\n            vault.collateral,\r\n            vault.oTokensIssued,\r\n            vault.underlying,\r\n            vault.owned\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the given ERC20 is ETH.\r\n     * @param _ierc20 the ERC20 asset.\r\n     */\r\n    function isETH(IERC20 _ierc20) public pure returns (bool) {\r\n        return _ierc20 == IERC20(0);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to burn their oTokens to increase the collateralization ratio of\r\n     * their vault.\r\n     * @param amtToBurn number of oTokens to burn\r\n     * @dev only want to call this function before expiry. After expiry, no benefit to calling it.\r\n     */\r\n    function burnOTokens(uint256 amtToBurn) public notExpired {\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        vault.oTokensIssued = vault.oTokensIssued.sub(amtToBurn);\r\n        _burn(msg.sender, amtToBurn);\r\n\r\n        emit BurnOTokens(msg.sender, amtToBurn);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to remove excess collateral from the vault before expiry. Removing collateral lowers\r\n     * the collateralization ratio of the vault.\r\n     * @param amtToRemove Amount of collateral to remove in 10^-18.\r\n     */\r\n    function removeCollateral(uint256 amtToRemove) public notExpired {\r\n        require(amtToRemove > 0, \"Cannot remove 0 collateral\");\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[msg.sender];\r\n        require(\r\n            amtToRemove <= getCollateral(msg.sender),\r\n            \"Can't remove more collateral than owned\"\r\n        );\r\n\r\n        // check that vault will remain safe after removing collateral\r\n        uint256 newCollateralBalance = vault.collateral.sub(amtToRemove);\r\n\r\n        require(\r\n            isSafe(newCollateralBalance, vault.oTokensIssued),\r\n            \"Vault is unsafe\"\r\n        );\r\n\r\n        // remove the collateral\r\n        vault.collateral = newCollateralBalance;\r\n        transferCollateral(msg.sender, amtToRemove);\r\n\r\n        emit RemoveCollateral(amtToRemove, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice after expiry, each vault holder can get back their proportional share of collateral\r\n     * from vaults that they own.\r\n     * @dev The owner gets all of their collateral back if no exercise event took their collateral.\r\n     */\r\n    function redeemVaultBalance() public {\r\n        require(hasExpired(), \"Can't collect collateral until expiry\");\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        // pay out owner their share\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        // To deal with lower precision\r\n        uint256 collateralToTransfer = vault.collateral;\r\n        uint256 underlyingToTransfer = vault.underlying;\r\n\r\n        vault.collateral = 0;\r\n        vault.oTokensIssued = 0;\r\n        vault.underlying = 0;\r\n\r\n        transferCollateral(msg.sender, collateralToTransfer);\r\n        transferUnderlying(msg.sender, underlyingToTransfer);\r\n\r\n        emit RedeemVaultBalance(\r\n            collateralToTransfer,\r\n            underlyingToTransfer,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * This function returns the maximum amount of collateral liquidatable if the given vault is unsafe\r\n     * @param vaultOwner The index of the vault to be liquidated\r\n     */\r\n    function maxOTokensLiquidatable(address payable vaultOwner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (isUnsafe(vaultOwner)) {\r\n            Vault storage vault = vaults[vaultOwner];\r\n            uint256 maxCollateralLiquidatable = vault\r\n                .collateral\r\n                .mul(liquidationFactor.value)\r\n                .div(10**uint256(-liquidationFactor.exponent));\r\n\r\n            uint256 one = 10**uint256(-liquidationIncentive.exponent);\r\n            Number memory liqIncentive = Number(\r\n                liquidationIncentive.value.add(one),\r\n                liquidationIncentive.exponent\r\n            );\r\n            return calculateOTokens(maxCollateralLiquidatable, liqIncentive);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function can be called by anyone who notices a vault is undercollateralized.\r\n     * The caller gets a reward for reducing the amount of oTokens in circulation.\r\n     * @dev Liquidator comes with _oTokens. They get _oTokens * strikePrice * (incentive + fee)\r\n     * amount of collateral out. They can liquidate a max of liquidationFactor * vault.collateral out\r\n     * in one function call i.e. partial liquidations.\r\n     * @param vaultOwner The index of the vault to be liquidated\r\n     * @param oTokensToLiquidate The number of oTokens being taken out of circulation\r\n     */\r\n    function liquidate(address payable vaultOwner, uint256 oTokensToLiquidate)\r\n        public\r\n        notExpired\r\n    {\r\n        require(hasVault(vaultOwner), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[vaultOwner];\r\n\r\n        // cannot liquidate a safe vault.\r\n        require(isUnsafe(vaultOwner), \"Vault is safe\");\r\n\r\n        // Owner can't liquidate themselves\r\n        require(msg.sender != vaultOwner, \"Owner can't liquidate themselves\");\r\n\r\n        uint256 amtCollateral = calculateCollateralToPay(\r\n            oTokensToLiquidate,\r\n            Number(1, 0)\r\n        );\r\n        uint256 amtIncentive = calculateCollateralToPay(\r\n            oTokensToLiquidate,\r\n            liquidationIncentive\r\n        );\r\n        uint256 amtCollateralToPay = amtCollateral.add(amtIncentive);\r\n\r\n        // calculate the maximum amount of collateral that can be liquidated\r\n        uint256 maxCollateralLiquidatable = vault.collateral.mul(\r\n            liquidationFactor.value\r\n        );\r\n\r\n        if (liquidationFactor.exponent > 0) {\r\n            maxCollateralLiquidatable = maxCollateralLiquidatable.mul(\r\n                10**uint256(liquidationFactor.exponent)\r\n            );\r\n        } else {\r\n            maxCollateralLiquidatable = maxCollateralLiquidatable.div(\r\n                10**uint256(-1 * liquidationFactor.exponent)\r\n            );\r\n        }\r\n\r\n        require(\r\n            amtCollateralToPay <= maxCollateralLiquidatable,\r\n            \"Can only liquidate liquidation factor at any given time\"\r\n        );\r\n\r\n        // deduct the collateral and oTokensIssued\r\n        vault.collateral = vault.collateral.sub(amtCollateralToPay);\r\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToLiquidate);\r\n\r\n        // transfer the collateral and burn the _oTokens\r\n        _burn(msg.sender, oTokensToLiquidate);\r\n        transferCollateral(msg.sender, amtCollateralToPay);\r\n\r\n        emit Liquidate(amtCollateralToPay, vaultOwner, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice checks if a vault is unsafe. If so, it can be liquidated\r\n     * @param vaultOwner The number of the vault to check\r\n     * @return true or false\r\n     */\r\n    function isUnsafe(address payable vaultOwner) public view returns (bool) {\r\n        bool stillUnsafe = !isSafe(\r\n            getCollateral(vaultOwner),\r\n            getOTokensIssued(vaultOwner)\r\n        );\r\n        return stillUnsafe;\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns if an -30 <= exponent <= 30\r\n     */\r\n    function isWithinExponentRange(int32 val) internal pure returns (bool) {\r\n        return ((val <= 30) && (val >= -30));\r\n    }\r\n\r\n    /**\r\n     * @notice This function calculates and returns the amount of collateral in the vault\r\n    */\r\n    function getCollateral(address payable vaultOwner)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        return vault.collateral;\r\n    }\r\n\r\n    /**\r\n     * @notice This function calculates and returns the amount of puts issued by the Vault\r\n    */\r\n    function getOTokensIssued(address payable vaultOwner)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        return vault.oTokensIssued;\r\n    }\r\n\r\n    /**\r\n     * @notice Called by anyone holding the oTokens and underlying during the\r\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\r\n     * transfers in their oTokens and corresponding amount of underlying and gets\r\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\r\n     * the specified vault holder. At the end of the expiry window, the vault holder can redeem their balance\r\n     * of collateral. The vault owner can withdraw their underlying at any time.\r\n     * The user has to allow the contract to handle their oTokens and underlying on his behalf before these functions are called.\r\n     * @param oTokensToExercise the number of oTokens being exercised.\r\n     * @param vaultToExerciseFrom the address of the vaultOwner to take collateral from.\r\n     * @dev oTokenExchangeRate is the number of underlying tokens that 1 oToken protects.\r\n     */\r\n    function _exercise(\r\n        uint256 oTokensToExercise,\r\n        address payable vaultToExerciseFrom\r\n    ) internal {\r\n        // 1. before exercise window: revert\r\n        require(\r\n            isExerciseWindow(),\r\n            \"Can't exercise outside of the exercise window\"\r\n        );\r\n\r\n        require(hasVault(vaultToExerciseFrom), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[vaultToExerciseFrom];\r\n        require(oTokensToExercise > 0, \"Can't exercise 0 oTokens\");\r\n        // Check correct amount of oTokens passed in)\r\n        require(\r\n            oTokensToExercise <= vault.oTokensIssued,\r\n            \"Can't exercise more oTokens than the owner has\"\r\n        );\r\n        // Ensure person calling has enough oTokens\r\n        require(\r\n            balanceOf(msg.sender) >= oTokensToExercise,\r\n            \"Not enough oTokens\"\r\n        );\r\n\r\n        // 1. Check sufficient underlying\r\n        // 1.1 update underlying balances\r\n        uint256 amtUnderlyingToPay = underlyingRequiredToExercise(\r\n            oTokensToExercise\r\n        );\r\n        vault.underlying = vault.underlying.add(amtUnderlyingToPay);\r\n\r\n        // 2. Calculate Collateral to pay\r\n        // 2.1 Payout enough collateral to get (strikePrice * oTokens) amount of collateral\r\n        uint256 amtCollateralToPay = calculateCollateralToPay(\r\n            oTokensToExercise,\r\n            Number(1, 0)\r\n        );\r\n\r\n        // 2.2 Take a small fee on every exercise\r\n        uint256 amtFee = calculateCollateralToPay(\r\n            oTokensToExercise,\r\n            transactionFee\r\n        );\r\n        totalFee = totalFee.add(amtFee);\r\n\r\n        uint256 totalCollateralToPay = amtCollateralToPay.add(amtFee);\r\n        require(\r\n            totalCollateralToPay <= vault.collateral,\r\n            \"Vault underwater, can't exercise\"\r\n        );\r\n\r\n        // 3. Update collateral + oToken balances\r\n        vault.collateral = vault.collateral.sub(totalCollateralToPay);\r\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToExercise);\r\n\r\n        // 4. Transfer in underlying, burn oTokens + pay out collateral\r\n        // 4.1 Transfer in underlying\r\n        if (isETH(underlying)) {\r\n            require(msg.value == amtUnderlyingToPay, \"Incorrect msg.value\");\r\n        } else {\r\n            require(\r\n                underlying.transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    amtUnderlyingToPay\r\n                ),\r\n                \"Could not transfer in tokens\"\r\n            );\r\n        }\r\n        // 4.2 burn oTokens\r\n        _burn(msg.sender, oTokensToExercise);\r\n\r\n        // 4.3 Pay out collateral\r\n        transferCollateral(msg.sender, amtCollateralToPay);\r\n\r\n        emit Exercise(\r\n            amtUnderlyingToPay,\r\n            amtCollateralToPay,\r\n            msg.sender,\r\n            vaultToExerciseFrom\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice adds `_amt` collateral to `vaultOwner` and returns the new balance of the vault\r\n     * @param vaultOwner the index of the vault\r\n     * @param amt the amount of collateral to add\r\n     */\r\n    function _addCollateral(address payable vaultOwner, uint256 amt)\r\n        internal\r\n        notExpired\r\n        returns (uint256)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        vault.collateral = vault.collateral.add(amt);\r\n\r\n        return vault.collateral;\r\n    }\r\n\r\n    /**\r\n     * @notice checks if a hypothetical vault is safe with the given collateralAmt and oTokensIssued\r\n     * @param collateralAmt The amount of collateral the hypothetical vault has\r\n     * @param oTokensIssued The amount of oTokens generated by the hypothetical vault\r\n     * @return true or false\r\n     */\r\n    function isSafe(uint256 collateralAmt, uint256 oTokensIssued)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // get price from Oracle\r\n        uint256 collateralToEthPrice = getPrice(address(collateral));\r\n        uint256 strikeToEthPrice = getPrice(address(strike));\r\n\r\n        // check `oTokensIssued * minCollateralizationRatio * strikePrice <= collAmt * collateralToStrikePrice`\r\n        uint256 leftSideVal = oTokensIssued\r\n            .mul(minCollateralizationRatio.value)\r\n            .mul(strikePrice.value);\r\n        int32 leftSideExp = minCollateralizationRatio.exponent +\r\n            strikePrice.exponent;\r\n\r\n        uint256 rightSideVal = (collateralAmt.mul(collateralToEthPrice)).div(\r\n            strikeToEthPrice\r\n        );\r\n        int32 rightSideExp = collateralExp;\r\n\r\n        uint256 exp = 0;\r\n        bool stillSafe = false;\r\n\r\n        if (rightSideExp < leftSideExp) {\r\n            exp = uint256(leftSideExp - rightSideExp);\r\n            stillSafe = leftSideVal.mul(10**exp) <= rightSideVal;\r\n        } else {\r\n            exp = uint256(rightSideExp - leftSideExp);\r\n            stillSafe = leftSideVal <= rightSideVal.mul(10**exp);\r\n        }\r\n\r\n        return stillSafe;\r\n    }\r\n\r\n    /**\r\n     * This function returns the maximum amount of oTokens that can safely be issued against the specified amount of collateral.\r\n     * @param collateralAmt The amount of collateral against which oTokens will be issued.\r\n     */\r\n    function maxOTokensIssuable(uint256 collateralAmt)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return calculateOTokens(collateralAmt, minCollateralizationRatio);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice This function is used to calculate the amount of tokens that can be issued.\r\n     * @dev The amount of oTokens is determined by:\r\n     * oTokensIssued  <= collateralAmt * collateralToStrikePrice / (proportion * strikePrice)\r\n     * @param collateralAmt The amount of collateral\r\n     * @param proportion The proportion of the collateral to pay out. If 100% of collateral\r\n     * should be paid out, pass in Number(1, 0). The proportion might be less than 100% if\r\n     * you are calculating fees.\r\n     */\r\n    function calculateOTokens(uint256 collateralAmt, Number memory proportion)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 collateralToEthPrice = getPrice(address(collateral));\r\n        uint256 strikeToEthPrice = getPrice(address(strike));\r\n\r\n        // oTokensIssued  <= collAmt * collateralToStrikePrice / (proportion * strikePrice)\r\n        uint256 denomVal = proportion.value.mul(strikePrice.value);\r\n        int32 denomExp = proportion.exponent + strikePrice.exponent;\r\n\r\n        uint256 numeratorVal = (collateralAmt.mul(collateralToEthPrice)).div(\r\n            strikeToEthPrice\r\n        );\r\n        int32 numeratorExp = collateralExp;\r\n\r\n        uint256 exp = 0;\r\n        uint256 numOptions = 0;\r\n\r\n        if (numeratorExp < denomExp) {\r\n            exp = uint256(denomExp - numeratorExp);\r\n            numOptions = numeratorVal.div(denomVal.mul(10**exp));\r\n        } else {\r\n            exp = uint256(numeratorExp - denomExp);\r\n            numOptions = numeratorVal.mul(10**exp).div(denomVal);\r\n        }\r\n\r\n        return numOptions;\r\n    }\r\n\r\n    /**\r\n     * @notice This function calculates the amount of collateral to be paid out.\r\n     * @dev The amount of collateral to paid out is determined by:\r\n     * (proportion * strikePrice * strikeToCollateralPrice * oTokens) amount of collateral.\r\n     * @param _oTokens The number of oTokens.\r\n     * @param proportion The proportion of the collateral to pay out. If 100% of collateral\r\n     * should be paid out, pass in Number(1, 0). The proportion might be less than 100% if\r\n     * you are calculating fees.\r\n     */\r\n    function calculateCollateralToPay(\r\n        uint256 _oTokens,\r\n        Number memory proportion\r\n    ) internal view returns (uint256) {\r\n        // Get price from oracle\r\n        uint256 collateralToEthPrice = getPrice(address(collateral));\r\n        uint256 strikeToEthPrice = getPrice(address(strike));\r\n\r\n        // calculate how much should be paid out\r\n        uint256 amtCollateralToPayInEthNum = _oTokens\r\n            .mul(strikePrice.value)\r\n            .mul(proportion.value)\r\n            .mul(strikeToEthPrice);\r\n        int32 amtCollateralToPayExp = strikePrice.exponent +\r\n            proportion.exponent -\r\n            collateralExp;\r\n        uint256 amtCollateralToPay = 0;\r\n        if (amtCollateralToPayExp > 0) {\r\n            uint32 exp = uint32(amtCollateralToPayExp);\r\n            amtCollateralToPay = amtCollateralToPayInEthNum.mul(10**exp).div(\r\n                collateralToEthPrice\r\n            );\r\n        } else {\r\n            uint32 exp = uint32(-1 * amtCollateralToPayExp);\r\n            amtCollateralToPay = (amtCollateralToPayInEthNum.div(10**exp)).div(\r\n                collateralToEthPrice\r\n            );\r\n        }\r\n\r\n        return amtCollateralToPay;\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice This function transfers `amt` collateral to `_addr`\r\n     * @param _addr The address to send the collateral to\r\n     * @param _amt The amount of the collateral to pay out.\r\n     */\r\n    function transferCollateral(address payable _addr, uint256 _amt) internal {\r\n        if (isETH(collateral)) {\r\n            _addr.transfer(_amt);\r\n        } else {\r\n            collateral.transfer(_addr, _amt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function transfers `amt` underlying to `_addr`\r\n     * @param _addr The address to send the underlying to\r\n     * @param _amt The amount of the underlying to pay out.\r\n     */\r\n    function transferUnderlying(address payable _addr, uint256 _amt) internal {\r\n        if (isETH(underlying)) {\r\n            _addr.transfer(_amt);\r\n        } else {\r\n            underlying.transfer(_addr, _amt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function gets the price ETH (wei) to asset price.\r\n     * @param asset The address of the asset to get the price of\r\n     */\r\n    function getPrice(address asset) internal view returns (uint256) {\r\n        if (address(collateral) == address(strike)) {\r\n            return 1;\r\n        } else if (asset == address(0)) {\r\n            return (10**18);\r\n        } else {\r\n            return COMPOUND_ORACLE.getPrice(asset);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/oToken.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n/**\r\n * @title Opyn's Options Contract\r\n * @author Opyn\r\n */\r\n\r\ncontract oToken is OptionsContract {\r\n    /**\r\n    * @param _collateral The collateral asset\r\n    * @param _collExp The precision of the collateral (-18 if ETH)\r\n    * @param _underlying The asset that is being protected\r\n    * @param _underlyingExp The precision of the underlying asset\r\n    * @param _oTokenExchangeExp The precision of the `amount of underlying` that 1 oToken protects\r\n    * @param _strikePrice The amount of strike asset that will be paid out\r\n    * @param _strikeExp The precision of the strike asset (-18 if ETH)\r\n    * @param _strike The asset in which the insurance is calculated\r\n    * @param _expiry The time at which the insurance expires\r\n    * @param _optionsExchange The contract which interfaces with the exchange + oracle\r\n    * @param _oracleAddress The address of the oracle\r\n    * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\r\n    */\r\n    constructor(\r\n        IERC20 _collateral,\r\n        int32 _collExp,\r\n        IERC20 _underlying,\r\n        int32 _underlyingExp,\r\n        int32 _oTokenExchangeExp,\r\n        uint256 _strikePrice,\r\n        int32 _strikeExp,\r\n        IERC20 _strike,\r\n        uint256 _expiry,\r\n        OptionsExchange _optionsExchange,\r\n        address _oracleAddress,\r\n        uint256 _windowSize\r\n    )\r\n        public\r\n        OptionsContract(\r\n            _collateral,\r\n            _collExp,\r\n            _underlying,\r\n            _underlyingExp,\r\n            _oTokenExchangeExp,\r\n            _strikePrice,\r\n            _strikeExp,\r\n            _strike,\r\n            _expiry,\r\n            _optionsExchange,\r\n            _oracleAddress,\r\n            _windowSize\r\n        )\r\n    {}\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ETH collateral, and mints new oTokens in one step\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function createETHCollateralOption(uint256 amtToCreate, address receiver)\r\n        external\r\n        payable\r\n    {\r\n        openVault();\r\n        addETHCollateralOption(amtToCreate, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice adds ETH collateral, and mints new oTokens in one step to an existing Vault\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addETHCollateralOption(uint256 amtToCreate, address receiver)\r\n        public\r\n        payable\r\n    {\r\n        addETHCollateral(msg.sender);\r\n        issueOTokens(amtToCreate, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ETH collateral, mints new oTokens and sell in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to receive the premiums\r\n     */\r\n    function createAndSellETHCollateralOption(\r\n        uint256 amtToCreate,\r\n        address payable receiver\r\n    ) external payable {\r\n        openVault();\r\n        addETHCollateralOption(amtToCreate, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice adds ETH collateral to an existing Vault, and mints new oTokens and sells the oTokens in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addAndSellETHCollateralOption(\r\n        uint256 amtToCreate,\r\n        address payable receiver\r\n    ) public payable {\r\n        addETHCollateral(msg.sender);\r\n        issueOTokens(amtToCreate, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ERC20 collateral, and mints new oTokens in one step\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function createERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address receiver\r\n    ) external {\r\n        openVault();\r\n        addERC20CollateralOption(amtToCreate, amtCollateral, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice adds ERC20 collateral, and mints new oTokens in one step\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address receiver\r\n    ) public {\r\n        addERC20Collateral(msg.sender, amtCollateral);\r\n        issueOTokens(amtToCreate, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ERC20 collateral, mints new oTokens and sells the oTokens in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function createAndSellERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address payable receiver\r\n    ) external {\r\n        openVault();\r\n        addERC20CollateralOption(amtToCreate, amtCollateral, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice adds ERC20 collateral, mints new oTokens and sells the oTokens in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addAndSellERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address payable receiver\r\n    ) public {\r\n        addERC20Collateral(msg.sender, amtCollateral);\r\n        issueOTokens(amtToCreate, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n}"}
{"address": "0xe0b94a7bb45dd905c79bb1992c9879f40f1caed5", "attacktype": "Other coding mistakes", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Blacksmith.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\npragma solidity ^0.7.4;\\n\\nimport \\\"./ERC20/IERC20.sol\\\";\\nimport \\\"./ERC20/SafeERC20.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/ICOVER.sol\\\";\\nimport \\\"./interfaces/IBlacksmith.sol\\\";\\n\\n/**\\n * @title COVER token shield mining contract\\n * @author crypto-pumpkin@github\\n */\\ncontract Blacksmith is Ownable, IBlacksmith, ReentrancyGuard {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  ICOVER public cover;\\n  address public governance;\\n  address public treasury;\\n  /// @notice Total 17k COVER in 1st 6 mths. TODO: update to 246e18 after 6 months from 1605830400 (11/20/2020 12am UTC)\\n  uint256 public weeklyTotal = 654e18;\\n  uint256 public totalWeight; // total weight for all pools\\n  uint256 public constant START_TIME = 1605830400; // 11/20/2020 12am UTC\\n  uint256 public constant WEEK = 7 days;\\n  uint256 private constant CAL_MULTIPLIER = 1e12; // help calculate rewards/bonus PerToken only. 1e12 will allow meaningful $1 deposit in a $1bn pool\\n  address[] public poolList;\\n  mapping(address => Pool) public pools; // lpToken => Pool\\n  mapping(address => BonusToken) public bonusTokens; // lpToken => BonusToken\\n  // bonusToken => 1 (allowed), allow anyone to use the bonus token to run a bonus program on any pool\\n  mapping(address => uint8) public allowBonusTokens;\\n  // lpToken => Miner address => Miner data\\n  mapping(address => mapping(address => Miner)) public miners;\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == governance, \\\"Blacksmith: caller not governance\\\");\\n    _;\\n  }\\n\\n  constructor (address _coverAddress, address _governance, address _treasury) {\\n    cover = ICOVER(_coverAddress);\\n    governance = _governance;\\n    treasury = _treasury;\\n  }\\n\\n  function getPoolList() external view override returns (address[] memory) {\\n    return poolList;\\n  }\\n\\n  function viewMined(address _lpToken, address _miner)\\n   external view override returns (uint256 _minedCOVER, uint256 _minedBonus)\\n  {\\n    Pool memory pool = pools[_lpToken];\\n    Miner memory miner = miners[_lpToken][_miner];\\n    uint256 lpTotal = IERC20(_lpToken).balanceOf(address(this));\\n    if (miner.amount > 0 && lpTotal > 0) {\\n      uint256 coverRewards = _calculateCoverRewardsForPeriod(pool);\\n      uint256 accRewardsPerToken = pool.accRewardsPerToken.add(coverRewards.div(lpTotal));\\n      _minedCOVER = miner.amount.mul(accRewardsPerToken).div(CAL_MULTIPLIER).sub(miner.rewardWriteoff);\\n\\n      BonusToken memory bonusToken = bonusTokens[_lpToken];\\n      if (bonusToken.startTime < block.timestamp && bonusToken.totalBonus > 0) {\\n        uint256 bonus = _calculateBonusForPeriod(bonusToken);\\n        uint256 accBonusPerToken = bonusToken.accBonusPerToken.add(bonus.div(lpTotal));\\n        _minedBonus = miner.amount.mul(accBonusPerToken).div(CAL_MULTIPLIER).sub(miner.bonusWriteoff);\\n      }\\n    }\\n    return (_minedCOVER, _minedBonus);\\n  }\\n\\n  /// @notice update pool's rewards & bonus per staked token till current block timestamp\\n  function updatePool(address _lpToken) public override {\\n    Pool storage pool = pools[_lpToken];\\n    if (block.timestamp <= pool.lastUpdatedAt) return;\\n    uint256 lpTotal = IERC20(_lpToken).balanceOf(address(this));\\n    if (lpTotal == 0) {\\n      pool.lastUpdatedAt = block.timestamp;\\n      return;\\n    }\\n    // update COVER rewards for pool\\n    uint256 coverRewards = _calculateCoverRewardsForPeriod(pool);\\n    pool.accRewardsPerToken = pool.accRewardsPerToken.add(coverRewards.div(lpTotal));\\n    pool.lastUpdatedAt = block.timestamp;\\n    // update bonus token rewards if exist for pool\\n    BonusToken storage bonusToken = bonusTokens[_lpToken];\\n    if (bonusToken.lastUpdatedAt < bonusToken.endTime && bonusToken.startTime < block.timestamp) {\\n      uint256 bonus = _calculateBonusForPeriod(bonusToken);\\n      bonusToken.accBonusPerToken = bonusToken.accBonusPerToken.add(bonus.div(lpTotal));\\n      bonusToken.lastUpdatedAt = block.timestamp <= bonusToken.endTime ? block.timestamp : bonusToken.endTime;\\n    }\\n  }\\n\\n  function claimRewards(address _lpToken) public override {\\n    updatePool(_lpToken);\\n\\n    Pool memory pool = pools[_lpToken];\\n    Miner storage miner = miners[_lpToken][msg.sender];\\n    BonusToken memory bonusToken = bonusTokens[_lpToken];\\n\\n    _claimCoverRewards(pool, miner);\\n    _claimBonus(bonusToken, miner);\\n    // update writeoff to match current acc rewards & bonus per token\\n    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER);\\n    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER);\\n  }\\n\\n  function claimRewardsForPools(address[] calldata _lpTokens) external override {\\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\\n      claimRewards(_lpTokens[i]);\\n    }\\n  }\\n\\n  function deposit(address _lpToken, uint256 _amount) external override {\\n    require(block.timestamp >= START_TIME , \\\"Blacksmith: not started\\\");\\n    require(_amount > 0, \\\"Blacksmith: amount is 0\\\");\\n    Pool memory pool = pools[_lpToken];\\n    require(pool.lastUpdatedAt > 0, \\\"Blacksmith: pool does not exists\\\");\\n    require(IERC20(_lpToken).balanceOf(msg.sender) >= _amount, \\\"Blacksmith: insufficient balance\\\");\\n    updatePool(_lpToken);\\n\\n    Miner storage miner = miners[_lpToken][msg.sender];\\n    BonusToken memory bonusToken = bonusTokens[_lpToken];\\n    _claimCoverRewards(pool, miner);\\n    _claimBonus(bonusToken, miner);\\n\\n    miner.amount = miner.amount.add(_amount);\\n    // update writeoff to match current acc rewards/bonus per token\\n    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER);\\n    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER);\\n\\n    IERC20(_lpToken).safeTransferFrom(msg.sender, address(this), _amount);\\n    emit Deposit(msg.sender, _lpToken, _amount);\\n  }\\n\\n  function withdraw(address _lpToken, uint256 _amount) external override {\\n    require(_amount > 0, \\\"Blacksmith: amount is 0\\\");\\n    Miner storage miner = miners[_lpToken][msg.sender];\\n    require(miner.amount >= _amount, \\\"Blacksmith: insufficient balance\\\");\\n    updatePool(_lpToken);\\n\\n    Pool memory pool = pools[_lpToken];\\n    BonusToken memory bonusToken = bonusTokens[_lpToken];\\n    _claimCoverRewards(pool, miner);\\n    _claimBonus(bonusToken, miner);\\n\\n    miner.amount = miner.amount.sub(_amount);\\n    // update writeoff to match current acc rewards/bonus per token\\n    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER);\\n    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER);\\n\\n    _safeTransfer(_lpToken, _amount);\\n    emit Withdraw(msg.sender, _lpToken, _amount);\\n  }\\n\\n  /// @notice withdraw all without rewards\\n  function emergencyWithdraw(address _lpToken) external override {\\n    Miner storage miner = miners[_lpToken][msg.sender];\\n    uint256 amount = miner.amount;\\n    require(miner.amount > 0, \\\"Blacksmith: insufficient balance\\\");\\n    miner.amount = 0;\\n    miner.rewardWriteoff = 0;\\n    _safeTransfer(_lpToken, amount);\\n    emit Withdraw(msg.sender, _lpToken, amount);\\n  }\\n\\n  /// @notice update pool weights\\n  function updatePoolWeights(address[] calldata _lpTokens, uint256[] calldata _weights) public override onlyGovernance {\\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\\n      Pool storage pool = pools[_lpTokens[i]];\\n      if (pool.lastUpdatedAt > 0) {\\n        totalWeight = totalWeight.add(_weights[i]).sub(pool.weight);\\n        pool.weight = _weights[i];\\n      }\\n    }\\n  }\\n\\n  /// @notice add a new pool for shield mining\\n  function addPool(address _lpToken, uint256 _weight) public override onlyOwner {\\n    Pool memory pool = pools[_lpToken];\\n    require(pool.lastUpdatedAt == 0, \\\"Blacksmith: pool exists\\\");\\n    pools[_lpToken] = Pool({\\n      weight: _weight,\\n      accRewardsPerToken: 0,\\n      lastUpdatedAt: block.timestamp\\n    });\\n    totalWeight = totalWeight.add(_weight);\\n    poolList.push(_lpToken);\\n  }\\n\\n  /// @notice add new pools for shield mining\\n  function addPools(address[] calldata _lpTokens, uint256[] calldata _weights) external override onlyOwner {\\n    require(_lpTokens.length == _weights.length, \\\"Blacksmith: size don't match\\\");\\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\\n     addPool(_lpTokens[i], _weights[i]);\\n    }\\n  }\\n\\n  /// @notice only statusCode 1 will enable the bonusToken to allow partners to set their program\\n  function updateBonusTokenStatus(address _bonusToken, uint8 _status) external override onlyOwner {\\n    require(_status != 0, \\\"Blacksmith: status cannot be 0\\\");\\n    require(pools[_bonusToken].lastUpdatedAt == 0, \\\"Blacksmith: lpToken is not allowed\\\");\\n    allowBonusTokens[_bonusToken] = _status;\\n  }\\n\\n  /// @notice always assign the same startTime and endTime for both CLAIM and NOCLAIM pool, one bonusToken can be used for only one set of CLAIM and NOCLAIM pools\\n  function addBonusToken(\\n    address _lpToken,\\n    address _bonusToken,\\n    uint256 _startTime,\\n    uint256 _endTime,\\n    uint256 _totalBonus\\n  ) external override {\\n    IERC20 bonusToken = IERC20(_bonusToken);\\n    require(pools[_lpToken].lastUpdatedAt != 0, \\\"Blacksmith: pool does NOT exist\\\");\\n    require(allowBonusTokens[_bonusToken] == 1, \\\"Blacksmith: bonusToken not allowed\\\");\\n\\n    BonusToken memory currentBonusToken = bonusTokens[_lpToken];\\n    if (currentBonusToken.totalBonus != 0) {\\n      require(currentBonusToken.endTime.add(WEEK) < block.timestamp, \\\"Blacksmith: last bonus period hasn't ended\\\");\\n      require(IERC20(currentBonusToken.addr).balanceOf(address(this)) == 0, \\\"Blacksmith: last bonus not all claimed\\\");\\n    }\\n\\n    require(_startTime >= block.timestamp && _endTime > _startTime, \\\"Blacksmith: messed up timeline\\\");\\n    require(_totalBonus > 0 && bonusToken.balanceOf(msg.sender) >= _totalBonus, \\\"Blacksmith: incorrect total rewards\\\");\\n\\n    uint256 balanceBefore = bonusToken.balanceOf(address(this));\\n    bonusToken.safeTransferFrom(msg.sender, address(this), _totalBonus);\\n    uint256 balanceAfter = bonusToken.balanceOf(address(this));\\n    require(balanceAfter > balanceBefore, \\\"Blacksmith: incorrect total rewards\\\");\\n\\n    bonusTokens[_lpToken] = BonusToken({\\n      addr: _bonusToken,\\n      startTime: _startTime,\\n      endTime: _endTime,\\n      totalBonus: balanceAfter.sub(balanceBefore),\\n      accBonusPerToken: 0,\\n      lastUpdatedAt: _startTime\\n    });\\n  }\\n\\n  /// @notice collect dust to treasury\\n  function collectDust(address _token) external override {\\n    Pool memory pool = pools[_token];\\n    require(pool.lastUpdatedAt == 0, \\\"Blacksmith: lpToken, not allowed\\\");\\n    require(allowBonusTokens[_token] == 0, \\\"Blacksmith: bonusToken, not allowed\\\");\\n\\n    IERC20 token = IERC20(_token);\\n    uint256 amount = token.balanceOf(address(this));\\n    require(amount > 0, \\\"Blacksmith: 0 to collect\\\");\\n\\n    if (_token == address(0)) { // token address(0) == ETH\\n      payable(treasury).transfer(amount);\\n    } else {\\n      token.safeTransfer(treasury, amount);\\n    }\\n  }\\n\\n  /// @notice collect bonus token dust to treasury\\n  function collectBonusDust(address _lpToken) external override {\\n    BonusToken memory bonusToken = bonusTokens[_lpToken];\\n    require(bonusToken.endTime.add(WEEK) < block.timestamp, \\\"Blacksmith: bonusToken, not ready\\\");\\n\\n    IERC20 token = IERC20(bonusToken.addr);\\n    uint256 amount = token.balanceOf(address(this));\\n    require(amount > 0, \\\"Blacksmith: 0 to collect\\\");\\n    token.safeTransfer(treasury, amount);\\n  }\\n\\n  /// @notice update all pools before update weekly total, otherwise, there will a small (more so for pools with less user interactions) rewards mess up for each pool\\n  function updateWeeklyTotal(uint256 _weeklyTotal) external override onlyGovernance {\\n    weeklyTotal = _weeklyTotal;\\n  }\\n\\n  /// @notice use start and end to avoid gas limit in one call\\n  function updatePools(uint256 _start, uint256 _end) external override {\\n    address[] memory poolListCopy = poolList;\\n    for (uint256 i = _start; i < _end; i++) {\\n      updatePool(poolListCopy[i]);\\n    }\\n  }\\n\\n  /// @notice transfer minting rights to new blacksmith\\n  function transferMintingRights(address _newAddress) external override onlyGovernance {\\n    cover.setBlacksmith(_newAddress);\\n  }\\n\\n  function _calculateCoverRewardsForPeriod(Pool memory _pool) internal view returns (uint256) {\\n    uint256 timePassed = block.timestamp.sub(_pool.lastUpdatedAt);\\n    return weeklyTotal.mul(CAL_MULTIPLIER).mul(timePassed).mul(_pool.weight).div(totalWeight).div(WEEK);\\n  }\\n\\n  function _calculateBonusForPeriod(BonusToken memory _bonusToken) internal view returns (uint256) {\\n    if (_bonusToken.endTime == _bonusToken.lastUpdatedAt) return 0;\\n\\n    uint256 calTime = block.timestamp > _bonusToken.endTime ? _bonusToken.endTime : block.timestamp;\\n    uint256 timePassed = calTime.sub(_bonusToken.lastUpdatedAt);\\n    uint256 totalDuration = _bonusToken.endTime.sub(_bonusToken.startTime);\\n    return _bonusToken.totalBonus.mul(CAL_MULTIPLIER).mul(timePassed).div(totalDuration);\\n  }\\n\\n  /// @notice tranfer upto what the contract has\\n  function _safeTransfer(address _token, uint256 _amount) private nonReentrant {\\n    IERC20 token = IERC20(_token);\\n    uint256 balance = token.balanceOf(address(this));\\n    if (balance > _amount) {\\n      token.safeTransfer(msg.sender, _amount);\\n    } else if (balance > 0) {\\n      token.safeTransfer(msg.sender, balance);\\n    }\\n  }\\n\\n  function _claimCoverRewards(Pool memory pool, Miner memory miner) private nonReentrant {\\n    if (miner.amount > 0) {\\n      uint256 minedSinceLastUpdate = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER).sub(miner.rewardWriteoff);\\n      if (minedSinceLastUpdate > 0) {\\n        cover.mint(msg.sender, minedSinceLastUpdate); // mint COVER tokens to miner\\n      }\\n    }\\n  }\\n\\n  function _claimBonus(BonusToken memory bonusToken, Miner memory miner) private {\\n    if (bonusToken.totalBonus > 0 && miner.amount > 0 && bonusToken.startTime < block.timestamp) {\\n      uint256 bonusSinceLastUpdate = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER).sub(miner.bonusWriteoff);\\n      if (bonusSinceLastUpdate > 0) {\\n        _safeTransfer(bonusToken.addr, bonusSinceLastUpdate); // transfer bonus tokens to miner\\n      }\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\n/**\\n * @title Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function totalSupply() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../utils/SafeMath.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n * @author crypto-pumpkin@github\\n *\\n * By initialization, the owner account will be the one that called initializeOwner. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev COVER: Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICOVER.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Interface of COVER\\n * @author crypto-pumpkin@github\\n */\\ninterface ICOVER is IERC20 {\\n  function mint(address _account, uint256 _amount) external;\\n  function setBlacksmith(address _newBlacksmith) external returns (bool);\\n  function setMigrator(address _newMigrator) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBlacksmith.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\n/**\\n * @title Interface of COVER shield mining contract Blacksmith\\n * @author crypto-pumpkin@github\\n */\\ninterface IBlacksmith {\\n  struct Miner {\\n    uint256 amount;\\n    uint256 rewardWriteoff; // the amount of COVER tokens to write off when calculate rewards from last update\\n    uint256 bonusWriteoff; // the amount of bonus tokens to write off when calculate rewards from last update\\n  }\\n\\n  struct Pool {\\n    uint256 weight; // the allocation weight for pool\\n    uint256 accRewardsPerToken; // accumulated COVER to the lastUpdated Time\\n    uint256 lastUpdatedAt; // last accumulated rewards update timestamp\\n  }\\n\\n  struct BonusToken {\\n    address addr; // the external bonus token, like CRV\\n    uint256 startTime;\\n    uint256 endTime;\\n    uint256 totalBonus; // total amount to be distributed from start to end\\n    uint256 accBonusPerToken; // accumulated bonus to the lastUpdated Time\\n    uint256 lastUpdatedAt; // last accumulated bonus update timestamp\\n  }\\n\\n  event Deposit(address indexed miner, address indexed lpToken, uint256 amount);\\n  event Withdraw(address indexed miner, address indexed lpToken, uint256 amount);\\n\\n  // View functions\\n  function getPoolList() external view returns (address[] memory);\\n  function viewMined(address _lpToken, address _miner) external view returns (uint256 _minedCOVER, uint256 _minedBonus);\\n  // function minedRewards(address _lpToken, address _miner) external view returns (uint256);\\n  // function minedBonus(address _lpToken, address _miner) external view returns (uint256 _minedBonus, address _bonusToken);\\n\\n  // User action functions\\n  function claimRewardsForPools(address[] calldata _lpTokens) external;\\n  function claimRewards(address _lpToken) external;\\n  function deposit(address _lpToken, uint256 _amount) external;\\n  function withdraw(address _lpToken, uint256 _amount) external;\\n  function emergencyWithdraw(address _lpToken) external;\\n\\n  // Partner action functions\\n  function addBonusToken(address _lpToken, address _bonusToken, uint256 _startTime, uint256 _endTime, uint256 _totalBonus) external;\\n\\n  // COVER mining actions\\n  function updatePool(address _lpToken) external;\\n  function updatePools(uint256 _start, uint256 _end) external;\\n  /// @notice dust will be collected to COVER treasury\\n  function collectDust(address _token) external;\\n  function collectBonusDust(address _lpToken) external;\\n\\n  /// @notice only dev\\n  function addPool(address _lpToken, uint256 _weight) external;\\n  function addPools(address[] calldata _lpTokens, uint256[] calldata _weights) external;\\n  function updateBonusTokenStatus(address _bonusToken, uint8 _status) external;\\n\\n  /// @notice only governance\\n  function updatePoolWeights(address[] calldata _lpTokens, uint256[] calldata _weights) external;\\n  function updateWeeklyTotal(uint256 _weeklyTotal) external;\\n  function transferMintingRights(address _newAddress) external;\\n}\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.4;\\n\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/Migrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\nimport \\\"./ERC20/IERC20.sol\\\";\\nimport \\\"./ERC20/SafeERC20.sol\\\";\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\nimport \\\"./interfaces/ICOVER.sol\\\";\\nimport \\\"./interfaces/IMigrator.sol\\\";\\n\\n/**\\n * @title COVER token migrator\\n * @author crypto-pumpkin@github + @Kiwi\\n */\\ncontract Migrator is Ownable, IMigrator {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  IERC20 public safe2;\\n  ICOVER public cover;\\n  address public governance;\\n  bytes32 public immutable merkleRoot;\\n  uint256 public safe2Migrated; // total: 52,689.18\\n  uint256 public safeClaimed; // total: 2160.76\\n  uint256 public constant migrationCap = 54850e18;\\n  uint256 public constant START_TIME = 1605830400; // 11/20/2020 12am UTC\\n  mapping(uint256 => uint256) private claimedBitMap;\\n\\n  constructor (address _governance, address _coverAddress, address _safe2, bytes32 _merkleRoot) {\\n    governance = _governance;\\n    cover = ICOVER(_coverAddress);\\n\\n    require(_safe2 == 0x250a3500f48666561386832f1F1f1019b89a2699, \\\"Migrator: safe2 address not match\\\");\\n    safe2 = IERC20(_safe2);\\n\\n    merkleRoot = _merkleRoot;\\n  }\\n\\n  function isSafeClaimed(uint256 _index) public view override returns (bool) {\\n    uint256 claimedWordIndex = _index / 256;\\t\\n    uint256 claimedBitIndex = _index % 256;\\t\\n    uint256 claimedWord = claimedBitMap[claimedWordIndex];\\t\\n    uint256 mask = (1 << claimedBitIndex);\\t\\n    return claimedWord & mask == mask;\\n  }\\n\\n  function migrateSafe2() external override {\\n    require(block.timestamp >= START_TIME, \\\"Migrator: not started\\\");\\n    uint256 safe2Balance = safe2.balanceOf(msg.sender);\\n\\n    require(safe2Balance > 0, \\\"Migrator: no safe2 balance\\\");\\n    safe2.transferFrom(msg.sender, 0x000000000000000000000000000000000000dEaD, safe2Balance);\\n    cover.mint(msg.sender, safe2Balance);\\n    safe2Migrated = safe2Migrated.add(safe2Balance);\\n  }\\n\\n  function claim(uint256 _index, uint256 _amount, bytes32[] calldata _merkleProof) external override {\\n    require(block.timestamp >= START_TIME, \\\"Migrator: not started\\\");\\n    require(_amount > 0, \\\"Migrator: amount is 0\\\");\\n    require(!isSafeClaimed(_index), 'Migrator: already claimed');\\n    require(safe2Migrated.add(safeClaimed).add(_amount) <= migrationCap, \\\"Migrator: cap exceeded\\\"); // SAFE2 take priority first\\n\\n    // Verify the merkle proof.\\n    bytes32 node = keccak256(abi.encodePacked(_index, msg.sender, _amount));\\n    require(MerkleProof.verify(_merkleProof, merkleRoot, node), 'Migrator: invalid proof');\\n\\n    // Mark it claimed and send the token.\\n    _setClaimed(_index);\\n    safeClaimed = safeClaimed.add(_amount);\\n    cover.mint(msg.sender, _amount);\\n  }\\n\\n  /// @notice transfer minting right to new migrator if migrator has issues. Once all migration is done, transfer right to 0.\\n  function transferMintingRights(address _newAddress) external override {\\n    require(msg.sender == governance, \\\"Migrator: caller not governance\\\");\\n    cover.setMigrator(_newAddress);\\n  }\\n\\n  function _setClaimed(uint256 _index) private {\\t\\n    uint256 claimedWordIndex = _index / 256;\\t\\n    uint256 claimedBitIndex = _index % 256;\\t\\n    claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\t\\n  }\\n}\"\r\n    },\r\n    \"contracts/utils/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.4;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMigrator.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\n/**\\n * @title COVER token migrator\\n * @author crypto-pumpkin@github + @Kiwi\\n */\\ninterface IMigrator {\\n  function isSafeClaimed(uint256 _index) external view returns (bool);\\n  function migrateSafe2() external;\\n  function claim(uint256 _index, uint256 _amount, bytes32[] calldata _merkleProof) external;\\n\\n  /// @notice only governance\\n  function transferMintingRights(address _newAddress) external;\\n}\"\r\n    },\r\n    \"contracts/Vesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\n\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./ERC20/SafeERC20.sol\\\";\\n\\n/**\\n * @title COVER token contract\\n * @author Alan\\n */\\ncontract Vesting {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public constant START_TIME = 1605830400; // 11/20/2020 12 AM UTC\\n    uint256 public constant MIDDLE_TIME = 1621468800; // 5/20/2021 12 AM UTC\\n    uint256 public constant END_TIME = 1637366400; // 11/20/2021 12 AM UTC\\n\\n    mapping (address => uint256) private _vested;\\n    mapping (address => uint256) private _total;\\n\\n    constructor() {\\n        // TODO: change addresses to team addresses\\n        _total[address(0x406a0c87A6bb25748252cb112a7a837e21aAcD98)] = 2700 ether;\\n        _total[address(0x3e677718f8665A40AC0AB044D8c008b55f277c98)] = 2700 ether;\\n        _total[address(0x094AD38fB69f27F6Eb0c515ad4a5BD4b9F9B2996)] = 2700 ether;\\n        _total[address(0xD4C8127AF1dE3Ebf8AB7449aac0fd892b70f3b45)] = 1620 ether;\\n        _total[address(0x82BBd2F08a59f5be1B4e719ff701e4D234c4F8db)] = 720 ether;\\n        _total[address(0xF00Bf178E3372C4eF6E15A1676fd770DAD2aDdfB)] = 360 ether;\\n        // _total[address(0x70997970C51812dc3A010C7d01b50e0d17dc79C8)] = 2700 ether;\\n        // _total[address(0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC)] = 2700 ether;\\n        // _total[address(0x90F79bf6EB2c4f870365E785982E1f101E93b906)] = 2700 ether;\\n        // _total[address(0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65)] = 1620 ether;\\n        // _total[address(0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc)] = 720 ether;\\n        // _total[address(0x976EA74026E726554dB657fA54763abd0C3a0aa9)] = 360 ether;\\n    }\\n\\n    function vest(IERC20 token) external {\\n        require(block.timestamp >= START_TIME, \\\"Vesting: !started\\\");\\n        require(_total[msg.sender] > 0, \\\"Vesting: not team\\\");\\n\\n        uint256 toBeReleased = releasableAmount(msg.sender);\\n        require(toBeReleased > 0, \\\"Vesting: all vested\\\");\\n\\n        _vested[msg.sender] = _vested[msg.sender].add(toBeReleased);\\n        token.safeTransfer(msg.sender, toBeReleased);\\n    }\\n\\n    function releasableAmount(address _addr) public view returns (uint256) {\\n        return unlockedAmount(_addr).sub(_vested[_addr]);\\n    }\\n\\n    function unlockedAmount(address _addr) public view returns (uint256) {\\n        if (block.timestamp <= MIDDLE_TIME) {\\n            uint256 duration = MIDDLE_TIME.sub(START_TIME);\\n            uint256 firstHalf = _total[_addr].mul(2).div(3);\\n            uint256 timePassed = block.timestamp.sub(START_TIME);\\n            return firstHalf.mul(timePassed).div(duration);\\n        } else if (block.timestamp > MIDDLE_TIME && block.timestamp <= END_TIME) {\\n            uint256 duration = END_TIME.sub(MIDDLE_TIME);\\n            uint256 firstHalf = _total[_addr].mul(2).div(3);\\n            uint256 secondHalf = _total[_addr].div(3);\\n            uint256 timePassed = block.timestamp.sub(MIDDLE_TIME);\\n            return firstHalf.add(secondHalf.mul(timePassed).div(duration));\\n        } else {\\n            return _total[_addr];\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\nimport \\\"../utils/SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n  constructor (string memory name_, string memory symbol_) {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = 18;\\n  }\\n\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function totalSupply() public view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) public view override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(msg.sender, recipient, amount);\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n    return true;\\n  }\\n\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n    require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n\\n    _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\\n    require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n}\"\r\n    },\r\n    \"contracts/COVER.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\n\\npragma solidity ^0.7.4;\\n\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./ERC20/ERC20.sol\\\";\\n\\n/**\\n * @title COVER token contract\\n * @author crypto-pumpkin@github\\n */\\ncontract COVER is Ownable, ERC20 {\\n  using SafeMath for uint256;\\n\\n  bool private isReleased;\\n  address public blacksmith; // mining contract\\n  address public migrator; // migration contract\\n  uint256 public constant START_TIME = 1605830400; // 11/20/2020 12am UTC\\n\\n  constructor () ERC20(\\\"Cover Protocol\\\", \\\"COVER\\\") {\\n    // mint 1 token to create pool2\\n    _mint(0x2f80E5163A7A774038753593010173322eA6f9fe, 1e18);\\n  }\\n\\n  function mint(address _account, uint256 _amount) public {\\n    require(isReleased, \\\"$COVER: not released\\\");\\n    require(msg.sender == migrator || msg.sender == blacksmith, \\\"$COVER: caller not migrator or Blacksmith\\\");\\n\\n    _mint(_account, _amount);\\n  }\\n\\n  function setBlacksmith(address _newBlacksmith) external returns (bool) {\\n    require(msg.sender == blacksmith, \\\"$COVER: caller not blacksmith\\\");\\n\\n    blacksmith = _newBlacksmith;\\n    return true;\\n  }\\n\\n  function setMigrator(address _newMigrator) external returns (bool) {\\n    require(msg.sender == migrator, \\\"$COVER: caller not migrator\\\");\\n\\n    migrator = _newMigrator;\\n    return true;\\n  }\\n\\n  /// @notice called once and only by owner\\n  function release(address _treasury, address _vestor, address _blacksmith, address _migrator) external onlyOwner {\\n    require(block.timestamp >= START_TIME, \\\"$COVER: not started\\\");\\n    require(isReleased == false, \\\"$COVER: already released\\\");\\n\\n    isReleased = true;\\n\\n    blacksmith = _blacksmith;\\n    migrator = _migrator;\\n    _mint(_treasury, 950e18);\\n    _mint(_vestor, 10800e18);\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x67b66c99d3eb37fa76aa3ed1ff33e8e39f0b9c7a", "attacktype": "Other unsafe DeFi protocol dependency, Absence of code logic or sanity check", "sourcecode": "// File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity-2.3.0/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity-2.3.0/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity-2.3.0/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity-2.3.0/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity-2.3.0/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: contracts/BankConfig.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface BankConfig {\r\n    /// @dev Return minimum ETH debt size per position.\r\n    function minDebtSize() external view returns (uint256);\r\n\r\n    /// @dev Return the interest rate per second, using 1e18 as denom.\r\n    function getInterestRate(uint256 debt, uint256 floating) external view returns (uint256);\r\n\r\n    /// @dev Return the bps rate for reserve pool.\r\n    function getReservePoolBps() external view returns (uint256);\r\n\r\n    /// @dev Return the bps rate for Avada Kill caster.\r\n    function getKillBps() external view returns (uint256);\r\n\r\n    /// @dev Return whether the given address is a goblin.\r\n    function isGoblin(address goblin) external view returns (bool);\r\n\r\n    /// @dev Return whether the given goblin accepts more debt. Revert on non-goblin.\r\n    function acceptDebt(address goblin) external view returns (bool);\r\n\r\n    /// @dev Return the work factor for the goblin + ETH debt, using 1e4 as denom. Revert on non-goblin.\r\n    function workFactor(address goblin, uint256 debt) external view returns (uint256);\r\n\r\n    /// @dev Return the kill factor for the goblin + ETH debt, using 1e4 as denom. Revert on non-goblin.\r\n    function killFactor(address goblin, uint256 debt) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/Goblin.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface Goblin {\r\n    /// @dev Work on a (potentially new) position. Optionally send ETH back to Bank.\r\n    function work(uint256 id, address user, uint256 debt, bytes calldata data) external payable;\r\n\r\n    /// @dev Re-invest whatever the goblin is working on.\r\n    function reinvest() external;\r\n\r\n    /// @dev Return the amount of ETH wei to get back if we are to liquidate the position.\r\n    function health(uint256 id) external view returns (uint256);\r\n\r\n    /// @dev Liquidate the given position to ETH. Send all ETH back to Bank.\r\n    function liquidate(uint256 id) external;\r\n}\r\n\r\n// File: contracts/SafeToken.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface ERC20Interface {\r\n    function balanceOf(address user) external view returns (uint256);\r\n}\r\n\r\nlibrary SafeToken {\r\n    function myBalance(address token) internal view returns (uint256) {\r\n        return ERC20Interface(token).balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOf(address token, address user) internal view returns (uint256) {\r\n        return ERC20Interface(token).balanceOf(user);\r\n    }\r\n\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeApprove\");\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransfer\");\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransferFrom\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call.value(value)(new bytes(0));\r\n        require(success, \"!safeTransferETH\");\r\n    }\r\n}\r\n\r\n// File: contracts/Bank.sol\r\n\r\npragma solidity 0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Bank is ERC20, ReentrancyGuard, Ownable {\r\n    /// @notice Libraries\r\n    using SafeToken for address;\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Events\r\n    event AddDebt(uint256 indexed id, uint256 debtShare);\r\n    event RemoveDebt(uint256 indexed id, uint256 debtShare);\r\n    event Work(uint256 indexed id, uint256 loan);\r\n    event Kill(uint256 indexed id, address indexed killer, uint256 prize, uint256 left);\r\n\r\n    string public name = \"Interest Bearing ETH\";\r\n    string public symbol = \"ibETH\";\r\n    uint8 public decimals = 18;\r\n\r\n    struct Position {\r\n        address goblin;\r\n        address owner;\r\n        uint256 debtShare;\r\n    }\r\n\r\n    BankConfig public config;\r\n    mapping (uint256 => Position) public positions;\r\n    uint256 public nextPositionID = 1;\r\n\r\n    uint256 public glbDebtShare;\r\n    uint256 public glbDebtVal;\r\n    uint256 public lastAccrueTime;\r\n    uint256 public reservePool;\r\n\r\n    /// @dev Require that the caller must be an EOA account to avoid flash loans.\r\n    modifier onlyEOA() {\r\n        require(msg.sender == tx.origin, \"not eoa\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Add more debt to the global debt pool.\r\n    modifier accrue(uint256 msgValue) {\r\n        if (now > lastAccrueTime) {\r\n            uint256 interest = pendingInterest(msgValue);\r\n            uint256 toReserve = interest.mul(config.getReservePoolBps()).div(10000);\r\n            reservePool = reservePool.add(toReserve);\r\n            glbDebtVal = glbDebtVal.add(interest);\r\n            lastAccrueTime = now;\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(BankConfig _config) public {\r\n        config = _config;\r\n        lastAccrueTime = now;\r\n    }\r\n\r\n    /// @dev Return the pending interest that will be accrued in the next call.\r\n    /// @param msgValue Balance value to subtract off address(this).balance when called from payable functions.\r\n    function pendingInterest(uint256 msgValue) public view returns (uint256) {\r\n        if (now > lastAccrueTime) {\r\n            uint256 timePast = now.sub(lastAccrueTime);\r\n            uint256 balance = address(this).balance.sub(msgValue);\r\n            uint256 ratePerSec = config.getInterestRate(glbDebtVal, balance);\r\n            return ratePerSec.mul(glbDebtVal).mul(timePast).div(1e18);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /// @dev Return the ETH debt value given the debt share. Be careful of unaccrued interests.\r\n    /// @param debtShare The debt share to be converted.\r\n    function debtShareToVal(uint256 debtShare) public view returns (uint256) {\r\n        if (glbDebtShare == 0) return debtShare; // When there's no share, 1 share = 1 val.\r\n        return debtShare.mul(glbDebtVal).div(glbDebtShare);\r\n    }\r\n\r\n    /// @dev Return the debt share for the given debt value. Be careful of unaccrued interests.\r\n    /// @param debtVal The debt value to be converted.\r\n    function debtValToShare(uint256 debtVal) public view returns (uint256) {\r\n        if (glbDebtShare == 0) return debtVal; // When there's no share, 1 share = 1 val.\r\n        return debtVal.mul(glbDebtShare).div(glbDebtVal);\r\n    }\r\n\r\n    /// @dev Return ETH value and debt of the given position. Be careful of unaccrued interests.\r\n    /// @param id The position ID to query.\r\n    function positionInfo(uint256 id) public view returns (uint256, uint256) {\r\n        Position storage pos = positions[id];\r\n        return (Goblin(pos.goblin).health(id), debtShareToVal(pos.debtShare));\r\n    }\r\n\r\n    /// @dev Return the total ETH entitled to the token holders. Be careful of unaccrued interests.\r\n    function totalETH() public view returns (uint256) {\r\n        return address(this).balance.add(glbDebtVal).sub(reservePool);\r\n    }\r\n\r\n    /// @dev Add more ETH to the bank. Hope to get some good returns.\r\n    function deposit() external payable accrue(msg.value) nonReentrant {\r\n        uint256 total = totalETH().sub(msg.value);\r\n        uint256 share = total == 0 ? msg.value : msg.value.mul(totalSupply()).div(total);\r\n        _mint(msg.sender, share);\r\n    }\r\n\r\n    /// @dev Withdraw ETH from the bank by burning the share tokens.\r\n    function withdraw(uint256 share) external accrue(0) nonReentrant {\r\n        uint256 amount = share.mul(totalETH()).div(totalSupply());\r\n        _burn(msg.sender, share);\r\n        SafeToken.safeTransferETH(msg.sender, amount);\r\n    }\r\n\r\n    /// @dev Create a new farming position to unlock your yield farming potential.\r\n    /// @param id The ID of the position to unlock the earning. Use ZERO for new position.\r\n    /// @param goblin The address of the authorized goblin to work for this position.\r\n    /// @param loan The amount of ETH to borrow from the pool.\r\n    /// @param maxReturn The max amount of ETH to return to the pool.\r\n    /// @param data The calldata to pass along to the goblin for more working context.\r\n    function work(uint256 id, address goblin, uint256 loan, uint256 maxReturn, bytes calldata data)\r\n        external payable\r\n        onlyEOA accrue(msg.value) nonReentrant\r\n    {\r\n        // 1. Sanity check the input position, or add a new position of ID is 0.\r\n        if (id == 0) {\r\n            id = nextPositionID++;\r\n            positions[id].goblin = goblin;\r\n            positions[id].owner = msg.sender;\r\n        } else {\r\n            require(id < nextPositionID, \"bad position id\");\r\n            require(positions[id].goblin == goblin, \"bad position goblin\");\r\n            require(positions[id].owner == msg.sender, \"not position owner\");\r\n        }\r\n        emit Work(id, loan);\r\n        // 2. Make sure the goblin can accept more debt and remove the existing debt.\r\n        require(config.isGoblin(goblin), \"not a goblin\");\r\n        require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\r\n        uint256 debt = _removeDebt(id).add(loan);\r\n        // 3. Perform the actual work, using a new scope to avoid stack-too-deep errors.\r\n        uint256 back;\r\n        {\r\n            uint256 sendETH = msg.value.add(loan);\r\n            require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");\r\n            uint256 beforeETH = address(this).balance.sub(sendETH);\r\n            Goblin(goblin).work.value(sendETH)(id, msg.sender, debt, data);\r\n            back = address(this).balance.sub(beforeETH);\r\n        }\r\n        // 4. Check and update position debt.\r\n        uint256 lessDebt = Math.min(debt, Math.min(back, maxReturn));\r\n        debt = debt.sub(lessDebt);\r\n        if (debt > 0) {\r\n            require(debt >= config.minDebtSize(), \"too small debt size\");\r\n            uint256 health = Goblin(goblin).health(id);\r\n            uint256 workFactor = config.workFactor(goblin, debt);\r\n            require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\r\n            _addDebt(id, debt);\r\n        }\r\n        // 5. Return excess ETH back.\r\n        if (back > lessDebt) SafeToken.safeTransferETH(msg.sender, back - lessDebt);\r\n    }\r\n\r\n    /// @dev Kill the given to the position. Liquidate it immediately if killFactor condition is met.\r\n    /// @param id The position ID to be killed.\r\n    function kill(uint256 id) external onlyEOA accrue(0) nonReentrant {\r\n        // 1. Verify that the position is eligible for liquidation.\r\n        Position storage pos = positions[id];\r\n        require(pos.debtShare > 0, \"no debt\");\r\n        uint256 debt = _removeDebt(id);\r\n        uint256 health = Goblin(pos.goblin).health(id);\r\n        uint256 killFactor = config.killFactor(pos.goblin, debt);\r\n        require(health.mul(killFactor) < debt.mul(10000), \"can't liquidate\");\r\n        // 2. Perform liquidation and compute the amount of ETH received.\r\n        uint256 beforeETH = address(this).balance;\r\n        Goblin(pos.goblin).liquidate(id);\r\n        uint256 back = address(this).balance.sub(beforeETH);\r\n        uint256 prize = back.mul(config.getKillBps()).div(10000);\r\n        uint256 rest = back.sub(prize);\r\n        // 3. Clear position debt and return funds to liquidator and position owner.\r\n        if (prize > 0) SafeToken.safeTransferETH(msg.sender, prize);\r\n        uint256 left = rest > debt ? rest - debt : 0;\r\n        if (left > 0) SafeToken.safeTransferETH(pos.owner, left);\r\n        emit Kill(id, msg.sender, prize, left);\r\n    }\r\n\r\n    /// @dev Internal function to add the given debt value to the given position.\r\n    function _addDebt(uint256 id, uint256 debtVal) internal {\r\n        Position storage pos = positions[id];\r\n        uint256 debtShare = debtValToShare(debtVal);\r\n        pos.debtShare = pos.debtShare.add(debtShare);\r\n        glbDebtShare = glbDebtShare.add(debtShare);\r\n        glbDebtVal = glbDebtVal.add(debtVal);\r\n        emit AddDebt(id, debtShare);\r\n    }\r\n\r\n    /// @dev Internal function to clear the debt of the given position. Return the debt value.\r\n    function _removeDebt(uint256 id) internal returns (uint256) {\r\n        Position storage pos = positions[id];\r\n        uint256 debtShare = pos.debtShare;\r\n        if (debtShare > 0) {\r\n            uint256 debtVal = debtShareToVal(debtShare);\r\n            pos.debtShare = 0;\r\n            glbDebtShare = glbDebtShare.sub(debtShare);\r\n            glbDebtVal = glbDebtVal.sub(debtVal);\r\n            emit RemoveDebt(id, debtShare);\r\n            return debtVal;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /// @dev Update bank configuration to a new address. Must only be called by owner.\r\n    /// @param _config The new configurator address.\r\n    function updateConfig(BankConfig _config) external onlyOwner {\r\n        config = _config;\r\n    }\r\n\r\n    /// @dev Withdraw ETH reserve for underwater positions to the given address.\r\n    /// @param to The address to transfer ETH to.\r\n    /// @param value The number of ETH tokens to withdraw. Must not exceed `reservePool`.\r\n    function withdrawReserve(address to, uint256 value) external onlyOwner nonReentrant {\r\n        reservePool = reservePool.sub(value);\r\n        SafeToken.safeTransferETH(to, value);\r\n    }\r\n\r\n    /// @dev Reduce ETH reserve, effectively giving them to the depositors.\r\n    /// @param value The number of ETH reserve to reduce.\r\n    function reduceReserve(uint256 value) external onlyOwner {\r\n        reservePool = reservePool.sub(value);\r\n    }\r\n\r\n    /// @dev Recover ERC20 tokens that were accidentally sent to this smart contract.\r\n    /// @param token The token contract. Can be anything. This contract should not hold ERC20 tokens.\r\n    /// @param to The address to send the tokens to.\r\n    /// @param value The number of tokens to transfer to `to`.\r\n    function recover(address token, address to, uint256 value) external onlyOwner nonReentrant {\r\n        token.safeTransfer(to, value);\r\n    }\r\n\r\n    /// @dev Fallback function to accept ETH. Goblins will send ETH back the pool.\r\n    function() external payable {}\r\n}"}
{"address": "0x9daec8d56cdcbde72abe65f4a5daf8cc0a5bf2f9", "attacktype": "Other unsafe DeFi protocol dependency, Inconsistent access control", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IUniswapConnector03.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.2;\\r\\n\\r\\nimport {\\r\\n    IUniswapV2Router02\\r\\n} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\nimport {\\r\\n    IUniswapV2Factory\\r\\n} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\r\\nimport { ITrader } from \\\"@primitivefi/contracts/contracts/option/interfaces/ITrader.sol\\\";\\r\\nimport { IOption, IERC20 } from \\\"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\\\";\\r\\n\\r\\ninterface IUniswapConnector03 {\\r\\n    // ==== Combo Operations ====\\r\\n\\r\\n    function mintShortOptionsThenSwapToTokens(\\r\\n        IOption optionToken,\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (bool);\\r\\n\\r\\n    // ==== Flash Functions ====\\r\\n\\r\\n    function flashCloseLongOptionsThenSwap(\\r\\n        address pairAddress,\\r\\n        address optionAddress,\\r\\n        uint256 flashLoanQuantity,\\r\\n        uint256 minPayout,\\r\\n        address[] calldata path,\\r\\n        address to\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    function flashMintShortOptionsThenSwap(\\r\\n        address pairAddress,\\r\\n        address optionAddress,\\r\\n        uint256 flashLoanQuantity,\\r\\n        uint256 maxPremium,\\r\\n        address[] calldata path,\\r\\n        address to\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    function openFlashLong(\\r\\n        IOption optionToken,\\r\\n        uint256 amountOptions,\\r\\n        uint256 amountOutMin\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function closeFlashLong(\\r\\n        IOption optionToken,\\r\\n        uint256 amountRedeems,\\r\\n        uint256 minPayout\\r\\n    ) external returns (bool);\\r\\n\\r\\n    // ==== Liquidity Functions ====\\r\\n\\r\\n    function addShortLiquidityWithUnderlying(\\r\\n        address optionAddress,\\r\\n        uint256 quantityOptions,\\r\\n        uint256 amountBMax,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function removeShortLiquidityThenCloseOptions(\\r\\n        address optionAddress,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    // ==== Management Functions ====\\r\\n\\r\\n    function deployUniswapMarket(address optionAddress, address otherToken)\\r\\n        external\\r\\n        returns (address);\\r\\n\\r\\n    // ==== View ====\\r\\n\\r\\n    function getUniswapMarketForTokens(address token0, address token1)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function router() external view returns (IUniswapV2Router02);\\r\\n\\r\\n    function factory() external view returns (IUniswapV2Factory);\\r\\n\\r\\n    function trader() external view returns (ITrader);\\r\\n\\r\\n    function getName() external pure returns (string memory);\\r\\n\\r\\n    function getVersion() external pure returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@primitivefi/contracts/contracts/option/interfaces/ITrader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.2;\\r\\n\\r\\nimport { IOption } from \\\"./IOption.sol\\\";\\r\\n\\r\\ninterface ITrader {\\r\\n    function safeMint(\\r\\n        IOption optionToken,\\r\\n        uint256 mintQuantity,\\r\\n        address receiver\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    function safeExercise(\\r\\n        IOption optionToken,\\r\\n        uint256 exerciseQuantity,\\r\\n        address receiver\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    function safeRedeem(\\r\\n        IOption optionToken,\\r\\n        uint256 redeemQuantity,\\r\\n        address receiver\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function safeClose(\\r\\n        IOption optionToken,\\r\\n        uint256 closeQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function safeUnwind(\\r\\n        IOption optionToken,\\r\\n        uint256 unwindQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n}\\r\\n\"\r\n    },\r\n    \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.2;\\r\\n\\r\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\n\\r\\ninterface IOption is IERC20 {\\r\\n    function mintOptions(address receiver) external returns (uint256, uint256);\\r\\n\\r\\n    function exerciseOptions(\\r\\n        address receiver,\\r\\n        uint256 outUnderlyings,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    function redeemStrikeTokens(address receiver) external returns (uint256);\\r\\n\\r\\n    function closeOptions(address receiver)\\r\\n        external\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function redeemToken() external view returns (address);\\r\\n\\r\\n    function getStrikeTokenAddress() external view returns (address);\\r\\n\\r\\n    function getUnderlyingTokenAddress() external view returns (address);\\r\\n\\r\\n    function getBaseValue() external view returns (uint256);\\r\\n\\r\\n    function getQuoteValue() external view returns (uint256);\\r\\n\\r\\n    function getExpiryTime() external view returns (uint256);\\r\\n\\r\\n    function underlyingCache() external view returns (uint256);\\r\\n\\r\\n    function strikeCache() external view returns (uint256);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function getCacheBalances() external view returns (uint256, uint256);\\r\\n\\r\\n    function getAssetAddresses()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address,\\r\\n            address,\\r\\n            address\\r\\n        );\\r\\n\\r\\n    function getParameters()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address _underlyingToken,\\r\\n            address _strikeToken,\\r\\n            address _redeemToken,\\r\\n            uint256 _base,\\r\\n            uint256 _quote,\\r\\n            uint256 _expiry\\r\\n        );\\r\\n\\r\\n    function initRedeemToken(address _redeemToken) external;\\r\\n\\r\\n    function updateCacheBalances() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapConnector03.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.2;\\r\\n\\r\\n///\\r\\n/// @title   Combines Uniswap V2 Protocol functions with Primitive V1.\\r\\n/// @notice  Primitive V1 UniswapConnector03 - @primitivefi/v1-connectors@v1.2.2\\r\\n/// @author  Primitive\\r\\n///\\r\\n\\r\\n// Uniswap V2 & Primitive V1\\r\\nimport {\\r\\n    IUniswapV2Callee\\r\\n} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol\\\";\\r\\nimport {\\r\\n    IUniswapV2Pair\\r\\n} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport {\\r\\n    IUniswapConnector03,\\r\\n    IUniswapV2Router02,\\r\\n    IUniswapV2Factory,\\r\\n    IOption,\\r\\n    ITrader,\\r\\n    IERC20\\r\\n} from \\\"./interfaces/IUniswapConnector03.sol\\\";\\r\\nimport {\\r\\n    TraderLib\\r\\n} from \\\"@primitivefi/contracts/contracts/option/libraries/TraderLib.sol\\\";\\r\\nimport {UniswapConnectorLib03} from \\\"./libraries/UniswapConnectorLib03.sol\\\";\\r\\n// Open Zeppelin\\r\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport {\\r\\n    ReentrancyGuard\\r\\n} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\n\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\n\\r\\ncontract UniswapConnector03 is\\r\\n    IUniswapConnector03,\\r\\n    IUniswapV2Callee,\\r\\n    ReentrancyGuard\\r\\n{\\r\\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\\r\\n    using SafeMath for uint256; // Reverts on math underflows/overflows\\r\\n\\r\\n    ITrader public override trader; // The Primitive contract used to interact with the protocol\\r\\n    IUniswapV2Factory public override factory; // The Uniswap V2 factory contract to get pair addresses from\\r\\n    IUniswapV2Router02 public override router; // The Uniswap contract used to interact with the protocol\\r\\n\\r\\n    event Initialized(address indexed from); // Emmitted on deployment\\r\\n    event FlashOpened(address indexed from, uint256 quantity, uint256 premium); // Emmitted on flash opening a long position\\r\\n    event FlashClosed(address indexed from, uint256 quantity, uint256 payout);\\r\\n    event WroteOption(address indexed from, uint256 quantity);\\r\\n\\r\\n    // ==== Constructor ====\\r\\n\\r\\n    constructor(\\r\\n        address router_,\\r\\n        address factory_,\\r\\n        address trader_\\r\\n    ) public {\\r\\n        require(address(router) == address(0x0), \\\"ERR_INITIALIZED\\\");\\r\\n        require(address(factory) == address(0x0), \\\"ERR_INITIALIZED\\\");\\r\\n        require(address(trader) == address(0x0), \\\"ERR_INITIALIZED\\\");\\r\\n        router = IUniswapV2Router02(router_);\\r\\n        factory = IUniswapV2Factory(factory_);\\r\\n        trader = ITrader(trader_);\\r\\n        emit Initialized(msg.sender);\\r\\n    }\\r\\n\\r\\n    // ==== Combo Operations ====\\r\\n\\r\\n    ///\\r\\n    /// @dev    Mints long + short option tokens, then swaps the shortOptionTokens (redeem) for tokens.\\r\\n    /// @notice If the first address in the path is not the shortOptionToken address, the tx will fail.\\r\\n    ///         underlyingToken -> shortOptionToken -> quoteToken.\\r\\n    ///         IMPORTANT: redeemTokens = shortOptionTokens\\r\\n    /// @param optionToken The address of the Option contract.\\r\\n    /// @param amountIn The quantity of options to mint.\\r\\n    /// @param amountOutMin The minimum quantity of tokens to receive in exchange for the shortOptionTokens.\\r\\n    /// @param path The token addresses to trade through using their Uniswap V2 pools. Assumes path[0] = shortOptionToken.\\r\\n    /// @param to The address to send the shortOptionToken proceeds and longOptionTokens to.\\r\\n    /// @param deadline The timestamp for a trade to fail at if not successful.\\r\\n    /// @return bool Whether the transaction was successful or not.\\r\\n    ///\\r\\n    function mintShortOptionsThenSwapToTokens(\\r\\n        IOption optionToken,\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external override nonReentrant returns (bool) {\\r\\n        bool success =\\r\\n            UniswapConnectorLib03.mintShortOptionsThenSwapToTokens(\\r\\n                router,\\r\\n                optionToken,\\r\\n                amountIn,\\r\\n                amountOutMin,\\r\\n                path,\\r\\n                to,\\r\\n                deadline\\r\\n            );\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    /// @dev    Write options by minting option tokens and selling the long option tokens for premium.\\r\\n    /// @notice IMPORTANT: if `minPayout` is 0, this function can cost the caller `underlyingToken`s.\\r\\n    /// @param optionToken The option contract to underwrite.\\r\\n    /// @param writeQuantity The quantity of option tokens to write and equally, the quantity of underlyings to deposit.\\r\\n    /// @param minPayout The minimum amount of underlyingTokens to receive from selling long option tokens.\\r\\n    function mintOptionsThenFlashCloseLong(\\r\\n        IOption optionToken,\\r\\n        uint256 writeQuantity,\\r\\n        uint256 minPayout\\r\\n    ) external returns (bool) {\\r\\n        // Pulls underlyingTokens from `msg.sender` using `transferFrom`. Mints option tokens to `msg.sender`.\\r\\n        (, uint256 outputRedeems) =\\r\\n            TraderLib.safeMint(optionToken, writeQuantity, msg.sender);\\r\\n\\r\\n        // Sell the long option tokens for underlyingToken premium.\\r\\n        bool success = closeFlashLong(optionToken, outputRedeems, minPayout);\\r\\n        require(success, \\\"ERR_FLASH_CLOSE\\\");\\r\\n        emit WroteOption(msg.sender, writeQuantity);\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    // ==== Flash Functions ====\\r\\n\\r\\n    ///\\r\\n    /// @dev    Receives underlyingTokens from a UniswapV2Pair.swap() call from a pair with\\r\\n    ///         reserve0 = shortOptionTokens and reserve1 = underlyingTokens.\\r\\n    ///         Uses underlyingTokens to mint long (option) + short (redeem) tokens.\\r\\n    ///         Sends longOptionTokens to msg.sender, and pays back the UniswapV2Pair the shortOptionTokens,\\r\\n    ///         AND any remainder quantity of underlyingTokens (paid by msg.sender).\\r\\n    /// @notice If the first address in the path is not the shortOptionToken address, the tx will fail.\\r\\n    /// @param optionAddress The address of the Option contract.\\r\\n    /// @param flashLoanQuantity The quantity of options to mint using borrowed underlyingTokens.\\r\\n    /// @param maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\\r\\n    /// @param path The token addresses to trade through using their Uniswap V2 pools. Assumes path[0] = shortOptionToken.\\r\\n    /// @param to The address to send the shortOptionToken proceeds and longOptionTokens to.\\r\\n    /// @return success bool Whether the transaction was successful or not.\\r\\n    ///\\r\\n    function flashMintShortOptionsThenSwap(\\r\\n        address pairAddress,\\r\\n        address optionAddress,\\r\\n        uint256 flashLoanQuantity,\\r\\n        uint256 maxPremium,\\r\\n        address[] memory path,\\r\\n        address to\\r\\n    ) public override returns (uint256, uint256) {\\r\\n        (uint256 outputOptions, uint256 loanRemainder) =\\r\\n            UniswapConnectorLib03.flashMintShortOptionsThenSwap(\\r\\n                router,\\r\\n                pairAddress,\\r\\n                optionAddress,\\r\\n                flashLoanQuantity,\\r\\n                maxPremium,\\r\\n                path,\\r\\n                to\\r\\n            );\\r\\n        emit FlashOpened(msg.sender, outputOptions, loanRemainder);\\r\\n        return (outputOptions, loanRemainder);\\r\\n    }\\r\\n\\r\\n    /// @dev    Sends shortOptionTokens to msg.sender, and pays back the UniswapV2Pair in underlyingTokens.\\r\\n    /// @notice IMPORTANT: If minPayout is 0, the `to` address is liable for negative payouts *if* that occurs.\\r\\n    /// @param pairAddress The address of the redeemToken<>underlyingToken UniswapV2Pair contract.\\r\\n    /// @param optionAddress The address of the longOptionTokes to close.\\r\\n    /// @param flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\\r\\n    /// @param minPayout The minimum payout of underlyingTokens sent to the `to` address.\\r\\n    /// @param path underlyingTokens -> shortOptionTokens, because we are paying the input of underlyingTokens.\\r\\n    /// @param to The address which is sent the underlyingToken payout, or liable to pay for a negative payout.\\r\\n    function flashCloseLongOptionsThenSwap(\\r\\n        address pairAddress,\\r\\n        address optionAddress,\\r\\n        uint256 flashLoanQuantity,\\r\\n        uint256 minPayout,\\r\\n        address[] memory path,\\r\\n        address to\\r\\n    ) public override returns (uint256, uint256) {\\r\\n        (uint256 outputUnderlyings, uint256 underlyingPayout) =\\r\\n            UniswapConnectorLib03.flashCloseLongOptionsThenSwap(\\r\\n                router,\\r\\n                pairAddress,\\r\\n                optionAddress,\\r\\n                flashLoanQuantity,\\r\\n                minPayout,\\r\\n                path,\\r\\n                to\\r\\n            );\\r\\n        emit FlashClosed(msg.sender, outputUnderlyings, underlyingPayout);\\r\\n        return (outputUnderlyings, underlyingPayout);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev    Opens a longOptionToken position by minting long + short tokens, then selling the short tokens.\\r\\n    /// @notice IMPORTANT: amountOutMin parameter is the price to swap shortOptionTokens to underlyingTokens.\\r\\n    ///         IMPORTANT: If the ratio between shortOptionTokens and underlyingTokens is 1:1, then only the swap fee (0.30%) has to be paid.\\r\\n    /// @param optionToken The option address.\\r\\n    /// @param amountOptions The quantity of longOptionTokens to purchase.\\r\\n    /// @param maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\\r\\n    ///\\r\\n    function openFlashLong(\\r\\n        IOption optionToken,\\r\\n        uint256 amountOptions,\\r\\n        uint256 maxPremium\\r\\n    ) external override nonReentrant returns (bool) {\\r\\n        address redeemToken = optionToken.redeemToken();\\r\\n        address underlyingToken = optionToken.getUnderlyingTokenAddress();\\r\\n        address pairAddress = factory.getPair(redeemToken, underlyingToken);\\r\\n\\r\\n        // Build the path to get the appropriate reserves to borrow from, and then pay back.\\r\\n        // We are borrowing from reserve1 then paying it back mostly in reserve0.\\r\\n        // Borrowing underlyingTokens, paying back in shortOptionTokens (normal swap). Pay any remainder in underlyingTokens.\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = redeemToken;\\r\\n        path[1] = underlyingToken;\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\r\\n\\r\\n        bytes4 selector =\\r\\n            bytes4(\\r\\n                keccak256(\\r\\n                    bytes(\\r\\n                        \\\"flashMintShortOptionsThenSwap(address,address,uint256,uint256,address[],address)\\\"\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        bytes memory params =\\r\\n            abi.encodeWithSelector(\\r\\n                selector, // function to call in this contract\\r\\n                pairAddress, // pair contract we are borrowing from\\r\\n                optionToken, // option token to mint with flash loaned tokens\\r\\n                amountOptions, // quantity of underlyingTokens from flash loan to use to mint options\\r\\n                maxPremium, // total price paid (in underlyingTokens) for selling shortOptionTokens\\r\\n                path, // redeemToken -> underlyingToken\\r\\n                msg.sender // address to pull the remainder loan amount to pay, and send longOptionTokens to.\\r\\n            );\\r\\n\\r\\n        // Receives 0 quoteTokens and `amountOptions` of underlyingTokens to `this` contract address.\\r\\n        // Then executes `flashMintShortOptionsThenSwap`.\\r\\n        uint256 amount0Out =\\r\\n            pair.token0() == underlyingToken ? amountOptions : 0;\\r\\n        uint256 amount1Out =\\r\\n            pair.token0() == underlyingToken ? 0 : amountOptions;\\r\\n\\r\\n        // Borrow the amountOptions quantity of underlyingTokens and execute the callback function using params.\\r\\n        pair.swap(amount0Out, amount1Out, address(this), params);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev    Closes a longOptionToken position by flash swapping in redeemTokens,\\r\\n    ///         closing the option, and paying back in underlyingTokens.\\r\\n    /// @notice IMPORTANT: If minPayout is 0, this function will cost the caller to close the option, for no gain.\\r\\n    /// @param optionToken The address of the longOptionTokens to close.\\r\\n    /// @param amountRedeems The quantity of redeemTokens to borrow to close the options.\\r\\n    /// @param minPayout The minimum payout of underlyingTokens sent out to the user.\\r\\n    ///\\r\\n    function closeFlashLong(\\r\\n        IOption optionToken,\\r\\n        uint256 amountRedeems,\\r\\n        uint256 minPayout\\r\\n    ) public override nonReentrant returns (bool) {\\r\\n        address redeemToken = optionToken.redeemToken();\\r\\n        address underlyingToken = optionToken.getUnderlyingTokenAddress();\\r\\n        address pairAddress = factory.getPair(redeemToken, underlyingToken);\\r\\n\\r\\n        // Build the path to get the appropriate reserves to borrow from, and then pay back.\\r\\n        // We are borrowing from reserve1 then paying it back mostly in reserve0.\\r\\n        // Borrowing redeemTokens, paying back in underlyingTokens (normal swap).\\r\\n        // Pay any remainder in underlyingTokens.\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = underlyingToken;\\r\\n        path[1] = redeemToken;\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\r\\n\\r\\n        bytes4 selector =\\r\\n            bytes4(\\r\\n                keccak256(\\r\\n                    bytes(\\r\\n                        \\\"flashCloseLongOptionsThenSwap(address,address,uint256,uint256,address[],address)\\\"\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        bytes memory params =\\r\\n            abi.encodeWithSelector(\\r\\n                selector, // function to call in this contract\\r\\n                pairAddress, // pair contract we are borrowing from\\r\\n                optionToken, // option token to close with flash loaned redeemTokens\\r\\n                amountRedeems, // quantity of redeemTokens from flash loan to use to close options\\r\\n                minPayout, // total remaining underlyingTokens after flash loan is paid\\r\\n                path, // underlyingToken -> redeemToken\\r\\n                msg.sender // address to send payout of underlyingTokens to. Will pull underlyingTokens if negative payout and minPayout <= 0.\\r\\n            );\\r\\n\\r\\n        // Receives 0 underlyingTokens and `amountRedeems` of redeemTokens to `this` contract address.\\r\\n        // Then executes `flashCloseLongOptionsThenSwap`.\\r\\n        uint256 amount0Out = pair.token0() == redeemToken ? amountRedeems : 0;\\r\\n        uint256 amount1Out = pair.token0() == redeemToken ? 0 : amountRedeems;\\r\\n\\r\\n        // Borrow the amountRedeems quantity of redeemTokens and execute the callback function using params.\\r\\n        pair.swap(amount0Out, amount1Out, address(this), params);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // ==== Liquidity Functions ====\\r\\n\\r\\n    ///\\r\\n    /// @dev    Adds redeemToken liquidity to a redeem<>token pair by minting shortOptionTokens with underlyingTokens.\\r\\n    /// @notice Pulls underlying tokens from msg.sender and pushes UNI-V2 liquidity tokens to the \\\"to\\\" address.\\r\\n    ///         underlyingToken -> redeemToken -> UNI-V2.\\r\\n    /// @param optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\\r\\n    /// @param quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\\r\\n    /// @param amountBMax The minimum quantity of shortOptionTokens expected to provide liquidity with.\\r\\n    /// @param amountBMin The minimum quantity of otherTokens expected to provide liquidity with.\\r\\n    /// @param to The address that receives UNI-V2 shares.\\r\\n    /// @param deadline The timestamp to expire a pending transaction.\\r\\n    ///\\r\\n    function addShortLiquidityWithUnderlying(\\r\\n        address optionAddress,\\r\\n        uint256 quantityOptions,\\r\\n        uint256 amountBMax,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n        nonReentrant\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        return\\r\\n            UniswapConnectorLib03.addShortLiquidityWithUnderlying(\\r\\n                router,\\r\\n                optionAddress,\\r\\n                quantityOptions,\\r\\n                amountBMax,\\r\\n                amountBMin,\\r\\n                to,\\r\\n                deadline\\r\\n            );\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev    Combines Uniswap V2 Router \\\"removeLiquidity\\\" function with Primitive \\\"closeOptions\\\" function.\\r\\n    /// @notice Pulls UNI-V2 liquidity shares with shortOption<>underlying token, and optionTokens from msg.sender.\\r\\n    ///         Then closes the longOptionTokens and withdraws underlyingTokens to the \\\"to\\\" address.\\r\\n    ///         Sends underlyingTokens from the burned UNI-V2 liquidity shares to the \\\"to\\\" address.\\r\\n    ///         UNI-V2 -> optionToken -> underlyingToken.\\r\\n    /// @param optionAddress The address of the option that will be closed from burned UNI-V2 liquidity shares.\\r\\n    /// @param liquidity The quantity of liquidity tokens to pull from msg.sender and burn.\\r\\n    /// @param amountAMin The minimum quantity of shortOptionTokens to receive from removing liquidity.\\r\\n    /// @param amountBMin The minimum quantity of underlyingTokens to receive from removing liquidity.\\r\\n    /// @param to The address that receives underlyingTokens from burned UNI-V2, and underlyingTokens from closed options.\\r\\n    /// @param deadline The timestamp to expire a pending transaction.\\r\\n    ///\\r\\n    function removeShortLiquidityThenCloseOptions(\\r\\n        address optionAddress,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external override nonReentrant returns (uint256, uint256) {\\r\\n        address redeemToken = IOption(optionAddress).redeemToken();\\r\\n        address underlyingTokenAddress =\\r\\n            IOption(optionAddress).getUnderlyingTokenAddress();\\r\\n\\r\\n        // Check the short option tokens before and after, there could be dust.\\r\\n        uint256 redeemBalance = IERC20(redeemToken).balanceOf(address(this));\\r\\n\\r\\n        // Remove liquidity by burning lp tokens from msg.sender, withdraw tokens to this contract.\\r\\n        // Notice: the `to` address is not passed into this function, because address(this) receives the withrawn tokens.\\r\\n        (uint256 shortTokensWithdrawn, uint256 underlyingTokensWithdrawn) =\\r\\n            UniswapConnectorLib03.removeLiquidity(\\r\\n                router, // UniswapV2Router02\\r\\n                redeemToken, // tokenA\\r\\n                underlyingTokenAddress, // tokenB\\r\\n                liquidity,\\r\\n                amountAMin,\\r\\n                amountBMin,\\r\\n                deadline\\r\\n            );\\r\\n\\r\\n        // Burn option and redeem tokens from this contract then send underlyingTokens to the `to` address.\\r\\n        (, , uint256 underlyingTokensFromClosedOptions) =\\r\\n            UniswapConnectorLib03.closeOptionsWithShortTokens(\\r\\n                trader, // Primitive V1 Trader\\r\\n                IOption(optionAddress),\\r\\n                shortTokensWithdrawn,\\r\\n                to\\r\\n            );\\r\\n\\r\\n        // After the options were closed, calculate the dust by checking after balance against the before balance.\\r\\n        redeemBalance = IERC20(redeemToken).balanceOf(address(this)).sub(\\r\\n            redeemBalance\\r\\n        );\\r\\n\\r\\n        // If there is dust, send it out\\r\\n        if (redeemBalance > 0) {\\r\\n            IERC20(redeemToken).safeTransfer(to, redeemBalance);\\r\\n        }\\r\\n\\r\\n        // Send the UnderlyingTokens received from burning liquidity shares to the \\\"to\\\" address.\\r\\n        IERC20(underlyingTokenAddress).safeTransfer(\\r\\n            to,\\r\\n            underlyingTokensWithdrawn\\r\\n        );\\r\\n        return (\\r\\n            underlyingTokensWithdrawn.add(underlyingTokensFromClosedOptions),\\r\\n            redeemBalance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // ==== Callback Implementation ====\\r\\n\\r\\n    ///\\r\\n    /// @dev The callback function triggered in a UniswapV2Pair.swap() call when the `data` parameter has data.\\r\\n    /// @param sender The original msg.sender of the UniswapV2Pair.swap() call.\\r\\n    /// @param amount0 The quantity of token0 received to the `to` address in the swap() call.\\r\\n    /// @param amount1 The quantity of token1 received to the `to` address in the swap() call.\\r\\n    /// @param data The payload passed in the `data` parameter of the swap() call.\\r\\n    ///\\r\\n    function uniswapV2Call(\\r\\n        address sender,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        bytes calldata data\\r\\n    ) external override {\\r\\n        address token0 = IUniswapV2Pair(msg.sender).token0();\\r\\n        address token1 = IUniswapV2Pair(msg.sender).token1();\\r\\n        assert(msg.sender == factory.getPair(token0, token1)); /// ensure that msg.sender is actually a V2 pair\\r\\n        (bool success, bytes memory returnData) = address(this).call(data);\\r\\n        require(\\r\\n            success &&\\r\\n                (returnData.length == 0 || abi.decode(returnData, (bool))),\\r\\n            \\\"ERR_UNISWAPV2_CALL_FAIL\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // ==== Management Functions ====\\r\\n\\r\\n    /// @dev Creates a UniswapV2Pair by calling `createPair` on the UniswapV2Factory.\\r\\n    function deployUniswapMarket(address optionAddress, address otherToken)\\r\\n        external\\r\\n        override\\r\\n        returns (address)\\r\\n    {\\r\\n        address uniswapPair = factory.createPair(optionAddress, otherToken);\\r\\n        return uniswapPair;\\r\\n    }\\r\\n\\r\\n    // ==== View ====\\r\\n\\r\\n    /// @dev Gets a UniswapV2Pair address for two tokens by calling the UniswapV2Factory.\\r\\n    function getUniswapMarketForTokens(address token0, address token1)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (address)\\r\\n    {\\r\\n        address uniswapPair = factory.getPair(token0, token1);\\r\\n        require(uniswapPair != address(0x0), \\\"ERR_PAIR_DOES_NOT_EXIST\\\");\\r\\n        return uniswapPair;\\r\\n    }\\r\\n\\r\\n    /// @dev Gets the name of the contract.\\r\\n    function getName() external pure override returns (string memory) {\\r\\n        return \\\"PrimitiveV1UniswapConnector03\\\";\\r\\n    }\\r\\n\\r\\n    /// @dev Gets the version of the contract.\\r\\n    function getVersion() external pure override returns (uint8) {\\r\\n        return uint8(3);\\r\\n    }\\r\\n\\r\\n    /// @dev    Gets the total premium cost to buy `quantity` of `optionToken`s.\\r\\n    /// @notice Also returns the negative premium, which will be 0 in most cases.\\r\\n    /// @param  optionToken The option to get the close premium of.\\r\\n    /// @param  quantityLong The quantity of long option tokens that will be closed.\\r\\n    /// @return premiumCost, premiumPayout\\r\\n    function getOpenPremium(IOption optionToken, uint256 quantityLong)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        return\\r\\n            UniswapConnectorLib03.getOpenPremium(\\r\\n                router,\\r\\n                optionToken,\\r\\n                quantityLong\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev    Gets the total premium payout to sell long option tokens proportional to `quantity` of `shortOptionToken`s.\\r\\n    /// @notice Also gets the cost, a negative payout, which will be 0 unless the reserve ratio is incorrectly set.\\r\\n    /// @param  optionToken The option to get the close premium of.\\r\\n    /// @param  quantityShort The quantity of short option tokens that will be closed.\\r\\n    /// @return premiumPayout, premumCost\\r\\n    function getClosePremium(IOption optionToken, uint256 quantityShort)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        return\\r\\n            UniswapConnectorLib03.getClosePremium(\\r\\n                router,\\r\\n                optionToken,\\r\\n                quantityShort\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Callee {\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@primitivefi/contracts/contracts/option/libraries/TraderLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.2;\\r\\n\\r\\n/**\\r\\n * @title   Trader Library\\r\\n * @notice  Internal functions that can be used to safeTransfer\\r\\n *          tokens into the option contract then call respective option contract functions.\\r\\n * @author  Primitive\\r\\n */\\r\\n\\r\\nimport { IOption } from \\\"../interfaces/IOption.sol\\\";\\r\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\n\\r\\nlibrary TraderLib {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /**\\r\\n     * @dev Conducts important safety checks to safely mint option tokens.\\r\\n     * @param optionToken The address of the option token to mint.\\r\\n     * @param mintQuantity The quantity of option tokens to mint.\\r\\n     * @param receiver The address which receives the minted option tokens.\\r\\n     */\\r\\n    function safeMint(\\r\\n        IOption optionToken,\\r\\n        uint256 mintQuantity,\\r\\n        address receiver\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        require(mintQuantity > 0, \\\"ERR_ZERO\\\");\\r\\n        IERC20(optionToken.getUnderlyingTokenAddress()).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            mintQuantity\\r\\n        );\\r\\n        (uint256 outputOptions, uint256 outputRedeems) = optionToken\\r\\n            .mintOptions(receiver);\\r\\n        return (outputOptions, outputRedeems);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Swaps strikeTokens to underlyingTokens using the strike ratio as the exchange rate.\\r\\n     * @notice Burns optionTokens, option contract receives strikeTokens, user receives underlyingTokens.\\r\\n     * @param optionToken The address of the option contract.\\r\\n     * @param exerciseQuantity Quantity of optionTokens to exercise.\\r\\n     * @param receiver The underlyingTokens are sent to the receiver address.\\r\\n     */\\r\\n    function safeExercise(\\r\\n        IOption optionToken,\\r\\n        uint256 exerciseQuantity,\\r\\n        address receiver\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        require(exerciseQuantity > 0, \\\"ERR_ZERO\\\");\\r\\n        require(\\r\\n            IERC20(address(optionToken)).balanceOf(msg.sender) >=\\r\\n                exerciseQuantity,\\r\\n            \\\"ERR_BAL_OPTIONS\\\"\\r\\n        );\\r\\n\\r\\n        // Calculate quantity of strikeTokens needed to exercise quantity of optionTokens.\\r\\n        uint256 inputStrikes = exerciseQuantity\\r\\n            .mul(optionToken.getQuoteValue())\\r\\n            .div(optionToken.getBaseValue());\\r\\n        require(\\r\\n            IERC20(optionToken.getStrikeTokenAddress()).balanceOf(msg.sender) >=\\r\\n                inputStrikes,\\r\\n            \\\"ERR_BAL_STRIKE\\\"\\r\\n        );\\r\\n        IERC20(optionToken.getStrikeTokenAddress()).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputStrikes\\r\\n        );\\r\\n        IERC20(address(optionToken)).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            exerciseQuantity\\r\\n        );\\r\\n\\r\\n        uint256 inputOptions;\\r\\n        (inputStrikes, inputOptions) = optionToken.exerciseOptions(\\r\\n            receiver,\\r\\n            exerciseQuantity,\\r\\n            new bytes(0)\\r\\n        );\\r\\n        return (inputStrikes, inputOptions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burns redeemTokens to withdraw available strikeTokens.\\r\\n     * @notice inputRedeems = outputStrikes.\\r\\n     * @param optionToken The address of the option contract.\\r\\n     * @param redeemQuantity redeemQuantity of redeemTokens to burn.\\r\\n     * @param receiver The strikeTokens are sent to the receiver address.\\r\\n     */\\r\\n    function safeRedeem(\\r\\n        IOption optionToken,\\r\\n        uint256 redeemQuantity,\\r\\n        address receiver\\r\\n    ) internal returns (uint256) {\\r\\n        require(redeemQuantity > 0, \\\"ERR_ZERO\\\");\\r\\n        require(\\r\\n            IERC20(optionToken.redeemToken()).balanceOf(msg.sender) >=\\r\\n                redeemQuantity,\\r\\n            \\\"ERR_BAL_REDEEM\\\"\\r\\n        );\\r\\n        // There can be the case there is no available strikes to redeem, causing a revert.\\r\\n        IERC20(optionToken.redeemToken()).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            redeemQuantity\\r\\n        );\\r\\n        uint256 inputRedeems = optionToken.redeemStrikeTokens(receiver);\\r\\n        return inputRedeems;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burn optionTokens and redeemTokens to withdraw underlyingTokens.\\r\\n     * @notice The redeemTokens to burn is equal to the optionTokens * strike ratio.\\r\\n     * inputOptions = inputRedeems / strike ratio = outUnderlyings\\r\\n     * @param optionToken The address of the option contract.\\r\\n     * @param closeQuantity Quantity of optionTokens to burn.\\r\\n     * (Implictly will burn the strike ratio quantity of redeemTokens).\\r\\n     * @param receiver The underlyingTokens are sent to the receiver address.\\r\\n     */\\r\\n    function safeClose(\\r\\n        IOption optionToken,\\r\\n        uint256 closeQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        require(closeQuantity > 0, \\\"ERR_ZERO\\\");\\r\\n        require(\\r\\n            IERC20(address(optionToken)).balanceOf(msg.sender) >= closeQuantity,\\r\\n            \\\"ERR_BAL_OPTIONS\\\"\\r\\n        );\\r\\n\\r\\n        // Calculate the quantity of redeemTokens that need to be burned. (What we mean by Implicit).\\r\\n        uint256 inputRedeems = closeQuantity\\r\\n            .mul(optionToken.getQuoteValue())\\r\\n            .div(optionToken.getBaseValue());\\r\\n        require(\\r\\n            IERC20(optionToken.redeemToken()).balanceOf(msg.sender) >=\\r\\n                inputRedeems,\\r\\n            \\\"ERR_BAL_REDEEM\\\"\\r\\n        );\\r\\n        IERC20(optionToken.redeemToken()).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputRedeems\\r\\n        );\\r\\n        IERC20(address(optionToken)).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            closeQuantity\\r\\n        );\\r\\n\\r\\n        uint256 inputOptions;\\r\\n        uint256 outUnderlyings;\\r\\n        (inputRedeems, inputOptions, outUnderlyings) = optionToken.closeOptions(\\r\\n            receiver\\r\\n        );\\r\\n        return (inputRedeems, inputOptions, outUnderlyings);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burn redeemTokens to withdraw underlyingTokens and strikeTokens from expired options.\\r\\n     * @param optionToken The address of the option contract.\\r\\n     * @param unwindQuantity Quantity of option tokens used to calculate the amount of redeem tokens to burn.\\r\\n     * @param receiver The underlyingTokens are sent to the receiver address and the redeemTokens are burned.\\r\\n     */\\r\\n    function safeUnwind(\\r\\n        IOption optionToken,\\r\\n        uint256 unwindQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        // Checks\\r\\n        require(unwindQuantity > 0, \\\"ERR_ZERO\\\");\\r\\n        // solhint-disable-next-line not-rely-on-time\\r\\n        require(\\r\\n            optionToken.getExpiryTime() < block.timestamp,\\r\\n            \\\"ERR_NOT_EXPIRED\\\"\\r\\n        );\\r\\n\\r\\n        // Calculate amount of redeems required\\r\\n        uint256 inputRedeems = unwindQuantity\\r\\n            .mul(optionToken.getQuoteValue())\\r\\n            .div(optionToken.getBaseValue());\\r\\n        require(\\r\\n            IERC20(optionToken.redeemToken()).balanceOf(msg.sender) >=\\r\\n                inputRedeems,\\r\\n            \\\"ERR_BAL_REDEEM\\\"\\r\\n        );\\r\\n        IERC20(optionToken.redeemToken()).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputRedeems\\r\\n        );\\r\\n\\r\\n        uint256 inputOptions;\\r\\n        uint256 outUnderlyings;\\r\\n        (inputRedeems, inputOptions, outUnderlyings) = optionToken.closeOptions(\\r\\n            receiver\\r\\n        );\\r\\n\\r\\n        return (inputRedeems, inputOptions, outUnderlyings);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapConnectorLib03.sol\": {\r\n      \"content\": \"pragma solidity 0.6.2;\\r\\n\\r\\n///\\r\\n/// @title   Library for business logic for connecting Uniswap V2 Protocol functions with Primitive V1.\\r\\n/// @notice  Primitive V1 UniswapConnectorLib03 - @primitivefi/v1-connectors@v1.2.2\\r\\n/// @author  Primitive\\r\\n///\\r\\n\\r\\n// Uniswap\\r\\nimport {\\r\\n    IUniswapV2Callee\\r\\n} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol\\\";\\r\\nimport {\\r\\n    IUniswapV2Router02\\r\\n} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\nimport {\\r\\n    IUniswapV2Factory\\r\\n} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\r\\nimport {\\r\\n    IUniswapV2Pair\\r\\n} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\r\\n// Primitive\\r\\nimport {\\r\\n    ITrader,\\r\\n    IOption\\r\\n} from \\\"@primitivefi/contracts/contracts/option/interfaces/ITrader.sol\\\";\\r\\nimport {\\r\\n    TraderLib,\\r\\n    IERC20\\r\\n} from \\\"@primitivefi/contracts/contracts/option/libraries/TraderLib.sol\\\";\\r\\nimport {IWethConnector01, IWETH} from \\\"../interfaces/IWethConnector01.sol\\\";\\r\\nimport {WethConnectorLib01} from \\\"./WethConnectorLib01.sol\\\";\\r\\n// Open Zeppelin\\r\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\n\\r\\nlibrary UniswapConnectorLib03 {\\r\\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\\r\\n    using SafeMath for uint256; // Reverts on math underflows/overflows\\r\\n\\r\\n    /// ==== Combo Operations ====\\r\\n\\r\\n    ///\\r\\n    /// @dev    Mints long + short option tokens, then swaps the shortOptionTokens (redeem) for tokens.\\r\\n    /// @notice If the first address in the path is not the shortOptionToken address, the tx will fail.\\r\\n    ///         underlyingToken -> shortOptionToken -> quoteToken.\\r\\n    ///         IMPORTANT: redeemTokens = shortOptionTokens\\r\\n    /// @param optionToken The address of the Option contract.\\r\\n    /// @param amountIn The quantity of options to mint.\\r\\n    /// @param amountOutMin The minimum quantity of tokens to receive in exchange for the shortOptionTokens.\\r\\n    /// @param path The token addresses to trade through using their Uniswap V2 pools. Assumes path[0] = shortOptionToken.\\r\\n    /// @param to The address to send the shortOptionToken proceeds and longOptionTokens to.\\r\\n    /// @param deadline The timestamp for a trade to fail at if not successful.\\r\\n    /// @return bool Whether the transaction was successful or not.\\r\\n    ///\\r\\n    function mintShortOptionsThenSwapToTokens(\\r\\n        IUniswapV2Router02 router,\\r\\n        IOption optionToken,\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] memory path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) internal returns (bool) {\\r\\n        // Pulls underlyingTokens from msg.sender, then pushes underlyingTokens to option contract.\\r\\n        // Mints long + short tokens to this contract.\\r\\n        (uint256 outputOptions, uint256 outputRedeems) =\\r\\n            mintOptionsKeepShortOptions(optionToken, amountIn);\\r\\n\\r\\n        // Swaps shortOptionTokens to the token specified at the end of the path, then sends to msg.sender.\\r\\n        // Reverts if the first address in the path is not the shortOptionToken address.\\r\\n        address redeemToken = optionToken.redeemToken();\\r\\n        (, bool success) =\\r\\n            swapExactOptionsForTokens(\\r\\n                router,\\r\\n                redeemToken,\\r\\n                outputRedeems, // shortOptionTokens = redeemTokens\\r\\n                amountOutMin,\\r\\n                path,\\r\\n                to,\\r\\n                deadline\\r\\n            );\\r\\n        // Fail early if the swap failed.\\r\\n        require(success, \\\"ERR_SWAP_FAILED\\\");\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    // ==== Flash Functions ====\\r\\n\\r\\n    ///\\r\\n    /// @dev    Receives underlyingTokens from a UniswapV2Pair.swap() call from a pair with\\r\\n    ///         shortOptionTokens and underlyingTokens.\\r\\n    ///         Uses underlyingTokens to mint long (option) + short (redeem) tokens.\\r\\n    ///         Sends longOptionTokens to msg.sender, and pays back the UniswapV2Pair with shortOptionTokens,\\r\\n    ///         AND any remainder quantity of underlyingTokens (paid by msg.sender).\\r\\n    /// @notice If the first address in the path is not the shortOptionToken address, the tx will fail.\\r\\n    ///         IMPORTANT: UniswapV2 adds a fee of 0.301% to the option premium cost.\\r\\n    /// @param router The address of the UniswapV2Router02 contract.\\r\\n    /// @param pairAddress The address of the redeemToken<>underlyingToken UniswapV2Pair contract.\\r\\n    /// @param optionAddress The address of the Option contract.\\r\\n    /// @param flashLoanQuantity The quantity of options to mint using borrowed underlyingTokens.\\r\\n    /// @param maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\\r\\n    /// @param path The token addresses to trade through using their Uniswap V2 pools. Assumes path[0] = shortOptionToken.\\r\\n    /// @param to The address to send the shortOptionToken proceeds and longOptionTokens to.\\r\\n    /// @return success bool Whether the transaction was successful or not.\\r\\n    ///\\r\\n    function flashMintShortOptionsThenSwap(\\r\\n        IUniswapV2Router02 router,\\r\\n        address pairAddress,\\r\\n        address optionAddress,\\r\\n        uint256 flashLoanQuantity,\\r\\n        uint256 maxPremium,\\r\\n        address[] memory path,\\r\\n        address to\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        require(msg.sender == address(this), \\\"ERR_NOT_SELF\\\");\\r\\n        require(to != address(0x0), \\\"ERR_TO_ADDRESS_ZERO\\\");\\r\\n        require(to != msg.sender, \\\"ERR_TO_MSG_SENDER\\\");\\r\\n        require(\\r\\n            pairFor(router.factory(), path[0], path[1]) == pairAddress,\\r\\n            \\\"ERR_INVALID_PAIR\\\"\\r\\n        );\\r\\n        // IMPORTANT: Assume this contract has already received `flashLoanQuantity` of underlyingTokens.\\r\\n        address underlyingToken =\\r\\n            IOption(optionAddress).getUnderlyingTokenAddress();\\r\\n        address redeemToken = IOption(optionAddress).redeemToken();\\r\\n        require(path[1] == underlyingToken, \\\"ERR_END_PATH_NOT_UNDERLYING\\\");\\r\\n\\r\\n        // Mint longOptionTokens using the underlyingTokens received from UniswapV2 flash swap to this contract.\\r\\n        // Send underlyingTokens from this contract to the optionToken contract, then call mintOptions.\\r\\n        (uint256 mintedOptions, uint256 mintedRedeems) =\\r\\n            mintOptionsWithUnderlyingBalance(\\r\\n                IOption(optionAddress),\\r\\n                flashLoanQuantity\\r\\n            );\\r\\n\\r\\n        // The loanRemainder will be the amount of underlyingTokens that are needed from the original\\r\\n        // transaction caller in order to pay the flash swap.\\r\\n        // IMPORTANT: THIS IS EFFECTIVELY THE PREMIUM PAID IN UNDERLYINGTOKENS TO PURCHASE THE OPTIONTOKEN.\\r\\n        uint256 loanRemainder;\\r\\n\\r\\n        // Economically, negativePremiumPaymentInRedeems value should always be 0.\\r\\n        // In the case that we minted more redeemTokens than are needed to pay back the flash swap,\\r\\n        // (short -> underlying is a positive trade), there is an effective negative premium.\\r\\n        // In that case, this function will send out `negativePremiumAmount` of redeemTokens to the original caller.\\r\\n        // This means the user gets to keep the extra redeemTokens for free.\\r\\n        // Negative premium amount is the opposite difference of the loan remainder: (paid - flash loan amount)\\r\\n        uint256 negativePremiumPaymentInRedeems;\\r\\n        (loanRemainder, negativePremiumPaymentInRedeems) = getOpenPremium(\\r\\n            router,\\r\\n            IOption(optionAddress),\\r\\n            flashLoanQuantity\\r\\n        );\\r\\n\\r\\n        // In the case that more redeemTokens were minted than need to be sent back as payment,\\r\\n        // calculate the new mintedRedeems value to send to the pair\\r\\n        // (don't send all the minted redeemTokens).\\r\\n        if (negativePremiumPaymentInRedeems > 0) {\\r\\n            mintedRedeems = mintedRedeems.sub(negativePremiumPaymentInRedeems);\\r\\n        }\\r\\n\\r\\n        // In most cases, all of the minted redeemTokens will be sent to the pair as payment for the flash swap.\\r\\n        if (mintedRedeems > 0) {\\r\\n            IERC20(redeemToken).safeTransfer(pairAddress, mintedRedeems);\\r\\n        }\\r\\n\\r\\n        // If loanRemainder is non-zero and non-negative (most cases), send underlyingTokens to the pair as payment (premium).\\r\\n        if (loanRemainder > 0) {\\r\\n            // Pull underlyingTokens from the original msg.sender to pay the remainder of the flash swap.\\r\\n            require(maxPremium >= loanRemainder, \\\"ERR_PREMIUM_OVER_MAX\\\"); // check for users to not pay over their max desired value.\\r\\n            IERC20(underlyingToken).safeTransferFrom(\\r\\n                to,\\r\\n                pairAddress,\\r\\n                loanRemainder\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // If negativePremiumAmount is non-zero and non-negative, send redeemTokens to the `to` address.\\r\\n        if (negativePremiumPaymentInRedeems > 0) {\\r\\n            IERC20(redeemToken).safeTransfer(\\r\\n                to,\\r\\n                negativePremiumPaymentInRedeems\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Send minted longOptionTokens (option) to the original msg.sender.\\r\\n        IERC20(optionAddress).safeTransfer(to, mintedOptions);\\r\\n        return (mintedOptions, loanRemainder);\\r\\n    }\\r\\n\\r\\n    /// @dev    Sends shortOptionTokens to msg.sender, and pays back the UniswapV2Pair in underlyingTokens.\\r\\n    /// @notice IMPORTANT: If minPayout is 0, the `to` address is liable for negative payouts *if* that occurs.\\r\\n    /// @param router The UniswapV2Router02 contract.\\r\\n    /// @param pairAddress The address of the redeemToken<>underlyingToken UniswapV2Pair contract.\\r\\n    /// @param optionAddress The address of the longOptionTokes to close.\\r\\n    /// @param flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\\r\\n    /// @param minPayout The minimum payout of underlyingTokens sent to the `to` address.\\r\\n    /// @param path underlyingTokens -> shortOptionTokens, because we are paying the input of underlyingTokens.\\r\\n    /// @param to The address which is sent the underlyingToken payout, or liable to pay for a negative payout.\\r\\n    function flashCloseLongOptionsThenSwap(\\r\\n        IUniswapV2Router02 router,\\r\\n        address pairAddress,\\r\\n        address optionAddress,\\r\\n        uint256 flashLoanQuantity,\\r\\n        uint256 minPayout,\\r\\n        address[] memory path,\\r\\n        address to\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        require(msg.sender == address(this), \\\"ERR_NOT_SELF\\\");\\r\\n        require(to != address(0x0), \\\"ERR_TO_ADDRESS_ZERO\\\");\\r\\n        require(to != msg.sender, \\\"ERR_TO_MSG_SENDER\\\");\\r\\n        require(\\r\\n            pairFor(router.factory(), path[0], path[1]) == pairAddress,\\r\\n            \\\"ERR_INVALID_PAIR\\\"\\r\\n        );\\r\\n\\r\\n        // IMPORTANT: Assume this contract has already received `flashLoanQuantity` of redeemTokens.\\r\\n        // We are flash swapping from an underlying <> shortOptionToken pair,\\r\\n        // paying back a portion using underlyingTokens received from closing options.\\r\\n        // In the flash open, we did redeemTokens to underlyingTokens.\\r\\n        // In the flash close, we are doing underlyingTokens to redeemTokens and keeping the remainder.\\r\\n        address underlyingToken =\\r\\n            IOption(optionAddress).getUnderlyingTokenAddress();\\r\\n        address redeemToken = IOption(optionAddress).redeemToken();\\r\\n        require(path[1] == redeemToken, \\\"ERR_END_PATH_NOT_REDEEM\\\");\\r\\n\\r\\n        // Quantity of underlyingTokens this contract receives from burning option + redeem tokens.\\r\\n        uint256 outputUnderlyings =\\r\\n            closeOptionsWithShortBalance(\\r\\n                to,\\r\\n                IOption(optionAddress),\\r\\n                flashLoanQuantity\\r\\n            );\\r\\n\\r\\n        // Loan Remainder is the cost to pay out, should be 0 in most cases.\\r\\n        // Underlying Payout is the `premium` that the original caller receives in underlyingTokens.\\r\\n        // It's the remainder of underlyingTokens after the pair has been paid back underlyingTokens for the\\r\\n        // flash swapped shortOptionTokens.\\r\\n        (uint256 underlyingPayout, uint256 loanRemainder) =\\r\\n            getClosePremium(router, IOption(optionAddress), flashLoanQuantity);\\r\\n\\r\\n        // In most cases there will be an underlying payout, which is subtracted from the outputUnderlyings.\\r\\n        if (underlyingPayout > 0) {\\r\\n            outputUnderlyings = outputUnderlyings.sub(underlyingPayout);\\r\\n        }\\r\\n\\r\\n        // Pay back the pair in underlyingTokens.\\r\\n        if (outputUnderlyings > 0) {\\r\\n            IERC20(underlyingToken).safeTransfer(\\r\\n                pairAddress,\\r\\n                outputUnderlyings\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // If loanRemainder is non-zero and non-negative, send underlyingTokens to the pair as payment (premium).\\r\\n        if (loanRemainder > 0) {\\r\\n            // Pull underlyingTokens from the original msg.sender to pay the remainder of the flash swap.\\r\\n            // Revert if the minPayout is less than or equal to the underlyingPayment of 0.\\r\\n            // There is 0 underlyingPayment in the case that loanRemainder > 0.\\r\\n            // This code branch can be successful by setting `minPayout` to 0.\\r\\n            // This means the user is willing to pay to close the position.\\r\\n            require(minPayout <= underlyingPayout, \\\"ERR_NEGATIVE_PAYOUT\\\");\\r\\n            IERC20(underlyingToken).safeTransferFrom(\\r\\n                to,\\r\\n                pairAddress,\\r\\n                loanRemainder\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // If underlyingPayout is non-zero and non-negative, send it to the `to` address.\\r\\n        if (underlyingPayout > 0) {\\r\\n            // Revert if minPayout is greater than the actual payout.\\r\\n            require(underlyingPayout >= minPayout, \\\"ERR_PREMIUM_UNDER_MIN\\\");\\r\\n            IERC20(underlyingToken).safeTransfer(to, underlyingPayout);\\r\\n        }\\r\\n\\r\\n        return (outputUnderlyings, underlyingPayout);\\r\\n    }\\r\\n\\r\\n    // ==== Liquidity Functions ====\\r\\n\\r\\n    ///\\r\\n    /// @dev    Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting shortOptionTokens with underlyingTokens.\\r\\n    /// @notice Pulls underlying tokens from msg.sender and pushes UNI-V2 liquidity tokens to the \\\"to\\\" address.\\r\\n    ///         underlyingToken -> redeemToken -> UNI-V2.\\r\\n    /// @param optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\\r\\n    /// @param quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\\r\\n    /// @param amountBMax The quantity of underlyingTokens to add with shortOptionTokens to the Uniswap V2 Pair.\\r\\n    /// @param amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\\r\\n    /// @param to The address that receives UNI-V2 shares.\\r\\n    /// @param deadline The timestamp to expire a pending transaction.\\r\\n    ///\\r\\n    function addShortLiquidityWithUnderlying(\\r\\n        IUniswapV2Router02 router,\\r\\n        address optionAddress,\\r\\n        uint256 quantityOptions,\\r\\n        uint256 amountBMax,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        uint256 amountA;\\r\\n        uint256 amountB;\\r\\n        uint256 liquidity;\\r\\n        (, uint256 outputRedeems) =\\r\\n            mintOptionsKeepShortOptions(\\r\\n                IOption(optionAddress),\\r\\n                quantityOptions\\r\\n            );\\r\\n\\r\\n        {\\r\\n            // scope for adding exact liquidity, avoids stack too deep errors\\r\\n            IOption optionToken = IOption(optionAddress);\\r\\n            IUniswapV2Router02 router_ = router;\\r\\n            address underlyingToken = optionToken.getUnderlyingTokenAddress();\\r\\n            uint256 outputRedeems_ = outputRedeems;\\r\\n            uint256 amountBMax_ = amountBMax;\\r\\n            uint256 amountBMin_ = amountBMin;\\r\\n            address to_ = to;\\r\\n            uint256 deadline_ = deadline;\\r\\n\\r\\n            // Adds liquidity to Uniswap V2 Pair and returns liquidity shares to the \\\"to\\\" address.\\r\\n            (amountA, amountB, liquidity) = addExactShortLiquidity(\\r\\n                router_,\\r\\n                optionToken.redeemToken(),\\r\\n                underlyingToken,\\r\\n                outputRedeems_,\\r\\n                amountBMax_,\\r\\n                amountBMin_,\\r\\n                to_,\\r\\n                deadline_\\r\\n            );\\r\\n            // check for exact liquidity provided\\r\\n            assert(amountA == outputRedeems);\\r\\n\\r\\n            uint256 remainder =\\r\\n                amountBMax_ > amountB ? amountBMax_.sub(amountB) : 0;\\r\\n            if (remainder > 0) {\\r\\n                IERC20(underlyingToken).safeTransfer(msg.sender, remainder);\\r\\n            }\\r\\n        }\\r\\n        return (amountA, amountB, liquidity);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev    Calls the \\\"swapExactTokensForTokens\\\" function on the Uniswap V2 Router 02 Contract.\\r\\n    /// @notice Fails early if the address in the beginning of the path is not the token address.\\r\\n    /// @param tokenAddress The address of the token to swap from.\\r\\n    /// @param amountIn The quantity of longOptionTokens to swap with.\\r\\n    /// @param amountOutMin The minimum quantity of tokens to receive in exchange for the tokens swapped.\\r\\n    /// @param path The token addresses to trade through using their Uniswap V2 pairs.\\r\\n    /// @param to The address to send the token proceeds to.\\r\\n    /// @param deadline The timestamp for a trade to fail at if not successful.\\r\\n    ///\\r\\n    function swapExactOptionsForTokens(\\r\\n        IUniswapV2Router02 router,\\r\\n        address tokenAddress,\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] memory path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) internal returns (uint256[] memory amounts, bool success) {\\r\\n        // Fails early if the token being swapped from is not the optionToken.\\r\\n        require(path[0] == tokenAddress, \\\"ERR_PATH_OPTION_START\\\");\\r\\n\\r\\n        // Approve the uniswap router to be able to transfer longOptionTokens from this contract.\\r\\n        IERC20(tokenAddress).approve(address(router), uint256(-1));\\r\\n        // Call the Uniswap V2 function to swap longOptionTokens to quoteTokens.\\r\\n        (amounts) = router.swapExactTokensForTokens(\\r\\n            amountIn,\\r\\n            amountOutMin,\\r\\n            path,\\r\\n            to,\\r\\n            deadline\\r\\n        );\\r\\n        success = true;\\r\\n    }\\r\\n\\r\\n    /// @dev Calls UniswapV2Router02 function addLiquidity, provides exact amount of `tokenA`.\\r\\n    /// @notice Assumes this contract has a current balance of `tokenA`, pulls required underlyingTokens from `msg.sender`.\\r\\n    function addExactShortLiquidity(\\r\\n        IUniswapV2Router02 router,\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        // Pull `tokenB` from msg.sender to add to Uniswap V2 Pair.\\r\\n        // Warning: calls into msg.sender using `safeTransferFrom`. Msg.sender is not trusted.\\r\\n        IERC20(tokenB).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amountBDesired\\r\\n        );\\r\\n        // Approves Uniswap V2 Pair pull tokens from this contract.\\r\\n        IERC20(tokenA).approve(address(router), uint256(-1));\\r\\n        IERC20(tokenB).approve(address(router), uint256(-1));\\r\\n\\r\\n        // Adds liquidity to Uniswap V2 Pair and returns liquidity shares to the \\\"to\\\" address.\\r\\n        return\\r\\n            router.addLiquidity(\\r\\n                tokenA,\\r\\n                tokenB,\\r\\n                amountADesired,\\r\\n                amountBDesired,\\r\\n                amountADesired, // notice how amountAMin === amountADesired\\r\\n                amountBMin,\\r\\n                to,\\r\\n                deadline\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev    Mints long + short option tokens by pulling underlyingTokens from `msg.sender`.\\r\\n    /// @notice Pushes minted longOptionTokens to `msg.sender`. Keeps shortOptionTokens in this contract.\\r\\n    ///         IMPORTANT: Must be used in conjuction with a function that uses the shortOptionTokens blanace.\\r\\n    /// @param optionToken The option token to mint.\\r\\n    /// @param quantity The amount of longOptionTokens to mint.\\r\\n    function mintOptionsKeepShortOptions(IOption optionToken, uint256 quantity)\\r\\n        internal\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        // Pulls underlyingTokens from msg.sender to this contract.\\r\\n        // Pushes underlyingTokens to option contract and mints option + redeem tokens to this contract.\\r\\n        // Warning: calls into msg.sender using `safeTransferFrom`. Msg.sender is not trusted.\\r\\n        (uint256 outputOptions, uint256 outputRedeems) =\\r\\n            TraderLib.safeMint(optionToken, quantity, address(this));\\r\\n        // Send longOptionTokens from minting option operation to msg.sender.\\r\\n        IERC20(address(optionToken)).safeTransfer(msg.sender, quantity);\\r\\n        return (outputOptions, outputRedeems);\\r\\n    }\\r\\n\\r\\n    /// @dev    Mints long + short option tokens using this contract's underlyingToken balance.\\r\\n    /// @notice Keeps minted tokens in this contract.\\r\\n    /// @param optionToken The option token to mint.\\r\\n    /// @param quantity The amount of longOptionTokens to mint.\\r\\n    function mintOptionsWithUnderlyingBalance(\\r\\n        IOption optionToken,\\r\\n        uint256 quantity\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        address underlyingToken = optionToken.getUnderlyingTokenAddress();\\r\\n        // Mint longOptionTokens using the underlyingTokens received from UniswapV2 flash swap to this contract.\\r\\n        // Send underlyingTokens from this contract to the optionToken contract, then call mintOptions.\\r\\n        IERC20(underlyingToken).safeTransfer(address(optionToken), quantity);\\r\\n        return optionToken.mintOptions(address(this));\\r\\n    }\\r\\n\\r\\n    /// @dev    Closes options using this contract's balance of shortOptionTokens (redeem), and pulls optionTokens from `from`.\\r\\n    /// @notice IMPORTANT: pulls optionTokens from `from`, an untrusted address.\\r\\n    /// @param from The address to pull optionTokens from which will be burned to release underlyingTokens.\\r\\n    /// @param optionToken The options that will be closed.\\r\\n    /// @param quantity The quantity of optionTokens to burn.\\r\\n    /// @return The quantity of underlyingTokens released.\\r\\n    function closeOptionsWithShortBalance(\\r\\n        address from,\\r\\n        IOption optionToken,\\r\\n        uint256 quantity\\r\\n    ) internal returns (uint256) {\\r\\n        // Close longOptionTokens using the redeemToken balance of this contract.\\r\\n        IERC20(optionToken.redeemToken()).safeTransfer(\\r\\n            address(optionToken),\\r\\n            quantity\\r\\n        );\\r\\n        uint256 requiredLongOptions =\\r\\n            getProportionalLongOptions(optionToken, quantity);\\r\\n\\r\\n        // Send out the required amount of options from the `from` address.\\r\\n        // WARNING: CALLS TO UNTRUSTED ADDRESS.\\r\\n        IERC20(address(optionToken)).safeTransferFrom(\\r\\n            from,\\r\\n            address(optionToken),\\r\\n            requiredLongOptions\\r\\n        );\\r\\n\\r\\n        // Close the options.\\r\\n        (, , uint256 outputUnderlyings) =\\r\\n            optionToken.closeOptions(address(this));\\r\\n        return outputUnderlyings;\\r\\n    }\\r\\n\\r\\n    /// @dev    Removes liquidity from a uniswap pair, using this contract's balance of LP tokens.\\r\\n    ///         Withdrawn tokens are sent to this contract.\\r\\n    /// @notice `tokenA` is the redeemToken and `tokenB` is the underlyingToken.\\r\\n    function removeLiquidity(\\r\\n        IUniswapV2Router02 router,\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        uint256 deadline\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        // Gets the Uniswap V2 Pair address for shortOptionToken (redeem) and underlyingTokens.\\r\\n        // Transfers the LP tokens of the pair to this contract.\\r\\n        address pair =\\r\\n            IUniswapV2Factory(router.factory()).getPair(tokenA, tokenB);\\r\\n        // Warning: internal call to a non-trusted address `msg.sender`.\\r\\n        IERC20(pair).safeTransferFrom(msg.sender, address(this), liquidity);\\r\\n        IERC20(pair).approve(address(router), uint256(-1));\\r\\n\\r\\n        // Remove liquidity from Uniswap V2 pool to receive the reserve tokens (shortOptionTokens + UnderlyingTokens).\\r\\n        (uint256 amountShortOptions, uint256 amountUnderlyingTokens) =\\r\\n            router.removeLiquidity(\\r\\n                tokenA,\\r\\n                tokenB,\\r\\n                liquidity,\\r\\n                amountAMin,\\r\\n                amountBMin,\\r\\n                address(this),\\r\\n                deadline\\r\\n            );\\r\\n        return (amountShortOptions, amountUnderlyingTokens);\\r\\n    }\\r\\n\\r\\n    /// @dev    Closes option tokens by buring option and redeem tokens.\\r\\n    /// @notice Pulls option tokens from `msg.sender`, uses this contract's balance of redeemTokens.\\r\\n    /// @param trader The Primitive V1 trader contract to handle the option closing operation.\\r\\n    /// @param optionToken The option to close.\\r\\n    /// @param amountShortOptions The quantity of short option tokens that will be burned to close the options.\\r\\n    /// @param receiver The address that will be sent the underlyingTokens from closed options.\\r\\n    function closeOptionsWithShortTokens(\\r\\n        ITrader trader,\\r\\n        IOption optionToken,\\r\\n        uint256 amountShortOptions,\\r\\n        address receiver\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        // Approves trader to pull longOptionTokens and shortOptionTokens from this contract to close options.\\r\\n        IERC20(address(optionToken)).approve(address(trader), uint256(-1));\\r\\n        IERC20(optionToken.redeemToken()).approve(address(trader), uint256(-1));\\r\\n        // Calculate equivalent quantity of redeem (short option) tokens to close the long option position.\\r\\n        // longOptions = shortOptions / strikeRatio\\r\\n        uint256 requiredLongOptions =\\r\\n            getProportionalLongOptions(optionToken, amountShortOptions);\\r\\n\\r\\n        // Pull the required longOptionTokens from `msg.sender` to this contract.\\r\\n        IERC20(address(optionToken)).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            requiredLongOptions\\r\\n        );\\r\\n\\r\\n        // Trader pulls option and redeem tokens from this contract and sends them to the option contract.\\r\\n        // Option and redeem tokens are then burned to release underlyingTokens.\\r\\n        // UnderlyingTokens are sent to the \\\"receiver\\\" address.\\r\\n        return trader.safeClose(optionToken, requiredLongOptions, receiver);\\r\\n    }\\r\\n\\r\\n    // ====== View ======\\r\\n\\r\\n    /// @dev    Calculates the effective premium, denominated in underlyingTokens, to \\\"buy\\\" `quantity` of optionTokens.\\r\\n    /// @notice UniswapV2 adds a 0.3009027% fee which is applied to the premium as 0.301%.\\r\\n    ///         IMPORTANT: If the pair's reserve ratio is incorrect, there could be a 'negative' premium.\\r\\n    ///         Buying negative premium options will pay out redeemTokens.\\r\\n    ///         An 'incorrect' ratio occurs when the (reserves of redeemTokens / strike ratio) >= reserves of underlyingTokens.\\r\\n    ///         Implicitly uses the `optionToken`'s underlying and redeem tokens for the pair.\\r\\n    /// @param  router The UniswapV2Router02 contract.\\r\\n    /// @param  optionToken The optionToken to get the premium cost of purchasing.\\r\\n    /// @param  quantity The quantity of long option tokens that will be purchased.\\r\\n    function getOpenPremium(\\r\\n        IUniswapV2Router02 router,\\r\\n        IOption optionToken,\\r\\n        uint256 quantity\\r\\n    ) internal view returns (uint256, uint256) {\\r\\n        // longOptionTokens are opened by doing a swap from redeemTokens to underlyingTokens effectively.\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = optionToken.redeemToken();\\r\\n        path[1] = optionToken.getUnderlyingTokenAddress();\\r\\n\\r\\n        // `quantity` of underlyingTokens are output from the swap.\\r\\n        // They are used to mint options, which will mint `quantity` * quoteValue / baseValue amount of redeemTokens.\\r\\n        uint256 redeemsMinted =\\r\\n            getProportionalShortOptions(optionToken, quantity);\\r\\n\\r\\n        // The loanRemainderInUnderlyings will be the amount of underlyingTokens that are needed from the original\\r\\n        // transaction caller in order to pay the flash swap.\\r\\n        // IMPORTANT: THIS IS EFFECTIVELY THE PREMIUM PAID IN UNDERLYINGTOKENS TO PURCHASE THE OPTIONTOKEN.\\r\\n        uint256 loanRemainderInUnderlyings;\\r\\n\\r\\n        // Economically, negativePremiumPaymentInRedeems value should always be 0.\\r\\n        // In the case that we minted more redeemTokens than are needed to pay back the flash swap,\\r\\n        // (short -> underlying is a positive trade), there is an effective negative premium.\\r\\n        // In that case, this function will send out `negativePremiumAmount` of redeemTokens to the original caller.\\r\\n        // This means the user gets to keep the extra redeemTokens for free.\\r\\n        // Negative premium amount is the opposite difference of the loan remainder: (paid - flash loan amount)\\r\\n        uint256 negativePremiumPaymentInRedeems;\\r\\n\\r\\n        // Need to return tokens from the flash swap by returning shortOptionTokens and any remainder of underlyingTokens.\\r\\n\\r\\n        // Since the borrowed amount is underlyingTokens, and we are paying back in redeemTokens,\\r\\n        // we need to see how much redeemTokens must be returned for the borrowed amount.\\r\\n        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\\r\\n        // of redeemTokens are needed for the output amount of the flash loan.\\r\\n        // IMPORTANT: amountsIn[0] is how many short tokens we need to pay back.\\r\\n        // This value is most likely greater than the amount of redeemTokens minted.\\r\\n        uint256[] memory amountsIn = router.getAmountsIn(quantity, path);\\r\\n\\r\\n        uint256 redeemsRequired = amountsIn[0]; // the amountIn of redeemTokens based on the amountOut of `quantity`.\\r\\n        // If redeemsMinted is greater than redeems required, there is a cost of 0, implying a negative premium.\\r\\n        uint256 redeemCostRemaining =\\r\\n            redeemsRequired > redeemsMinted\\r\\n                ? redeemsRequired.sub(redeemsMinted)\\r\\n                : 0;\\r\\n        // If there is a negative premium, calculate the quantity of remaining redeemTokens after the `redeemsMinted` is spent.\\r\\n        negativePremiumPaymentInRedeems = redeemsMinted > redeemsRequired\\r\\n            ? redeemsMinted.sub(redeemsRequired)\\r\\n            : 0;\\r\\n\\r\\n        // In most cases, there will be an outstanding cost (assuming we minted less redeemTokens than the\\r\\n        // required amountIn of redeemTokens for the swap).\\r\\n        if (redeemCostRemaining > 0) {\\r\\n            // The user won't want to pay back the remaining cost in redeemTokens,\\r\\n            // because they borrowed underlyingTokens to mint them in the first place.\\r\\n            // So instead, we get the quantity of underlyingTokens that could be paid instead.\\r\\n            // We can calculate this using normal swap math.\\r\\n            // getAmountsOut will return the quantity of underlyingTokens that are output,\\r\\n            // based on some input of redeemTokens.\\r\\n            // The input redeemTokens is the remaining redeemToken cost, and the output\\r\\n            // underlyingTokens is the proportional amount of underlyingTokens.\\r\\n            // amountsOut[1] is then the outstanding flash loan value denominated in underlyingTokens.\\r\\n            uint256[] memory amountsOut =\\r\\n                router.getAmountsOut(redeemCostRemaining, path);\\r\\n\\r\\n            // Returning withdrawn tokens to the pair has a fee of .003 / .997 = 0.3009027% which must be applied.\\r\\n            loanRemainderInUnderlyings = (\\r\\n                amountsOut[1].mul(100000).add(amountsOut[1].mul(301))\\r\\n            )\\r\\n                .div(100000);\\r\\n        }\\r\\n        return (loanRemainderInUnderlyings, negativePremiumPaymentInRedeems);\\r\\n    }\\r\\n\\r\\n    /// @dev    Calculates the effective premium, denominated in underlyingTokens, to \\\"sell\\\" option tokens.\\r\\n    /// @param  router The UniswapV2Router02 contract.\\r\\n    /// @param  optionToken The optionToken to get the premium cost of purchasing.\\r\\n    /// @param  quantity The quantity of short option tokens that will be closed.\\r\\n    function getClosePremium(\\r\\n        IUniswapV2Router02 router,\\r\\n        IOption optionToken,\\r\\n        uint256 quantity\\r\\n    ) internal view returns (uint256, uint256) {\\r\\n        // longOptionTokens are closed by doing a swap from underlyingTokens to redeemTokens.\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = optionToken.getUnderlyingTokenAddress();\\r\\n        path[1] = optionToken.redeemToken();\\r\\n        uint256 outputUnderlyings =\\r\\n            getProportionalLongOptions(optionToken, quantity);\\r\\n        // The loanRemainder will be the amount of underlyingTokens that are needed from the original\\r\\n        // transaction caller in order to pay the flash swap.\\r\\n        uint256 loanRemainder;\\r\\n\\r\\n        // Economically, underlyingPayout value should always be greater than 0, or this trade shouldn't be made.\\r\\n        // If an underlyingPayout is greater than 0, it means that the redeemTokens borrowed are worth less than the\\r\\n        // underlyingTokens received from closing the redeemToken<>optionTokens.\\r\\n        // If the redeemTokens are worth more than the underlyingTokens they are entitled to,\\r\\n        // then closing the redeemTokens will cost additional underlyingTokens. In this case,\\r\\n        // the transaction should be reverted. Or else, the user is paying extra at the expense of\\r\\n        // rebalancing the pool.\\r\\n        uint256 underlyingPayout;\\r\\n\\r\\n        // Need to return tokens from the flash swap by returning underlyingTokens.\\r\\n\\r\\n        // Since the borrowed amount is redeemTokens, and we are paying back in underlyingTokens,\\r\\n        // we need to see how much underlyingTokens must be returned for the borrowed amount.\\r\\n        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\\r\\n        // of underlyingTokens are needed for the output amount of the flash loan.\\r\\n        // IMPORTANT: amountsIn 0 is how many underlyingTokens we need to pay back.\\r\\n        // This value is most likely greater than the amount of underlyingTokens received from closing.\\r\\n        uint256[] memory amountsIn = router.getAmountsIn(quantity, path);\\r\\n\\r\\n        uint256 underlyingsRequired = amountsIn[0]; // the amountIn required of underlyingTokens based on the amountOut of flashloanQuantity\\r\\n        // If outputUnderlyings (received from closing) is greater than underlyings required,\\r\\n        // there is a positive payout.\\r\\n        underlyingPayout = outputUnderlyings > underlyingsRequired\\r\\n            ? outputUnderlyings.sub(underlyingsRequired)\\r\\n            : 0;\\r\\n\\r\\n        // If there is a negative payout, calculate the remaining cost of underlyingTokens.\\r\\n        uint256 underlyingCostRemaining =\\r\\n            underlyingsRequired > outputUnderlyings\\r\\n                ? underlyingsRequired.sub(outputUnderlyings)\\r\\n                : 0;\\r\\n\\r\\n        // In the case that there is a negative payout (additional underlyingTokens are required),\\r\\n        // get the remaining cost into the `loanRemainder` variable and also check to see\\r\\n        // if a user is willing to pay the negative cost. There is no rational economic incentive for this.\\r\\n        if (underlyingCostRemaining > 0) {\\r\\n            loanRemainder = underlyingCostRemaining;\\r\\n        }\\r\\n\\r\\n        return (underlyingPayout, loanRemainder);\\r\\n    }\\r\\n\\r\\n    // ==== Primitive V1 =====\\r\\n\\r\\n    /// @dev    Calculates the proportional quantity of long option tokens per short option token.\\r\\n    /// @notice For each long option token, there is quoteValue / baseValue quantity of short option tokens.\\r\\n    function getProportionalLongOptions(\\r\\n        IOption optionToken,\\r\\n        uint256 quantityShort\\r\\n    ) internal view returns (uint256) {\\r\\n        uint256 quantityLong =\\r\\n            quantityShort.mul(optionToken.getBaseValue()).div(\\r\\n                optionToken.getQuoteValue()\\r\\n            );\\r\\n\\r\\n        return quantityLong;\\r\\n    }\\r\\n\\r\\n    /// @dev    Calculates the proportional quantity of short option tokens per long option token.\\r\\n    /// @notice For each short option token, there is baseValue / quoteValue quantity of long option tokens.\\r\\n    function getProportionalShortOptions(\\r\\n        IOption optionToken,\\r\\n        uint256 quantityLong\\r\\n    ) internal view returns (uint256) {\\r\\n        uint256 quantityShort =\\r\\n            quantityLong.mul(optionToken.getQuoteValue()).div(\\r\\n                optionToken.getBaseValue()\\r\\n            );\\r\\n\\r\\n        return quantityShort;\\r\\n    }\\r\\n\\r\\n    // ==== Uniswap V2 Library =====\\r\\n\\r\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\r\\n    function sortTokens(address tokenA, address tokenB)\\r\\n        internal\\r\\n        pure\\r\\n        returns (address token0, address token1)\\r\\n    {\\r\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\r\\n        (token0, token1) = tokenA < tokenB\\r\\n            ? (tokenA, tokenB)\\r\\n            : (tokenB, tokenA);\\r\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\r\\n    }\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(\\r\\n        address factory,\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) internal pure returns (address pair) {\\r\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\r\\n        pair = address(\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        hex\\\"ff\\\",\\r\\n                        factory,\\r\\n                        keccak256(abi.encodePacked(token0, token1)),\\r\\n                        hex\\\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\\\" // init code hash\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.8.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logByte(byte p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(byte)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWethConnector01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.2;\\r\\n\\r\\n// Primitive\\r\\nimport { IOption } from \\\"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\\\";\\r\\nimport { IWETH } from \\\"./IWETH.sol\\\";\\r\\n\\r\\ninterface IWethConnector01 {\\r\\n    function weth() external view returns (IWETH);\\r\\n\\r\\n    function safeMintWithETH(IOption optionToken, address receiver)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256, uint256);\\r\\n\\r\\n    function safeExerciseWithETH(IOption optionToken, address receiver)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256, uint256);\\r\\n\\r\\n    function safeExerciseForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 exerciseQuantity,\\r\\n        address receiver\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    function safeRedeemForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 redeemQuantity,\\r\\n        address receiver\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function safeCloseForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 closeQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function safeUnwindForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 unwindQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function getName() external pure returns (string memory);\\r\\n\\r\\n    function getVersion() external pure returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/WethConnectorLib01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.2;\\r\\n\\r\\n///\\r\\n/// @title   Weth Connector for bridging ether to WETH Primitive options.\\r\\n/// @notice  Abstracts the interfacing with the protocol's option contract for ease-of-use.\\r\\n///          Manages operations involving options with WETH as the underlying or strike asset.\\r\\n///          Accepts deposits in ethers and withdraws ethers.\\r\\n///          Primitive V1 WethConnectorLib01 - @primitivefi/contracts@v0.4.1\\r\\n/// @author  Primitive\\r\\n///\\r\\n\\r\\n// WETH Interface\\r\\nimport { IWETH } from \\\"../interfaces/IWETH.sol\\\";\\r\\n// Primitive\\r\\nimport { IOption, IERC20 } from \\\"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\\\";\\r\\n// Open Zeppelin\\r\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\n\\r\\nlibrary WethConnectorLib01 {\\r\\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\\r\\n    using SafeMath for uint256; // Reverts on math underflows/overflows\\r\\n\\r\\n    ///\\r\\n    /// @dev Checks the quantity of an operation to make sure its not zero. Fails early.\\r\\n    ///\\r\\n    modifier nonZero(uint256 quantity) {\\r\\n        require(quantity > 0, \\\"ERR_ZERO\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // ==== Operation Functions ====\\r\\n\\r\\n    ///\\r\\n    ///@dev Mints msg.value quantity of options and \\\"quote\\\" (option parameter) quantity of redeem tokens.\\r\\n    ///@notice This function is for options that have WETH as the underlying asset.\\r\\n    ///@param optionToken The address of the option token to mint.\\r\\n    ///@param receiver The address which receives the minted option and redeem tokens.\\r\\n    ///\\r\\n    function safeMintWithETH(\\r\\n        IWETH weth,\\r\\n        IOption optionToken,\\r\\n        address receiver\\r\\n    ) internal nonZero(msg.value) returns (uint256, uint256) {\\r\\n        // Check to make sure we are minting a WETH call option.\\r\\n        address underlyingAddress = optionToken.getUnderlyingTokenAddress();\\r\\n        require(address(weth) == underlyingAddress, \\\"ERR_NOT_WETH\\\");\\r\\n\\r\\n        // Convert ethers into WETH, then send WETH to option contract in preparation of calling mintOptions().\\r\\n        _depositEthSendWeth(weth, address(optionToken));\\r\\n\\r\\n        // Mint the option and redeem tokens.\\r\\n        (uint256 outputOptions, uint256 outputRedeems) = optionToken\\r\\n            .mintOptions(receiver);\\r\\n\\r\\n        return (outputOptions, outputRedeems);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Swaps msg.value of strikeTokens (ethers) to underlyingTokens.\\r\\n    /// Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\\r\\n    /// Msg.value (quote units) * base / quote = base units (underlyingTokens) to withdraw.\\r\\n    /// @notice This function is for options with WETH as the strike asset.\\r\\n    /// Burns option tokens, accepts ethers, and pushes out underlyingTokens.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param receiver The underlyingTokens are sent to the receiver address.\\r\\n    ///\\r\\n    function safeExerciseWithETH(\\r\\n        IWETH weth,\\r\\n        IOption optionToken,\\r\\n        address receiver\\r\\n    ) internal nonZero(msg.value) returns (uint256, uint256) {\\r\\n        // Require one of the option's assets to be WETH.\\r\\n        address strikeAddress = optionToken.getStrikeTokenAddress();\\r\\n        require(strikeAddress == address(weth), \\\"ERR_NOT_WETH\\\");\\r\\n\\r\\n        uint256 inputStrikes = msg.value;\\r\\n        // Calculate quantity of optionTokens needed to burn.\\r\\n        // An ether put option with strike price $300 has a \\\"base\\\" value of 300, and a \\\"quote\\\" value of 1.\\r\\n        // To calculate how many options are needed to be burned, we need to cancel out the \\\"quote\\\" units.\\r\\n        // The input strike quantity can be multiplied by the strike ratio to cancel out \\\"quote\\\" units.\\r\\n        // 1 ether (quote units) * 300 (base units) / 1 (quote units) = 300 inputOptions\\r\\n        uint256 inputOptions = inputStrikes.mul(optionToken.getBaseValue()).div(\\r\\n            optionToken.getQuoteValue()\\r\\n        );\\r\\n\\r\\n        // Fail early if msg.sender does not have enough optionTokens to burn.\\r\\n        require(\\r\\n            IERC20(address(optionToken)).balanceOf(msg.sender) >= inputOptions,\\r\\n            \\\"ERR_BAL_OPTIONS\\\"\\r\\n        );\\r\\n\\r\\n        // Wrap the ethers into WETH, and send the WETH to the option contract to prepare for calling exerciseOptions().\\r\\n        _depositEthSendWeth(weth, address(optionToken));\\r\\n\\r\\n        // Send the option tokens required to prepare for calling exerciseOptions().\\r\\n        IERC20(address(optionToken)).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputOptions\\r\\n        );\\r\\n\\r\\n        // Burns the transferred option tokens, stores the strike asset (ether), and pushes underlyingTokens\\r\\n        // to the receiver address.\\r\\n        (inputStrikes, inputOptions) = optionToken.exerciseOptions(\\r\\n            receiver,\\r\\n            inputOptions,\\r\\n            new bytes(0)\\r\\n        );\\r\\n\\r\\n        return (inputStrikes, inputOptions);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Swaps strikeTokens to underlyingTokens, WETH, which is converted to ethers before withdrawn.\\r\\n    /// Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\\r\\n    /// @notice This function is for options with WETH as the underlying asset.\\r\\n    /// Burns option tokens, pulls strikeTokens, and pushes out ethers.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param exerciseQuantity Quantity of optionTokens to exercise.\\r\\n    /// @param receiver The underlyingTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeExerciseForETH(\\r\\n        IWETH weth,\\r\\n        IOption optionToken,\\r\\n        uint256 exerciseQuantity,\\r\\n        address receiver\\r\\n    ) internal nonZero(exerciseQuantity) returns (uint256, uint256) {\\r\\n        // Require one of the option's assets to be WETH.\\r\\n        address underlyingAddress = optionToken.getUnderlyingTokenAddress();\\r\\n        address strikeAddress = optionToken.getStrikeTokenAddress();\\r\\n        require(underlyingAddress == address(weth), \\\"ERR_NOT_WETH\\\");\\r\\n\\r\\n        // Fails early if msg.sender does not have enough optionTokens.\\r\\n        require(\\r\\n            IERC20(address(optionToken)).balanceOf(msg.sender) >=\\r\\n                exerciseQuantity,\\r\\n            \\\"ERR_BAL_OPTIONS\\\"\\r\\n        );\\r\\n\\r\\n        // Calculate quantity of strikeTokens needed to exercise quantity of optionTokens.\\r\\n        uint256 inputStrikes = exerciseQuantity\\r\\n            .mul(optionToken.getQuoteValue())\\r\\n            .div(optionToken.getBaseValue());\\r\\n\\r\\n        // Fails early if msg.sender does not have enough strikeTokens.\\r\\n        require(\\r\\n            IERC20(strikeAddress).balanceOf(msg.sender) >= inputStrikes,\\r\\n            \\\"ERR_BAL_STRIKE\\\"\\r\\n        );\\r\\n\\r\\n        // Send strikeTokens to option contract to prepare for calling exerciseOptions().\\r\\n        IERC20(strikeAddress).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputStrikes\\r\\n        );\\r\\n\\r\\n        // Send the option tokens to prepare for calling exerciseOptions().\\r\\n        IERC20(address(optionToken)).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            exerciseQuantity\\r\\n        );\\r\\n\\r\\n        // Burns the optionTokens sent, stores the strikeTokens sent, and pushes underlyingTokens\\r\\n        // to this contract.\\r\\n        uint256 inputOptions;\\r\\n        (inputStrikes, inputOptions) = optionToken.exerciseOptions(\\r\\n            address(this),\\r\\n            exerciseQuantity,\\r\\n            new bytes(0)\\r\\n        );\\r\\n\\r\\n        // Converts the withdrawn WETH to ethers, then sends the ethers to the receiver address.\\r\\n        _withdrawEthAndSend(weth, receiver, exerciseQuantity);\\r\\n\\r\\n        return (inputStrikes, inputOptions);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Burns redeem tokens to withdraw strike tokens (ethers) at a 1:1 ratio.\\r\\n    /// @notice This function is for options that have WETH as the strike asset.\\r\\n    /// Converts WETH to ethers, and withdraws ethers to the receiver address.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param redeemQuantity The quantity of redeemTokens to burn.\\r\\n    /// @param receiver The strikeTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeRedeemForETH(\\r\\n        IWETH weth,\\r\\n        IOption optionToken,\\r\\n        uint256 redeemQuantity,\\r\\n        address receiver\\r\\n    ) internal nonZero(redeemQuantity) returns (uint256) {\\r\\n        // Require strikeToken to be WETH.\\r\\n        address strikeAddress = optionToken.getStrikeTokenAddress();\\r\\n        require(strikeAddress == address(weth), \\\"ERR_NOT_WETH\\\");\\r\\n\\r\\n        // Fail early if msg.sender does not have enough redeemTokens.\\r\\n        address redeemAddress = optionToken.redeemToken();\\r\\n        require(\\r\\n            IERC20(redeemAddress).balanceOf(msg.sender) >= redeemQuantity,\\r\\n            \\\"ERR_BAL_REDEEM\\\"\\r\\n        );\\r\\n\\r\\n        // Send redeemTokens to option contract in preparation for calling redeemStrikeTokens().\\r\\n        IERC20(redeemAddress).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            redeemQuantity\\r\\n        );\\r\\n\\r\\n        // If options have not been exercised, there will be no strikeTokens to redeem, causing a revert.\\r\\n        // Burns the redeem tokens that were sent to the contract, and withdraws the same quantity of WETH.\\r\\n        // Sends the withdrawn WETH to this contract, so that it can be unwrapped prior to being sent to receiver.\\r\\n        uint256 inputRedeems = optionToken.redeemStrikeTokens(address(this));\\r\\n\\r\\n        // Unwrap the redeemed WETH and then send the ethers to the receiver.\\r\\n        _withdrawEthAndSend(weth, receiver, redeemQuantity);\\r\\n\\r\\n        return inputRedeems;\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Burn optionTokens and redeemTokens to withdraw underlyingTokens (ethers).\\r\\n    /// @notice This function is for options with WETH as the underlying asset.\\r\\n    /// WETH underlyingTokens are converted to ethers before being sent to receiver.\\r\\n    /// The redeemTokens to burn is equal to the optionTokens * strike ratio.\\r\\n    /// inputOptions = inputRedeems / strike ratio = outUnderlyings\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param closeQuantity Quantity of optionTokens to burn and an input to calculate how many redeems to burn.\\r\\n    /// @param receiver The underlyingTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeCloseForETH(\\r\\n        IWETH weth,\\r\\n        IOption optionToken,\\r\\n        uint256 closeQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        internal\\r\\n        nonZero(closeQuantity)\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        // Require the optionToken to have WETH as the underlying asset.\\r\\n        address underlyingAddress = optionToken.getUnderlyingTokenAddress();\\r\\n        require(address(weth) == underlyingAddress, \\\"ERR_NOT_WETH\\\");\\r\\n\\r\\n        // Fail early if msg.sender does not have enough optionTokens to burn.\\r\\n        require(\\r\\n            IERC20(address(optionToken)).balanceOf(msg.sender) >= closeQuantity,\\r\\n            \\\"ERR_BAL_OPTIONS\\\"\\r\\n        );\\r\\n\\r\\n        // Calculate the quantity of redeemTokens that need to be burned.\\r\\n        uint256 inputRedeems = closeQuantity\\r\\n            .mul(optionToken.getQuoteValue())\\r\\n            .div(optionToken.getBaseValue());\\r\\n\\r\\n        // Fail early is msg.sender does not have enough redeemTokens to burn.\\r\\n        require(\\r\\n            IERC20(optionToken.redeemToken()).balanceOf(msg.sender) >=\\r\\n                inputRedeems,\\r\\n            \\\"ERR_BAL_REDEEM\\\"\\r\\n        );\\r\\n\\r\\n        // Send redeem and option tokens in preparation of calling closeOptions().\\r\\n        IERC20(optionToken.redeemToken()).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputRedeems\\r\\n        );\\r\\n        IERC20(address(optionToken)).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            closeQuantity\\r\\n        );\\r\\n\\r\\n        // Call the closeOptions() function to burn option and redeem tokens and withdraw underlyingTokens.\\r\\n        uint256 inputOptions;\\r\\n        uint256 outUnderlyings;\\r\\n        (inputRedeems, inputOptions, outUnderlyings) = optionToken.closeOptions(\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        // Since underlyngTokens are WETH, unwrap them then send the ethers to the receiver.\\r\\n        _withdrawEthAndSend(weth, receiver, closeQuantity);\\r\\n\\r\\n        return (inputRedeems, inputOptions, outUnderlyings);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Burn redeemTokens to withdraw underlyingTokens (ethers) from expired options.\\r\\n    /// This function is for options with WETH as the underlying asset.\\r\\n    /// The underlyingTokens are WETH, which are converted to ethers prior to being sent to receiver.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param unwindQuantity Quantity of underlyingTokens (ethers) to withdraw.\\r\\n    /// @param receiver The underlyingTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeUnwindForETH(\\r\\n        IWETH weth,\\r\\n        IOption optionToken,\\r\\n        uint256 unwindQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        internal\\r\\n        nonZero(unwindQuantity)\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        // Require the optionToken to have WETH as the underlying asset.\\r\\n        address underlyingAddress = optionToken.getUnderlyingTokenAddress();\\r\\n        require(address(weth) == underlyingAddress, \\\"ERR_NOT_WETH\\\");\\r\\n\\r\\n        // If the option is not expired, fail early.\\r\\n        // solhint-disable-next-line not-rely-on-time\\r\\n        require(optionToken.getExpiryTime() < now, \\\"ERR_NOT_EXPIRED\\\");\\r\\n\\r\\n        // Calculate the quantity of redeemTokens that need to be burned.\\r\\n        uint256 inputRedeems = unwindQuantity\\r\\n            .mul(optionToken.getQuoteValue())\\r\\n            .div(optionToken.getBaseValue());\\r\\n\\r\\n        // Fail early if msg.sender does not have enough redeemTokens to burn.\\r\\n        require(\\r\\n            IERC20(optionToken.redeemToken()).balanceOf(msg.sender) >=\\r\\n                inputRedeems,\\r\\n            \\\"ERR_BAL_REDEEM\\\"\\r\\n        );\\r\\n\\r\\n        // Send redeem in preparation of calling closeOptions().\\r\\n        IERC20(optionToken.redeemToken()).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputRedeems\\r\\n        );\\r\\n\\r\\n        // Call the closeOptions() function to burn redeem tokens and withdraw underlyingTokens.\\r\\n        uint256 inputOptions;\\r\\n        uint256 outUnderlyings;\\r\\n        (inputRedeems, inputOptions, outUnderlyings) = optionToken.closeOptions(\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        // Since underlyngTokens are WETH, unwrap them to ethers then send the ethers to the receiver.\\r\\n        _withdrawEthAndSend(weth, receiver, unwindQuantity);\\r\\n        return (inputRedeems, inputOptions, outUnderlyings);\\r\\n    }\\r\\n\\r\\n    // ==== WETH Operations ====\\r\\n\\r\\n    ///\\r\\n    /// @dev Deposits msg.value of ethers into WETH contract. Then sends WETH to \\\"to\\\".\\r\\n    /// @param to The address to send WETH ERC-20 tokens to.\\r\\n    ///\\r\\n    function _depositEthSendWeth(IWETH weth, address to) internal {\\r\\n        // Deposit the ethers received from msg.value into the WETH contract.\\r\\n        weth.deposit.value(msg.value)();\\r\\n\\r\\n        // Send WETH.\\r\\n        weth.transfer(to, msg.value);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Unwraps WETH to withrdaw ethers, which are then sent to the \\\"to\\\" address.\\r\\n    /// @param to The address to send withdrawn ethers to.\\r\\n    /// @param quantity The quantity of WETH to unwrap.\\r\\n    ///\\r\\n    function _withdrawEthAndSend(\\r\\n        IWETH weth,\\r\\n        address to,\\r\\n        uint256 quantity\\r\\n    ) internal {\\r\\n        // Withdraw ethers with weth.\\r\\n        weth.withdraw(quantity);\\r\\n\\r\\n        // Send ether.\\r\\n        (bool success, ) = to.call.value(quantity)(\\\"\\\");\\r\\n\\r\\n        // Revert is call is unsuccessful.\\r\\n        require(success, \\\"ERR_SENDING_ETHER\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function withdraw(uint256) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/WethConnector01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.2;\\r\\n\\r\\n///\\r\\n/// @title   Weth Connector for bridging ether to WETH Primitive options.\\r\\n/// @notice  Abstracts the interfacing with the protocol's option contract for ease-of-use.\\r\\n///          Manages operations involving options with WETH as the underlying or strike asset.\\r\\n///          Accepts deposits in ethers and withdraws ethers.\\r\\n///          Primitive V1 WethConnector01 - @primitivefi/contracts@v0.4.1\\r\\n/// @author  Primitive\\r\\n///\\r\\n\\r\\n// Primitive\\r\\nimport { IWethConnector01, IOption, IWETH } from \\\"./interfaces/IWethConnector01.sol\\\";\\r\\nimport { WethConnectorLib01, IERC20 } from \\\"./libraries/WethConnectorLib01.sol\\\";\\r\\n// Open Zeppelin\\r\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport {\\r\\n    ReentrancyGuard\\r\\n} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\n\\r\\ncontract WethConnector01 is IWethConnector01, ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\\r\\n    using SafeMath for uint256; // Reverts on math underflows/overflows\\r\\n\\r\\n    IWETH public override weth;\\r\\n\\r\\n    event WethConnectorMint(\\r\\n        address indexed from,\\r\\n        address indexed option,\\r\\n        uint256 outputOptions,\\r\\n        uint256 outputRedeems\\r\\n    );\\r\\n    event WethConnectorExercise(\\r\\n        address indexed from,\\r\\n        address indexed option,\\r\\n        uint256 outUnderlyings,\\r\\n        uint256 inStrikes\\r\\n    );\\r\\n    event WethConnectorRedeem(\\r\\n        address indexed from,\\r\\n        address indexed option,\\r\\n        uint256 inRedeems\\r\\n    );\\r\\n    event WethConnectorClose(\\r\\n        address indexed from,\\r\\n        address indexed option,\\r\\n        uint256 inOptions\\r\\n    );\\r\\n\\r\\n    event WethConnectorUnwind(\\r\\n        address indexed from,\\r\\n        address indexed option,\\r\\n        uint256 inOptions\\r\\n    );\\r\\n\\r\\n    ///\\r\\n    /// @dev Checks the quantity of an operation to make sure its not zero. Fails early.\\r\\n    ///\\r\\n    modifier nonZero(uint256 quantity) {\\r\\n        require(quantity > 0, \\\"ERR_ZERO\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Since the WethConnector contract is responsible for converting between ethers and WETH,\\r\\n    /// the contract is initialized with the address for WETH.\\r\\n    ///\\r\\n    constructor(address payable _weth) public {\\r\\n        weth = IWETH(_weth);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev If ether is sent to this contract through a normal transaction, it will fail, unless\\r\\n    /// it was the WETH contract who sent it.\\r\\n    ///\\r\\n    receive() external payable {\\r\\n        assert(msg.sender == address(weth));\\r\\n    }\\r\\n\\r\\n    // ==== Operation Functions ====\\r\\n\\r\\n    ///\\r\\n    /// @dev Mints msg.value quantity of options and \\\"quote\\\" (option parameter) quantity of redeem tokens.\\r\\n    /// @notice This function is for options that have WETH as the underlying asset.\\r\\n    /// @param optionToken The address of the option token to mint.\\r\\n    /// @param receiver The address which receives the minted option and redeem tokens.\\r\\n    ///\\r\\n    function safeMintWithETH(IOption optionToken, address receiver)\\r\\n        external\\r\\n        override\\r\\n        payable\\r\\n        nonReentrant\\r\\n        nonZero(msg.value)\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        (uint256 outputOptions, uint256 outputRedeems) = WethConnectorLib01\\r\\n            .safeMintWithETH(weth, optionToken, receiver);\\r\\n        emit WethConnectorMint(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            outputOptions,\\r\\n            outputRedeems\\r\\n        );\\r\\n\\r\\n        return (outputOptions, outputRedeems);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Swaps msg.value of strikeTokens (ethers) to underlyingTokens.\\r\\n    /// Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\\r\\n    /// Msg.value (quote units) * base / quote = base units (underlyingTokens) to withdraw.\\r\\n    /// @notice This function is for options with WETH as the strike asset.\\r\\n    /// Burns option tokens, accepts ethers, and pushes out underlyingTokens.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param receiver The underlyingTokens are sent to the receiver address.\\r\\n    ///\\r\\n    function safeExerciseWithETH(IOption optionToken, address receiver)\\r\\n        external\\r\\n        override\\r\\n        payable\\r\\n        nonReentrant\\r\\n        nonZero(msg.value)\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        (uint256 inputStrikes, uint256 inputOptions) = WethConnectorLib01\\r\\n            .safeExerciseWithETH(weth, optionToken, receiver);\\r\\n\\r\\n        emit WethConnectorExercise(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputOptions,\\r\\n            inputStrikes\\r\\n        );\\r\\n\\r\\n        return (inputStrikes, inputOptions);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Swaps strikeTokens to underlyingTokens, WETH, which is converted to ethers before withdrawn.\\r\\n    /// Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\\r\\n    /// @notice This function is for options with WETH as the underlying asset.\\r\\n    /// Burns option tokens, pulls strikeTokens, and pushes out ethers.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param exerciseQuantity Quantity of optionTokens to exercise.\\r\\n    /// @param receiver The underlyingTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeExerciseForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 exerciseQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n        nonReentrant\\r\\n        nonZero(exerciseQuantity)\\r\\n        returns (uint256, uint256)\\r\\n    {\\r\\n        (uint256 inputStrikes, uint256 inputOptions) = WethConnectorLib01\\r\\n            .safeExerciseForETH(weth, optionToken, exerciseQuantity, receiver);\\r\\n\\r\\n        emit WethConnectorExercise(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            exerciseQuantity,\\r\\n            inputStrikes\\r\\n        );\\r\\n\\r\\n        return (inputStrikes, inputOptions);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Burns redeem tokens to withdraw strike tokens (ethers) at a 1:1 ratio.\\r\\n    /// @notice This function is for options that have WETH as the strike asset.\\r\\n    /// Converts WETH to ethers, and withdraws ethers to the receiver address.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param redeemQuantity The quantity of redeemTokens to burn.\\r\\n    /// @param receiver The strikeTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeRedeemForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 redeemQuantity,\\r\\n        address receiver\\r\\n    ) external override nonReentrant nonZero(redeemQuantity) returns (uint256) {\\r\\n        uint256 inputRedeems = WethConnectorLib01.safeRedeemForETH(\\r\\n            weth,\\r\\n            optionToken,\\r\\n            redeemQuantity,\\r\\n            receiver\\r\\n        );\\r\\n\\r\\n        emit WethConnectorRedeem(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputRedeems\\r\\n        );\\r\\n        return inputRedeems;\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Burn optionTokens and redeemTokens to withdraw underlyingTokens (ethers).\\r\\n    /// @notice This function is for options with WETH as the underlying asset.\\r\\n    /// WETH underlyingTokens are converted to ethers before being sent to receiver.\\r\\n    /// The redeemTokens to burn is equal to the optionTokens * strike ratio.\\r\\n    /// inputOptions = inputRedeems / strike ratio = outUnderlyings\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param closeQuantity Quantity of optionTokens to burn and an input to calculate how many redeems to burn.\\r\\n    /// @param receiver The underlyingTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeCloseForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 closeQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n        nonReentrant\\r\\n        nonZero(closeQuantity)\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        (\\r\\n            uint256 inputRedeems,\\r\\n            uint256 inputOptions,\\r\\n            uint256 outUnderlyings\\r\\n        ) = WethConnectorLib01.safeCloseForETH(\\r\\n            weth,\\r\\n            optionToken,\\r\\n            closeQuantity,\\r\\n            receiver\\r\\n        );\\r\\n        emit WethConnectorClose(msg.sender, address(optionToken), inputOptions);\\r\\n        return (inputRedeems, inputOptions, outUnderlyings);\\r\\n    }\\r\\n\\r\\n    ///\\r\\n    /// @dev Burn redeemTokens to withdraw underlyingTokens (ethers) from expired options.\\r\\n    /// This function is for options with WETH as the underlying asset.\\r\\n    /// The underlyingTokens are WETH, which are converted to ethers prior to being sent to receiver.\\r\\n    /// @param optionToken The address of the option contract.\\r\\n    /// @param unwindQuantity Quantity of underlyingTokens (ethers) to withdraw.\\r\\n    /// @param receiver The underlyingTokens (ethers) are sent to the receiver address.\\r\\n    ///\\r\\n    function safeUnwindForETH(\\r\\n        IOption optionToken,\\r\\n        uint256 unwindQuantity,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n        nonReentrant\\r\\n        nonZero(unwindQuantity)\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        (\\r\\n            uint256 inputRedeems,\\r\\n            uint256 inputOptions,\\r\\n            uint256 outUnderlyings\\r\\n        ) = WethConnectorLib01.safeUnwindForETH(\\r\\n            weth,\\r\\n            optionToken,\\r\\n            unwindQuantity,\\r\\n            receiver\\r\\n        );\\r\\n\\r\\n        emit WethConnectorUnwind(\\r\\n            msg.sender,\\r\\n            address(optionToken),\\r\\n            inputOptions\\r\\n        );\\r\\n        return (inputRedeems, inputOptions, outUnderlyings);\\r\\n    }\\r\\n\\r\\n    // ==== View ====\\r\\n\\r\\n    /// @dev Gets the name of the contract.\\r\\n    function getName() external override pure returns (string memory) {\\r\\n        return \\\"PrimitiveV1WethConnector01\\\";\\r\\n    }\\r\\n\\r\\n    /// @dev Gets the version of the contract.\\r\\n    function getVersion() external override pure returns (uint8) {\\r\\n        return uint8(1);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/test/TestERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\n\\r\\ncontract TestERC20 is ERC20 {\\r\\n    constructor(\\r\\n        string memory name,\\r\\n        string memory symbol,\\r\\n        uint256 initialSupply\\r\\n    ) public ERC20(name, symbol) {\\r\\n        _mint(msg.sender, initialSupply);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to mint tokens\\r\\n     * @param to The address that will receive the minted tokens.\\r\\n     * @param value The amount of tokens to mint.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function mint(address to, uint256 value) public returns (bool) {\\r\\n        _mint(to, value);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x0e511aa1a137aad267dfe3a6bfca0b856c1a3682", "attacktype": "Other unsafe DeFi protocol dependency", "sourcecode": "{\"BColor.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\ncontract BColor {\\n    function getColor()\\n        external view\\n        returns (bytes32);\\n}\\n\\ncontract BBronze is BColor {\\n    function getColor()\\n        external view\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"},\"BConst.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BColor.sol\\\";\\n\\ncontract BConst is BBronze {\\n    uint public constant BONE              = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 8;\\n\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    uint public constant EXIT_FEE          = 0;\\n\\n    uint public constant MIN_WEIGHT        = BONE;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"},\"BMath.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BMath is BBronze, BConst, BNum {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint spotPrice)\\n    {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountOut)\\n    {\\n        // Charge the trading fee for the proportion of tokenAi\\n        ///  which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n      \\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight); \\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        // charge exit fee on the pool token side\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n     \\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side \\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountIn)\\n    {\\n\\n        // charge swap fee on the output token side \\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee); \\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n        // charge exit fee on the pool token side\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n        return poolAmountIn;\\n    }\\n\\n\\n}\\n\"},\"BNum.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a \\u003e= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base \\u003e= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base \\u003c= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);   \\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1--\\u003ek) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term \\u003e= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"},\"BPool.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\ncontract BPool is BBronze, BToken, BMath {\\n\\n    struct Record {\\n        bool bound;   // is token bound to pool\\n        uint index;   // private\\n        uint denorm;  // denormalized weight\\n        uint balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n    ) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _factory;    // BFactory address to push token exitFee to\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    uint private _swapFee;\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address=\\u003eRecord) private  _records;\\n    uint private _totalWeight;\\n\\n    constructor() public {\\n        _controller = msg.sender;\\n        _factory = msg.sender;\\n        _swapFee = MIN_FEE;\\n        _publicSwap = false;\\n        _finalized = false;\\n    }\\n\\n    function isPublicSwap()\\n        external view\\n        returns (bool)\\n    {\\n        return _publicSwap;\\n    }\\n\\n    function isFinalized()\\n        external view\\n        returns (bool)\\n    {\\n        return _finalized;\\n    }\\n\\n    function isBound(address t)\\n        external view\\n        returns (bool)\\n    {\\n        return _records[t].bound;\\n    }\\n\\n    function getNumTokens()\\n        external view\\n        returns (uint) \\n    {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens()\\n        external view _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    function getFinalTokens()\\n        external view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].denorm;\\n    }\\n\\n    function getTotalDenormalizedWeight()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    function getNormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        uint denorm = _records[token].denorm;\\n        return bdiv(denorm, _totalWeight);\\n    }\\n\\n    function getBalance(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].balance;\\n    }\\n\\n    function getSwapFee()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _swapFee;\\n    }\\n\\n    function getController()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _controller;\\n    }\\n\\n    function setSwapFee(uint swapFee)\\n        external\\n        _logs_\\n        _lock_\\n    { \\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(swapFee \\u003e= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFee \\u003c= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _swapFee = swapFee;\\n    }\\n\\n    function setController(address manager)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _controller = manager;\\n    }\\n\\n    function setPublicSwap(bool public_)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _publicSwap = public_;\\n    }\\n\\n    function finalize()\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(_tokens.length \\u003e= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n\\n    function bind(address token, uint balance, uint denorm)\\n        external\\n        _logs_\\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(_tokens.length \\u003c MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0,    // balance and denorm will be validated\\n            balance: 0   // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    function rebind(address token, uint balance, uint denorm)\\n        public\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(denorm \\u003e= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm \\u003c= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance \\u003e= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint oldWeight = _records[token].denorm;\\n        if (denorm \\u003e oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight \\u003c= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm \\u003c oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }        \\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance \\u003e oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance \\u003c oldBalance) {\\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\\n            _pushUnderlying(token, _factory, tokenExitFee);\\n        }\\n    }\\n\\n    function unbind(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        uint tokenBalance = _records[token].balance;\\n        uint tokenExitFee = bmul(tokenBalance, EXIT_FEE);\\n\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({\\n            bound: false,\\n            index: 0,\\n            denorm: 0,\\n            balance: 0\\n        });\\n\\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\\n        _pushUnderlying(token, _factory, tokenExitFee);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function getSpotPrice(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n    }\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\n    }\\n\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountIn = bmul(ratio, bal);\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn \\u003c= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = totalSupply();\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(_factory, exitFee);\\n        _burnPoolShare(pAiAfterExitFee);\\n\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountOut = bmul(ratio, bal);\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountOut \\u003e= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n\\n    }\\n\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\n    {\\n\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountIn \\u003c= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore \\u003c= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n        require(tokenAmountOut \\u003e= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter \\u003e= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");     \\n        require(spotPriceAfter \\u003c= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore \\u003c= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint maxAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_ \\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountOut \\u003c= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore \\u003c= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n        require(tokenAmountIn \\u003c= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter \\u003e= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter \\u003c= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore \\u003c= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n\\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountOut)\\n\\n    {        \\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountIn \\u003c= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountOut \\u003e= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return poolAmountOut;\\n    }\\n\\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountIn)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            poolAmountOut,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountIn \\u003c= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n        \\n        require(tokenAmountIn \\u003c= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return tokenAmountIn;\\n    }\\n\\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            poolAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountOut \\u003e= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n        \\n        require(tokenAmountOut \\u003c= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return tokenAmountOut;\\n    }\\n\\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountIn)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountOut \\u003c= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(poolAmountIn \\u003c= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);        \\n\\n        return poolAmountIn;\\n    }\\n\\n\\n    // ==\\n    // \\u0027Underlying\\u0027 token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(address erc20, address to, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount)\\n        internal\\n    {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n\\n}\\n\"},\"BToken.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\ninterface IERC20 {\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address =\\u003e uint)                   internal _balance;\\n    mapping(address =\\u003e mapping(address=\\u003euint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] \\u003e= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] \\u003e= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20 {\\n\\n    string  private _name     = \\\"Balancer Pool Token\\\";\\n    string  private _symbol   = \\\"BPT\\\";\\n    uint8   private _decimals = 18;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt \\u003e oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\\n        require(msg.sender == src || amt \\u003c= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src \\u0026\\u0026 _allowance[src][msg.sender] != uint256(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"}}"}
{"address": "0x75572098dc462f976127f59f8c97dfa291f81d8b", "attacktype": "Visibility errors, including unrestricted action", "sourcecode": "pragma solidity 0.6.4;\r\n//ERC20 Interface\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address, uint) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    }\r\ninterface VETH {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function genesis() external view returns (uint);\r\n    function currentEra() external view returns (uint);\r\n    function currentDay() external view returns (uint);\r\n    function emission() external view returns (uint);\r\n    function daysPerEra() external view returns (uint);\r\n    function secondsPerDay() external view returns (uint);\r\n    function nextDayTime() external view returns (uint);\r\n    function totalBurnt() external view returns (uint);\r\n    function totalFees() external view returns (uint);\r\n    function burnAddress() external view returns (address payable);\r\n    function upgradeHeight() external view returns (uint);\r\n    function mapEraDay_Units(uint, uint) external view returns (uint);\r\n    function mapPreviousOwnership(address payable) external view returns (uint);\r\n}\r\nlibrary SafeMath {\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n}\r\n    //======================================VETHER=========================================//\r\ncontract Vether3 is ERC20 {\r\n    using SafeMath for uint;\r\n    // ERC-20 Parameters\r\n    string public name; string public symbol;\r\n    uint public decimals; uint public override totalSupply;\r\n    // ERC-20 Mappings\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n    // Public Parameters\r\n    uint coin = 10**18; uint public emission;\r\n    uint public currentEra; uint public currentDay;\r\n    uint public daysPerEra; uint public secondsPerDay;\r\n    uint public upgradeHeight; uint public upgradedAmount;\r\n    uint public genesis; uint public nextEraTime; uint public nextDayTime;\r\n    address payable public burnAddress; address public vether1; address public vether2; address deployer;\r\n    uint public totalFees; uint public totalBurnt; uint public totalEmitted;\r\n    address[] public holderArray; uint public holders;\r\n    address[] public excludedArray; uint public excludedCount;\r\n    // Public Mappings\r\n    mapping(uint=>uint) public mapEra_Emission;                                             // Era->Emission\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_MemberCount;                        // Era,Days->MemberCount\r\n    mapping(uint=>mapping(uint=>address[])) public mapEraDay_Members;                       // Era,Days->Members\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Units;                              // Era,Days->Units\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_UnitsRemaining;                     // Era,Days->TotalUnits\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_EmissionRemaining;                  // Era,Days->Emission\r\n    mapping(uint=>mapping(uint=>mapping(address=>uint))) public mapEraDay_MemberUnits;      // Era,Days,Member->Units\r\n    mapping(address=>mapping(uint=>uint[])) public mapMemberEra_Days;                       // Member,Era->Days[]\r\n    mapping(address=>uint) public mapPreviousOwnership;                                     // Map previous owners\r\n    mapping(address=>bool) public mapHolder;                                                // Vether Holder\r\n    mapping(address=>bool) public mapAddress_Excluded;                                      // Address->Excluded\r\n    mapping(address=>uint) public mapAddress_BlockChange;                                   // Address->BlockHeight Change\r\n    // Events\r\n    event NewEra(uint era, uint emission, uint time, uint totalBurnt);\r\n    event NewDay(uint era, uint day, uint time, uint previousDayTotal, uint previousDayMembers);\r\n    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units, uint dailyTotal);\r\n    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value, uint vetherRemaining);\r\n\r\n    //=====================================CREATION=========================================//\r\n    // Constructor\r\n    constructor() public {\r\n        vether1 = 0x31Bb711de2e457066c6281f231fb473FC5c2afd3;                               // First Vether\r\n        vether2 = 0x01217729940055011F17BeFE6270e6E59B7d0337;                               // Second Vether\r\n        upgradeHeight = 50;                                                                 // Height at which to upgrade\r\n        name = VETH(vether2).name(); symbol = VETH(vether2).symbol();\r\n        decimals = VETH(vether2).decimals(); totalSupply = VETH(vether2).totalSupply();\r\n        genesis = VETH(vether2).genesis(); emission = VETH(vether2).emission(); \r\n        currentEra = VETH(vether2).currentEra(); currentDay = upgradeHeight;                // Begin at Upgrade Height\r\n        daysPerEra = VETH(vether2).daysPerEra(); secondsPerDay = VETH(vether2).secondsPerDay();\r\n        totalBurnt = VETH(vether2).totalBurnt(); totalFees = VETH(vether2).totalFees();\r\n        totalEmitted = (upgradeHeight-1)*emission;\r\n        burnAddress = VETH(vether2).burnAddress(); deployer = msg.sender;\r\n        _balances[address(this)] = totalSupply; \r\n        emit Transfer(burnAddress, address(this), totalSupply);\r\n        nextEraTime = genesis + (secondsPerDay * daysPerEra);\r\n        nextDayTime = VETH(vether2).nextDayTime() + (secondsPerDay * (upgradeHeight - VETH(vether2).currentDay())); \r\n        mapAddress_Excluded[address(this)] = true;                                          \r\n        excludedArray.push(address(this)); excludedCount =1;                               \r\n        mapAddress_Excluded[burnAddress] = true;\r\n        excludedArray.push(burnAddress); excludedCount +=1; \r\n        mapEra_Emission[currentEra] = emission; \r\n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \r\n        _setMappings();                                                                  // Map historical units\r\n    }\r\n    function _setMappings() internal {\r\n        uint upgradeHeight1 = VETH(vether2).upgradeHeight();                \r\n        for(uint i=0;i<upgradeHeight1; i++) {\r\n            mapEraDay_Units[1][i] = VETH(vether1).mapEraDay_Units(1,i); \r\n        }\r\n        for(uint i=upgradeHeight1;i<upgradeHeight; i++) {\r\n            mapEraDay_Units[1][i] = VETH(vether2).mapEraDay_Units(1,i); \r\n        }\r\n    }\r\n\r\n    //========================================ERC20=========================================//\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        if(mapAddress_Excluded[spender]){\r\n            return totalSupply;\r\n        } else {\r\n            return _allowances[owner][spender];\r\n        }\r\n    }\r\n    // ERC20 Transfer function\r\n    function transfer(address to, uint value) public override returns (bool success) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n    // ERC20 Approve function\r\n    function approve(address spender, uint value) public override returns (bool success) {\r\n        _allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    // ERC20 TransferFrom function\r\n    function transferFrom(address from, address to, uint value) public override returns (bool success) {\r\n        if(!mapAddress_Excluded[msg.sender]){\r\n            require(value <= _allowances[from][msg.sender], 'Must not send more than allowance');\r\n            _allowances[from][msg.sender] -= value;\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n    // Internal transfer function which includes the Fee\r\n    function _transfer(address _from, address _to, uint _value) private {\r\n        require(_balances[_from] >= _value, 'Must not send more than balance');\r\n        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');\r\n        if(!mapHolder[_to]){holderArray.push(_to); holders+=1; mapHolder[_to]=true;}\r\n        _balances[_from] =_balances[_from].sub(_value);\r\n        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount\r\n        _balances[_to] += (_value.sub(_fee));                                               // Add to receiver\r\n        _balances[address(this)] += _fee;                                                   // Add fee to self\r\n        totalFees += _fee;                                                                  // Track fees collected\r\n        emit Transfer(_from, _to, (_value.sub(_fee)));                                      // Transfer event\r\n        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {\r\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\r\n        }\r\n    }\r\n    // Calculate Fee amount\r\n    function _getFee(address _from, address _to, uint _value) private view returns (uint) {\r\n        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {\r\n           return 0;                                                                        // No fee if excluded\r\n        } else {\r\n            return (_value / 1000);                                                         // Fee amount = 0.1%\r\n        }\r\n    }\r\n\r\n    //=======================================UPGRADE========================================//\r\n    // Allow to query for remaining upgrade amount\r\n    function getRemainingAmount() public view returns (uint amount){\r\n        uint maxEmissions = (upgradeHeight-1) * mapEra_Emission[1];                         // Max Emission on Old Contract\r\n        uint maxUpgradeAmount = (maxEmissions).sub(VETH(vether2).totalFees());              // Minus any collected fees\r\n        if(maxUpgradeAmount >= upgradedAmount){\r\n            return maxUpgradeAmount.sub(upgradedAmount);                                    // Return remaining\r\n        } else {\r\n            return 0;                                                                       // Return 0\r\n        }\r\n    }\r\n    // V1 upgrades \r\n    function upgradeV1() public {\r\n        uint amount = ERC20(vether1).balanceOf(msg.sender);                                 // Get Balance Vether1\r\n        if(amount > 0){\r\n            if(mapPreviousOwnership[msg.sender] < amount){\r\n                amount = mapPreviousOwnership[msg.sender];                                  // Upgrade as much as possible\r\n            } \r\n            uint remainingAmount = getRemainingAmount();\r\n            if(remainingAmount < amount){amount = remainingAmount;}                         // Handle final amount\r\n            upgradedAmount += amount; \r\n            mapPreviousOwnership[msg.sender] = mapPreviousOwnership[msg.sender].sub(amount);    // Update mappings\r\n            ERC20(vether1).transferFrom(msg.sender, burnAddress, amount);                   // Must collect & burn tokens\r\n            _transfer(address(this), msg.sender, amount);                                   // Send to owner\r\n        }\r\n    }\r\n    // V2 upgrades \r\n    function upgradeV2() public {\r\n        uint amount = ERC20(vether2).balanceOf(msg.sender);                                 // Get Balance Vether2\r\n        if(amount > 0){\r\n            if(mapPreviousOwnership[msg.sender] < amount){\r\n                amount = mapPreviousOwnership[msg.sender];                                  // Upgrade as much as possible\r\n            } \r\n            uint remainingAmount = getRemainingAmount();\r\n            if(remainingAmount < amount){amount = remainingAmount;}                         // Handle final amount\r\n            upgradedAmount += amount; \r\n            mapPreviousOwnership[msg.sender] = mapPreviousOwnership[msg.sender].sub(amount);    // Update mappings\r\n            ERC20(vether2).transferFrom(msg.sender, burnAddress, amount);                   // Must collect & burn tokens\r\n            _transfer(address(this), msg.sender, amount);                                   // Send to owner\r\n        }\r\n    }\r\n    // Snapshot previous owners\r\n    function snapshot(address[] memory owners, uint[] memory ownership) public{\r\n        require(msg.sender == deployer);\r\n        for(uint i = 0; i<owners.length; i++){\r\n            mapPreviousOwnership[owners[i]] = ownership[i];\r\n        }\r\n    }\r\n    // purge\r\n    function purgeDeployer() public{require(msg.sender == deployer);deployer = address(0);}\r\n\r\n    //==================================PROOF-OF-VALUE======================================//\r\n    // Calls when sending Ether\r\n    receive() external payable {\r\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\r\n        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);             // Record Burn\r\n    }\r\n    // Burn ether for nominated member\r\n    function burnEtherForMember(address member) external payable {\r\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\r\n        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);                 // Record Burn\r\n    }\r\n    // Internal - Records burn\r\n    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {\r\n        require(VETH(vether2).currentDay() >= upgradeHeight || VETH(vether2).currentEra() > 1); // Prohibit until upgrade height\r\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0){                               // If hasn't contributed to this Day yet\r\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\r\n            mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member\r\n            mapEraDay_Members[_era][_day].push(_member);                                    // Add member\r\n        }\r\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\r\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\r\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\r\n        totalBurnt += _eth;                                                                 // Add to total burnt\r\n        emit Burn(_payer, _member, _era, _day, _eth, mapEraDay_Units[_era][_day]);          // Burn event\r\n        _updateEmission();                                                                  // Update emission Schedule\r\n    }\r\n    // Allows changing an excluded address\r\n    function changeExcluded(address excluded) external {    \r\n        if(!mapAddress_Excluded[excluded]){\r\n            _transfer(msg.sender, address(this), mapEra_Emission[1]/16);                    // Pay fee of 128 Vether\r\n            mapAddress_Excluded[excluded] = true;                                           // Add desired address\r\n            excludedArray.push(excluded); excludedCount +=1;                                // Record details\r\n            totalFees += mapEra_Emission[1]/16;                                             // Record fees\r\n            mapAddress_BlockChange[excluded] = block.number;                                // Record time of change\r\n        } else {\r\n            _transfer(msg.sender, address(this), mapEra_Emission[1]/32);                    // Pay fee of 64 Vether\r\n            mapAddress_Excluded[excluded] = false;                                          // Change desired address\r\n            totalFees += mapEra_Emission[1]/32;                                             // Record fees\r\n            mapAddress_BlockChange[excluded] = block.number;                                // Record time of change\r\n        }               \r\n    }\r\n    //======================================WITHDRAWAL======================================//\r\n    // Used to efficiently track participation in each era\r\n    function getDaysContributedForEra(address member, uint era) public view returns(uint){\r\n        return mapMemberEra_Days[member][era].length;\r\n    }\r\n    // Call to withdraw a claim\r\n    function withdrawShare(uint era, uint day) external returns (uint value) {\r\n        value = _withdrawShare(era, day, msg.sender);                           \r\n    }\r\n    // Call to withdraw a claim for another member\r\n    function withdrawShareForMember(uint era, uint day, address member) external returns (uint value) {\r\n        value = _withdrawShare(era, day, member);\r\n    }\r\n    // Internal - withdraw function\r\n    function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {\r\n        _updateEmission(); \r\n        if (_era < currentEra) {                                                            // Allow if in previous Era\r\n            value = _processWithdrawal(_era, _day, _member);                                // Process Withdrawal\r\n        } else if (_era == currentEra) {                                                    // Handle if in current Era\r\n            if (_day < currentDay) {                                                        // Allow only if in previous Day\r\n                value = _processWithdrawal(_era, _day, _member);                            // Process Withdrawal\r\n            }\r\n        }  \r\n        return value;\r\n    }\r\n    // Internal - Withdrawal function\r\n    function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {\r\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                      // Get Member Units\r\n        if (memberUnits == 0) { \r\n            value = 0;                                                                      // Do nothing if 0 (prevents revert)\r\n        } else {\r\n            value = getEmissionShare(_era, _day, _member);                                  // Get the emission Share for Member\r\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\r\n            mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units\r\n            mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission\r\n            totalEmitted += value;                                                          // Add to Total Emitted\r\n            _transfer(address(this), _member, value);                                       // ERC20 transfer function\r\n            emit Withdrawal(msg.sender, _member, _era, _day, \r\n            value, mapEraDay_EmissionRemaining[_era][_day]);\r\n        }\r\n        return value;\r\n    }\r\n    // Get emission Share function\r\n    function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {\r\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units\r\n        if (memberUnits == 0) {\r\n            return 0;                                                                       // If 0, return 0\r\n        } else {\r\n            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units\r\n            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day\r\n            uint balance = _balances[address(this)];                                        // Find remaining balance\r\n            if (emissionRemaining > balance) { emissionRemaining = balance; }               // In case less than required emission\r\n            value = (emissionRemaining * memberUnits) / totalUnits;                         // Calculate share\r\n            return  value;                            \r\n        }\r\n    }\r\n    //======================================EMISSION========================================//\r\n    // Internal - Update emission function\r\n    function _updateEmission() private {\r\n        uint _now = now;                                                                    // Find now()\r\n        if (_now >= nextDayTime) {                                                          // If time passed the next Day time\r\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\r\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\r\n                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time\r\n                emission = getNextEraEmission();                                            // Get correct emission\r\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\r\n                emit NewEra(currentEra, emission, nextEraTime, totalBurnt);                 // Emit Event\r\n            }\r\n            currentDay += 1;                                                                // Increment Day\r\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\r\n            emission = getDayEmission();                                                    // Check daily Dmission\r\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\r\n            uint _era = currentEra; uint _day = currentDay-1;\r\n            if(currentDay == 1){ _era = currentEra-1; _day = daysPerEra; }                  // Handle New Era\r\n            emit NewDay(currentEra, currentDay, nextDayTime, \r\n            mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);                // Emit Event\r\n        }\r\n    }\r\n    // Calculate Era emission\r\n    function getNextEraEmission() public view returns (uint) {\r\n        if (emission > coin) {                                                              // Normal Emission Schedule\r\n            return emission / 2;                                                            // Emissions: 2048 -> 1.0\r\n        } else{                                                                             // Enters Fee Era\r\n            return coin;                                                                    // Return 1.0 from fees\r\n        }\r\n    }\r\n    // Calculate Day emission\r\n    function getDayEmission() public view returns (uint) {\r\n        uint balance = _balances[address(this)];                                            // Find remaining balance\r\n        if (balance > emission) {                                                           // Balance is sufficient\r\n            return emission;                                                                // Return emission\r\n        } else {                                                                            // Balance has dropped low\r\n            return balance;                                                                 // Return full balance\r\n        }\r\n    }\r\n}"}
{"address": "0x6847259b2b3a4c17e7c43c54409810af48ba5210", "attacktype": "Absence of code logic or sanity check, Other unsafe DeFi protocol dependency", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/pickle-swap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\n\\nimport \\\"./lib/erc20.sol\\\";\\n\\nimport \\\"./interfaces/uniswapv2.sol\\\";\\n\\ncontract PickleSwap {\\n    using SafeERC20 for IERC20;\\n\\n    UniswapRouterV2 router = UniswapRouterV2(\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n    );\\n\\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    function convertWETHPair(\\n        address fromLP,\\n        address toLP,\\n        uint256 value\\n    ) public {\\n        IUniswapV2Pair fromPair = IUniswapV2Pair(fromLP);\\n        IUniswapV2Pair toPair = IUniswapV2Pair(toLP);\\n\\n        // Only for WETH/<TOKEN> pairs\\n        if (!(fromPair.token0() == weth || fromPair.token1() == weth)) {\\n            revert(\\\"!eth-from\\\");\\n        }\\n        if (!(toPair.token0() == weth || toPair.token1() == weth)) {\\n            revert(\\\"!eth-to\\\");\\n        }\\n\\n        // Get non-eth token from pairs\\n        address _from = fromPair.token0() != weth\\n            ? fromPair.token0()\\n            : fromPair.token1();\\n\\n        address _to = toPair.token0() != weth\\n            ? toPair.token0()\\n            : toPair.token1();\\n\\n        // Transfer\\n        IERC20(fromLP).safeTransferFrom(msg.sender, address(this), value);\\n\\n        // Remove liquidity\\n        IERC20(fromLP).safeApprove(address(router), 0);\\n        IERC20(fromLP).safeApprove(address(router), value);\\n        router.removeLiquidity(\\n            fromPair.token0(),\\n            fromPair.token1(),\\n            value,\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n\\n        // Convert to target token\\n        address[] memory path = new address[](3);\\n        path[0] = _from;\\n        path[1] = weth;\\n        path[2] = _to;\\n\\n        IERC20(_from).safeApprove(address(router), 0);\\n        IERC20(_from).safeApprove(address(router), uint256(-1));\\n        router.swapExactTokensForTokens(\\n            IERC20(_from).balanceOf(address(this)),\\n            0,\\n            path,\\n            address(this),\\n            now + 60\\n        );\\n\\n        // Supply liquidity\\n        IERC20(weth).safeApprove(address(router), 0);\\n        IERC20(weth).safeApprove(address(router), uint256(-1));\\n\\n        IERC20(_to).safeApprove(address(router), 0);\\n        IERC20(_to).safeApprove(address(router), uint256(-1));\\n        router.addLiquidity(\\n            weth,\\n            _to,\\n            IERC20(weth).balanceOf(address(this)),\\n            IERC20(_to).balanceOf(address(this)),\\n            0,\\n            0,\\n            msg.sender,\\n            now + 60\\n        );\\n\\n        // Refund sender any remaining tokens\\n        IERC20(weth).safeTransfer(\\n            msg.sender,\\n            IERC20(weth).balanceOf(address(this))\\n        );\\n        IERC20(_to).safeTransfer(msg.sender, IERC20(_to).balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/exponential.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./careful-math.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract Exponential is CarefulMath {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Creates an exponential from numerator and denominator values.\\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n     *            or if `denom` is zero.\\n     */\\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n    }\\n\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\\n     */\\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(product));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return addUInt(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Divide an Exp by a scalar, returning a new Exp.\\n     */\\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, returning a new Exp.\\n     */\\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\\n        /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n        return getExp(numerator, divisor.mantissa);\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n     */\\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(fraction));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n\\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        // We add half the scale before dividing so that we get rounding instead of truncation.\\n        //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n     */\\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n     */\\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\\n        return getExp(a.mantissa, b.mantissa);\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\n        require(n < 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return add_(a, b, \\\"addition overflow\\\");\\n    }\\n\\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return sub_(a, b, \\\"subtraction underflow\\\");\\n    }\\n\\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return mul_(a, b, \\\"multiplication overflow\\\");\\n    }\\n\\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint c = a * b;\\n        require(c / a == b, errorMessage);\\n        return c;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return div_(a, b, \\\"divide by zero\\\");\\n    }\\n\\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\"\r\n    },\r\n    \"src/lib/context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/enumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/owned.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\n// https://docs.synthetix.io/contracts/Owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(\\n            msg.sender == nominatedOwner,\\n            \\\"You must be nominated before you can accept ownership\\\"\\n        );\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(\\n            msg.sender == owner,\\n            \\\"Only the contract owner may perform this action\\\"\\n        );\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\"\r\n    },\r\n    \"src/lib/ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/erc20.sol\": {\r\n      \"content\": \"\\n// File: contracts/GSN/Context.sol\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./safe-math.sol\\\";\\nimport \\\"./context.sol\\\";\\n\\n// File: contracts/token/ERC20/IERC20.sol\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n// File: contracts/utils/Address.sol\\n\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n// File: contracts/token/ERC20/ERC20.sol\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"src/lib/pausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\n// Inheritance\\nimport \\\"./owned.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/Pausable\\nabstract contract Pausable is Owned {\\n    uint256 public lastPauseTime;\\n    bool public paused;\\n\\n    constructor() internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\\n    }\\n\\n    /**\\n     * @notice Change the paused state of the contract\\n     * @dev Only the contract owner may call this.\\n     */\\n    function setPaused(bool _paused) external onlyOwner {\\n        // Ensure we're actually changing the state before we do anything\\n        if (_paused == paused) {\\n            return;\\n        }\\n\\n        // Set our paused state.\\n        paused = _paused;\\n\\n        // If applicable, set the last pause time.\\n        if (paused) {\\n            lastPauseTime = now;\\n        }\\n\\n        // Let everyone know that our pause state has changed.\\n        emit PauseChanged(paused);\\n    }\\n\\n    event PauseChanged(bool isPaused);\\n\\n    modifier notPaused {\\n        require(\\n            !paused,\\n            \\\"This action cannot be performed while the contract is paused\\\"\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/careful-math.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n  * @title Careful Math\\n  * @author Compound\\n  * @notice Derived from OpenZeppelin's SafeMath library\\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n  */\\ncontract CarefulMath {\\n\\n    /**\\n     * @dev Possible error codes that we can return\\n     */\\n    enum MathError {\\n        NO_ERROR,\\n        DIVISION_BY_ZERO,\\n        INTEGER_OVERFLOW,\\n        INTEGER_UNDERFLOW\\n    }\\n\\n    /**\\n    * @dev Multiplies two numbers, returns an error on overflow.\\n    */\\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        if (b <= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, returns an error on overflow.\\n    */\\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n        uint c = a + b;\\n\\n        if (c >= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n    * @dev add a and b and then subtract c\\n    */\\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\\n        (MathError err0, uint sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n}\"\r\n    },\r\n    \"src/lib/safe-math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"src/lib/reentrancy-guard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"src/interfaces/usdt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// https://forum.openzeppelin.com/t/can-not-call-the-function-approve-of-the-usdt-contract/2130/2\\n// USDT is gay and should be ashamed\\n\\npragma solidity ^0.6.0;\\n\\ninterface USDT {\\n    function approve(address guy, uint256 wad) external;\\n\\n    function transfer(address _to, uint256 _value) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/jar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../lib/erc20.sol\\\";\\n\\ninterface IJar is IERC20 {\\n    function token() external view returns (address);\\n\\n    function claimInsurance() external; // NOTE: Only yDelegatedVault implements this\\n\\n    function getRatio() external view returns (uint256);\\n\\n    function deposit(uint256) external;\\n\\n    function withdraw(uint256) external;\\n\\n    function earn() external;\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/converter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\ninterface Converter {\\n    function convert(address) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/compound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface ICToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function totalBorrows() external returns (uint256);\\n\\n    function borrowIndex() external returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external returns (uint256);\\n\\n    function getAccountSnapshot(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    function supplyRatePerBlock() external view returns (uint256);\\n\\n    function totalBorrowsCurrent() external returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external returns (uint256);\\n\\n    function borrowBalanceStored(address account)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function getCash() external view returns (uint256);\\n\\n    function accrueInterest() external returns (uint256);\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external returns (uint256);\\n}\\n\\ninterface ICEther {\\n    function mint() external payable;\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    /**\\n     * @notice Sender borrows assets from the protocol to their own address\\n     * @param borrowAmount The amount of the underlying asset to borrow\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @dev Reverts upon any failure\\n     */\\n    function repayBorrow() external payable;\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @dev Reverts upon any failure\\n     * @param borrower the account with the debt being payed off\\n     */\\n    function repayBorrowBehalf(address borrower) external payable;\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @dev Reverts upon any failure\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     */\\n    function liquidateBorrow(address borrower, address cTokenCollateral)\\n        external\\n        payable;\\n}\\n\\ninterface IComptroller {\\n    function compAccrued(address) external view returns (uint256);\\n\\n    function compSupplierIndex(address, address)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function compBorrowerIndex(address, address)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function compSpeeds(address) external view returns (uint256);\\n\\n    function compBorrowState(address) external view returns (uint224, uint32);\\n\\n    function compSupplyState(address) external view returns (uint224, uint32);\\n\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata cTokens)\\n        external\\n        returns (uint256[] memory);\\n\\n    function exitMarket(address cToken) external returns (uint256);\\n\\n    /*** Policy Hooks ***/\\n\\n    function mintAllowed(\\n        address cToken,\\n        address minter,\\n        uint256 mintAmount\\n    ) external returns (uint256);\\n\\n    function mintVerify(\\n        address cToken,\\n        address minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    ) external;\\n\\n    function redeemAllowed(\\n        address cToken,\\n        address redeemer,\\n        uint256 redeemTokens\\n    ) external returns (uint256);\\n\\n    function redeemVerify(\\n        address cToken,\\n        address redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    ) external;\\n\\n    function borrowAllowed(\\n        address cToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external returns (uint256);\\n\\n    function borrowVerify(\\n        address cToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external;\\n\\n    function repayBorrowAllowed(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256);\\n\\n    function repayBorrowVerify(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount,\\n        uint256 borrowerIndex\\n    ) external;\\n\\n    function liquidateBorrowAllowed(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256);\\n\\n    function liquidateBorrowVerify(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        uint256 seizeTokens\\n    ) external;\\n\\n    function seizeAllowed(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external returns (uint256);\\n\\n    function seizeVerify(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external;\\n\\n    function transferAllowed(\\n        address cToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external returns (uint256);\\n\\n    function transferVerify(\\n        address cToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external;\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        uint256 repayAmount\\n    ) external view returns (uint256, uint256);\\n\\n    // Claim all the COMP accrued by holder in all markets\\n    function claimComp(address holder) external;\\n\\n    // Claim all the COMP accrued by holder in specific markets\\n    function claimComp(address holder, address[] calldata cTokens) external;\\n\\n    // Claim all the COMP accrued by specific holders in specific markets for their supplies and/or borrows\\n    function claimComp(\\n        address[] calldata holders,\\n        address[] calldata cTokens,\\n        bool borrowers,\\n        bool suppliers\\n    ) external;\\n\\n    function markets(address cTokenAddress)\\n        external\\n        view\\n        returns (bool, uint256);\\n}\\n\\ninterface ICompoundLens {\\n    function getCompBalanceMetadataExt(\\n        address comp,\\n        address comptroller,\\n        address account\\n    )\\n        external\\n        returns (\\n            uint256 balance,\\n            uint256 votes,\\n            address delegate,\\n            uint256 allocated\\n        );\\n}\\n\"\r\n    },\r\n    \"src/interfaces/proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\n\\ninterface Proxy {\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool, bytes memory);\\n\\n    function increaseAmount(uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/curve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\ninterface ICurveFi_2 {\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\\n        external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[2] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts)\\n        external;\\n\\n    function exchange(\\n        int128 from,\\n        int128 to,\\n        uint256 _from_amount,\\n        uint256 _min_to_amount\\n    ) external;\\n\\n    function balances(int128) external view returns (uint256);\\n}\\n\\ninterface ICurveFi_3 {\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount)\\n        external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[3] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts)\\n        external;\\n\\n    function exchange(\\n        int128 from,\\n        int128 to,\\n        uint256 _from_amount,\\n        uint256 _min_to_amount\\n    ) external;\\n\\n    function balances(uint256) external view returns (uint256);\\n}\\n\\ninterface ICurveFi_4 {\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function add_liquidity(uint256[4] calldata amounts, uint256 min_mint_amount)\\n        external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[4] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts)\\n        external;\\n\\n    function exchange(\\n        int128 from,\\n        int128 to,\\n        uint256 _from_amount,\\n        uint256 _min_to_amount\\n    ) external;\\n\\n    function balances(int128) external view returns (uint256);\\n}\\n\\ninterface ICurveZap_4 {\\n    function add_liquidity(\\n        uint256[4] calldata uamounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[4] calldata min_uamounts)\\n        external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[4] calldata uamounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\\n        external\\n        returns (uint256);\\n\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        int128 i,\\n        uint256 min_uamount\\n    ) external;\\n\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        int128 i,\\n        uint256 min_uamount,\\n        bool donate_dust\\n    ) external;\\n\\n    function withdraw_donated_dust() external;\\n\\n    function coins(int128 arg0) external returns (address);\\n\\n    function underlying_coins(int128 arg0) external returns (address);\\n\\n    function curve() external returns (address);\\n\\n    function token() external returns (address);\\n}\\n\\ninterface ICurveZap {\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        int128 i,\\n        uint256 min_uamount\\n    ) external;\\n}\\n\\ninterface ICurveGauge {\\n    function deposit(uint256 _value) external;\\n\\n    function deposit(uint256 _value, address addr) external;\\n\\n    function balanceOf(address arg0) external view returns (uint256);\\n\\n    function withdraw(uint256 _value) external;\\n\\n    function withdraw(uint256 _value, bool claim_rewards) external;\\n\\n    function claim_rewards() external;\\n\\n    function claim_rewards(address addr) external;\\n\\n    function claimable_tokens(address addr) external returns (uint256);\\n\\n    function claimable_reward(address addr) external view returns (uint256);\\n\\n    function integrate_fraction(address arg0) external view returns (uint256);\\n}\\n\\ninterface ICurveMintr {\\n    function mint(address) external;\\n\\n    function minted(address arg0, address arg1) external view returns (uint256);\\n}\\n\\ninterface ICurveVotingEscrow {\\n    function locked(address arg0)\\n        external\\n        view\\n        returns (int128 amount, uint256 end);\\n\\n    function locked__end(address _addr) external view returns (uint256);\\n\\n    function create_lock(uint256, uint256) external;\\n\\n    function increase_amount(uint256) external;\\n\\n    function increase_unlock_time(uint256 _unlock_time) external;\\n\\n    function withdraw() external;\\n\\n    function smart_wallet_checker() external returns (address);\\n}\\n\\ninterface ICurveSmartContractChecker {\\n    function wallets(address) external returns (bool);\\n\\n    function approveWallet(address _wallet) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/uniswapv2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\ninterface UniswapRouterV2 {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapV2Pair {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/jar-converter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\ninterface IJarConverter {\\n    function convert(\\n        address _refundExcess, // address to send the excess amount when adding liquidity\\n        uint256 _amount, // UNI LP Amount\\n        bytes calldata _data\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/controller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IController {\\n    function jars(address) external view returns (address);\\n\\n    function rewards() external view returns (address);\\n\\n    function devfund() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function withdraw(address, uint256) external;\\n\\n    function earn(address, uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/masterchef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\ninterface IMasterchef {\\n    function BONUS_MULTIPLIER() external view returns (uint256);\\n\\n    function add(\\n        uint256 _allocPoint,\\n        address _lpToken,\\n        bool _withUpdate\\n    ) external;\\n\\n    function bonusEndBlock() external view returns (uint256);\\n\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n\\n    function dev(address _devaddr) external;\\n\\n    function devFundDivRate() external view returns (uint256);\\n\\n    function devaddr() external view returns (address);\\n\\n    function emergencyWithdraw(uint256 _pid) external;\\n\\n    function getMultiplier(uint256 _from, uint256 _to)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function massUpdatePools() external;\\n\\n    function owner() external view returns (address);\\n\\n    function pendingPickle(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function pickle() external view returns (address);\\n\\n    function picklePerBlock() external view returns (uint256);\\n\\n    function poolInfo(uint256)\\n        external\\n        view\\n        returns (\\n            address lpToken,\\n            uint256 allocPoint,\\n            uint256 lastRewardBlock,\\n            uint256 accPicklePerShare\\n        );\\n\\n    function poolLength() external view returns (uint256);\\n\\n    function renounceOwnership() external;\\n\\n    function set(\\n        uint256 _pid,\\n        uint256 _allocPoint,\\n        bool _withUpdate\\n    ) external;\\n\\n    function setBonusEndBlock(uint256 _bonusEndBlock) external;\\n\\n    function setDevFundDivRate(uint256 _devFundDivRate) external;\\n\\n    function setPicklePerBlock(uint256 _picklePerBlock) external;\\n\\n    function startBlock() external view returns (uint256);\\n\\n    function totalAllocPoint() external view returns (uint256);\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function updatePool(uint256 _pid) external;\\n\\n    function userInfo(uint256, address)\\n        external\\n        view\\n        returns (uint256 amount, uint256 rewardDebt);\\n\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/staking-rewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\ninterface IStakingRewards {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function earned(address account) external view returns (uint256);\\n\\n    function exit() external;\\n\\n    function getReward() external;\\n\\n    function getRewardForDuration() external view returns (uint256);\\n\\n    function lastTimeRewardApplicable() external view returns (uint256);\\n\\n    function lastUpdateTime() external view returns (uint256);\\n\\n    function notifyRewardAmount(uint256 reward) external;\\n\\n    function periodFinish() external view returns (uint256);\\n\\n    function rewardPerToken() external view returns (uint256);\\n\\n    function rewardPerTokenStored() external view returns (uint256);\\n\\n    function rewardRate() external view returns (uint256);\\n\\n    function rewards(address) external view returns (uint256);\\n\\n    function rewardsDistribution() external view returns (address);\\n\\n    function rewardsDuration() external view returns (uint256);\\n\\n    function rewardsToken() external view returns (address);\\n\\n    function stake(uint256 amount) external;\\n\\n    function stakeWithPermit(\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function stakingToken() external view returns (address);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function userRewardPerTokenPaid(address) external view returns (uint256);\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\\ninterface IStakingRewardsFactory {\\n    function deploy(address stakingToken, uint256 rewardAmount) external;\\n\\n    function isOwner() external view returns (bool);\\n\\n    function notifyRewardAmount(address stakingToken) external;\\n\\n    function notifyRewardAmounts() external;\\n\\n    function owner() external view returns (address);\\n\\n    function renounceOwnership() external;\\n\\n    function rewardsToken() external view returns (address);\\n\\n    function stakingRewardsGenesis() external view returns (uint256);\\n\\n    function stakingRewardsInfoByStakingToken(address)\\n        external\\n        view\\n        returns (address stakingRewards, uint256 rewardAmount);\\n\\n    function stakingTokens(uint256) external view returns (address);\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/weth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface WETH {\\n    function name() external view returns (string memory);\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function deposit() external payable;\\n\\n    function allowance(address, address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/strategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\ninterface IStrategy {\\n    function rewards() external view returns (address);\\n\\n    function gauge() external view returns (address);\\n\\n    function want() external view returns (address);\\n\\n    function timelock() external view returns (address);\\n\\n    function deposit() external;\\n\\n    function withdrawForSwap(uint256) external returns (uint256);\\n\\n    function withdraw(address) external;\\n\\n    function withdraw(uint256) external;\\n\\n    function skim() external;\\n\\n    function withdrawAll() external returns (uint256);\\n\\n    function balanceOf() external view returns (uint256);\\n\\n    function harvest() external;\\n\\n    function setTimelock(address) external;\\n\\n    function setController(address _controller) external;\\n\\n    function execute(address _target, bytes calldata _data)\\n        external\\n        payable\\n        returns (bytes memory response);\\n\\n    function execute(bytes calldata _data)\\n        external\\n        payable\\n        returns (bytes memory response);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/onesplit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\ninterface OneSplitAudit {\\n    function getExpectedReturn(\\n        address fromToken,\\n        address toToken,\\n        uint256 amount,\\n        uint256 parts,\\n        uint256 featureFlags\\n    )\\n        external\\n        view\\n        returns (uint256 returnAmount, uint256[] memory distribution);\\n\\n    function swap(\\n        address fromToken,\\n        address toToken,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256[] calldata distribution,\\n        uint256 featureFlags\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/controller-v4.sol\": {\r\n      \"content\": \"// https://github.com/iearn-finance/jars/blob/master/contracts/controllers/StrategyControllerV1.sol\\n\\npragma solidity ^0.6.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/controller.sol\\\";\\n\\nimport \\\"./lib/erc20.sol\\\";\\nimport \\\"./lib/safe-math.sol\\\";\\n\\nimport \\\"./interfaces/jar.sol\\\";\\nimport \\\"./interfaces/jar-converter.sol\\\";\\nimport \\\"./interfaces/onesplit.sol\\\";\\nimport \\\"./interfaces/strategy.sol\\\";\\nimport \\\"./interfaces/converter.sol\\\";\\n\\ncontract ControllerV4 {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    address public constant burn = 0x000000000000000000000000000000000000dEaD;\\n    address public onesplit = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\\n\\n    address public governance;\\n    address public strategist;\\n    address public devfund;\\n    address public treasury;\\n    address public timelock;\\n\\n    // Convenience fee 0.1%\\n    uint256 public convenienceFee = 100;\\n    uint256 public constant convenienceFeeMax = 100000;\\n\\n    mapping(address => address) public jars;\\n    mapping(address => address) public strategies;\\n    mapping(address => mapping(address => address)) public converters;\\n    mapping(address => mapping(address => bool)) public approvedStrategies;\\n    mapping(address => bool) public approvedJarConverters;\\n\\n    uint256 public split = 500;\\n    uint256 public constant max = 10000;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _timelock,\\n        address _devfund,\\n        address _treasury\\n    ) public {\\n        governance = _governance;\\n        strategist = _strategist;\\n        timelock = _timelock;\\n        devfund = _devfund;\\n        treasury = _treasury;\\n    }\\n\\n    function setDevFund(address _devfund) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        devfund = _devfund;\\n    }\\n\\n    function setTreasury(address _treasury) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        treasury = _treasury;\\n    }\\n\\n    function setStrategist(address _strategist) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        strategist = _strategist;\\n    }\\n\\n    function setSplit(uint256 _split) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        split = _split;\\n    }\\n\\n    function setOneSplit(address _onesplit) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        onesplit = _onesplit;\\n    }\\n\\n    function setGovernance(address _governance) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        governance = _governance;\\n    }\\n\\n    function setTimelock(address _timelock) public {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        timelock = _timelock;\\n    }\\n\\n    function setJar(address _token, address _jar) public {\\n        require(\\n            msg.sender == strategist || msg.sender == governance,\\n            \\\"!strategist\\\"\\n        );\\n        require(jars[_token] == address(0), \\\"jar\\\");\\n        jars[_token] = _jar;\\n    }\\n\\n    function approveJarConverter(address _converter) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        approvedJarConverters[_converter] = true;\\n    }\\n\\n    function revokeJarConverter(address _converter) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        approvedJarConverters[_converter] = false;\\n    }\\n\\n    function approveStrategy(address _token, address _strategy) public {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        approvedStrategies[_token][_strategy] = true;\\n    }\\n\\n    function revokeStrategy(address _token, address _strategy) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        approvedStrategies[_token][_strategy] = false;\\n    }\\n\\n    function setConvenienceFee(uint256 _convenienceFee) external {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        convenienceFee = _convenienceFee;\\n    }\\n\\n    function setStrategy(address _token, address _strategy) public {\\n        require(\\n            msg.sender == strategist || msg.sender == governance,\\n            \\\"!strategist\\\"\\n        );\\n        require(approvedStrategies[_token][_strategy] == true, \\\"!approved\\\");\\n\\n        address _current = strategies[_token];\\n        if (_current != address(0)) {\\n            IStrategy(_current).withdrawAll();\\n        }\\n        strategies[_token] = _strategy;\\n    }\\n\\n    function earn(address _token, uint256 _amount) public {\\n        address _strategy = strategies[_token];\\n        address _want = IStrategy(_strategy).want();\\n        if (_want != _token) {\\n            address converter = converters[_token][_want];\\n            IERC20(_token).safeTransfer(converter, _amount);\\n            _amount = Converter(converter).convert(_strategy);\\n            IERC20(_want).safeTransfer(_strategy, _amount);\\n        } else {\\n            IERC20(_token).safeTransfer(_strategy, _amount);\\n        }\\n        IStrategy(_strategy).deposit();\\n    }\\n\\n    function balanceOf(address _token) external view returns (uint256) {\\n        return IStrategy(strategies[_token]).balanceOf();\\n    }\\n\\n    function withdrawAll(address _token) public {\\n        require(\\n            msg.sender == strategist || msg.sender == governance,\\n            \\\"!strategist\\\"\\n        );\\n        IStrategy(strategies[_token]).withdrawAll();\\n    }\\n\\n    function inCaseTokensGetStuck(address _token, uint256 _amount) public {\\n        require(\\n            msg.sender == strategist || msg.sender == governance,\\n            \\\"!governance\\\"\\n        );\\n        IERC20(_token).safeTransfer(msg.sender, _amount);\\n    }\\n\\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token)\\n        public\\n    {\\n        require(\\n            msg.sender == strategist || msg.sender == governance,\\n            \\\"!governance\\\"\\n        );\\n        IStrategy(_strategy).withdraw(_token);\\n    }\\n\\n    function getExpectedReturn(\\n        address _strategy,\\n        address _token,\\n        uint256 parts\\n    ) public view returns (uint256 expected) {\\n        uint256 _balance = IERC20(_token).balanceOf(_strategy);\\n        address _want = IStrategy(_strategy).want();\\n        (expected, ) = OneSplitAudit(onesplit).getExpectedReturn(\\n            _token,\\n            _want,\\n            _balance,\\n            parts,\\n            0\\n        );\\n    }\\n\\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\\n    function yearn(\\n        address _strategy,\\n        address _token,\\n        uint256 parts\\n    ) public {\\n        require(\\n            msg.sender == strategist || msg.sender == governance,\\n            \\\"!governance\\\"\\n        );\\n        // This contract should never have value in it, but just incase since this is a public call\\n        uint256 _before = IERC20(_token).balanceOf(address(this));\\n        IStrategy(_strategy).withdraw(_token);\\n        uint256 _after = IERC20(_token).balanceOf(address(this));\\n        if (_after > _before) {\\n            uint256 _amount = _after.sub(_before);\\n            address _want = IStrategy(_strategy).want();\\n            uint256[] memory _distribution;\\n            uint256 _expected;\\n            _before = IERC20(_want).balanceOf(address(this));\\n            IERC20(_token).safeApprove(onesplit, 0);\\n            IERC20(_token).safeApprove(onesplit, _amount);\\n            (_expected, _distribution) = OneSplitAudit(onesplit)\\n                .getExpectedReturn(_token, _want, _amount, parts, 0);\\n            OneSplitAudit(onesplit).swap(\\n                _token,\\n                _want,\\n                _amount,\\n                _expected,\\n                _distribution,\\n                0\\n            );\\n            _after = IERC20(_want).balanceOf(address(this));\\n            if (_after > _before) {\\n                _amount = _after.sub(_before);\\n                uint256 _treasury = _amount.mul(split).div(max);\\n                earn(_want, _amount.sub(_treasury));\\n                IERC20(_want).safeTransfer(treasury, _treasury);\\n            }\\n        }\\n    }\\n\\n    function withdraw(address _token, uint256 _amount) public {\\n        require(msg.sender == jars[_token], \\\"!jar\\\");\\n        IStrategy(strategies[_token]).withdraw(_amount);\\n    }\\n\\n    // Function to swap between jars\\n    function swapExactJarForJar(\\n        address _fromJar, // From which Jar\\n        address _toJar, // To which Jar\\n        uint256 _fromJarAmount, // How much jar tokens to swap\\n        uint256 _toJarMinAmount, // How much jar tokens you'd like at a minimum\\n        address payable[] calldata _targets,\\n        bytes[] calldata _data\\n    ) external returns (uint256) {\\n        require(_targets.length == _data.length, \\\"!length\\\");\\n\\n        // Only return last response\\n        for (uint256 i = 0; i < _targets.length; i++) {\\n            require(_targets[i] != address(0), \\\"!converter\\\");\\n            require(approvedJarConverters[_targets[i]], \\\"!converter\\\");\\n        }\\n\\n        address _fromJarToken = IJar(_fromJar).token();\\n        address _toJarToken = IJar(_toJar).token();\\n\\n        // Get pTokens from msg.sender\\n        IERC20(_fromJar).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            _fromJarAmount\\n        );\\n\\n        // Calculate how much underlying\\n        // is the amount of pTokens worth\\n        uint256 _fromJarUnderlyingAmount = _fromJarAmount\\n            .mul(IJar(_fromJar).getRatio())\\n            .div(10**uint256(IJar(_fromJar).decimals()));\\n\\n        // Call 'withdrawForSwap' on Jar's current strategy if Jar\\n        // doesn't have enough initial capital.\\n        // This has moves the funds from the strategy to the Jar's\\n        // 'earnable' amount. Enabling 'free' withdrawals\\n        uint256 _fromJarAvailUnderlying = IERC20(_fromJarToken).balanceOf(\\n            _fromJar\\n        );\\n        if (_fromJarAvailUnderlying < _fromJarUnderlyingAmount) {\\n            IStrategy(strategies[_fromJarToken]).withdrawForSwap(\\n                _fromJarUnderlyingAmount.sub(_fromJarAvailUnderlying)\\n            );\\n        }\\n\\n        // Withdraw from Jar\\n        // Note: this is free since its still within the \\\"earnable\\\" amount\\n        //       as we transferred the access\\n        IERC20(_fromJar).safeApprove(_fromJar, 0);\\n        IERC20(_fromJar).safeApprove(_fromJar, _fromJarAmount);\\n        IJar(_fromJar).withdraw(_fromJarAmount);\\n\\n        // Calculate fee\\n        uint256 _fromUnderlyingBalance = IERC20(_fromJarToken).balanceOf(\\n            address(this)\\n        );\\n        uint256 _convenienceFee = _fromUnderlyingBalance.mul(convenienceFee).div(\\n            convenienceFeeMax\\n        );\\n\\n        if (_convenienceFee > 1) {\\n            IERC20(_fromJarToken).safeTransfer(devfund, _convenienceFee.div(2));\\n            IERC20(_fromJarToken).safeTransfer(treasury, _convenienceFee.div(2));\\n        }\\n\\n        // Executes sequence of logic\\n        for (uint256 i = 0; i < _targets.length; i++) {\\n            _execute(_targets[i], _data[i]);\\n        }\\n\\n        // Deposit into new Jar\\n        uint256 _toBal = IERC20(_toJarToken).balanceOf(address(this));\\n        IERC20(_toJarToken).safeApprove(_toJar, 0);\\n        IERC20(_toJarToken).safeApprove(_toJar, _toBal);\\n        IJar(_toJar).deposit(_toBal);\\n\\n        // Send Jar Tokens to user\\n        uint256 _toJarBal = IJar(_toJar).balanceOf(address(this));\\n        if (_toJarBal < _toJarMinAmount) {\\n            revert(\\\"!min-jar-amount\\\");\\n        }\\n\\n        IJar(_toJar).transfer(msg.sender, _toJarBal);\\n\\n        return _toJarBal;\\n    }\\n\\n    function _execute(address _target, bytes memory _data)\\n        internal\\n        returns (bytes memory response)\\n    {\\n        require(_target != address(0), \\\"!target\\\");\\n\\n        // call contract in current context\\n        assembly {\\n            let succeeded := delegatecall(\\n                sub(gas(), 5000),\\n                _target,\\n                add(_data, 0x20),\\n                mload(_data),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n\\n            response := mload(0x40)\\n            mstore(\\n                0x40,\\n                add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n            )\\n            mstore(response, size)\\n            returndatacopy(add(response, 0x20), 0, size)\\n\\n            switch iszero(succeeded)\\n                case 1 {\\n                    // throw if delegatecall failed\\n                    revert(add(response, 0x20), size)\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/voting/PicklesInTheCitadel.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ninterface MasterChef {\\n    function userInfo(uint256, address)\\n        external\\n        view\\n        returns (uint256, uint256);\\n}\\n\\ncontract PickleVoteProxy {\\n    // ETH/PICKLE token\\n    IERC20 public constant votes = IERC20(\\n        0xdc98556Ce24f007A5eF6dC1CE96322d65832A819\\n    );\\n\\n    // Pickle's masterchef contract\\n    MasterChef public constant chef = MasterChef(\\n        0xbD17B1ce622d73bD438b9E658acA5996dc394b0d\\n    );\\n\\n    // Pool 0 is the ETH/PICKLE pool\\n    uint256 public constant pool = uint256(0);\\n\\n    // Using 9 decimals as we're square rooting the votes\\n    function decimals() external pure returns (uint8) {\\n        return uint8(9);\\n    }\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"PICKLEs In The Citadel\\\";\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return \\\"PICKLE C\\\";\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return sqrt(votes.totalSupply());\\n    }\\n\\n    function balanceOf(address _voter) external view returns (uint256) {\\n        (uint256 _votes, ) = chef.userInfo(pool, _voter);\\n        return sqrt(_votes);\\n    }\\n\\n    function sqrt(uint256 x) public pure returns (uint256 y) {\\n        uint256 z = (x + 1) / 2;\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n\\n    constructor() public {}\\n}\\n\"\r\n    },\r\n    \"src/proxy-logic/curve.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\nimport \\\"../lib/safe-math.sol\\\";\\nimport \\\"../lib/erc20.sol\\\";\\n\\nimport \\\"../interfaces/uniswapv2.sol\\\";\\nimport \\\"../interfaces/curve.sol\\\";\\n\\n// Converts Curve LP Tokens to UNI LP Tokens\\ncontract CurveProxyLogic {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    function remove_liquidity_one_coin(\\n        address curve,\\n        address curveLp,\\n        int128 index\\n    ) public {\\n        uint256 lpAmount = IERC20(curveLp).balanceOf(address(this));\\n\\n        IERC20(curveLp).safeApprove(curve, 0);\\n        IERC20(curveLp).safeApprove(curve, lpAmount);\\n\\n        ICurveZap(curve).remove_liquidity_one_coin(lpAmount, index, 0);\\n    }\\n\\n    function add_liquidity(\\n        address curve,\\n        bytes4 curveFunctionSig,\\n        uint256 curvePoolSize,\\n        uint256 curveUnderlyingIndex,\\n        address underlying\\n    ) public {\\n        uint256 underlyingAmount = IERC20(underlying).balanceOf(address(this));\\n\\n        // curveFunctionSig should be the abi.encodedFormat of\\n        // add_liquidity(uint256[N_COINS],uint256)\\n        // The reason why its here is because different curve pools\\n        // have a different function signature\\n\\n        uint256[] memory liquidity = new uint256[](curvePoolSize);\\n        liquidity[curveUnderlyingIndex] = underlyingAmount;\\n\\n        bytes memory callData = abi.encodePacked(\\n            curveFunctionSig,\\n            liquidity,\\n            uint256(0)\\n        );\\n\\n        IERC20(underlying).safeApprove(curve, 0);\\n        IERC20(underlying).safeApprove(curve, underlyingAmount);\\n        (bool success, ) = curve.call(callData);\\n        require(success, \\\"!success\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/proxy-logic/uniswapv2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/safe-math.sol\\\";\\nimport \\\"../lib/erc20.sol\\\";\\n\\nimport \\\"../interfaces/uniswapv2.sol\\\";\\nimport \\\"../interfaces/curve.sol\\\";\\n\\n// Converts Curve LP Tokens to UNI LP Tokens\\ncontract UniswapV2ProxyLogic {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IUniswapV2Factory public constant factory = IUniswapV2Factory(\\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\\n    );\\n    UniswapRouterV2 public constant router = UniswapRouterV2(\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n    );\\n\\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    function getSwapAmt(uint256 amtA, uint256 resA)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            sqrt(amtA.mul(resA.mul(3988000).add(amtA.mul(3988009))))\\n                .sub(amtA.mul(1997))\\n                .div(1994);\\n    }\\n\\n    // https://blog.alphafinance.io/onesideduniswap/\\n    // https://github.com/AlphaFinanceLab/alphahomora/blob/88a8dfe4d4fa62b13b40f7983ee2c646f83e63b5/contracts/StrategyAddETHOnly.sol#L39\\n    // AlphaFinance is gripbook licensed\\n    function optimalOneSideSupply(\\n        IUniswapV2Pair pair,\\n        address from,\\n        address to\\n    ) public {\\n        address[] memory path = new address[](2);\\n\\n        // 1. Compute optimal amount of WETH to be converted\\n        (uint256 r0, uint256 r1, ) = pair.getReserves();\\n        uint256 rIn = pair.token0() == from ? r0 : r1;\\n        uint256 aIn = getSwapAmt(rIn, IERC20(from).balanceOf(address(this)));\\n\\n        // 2. Convert that from -> to\\n        path[0] = from;\\n        path[1] = to;\\n\\n        IERC20(from).safeApprove(address(router), 0);\\n        IERC20(from).safeApprove(address(router), aIn);\\n\\n        router.swapExactTokensForTokens(aIn, 0, path, address(this), now + 60);\\n    }\\n\\n    function swapUniswap(address from, address to) public {\\n        require(to != address(0));\\n\\n        address[] memory path;\\n\\n        if (from == weth || to == weth) {\\n            path = new address[](2);\\n            path[0] = from;\\n            path[1] = to;\\n        } else {\\n            path = new address[](3);\\n            path[0] = from;\\n            path[1] = weth;\\n            path[2] = to;\\n        }\\n\\n        uint256 amount = IERC20(from).balanceOf(address(this));\\n\\n        IERC20(from).safeApprove(address(router), 0);\\n        IERC20(from).safeApprove(address(router), amount);\\n        router.swapExactTokensForTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    function removeLiquidity(IUniswapV2Pair pair) public {\\n        uint256 _balance = pair.balanceOf(address(this));\\n        pair.approve(address(router), _balance);\\n\\n        router.removeLiquidity(\\n            pair.token0(),\\n            pair.token1(),\\n            _balance,\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    function supplyLiquidity(\\n        address token0,\\n        address token1\\n    ) public returns (uint256) {\\n        // Add liquidity to uniswap\\n        IERC20(token0).safeApprove(address(router), 0);\\n        IERC20(token0).safeApprove(\\n            address(router),\\n            IERC20(token0).balanceOf(address(this))\\n        );\\n\\n        IERC20(token1).safeApprove(address(router), 0);\\n        IERC20(token1).safeApprove(\\n            address(router),\\n            IERC20(token1).balanceOf(address(this))\\n        );\\n\\n        (, , uint256 _to) = router.addLiquidity(\\n            token0,\\n            token1,\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n\\n        return _to;\\n    }\\n\\n    function refundDust(IUniswapV2Pair pair, address recipient) public {\\n        address token0 = pair.token0();\\n        address token1 = pair.token1();\\n\\n        IERC20(token0).safeTransfer(\\n            recipient,\\n            IERC20(token0).balanceOf(address(this))\\n        );\\n        IERC20(token1).safeTransfer(\\n            recipient,\\n            IERC20(token1).balanceOf(address(this))\\n        );\\n    }\\n\\n    function lpTokensToPrimitive(\\n        IUniswapV2Pair from,\\n        address to\\n    ) public {\\n        if (from.token0() != weth && from.token1() != weth) {\\n            revert(\\\"!from-weth-pair\\\");\\n        }\\n\\n        address fromOther = from.token0() == weth ? from.token1() : from.token0();\\n\\n        // Removes liquidity\\n        removeLiquidity(from);\\n\\n        // Swap from WETH to other\\n        swapUniswap(weth, to);\\n\\n        // If from is not to, we swap them too\\n        if (fromOther != to) {\\n            swapUniswap(fromOther, to);\\n        }\\n    }\\n\\n    function primitiveToLpTokens(\\n        address from,\\n        IUniswapV2Pair to,\\n        address dustRecipient\\n    ) public {\\n        if (to.token0() != weth && to.token1() != weth) {\\n            revert(\\\"!to-weth-pair\\\");\\n        }\\n\\n        address toOther = to.token0() == weth ? to.token1() : to.token0();\\n\\n        // Swap to WETH\\n        swapUniswap(from, weth);\\n\\n        // Optimal supply from WETH to\\n        optimalOneSideSupply(to, weth, toOther);\\n\\n        // Supply tokens\\n        supplyLiquidity(weth, toOther);\\n\\n        // Dust\\n        refundDust(to, dustRecipient);\\n    }\\n\\n    function swapUniLPTokens(\\n        IUniswapV2Pair from,\\n        IUniswapV2Pair to,\\n        address dustRecipient\\n    ) public {\\n        if (from.token0() != weth && from.token1() != weth) {\\n            revert(\\\"!from-weth-pair\\\");\\n        }\\n\\n        if (to.token0() != weth && to.token1() != weth) {\\n            revert(\\\"!to-weth-pair\\\");\\n        }\\n\\n        address fromOther = from.token0() == weth\\n            ? from.token1()\\n            : from.token0();\\n\\n        address toOther = to.token0() == weth ? to.token1() : to.token0();\\n\\n        // Remove weth-<token> pair\\n        removeLiquidity(from);\\n\\n        // Swap <token> to WETH\\n        swapUniswap(fromOther, weth);\\n\\n        // Optimal supply from WETH to <other-token>\\n        optimalOneSideSupply(to, weth, toOther);\\n\\n        // Supply weth-<other-token> pair\\n        supplyLiquidity(weth, toOther);\\n\\n        // Refund dust\\n        refundDust(to, dustRecipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/lib/hevm.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface Hevm {\\n    function warp(uint256) external;\\n    function roll(uint x) external;\\n    function store(address c, bytes32 loc, bytes32 val) external;\\n}\"\r\n    },\r\n    \"src/tests/lib/test-defi-base.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\nimport \\\"../../lib/safe-math.sol\\\";\\nimport \\\"../../lib/erc20.sol\\\";\\n\\nimport \\\"./hevm.sol\\\";\\nimport \\\"./user.sol\\\";\\nimport \\\"./test-approx.sol\\\";\\n\\nimport \\\"../../interfaces/usdt.sol\\\";\\nimport \\\"../../interfaces/weth.sol\\\";\\nimport \\\"../../interfaces/strategy.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\n\\ncontract DSTestDefiBase is DSTestApprox {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    address pickle = 0x429881672B9AE42b8EbA0E26cD9C73711b891Ca5;\\n    address burn = 0x000000000000000000000000000000000000dEaD;\\n\\n    address susdv2_deposit = 0xFCBa3E75865d2d561BE8D220616520c171F12851;\\n\\n    address susdv2_pool = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\\n    address three_pool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\n    address ren_pool = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\\n\\n    address scrv = 0xC25a3A3b969415c80451098fa907EC722572917F;\\n    address three_crv = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\\n    address ren_crv = 0x49849C98ae39Fff122806C06791Fa73784FB3675;\\n\\n    address eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\\n    address snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\\n    address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n    address uni = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\\n\\n    address wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address renbtc = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D;\\n\\n    Hevm hevm = Hevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\\n\\n    UniswapRouterV2 univ2 = UniswapRouterV2(\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n    );\\n\\n    IUniswapV2Factory univ2Factory = IUniswapV2Factory(\\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\\n    );\\n\\n    ICurveFi_4 curveSusdV2 = ICurveFi_4(\\n        0xA5407eAE9Ba41422680e2e00537571bcC53efBfD\\n    );\\n\\n    uint256 startTime = block.timestamp;\\n\\n    receive() external payable {}\\n    fallback () external payable {}\\n\\n    function _swap(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        address[] memory path;\\n\\n        if (_from == eth || _from == weth) {\\n            path = new address[](2);\\n            path[0] = weth;\\n            path[1] = _to;\\n\\n            univ2.swapExactETHForTokens{value: _amount}(\\n                0,\\n                path,\\n                address(this),\\n                now + 60\\n            );\\n        } else {\\n            path = new address[](3);\\n            path[0] = _from;\\n            path[1] = weth;\\n            path[2] = _to;\\n\\n            IERC20(_from).safeApprove(address(univ2), 0);\\n            IERC20(_from).safeApprove(address(univ2), _amount);\\n\\n            univ2.swapExactTokensForTokens(\\n                _amount,\\n                0,\\n                path,\\n                address(this),\\n                now + 60\\n            );\\n        }\\n    }\\n\\n    function _getERC20(address token, uint256 _amount) internal {\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = token;\\n\\n        uint256[] memory ins = univ2.getAmountsIn(_amount, path);\\n        uint256 ethAmount = ins[0];\\n\\n        univ2.swapETHForExactTokens{value: ethAmount}(\\n            _amount,\\n            path,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    function _getERC20WithETH(address token, uint256 _ethAmount) internal {\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = token;\\n\\n        univ2.swapExactETHForTokens{value: _ethAmount}(\\n            0,\\n            path,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    function _getUniV2LPToken(address lpToken, uint256 _ethAmount) internal {\\n        address token0 = IUniswapV2Pair(lpToken).token0();\\n        address token1 = IUniswapV2Pair(lpToken).token1();\\n\\n        if (token0 != weth) {\\n            _getERC20WithETH(token0, _ethAmount.div(2));\\n        } else {\\n            WETH(weth).deposit{value: _ethAmount.div(2)}();\\n        }\\n\\n        if (token1 != weth) {\\n            _getERC20WithETH(token1, _ethAmount.div(2));\\n        } else {\\n            WETH(weth).deposit{value: _ethAmount.div(2)}();\\n        }\\n\\n        IERC20(token0).safeApprove(address(univ2), uint256(0));\\n        IERC20(token0).safeApprove(address(univ2), uint256(-1));\\n\\n        IERC20(token1).safeApprove(address(univ2), uint256(0));\\n        IERC20(token1).safeApprove(address(univ2), uint256(-1));\\n        univ2.addLiquidity(\\n            token0,\\n            token1,\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    function _getUniV2LPToken(\\n        address token0,\\n        address token1,\\n        uint256 _ethAmount\\n    ) internal {\\n        _getUniV2LPToken(univ2Factory.getPair(token0, token1), _ethAmount);\\n    }\\n\\n    function _getFunctionSig(string memory sig) internal pure returns (bytes4) {\\n        return bytes4(keccak256(bytes(sig)));\\n    }\\n\\n    function _getDynamicArray(address payable one)\\n        internal\\n        pure\\n        returns (address payable[] memory)\\n    {\\n        address payable[] memory targets = new address payable[](1);\\n        targets[0] = one;\\n\\n        return targets;\\n    }\\n\\n    function _getDynamicArray(bytes memory one)\\n        internal\\n        pure\\n        returns (bytes[] memory)\\n    {\\n        bytes[] memory data = new bytes[](1);\\n        data[0] = one;\\n\\n        return data;\\n    }\\n\\n    function _getDynamicArray(address payable one, address payable two)\\n        internal\\n        pure\\n        returns (address payable[] memory)\\n    {\\n        address payable[] memory targets = new address payable[](2);\\n        targets[0] = one;\\n        targets[1] = two;\\n\\n        return targets;\\n    }\\n\\n    function _getDynamicArray(bytes memory one, bytes memory two)\\n        internal\\n        pure\\n        returns (bytes[] memory)\\n    {\\n        bytes[] memory data = new bytes[](2);\\n        data[0] = one;\\n        data[1] = two;\\n\\n        return data;\\n    }\\n\\n    function _getDynamicArray(\\n        address payable one,\\n        address payable two,\\n        address payable three\\n    ) internal pure returns (address payable[] memory) {\\n        address payable[] memory targets = new address payable[](3);\\n        targets[0] = one;\\n        targets[1] = two;\\n        targets[2] = three;\\n\\n        return targets;\\n    }\\n\\n    function _getDynamicArray(\\n        bytes memory one,\\n        bytes memory two,\\n        bytes memory three\\n    ) internal pure returns (bytes[] memory) {\\n        bytes[] memory data = new bytes[](3);\\n        data[0] = one;\\n        data[1] = two;\\n        data[2] = three;\\n\\n        return data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/lib/test-strategy-curve-farm-base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\nimport \\\"../lib/hevm.sol\\\";\\nimport \\\"../lib/user.sol\\\";\\nimport \\\"../lib/test-approx.sol\\\";\\nimport \\\"../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../interfaces/strategy.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../pickle-jar.sol\\\";\\nimport \\\"../../controller-v4.sol\\\";\\n\\ncontract StrategyCurveFarmTestBase is DSTestDefiBase {\\n    address governance;\\n    address strategist;\\n    address timelock;\\n\\n    address devfund;\\n    address treasury;\\n\\n    address want;\\n\\n    PickleJar pickleJar;\\n    ControllerV4 controller;\\n    IStrategy strategy;\\n\\n    // **** Tests ****\\n\\n    function _test_withdraw() internal {\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n\\n        // Deposits to strategy\\n        pickleJar.earn();\\n\\n        // Fast forwards\\n        hevm.warp(block.timestamp + 1 weeks);\\n\\n        strategy.harvest();\\n\\n        // Withdraws back to pickleJar\\n        uint256 _before = IERC20(want).balanceOf(address(pickleJar));\\n        controller.withdrawAll(want);\\n        uint256 _after = IERC20(want).balanceOf(address(pickleJar));\\n\\n        assertTrue(_after > _before);\\n\\n        _before = IERC20(want).balanceOf(address(this));\\n        pickleJar.withdrawAll();\\n        _after = IERC20(want).balanceOf(address(this));\\n\\n        assertTrue(_after > _before);\\n\\n        // Gained some interest\\n        assertTrue(_after > _want);\\n    }\\n\\n    function _test_get_earn_harvest_rewards() internal {\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n\\n        // Fast forward one week\\n        hevm.warp(block.timestamp + 1 weeks);\\n\\n        // Call the harvest function\\n        uint256 _before = pickleJar.balance();\\n        uint256 _treasuryBefore = IERC20(want).balanceOf(treasury);\\n        strategy.harvest();\\n        uint256 _after = pickleJar.balance();\\n        uint256 _treasuryAfter = IERC20(want).balanceOf(treasury);\\n\\n        uint256 earned = _after.sub(_before).mul(1000).div(955);\\n        uint256 earnedRewards = earned.mul(45).div(1000); // 4.5%\\n        uint256 actualRewardsEarned = _treasuryAfter.sub(_treasuryBefore);\\n\\n        // 4.5% performance fee is given\\n        assertEqApprox(earnedRewards, actualRewardsEarned);\\n\\n        // Withdraw\\n        uint256 _devBefore = IERC20(want).balanceOf(devfund);\\n        _treasuryBefore = IERC20(want).balanceOf(treasury);\\n        uint256 _stratBal = strategy.balanceOf();\\n        pickleJar.withdrawAll();\\n        uint256 _devAfter = IERC20(want).balanceOf(devfund);\\n        _treasuryAfter = IERC20(want).balanceOf(treasury);\\n\\n        // 0.175% goes to dev\\n        uint256 _devFund = _devAfter.sub(_devBefore);\\n        assertEq(_devFund, _stratBal.mul(175).div(100000));\\n\\n        // 0.325% goes to treasury\\n        uint256 _treasuryFund = _treasuryAfter.sub(_treasuryBefore);\\n        assertEq(_treasuryFund, _stratBal.mul(325).div(100000));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/lib/user.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n// Contract account to simulate another user\\ncontract User {\\n    function execute(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data\\n    ) public payable returns (bytes memory) {\\n        bytes memory callData;\\n\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(\\n                bytes4(keccak256(bytes(signature))),\\n                data\\n            );\\n        }\\n\\n        (bool success, bytes memory returnData) = target.call{value: value}(\\n            callData\\n        );\\n        require(success, \\\"!user-execute\\\");\\n\\n        return returnData;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/lib/test-approx.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\nimport \\\"./test.sol\\\";\\n\\ncontract DSTestApprox is DSTest {\\n    function assertEqApprox(uint256 a, uint256 b) internal {\\n        if (a == 0 && b == 0) {\\n            return;\\n        }\\n\\n        // +/- 5%\\n        uint256 bMax = (b * 105) / 100;\\n        uint256 bMin = (b * 95) / 100;\\n\\n        if (!(a > bMin && a < bMax)) {\\n            emit log_bytes32(\\\"Error: Wrong `a-uint` value!\\\");\\n            emit log_named_uint(\\\"  Expected\\\", b);\\n            emit log_named_uint(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n\\n    function assertEqVerbose(bool a, bytes memory b) internal {\\n        if (!a) {\\n            emit log_bytes32(\\\"Error: assertion error!\\\");\\n            emit logs(b);\\n            fail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/lib/test-strategy-uni-farm-base.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\nimport \\\"../lib/hevm.sol\\\";\\nimport \\\"../lib/user.sol\\\";\\nimport \\\"../lib/test-approx.sol\\\";\\nimport \\\"../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../interfaces/strategy.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../pickle-jar.sol\\\";\\nimport \\\"../../controller-v4.sol\\\";\\n\\ncontract StrategyUniFarmTestBase is DSTestDefiBase {\\n    address want;\\n    address token1;\\n\\n    address governance;\\n    address strategist;\\n    address timelock;\\n\\n    address devfund;\\n    address treasury;\\n\\n    PickleJar pickleJar;\\n    ControllerV4 controller;\\n    IStrategy strategy;\\n\\n    function _getWant(uint256 ethAmount, uint256 amount) internal {\\n        _getERC20(token1, amount);\\n\\n        uint256 _token1 = IERC20(token1).balanceOf(address(this));\\n\\n        IERC20(token1).safeApprove(address(univ2), 0);\\n        IERC20(token1).safeApprove(address(univ2), _token1);\\n\\n        univ2.addLiquidityETH{value: ethAmount}(\\n            token1,\\n            _token1,\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    // **** Tests ****\\n\\n    function _test_timelock() internal {\\n        assertTrue(strategy.timelock() == timelock);\\n        strategy.setTimelock(address(1));\\n        assertTrue(strategy.timelock() == address(1));\\n    }\\n\\n    function _test_withdraw_release() internal {\\n        uint256 decimals = ERC20(token1).decimals();\\n        _getWant(10 ether, 4000 * (10**decimals));\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).safeApprove(address(pickleJar), 0);\\n        IERC20(want).safeApprove(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n        hevm.warp(block.timestamp + 1 weeks);\\n        strategy.harvest();\\n\\n        // Checking withdraw\\n        uint256 _before = IERC20(want).balanceOf(address(pickleJar));\\n        controller.withdrawAll(want);\\n        uint256 _after = IERC20(want).balanceOf(address(pickleJar));\\n        assertTrue(_after > _before);\\n        _before = IERC20(want).balanceOf(address(this));\\n        pickleJar.withdrawAll();\\n        _after = IERC20(want).balanceOf(address(this));\\n        assertTrue(_after > _before);\\n\\n        // Check if we gained interest\\n        assertTrue(_after > _want);\\n    }\\n\\n    function _test_get_earn_harvest_rewards() internal {\\n        uint256 decimals = ERC20(token1).decimals();\\n        _getWant(10 ether, 4000 * (10**decimals));\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).safeApprove(address(pickleJar), 0);\\n        IERC20(want).safeApprove(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n        hevm.warp(block.timestamp + 1 weeks);\\n\\n        // Call the harvest function\\n        uint256 _before = pickleJar.balance();\\n        uint256 _treasuryBefore = IERC20(want).balanceOf(treasury);\\n        strategy.harvest();\\n        uint256 _after = pickleJar.balance();\\n        uint256 _treasuryAfter = IERC20(want).balanceOf(treasury);\\n\\n        uint256 earned = _after.sub(_before).mul(1000).div(955);\\n        uint256 earnedRewards = earned.mul(45).div(1000); // 4.5%\\n        uint256 actualRewardsEarned = _treasuryAfter.sub(_treasuryBefore);\\n\\n        // 4.5% performance fee is given\\n        assertEqApprox(earnedRewards, actualRewardsEarned);\\n\\n        // Withdraw\\n        uint256 _devBefore = IERC20(want).balanceOf(devfund);\\n        _treasuryBefore = IERC20(want).balanceOf(treasury);\\n        uint256 _stratBal = strategy.balanceOf();\\n        pickleJar.withdrawAll();\\n        uint256 _devAfter = IERC20(want).balanceOf(devfund);\\n        _treasuryAfter = IERC20(want).balanceOf(treasury);\\n\\n        // 0.175% goes to dev\\n        uint256 _devFund = _devAfter.sub(_devBefore);\\n        assertEq(_devFund, _stratBal.mul(175).div(100000));\\n\\n        // 0.325% goes to treasury\\n        uint256 _treasuryFund = _treasuryAfter.sub(_treasuryBefore);\\n        assertEq(_treasuryFund, _stratBal.mul(325).div(100000));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/lib/test.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.4.23;\\n\\ncontract DSTest {\\n    event eventListener          (address target, bool exact);\\n    event logs                   (bytes);\\n    event log_bytes32            (bytes32);\\n    event log_named_address      (bytes32 key, address val);\\n    event log_named_bytes32      (bytes32 key, bytes32 val);\\n    event log_named_decimal_int  (bytes32 key, int val, uint decimals);\\n    event log_named_decimal_uint (bytes32 key, uint val, uint decimals);\\n    event log_named_int          (bytes32 key, int val);\\n    event log_named_uint         (bytes32 key, uint val);\\n    event log_named_string       (bytes32 key, string val);\\n\\n    bool public IS_TEST;\\n    bool public failed;\\n\\n    constructor() internal {\\n        IS_TEST = true;\\n    }\\n\\n    function fail() internal {\\n        failed = true;\\n    }\\n\\n    function expectEventsExact(address target) internal {\\n        emit eventListener(target, true);\\n    }\\n\\n    modifier logs_gas() {\\n        uint startGas = gasleft();\\n        _;\\n        uint endGas = gasleft();\\n        emit log_named_uint(\\\"gas\\\", startGas - endGas);\\n    }\\n\\n    function assertTrue(bool condition) internal {\\n        if (!condition) {\\n            emit log_bytes32(\\\"Assertion failed\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(address a, address b) internal {\\n        if (a != b) {\\n            emit log_bytes32(\\\"Error: Wrong `address' value\\\");\\n            emit log_named_address(\\\"  Expected\\\", b);\\n            emit log_named_address(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq32(bytes32 a, bytes32 b) internal {\\n        assertEq(a, b);\\n    }\\n\\n    function assertEq(bytes32 a, bytes32 b) internal {\\n        if (a != b) {\\n            emit log_bytes32(\\\"Error: Wrong `bytes32' value\\\");\\n            emit log_named_bytes32(\\\"  Expected\\\", b);\\n            emit log_named_bytes32(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n\\n    function assertEqDecimal(int a, int b, uint decimals) internal {\\n        if (a != b) {\\n            emit log_bytes32(\\\"Error: Wrong fixed-point decimal\\\");\\n            emit log_named_decimal_int(\\\"  Expected\\\", b, decimals);\\n            emit log_named_decimal_int(\\\"    Actual\\\", a, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a != b) {\\n            emit log_bytes32(\\\"Error: Wrong fixed-point decimal\\\");\\n            emit log_named_decimal_uint(\\\"  Expected\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\"    Actual\\\", a, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(int a, int b) internal {\\n        if (a != b) {\\n            emit log_bytes32(\\\"Error: Wrong `int' value\\\");\\n            emit log_named_int(\\\"  Expected\\\", b);\\n            emit log_named_int(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(uint a, uint b) internal {\\n        if (a != b) {\\n            emit log_bytes32(\\\"Error: Wrong `uint' value\\\");\\n            emit log_named_uint(\\\"  Expected\\\", b);\\n            emit log_named_uint(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log_bytes32(\\\"Error: Wrong `string' value\\\");\\n            emit log_named_string(\\\"  Expected\\\", b);\\n            emit log_named_string(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq0(bytes memory a, bytes memory b) internal {\\n        bool ok = true;\\n\\n        if (a.length == b.length) {\\n            for (uint i = 0; i < a.length; i++) {\\n                if (a[i] != b[i]) {\\n                    ok = false;\\n                }\\n            }\\n        } else {\\n            ok = false;\\n        }\\n\\n        if (!ok) {\\n            emit log_bytes32(\\\"Error: Wrong `bytes' value\\\");\\n            emit log_named_bytes32(\\\"  Expected\\\", \\\"[cannot show `bytes' value]\\\");\\n            emit log_named_bytes32(\\\"  Actual\\\", \\\"[cannot show `bytes' value]\\\");\\n            fail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/lib/mock-erc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\n\\ncontract MockERC20 is ERC20 {\\n    constructor(string memory name, string memory symbol)\\n        public\\n        ERC20(name, symbol)\\n    {}\\n\\n    function mint(address recipient, uint256 amount) public {\\n        _mint(recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/pickle-swap.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\n\\nimport \\\"./lib/test-defi-base.sol\\\";\\nimport \\\"../lib/safe-math.sol\\\";\\n\\nimport \\\"../pickle-swap.sol\\\";\\n\\ncontract PickleSwapTest is DSTestDefiBase {\\n    PickleSwap pickleSwap;\\n\\n    function setUp() public {\\n        pickleSwap = new PickleSwap();\\n    }\\n\\n    function _test_uni_lp_swap(address lp1, address lp2) internal {\\n        _getUniV2LPToken(lp1, 20 ether);\\n        uint256 _balance = IERC20(lp1).balanceOf(address(this));\\n\\n        uint256 _before = IERC20(lp2).balanceOf(address(this));\\n        IERC20(lp1).safeIncreaseAllowance(address(pickleSwap), _balance);\\n        pickleSwap.convertWETHPair(lp1, lp2, _balance);\\n        uint256 _after = IERC20(lp2).balanceOf(address(this));\\n\\n        assertTrue(_after > _before);\\n        assertTrue(_after > 0);\\n    }\\n\\n    function test_pickleswap_dai_usdc() public {\\n        _test_uni_lp_swap(\\n            univ2Factory.getPair(weth, dai),\\n            univ2Factory.getPair(weth, usdc)\\n        );\\n    }\\n\\n    function test_pickleswap_dai_usdt() public {\\n        _test_uni_lp_swap(\\n            univ2Factory.getPair(weth, dai),\\n            univ2Factory.getPair(weth, usdt)\\n        );\\n    }\\n\\n    function test_pickleswap_usdt_susd() public {\\n        _test_uni_lp_swap(\\n            univ2Factory.getPair(weth, usdt),\\n            univ2Factory.getPair(weth, susd)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/uni-curve-converter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\n\\nimport \\\"./lib/test-defi-base.sol\\\";\\nimport \\\"../lib/safe-math.sol\\\";\\n\\nimport \\\"../uni-curve-converter.sol\\\";\\n\\ncontract UniCurveConverterTest is DSTestDefiBase {\\n    UniCurveConverter uniCurveConverter;\\n\\n    function setUp() public {\\n        uniCurveConverter = new UniCurveConverter();\\n    }\\n\\n    function _test_uni_curve_converter(address token0, address token1)\\n        internal\\n    {\\n        address lp = univ2Factory.getPair(token0, token1);\\n        _getUniV2LPToken(lp, 100 ether);\\n\\n        uint256 _balance = IERC20(lp).balanceOf(address(this));\\n\\n        IERC20(lp).safeApprove(address(uniCurveConverter), 0);\\n        IERC20(lp).safeApprove(address(uniCurveConverter), uint256(-1));\\n\\n        uint256 _before = IERC20(scrv).balanceOf(address(this));\\n        uniCurveConverter.convert(lp, _balance);\\n        uint256 _after = IERC20(scrv).balanceOf(address(this));\\n\\n        // Gets scrv\\n        assertTrue(_after > _before);\\n        assertTrue(_after > 0);\\n\\n        // No token left behind in router\\n        assertEq(IERC20(token0).balanceOf(address(uniCurveConverter)), 0);\\n        assertEq(IERC20(token1).balanceOf(address(uniCurveConverter)), 0);\\n        assertEq(IERC20(weth).balanceOf(address(uniCurveConverter)), 0);\\n\\n        assertEq(IERC20(dai).balanceOf(address(uniCurveConverter)), 0);\\n        assertEq(IERC20(usdc).balanceOf(address(uniCurveConverter)), 0);\\n        assertEq(IERC20(usdt).balanceOf(address(uniCurveConverter)), 0);\\n        assertEq(IERC20(susd).balanceOf(address(uniCurveConverter)), 0);\\n    }\\n\\n    function test_uni_curve_convert_dai_weth() public {\\n        _test_uni_curve_converter(dai, weth);\\n    }\\n\\n    function test_uni_curve_convert_usdt_weth() public {\\n        _test_uni_curve_converter(usdt, weth);\\n    }\\n\\n    function test_uni_curve_convert_wbtc_weth() public {\\n        _test_uni_curve_converter(wbtc, weth);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/curve/strategy-curve-scrv-v4_1.test.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/hevm.sol\\\";\\nimport \\\"../../lib/user.sol\\\";\\nimport \\\"../../lib/test-approx.sol\\\";\\nimport \\\"../../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\n\\nimport \\\"../../../strategies/curve/strategy-curve-scrv-v4_1.sol\\\";\\nimport \\\"../../../strategies/curve/scrv-voter.sol\\\";\\nimport \\\"../../../strategies/curve/crv-locker.sol\\\";\\n\\ncontract StrategyCurveSCRVv4Test is DSTestDefiBase {\\n    address escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\\n    address curveSmartContractChecker = 0xca719728Ef172d0961768581fdF35CB116e0B7a4;\\n\\n    address governance;\\n    address strategist;\\n    address timelock;\\n    address devfund;\\n    address treasury;\\n\\n    PickleJar pickleJar;\\n    ControllerV4 controller;\\n    StrategyCurveSCRVv4_1 strategy;\\n    SCRVVoter scrvVoter;\\n    CRVLocker crvLocker;\\n\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(new User());\\n        timelock = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        crvLocker = new CRVLocker(governance);\\n\\n        scrvVoter = new SCRVVoter(governance, address(crvLocker));\\n\\n        strategy = new StrategyCurveSCRVv4_1(\\n            address(scrvVoter),\\n            address(crvLocker),\\n            governance,\\n            strategist,\\n            address(controller),\\n            timelock\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        scrvVoter.approveStrategy(address(strategy));\\n        scrvVoter.approveStrategy(governance);\\n        crvLocker.addVoter(address(scrvVoter));\\n\\n        hevm.warp(startTime);\\n\\n        // Approve our strategy on smartContractWhitelist\\n        // Modify storage value so we are approved by the smart-wallet-white-list\\n        // storage in solidity - https://ethereum.stackexchange.com/a/41304\\n        bytes32 key = bytes32(uint256(address(crvLocker)));\\n        bytes32 pos = bytes32(0); // pos 0 as its the first state variable\\n        bytes32 loc = keccak256(abi.encodePacked(key, pos));\\n        hevm.store(curveSmartContractChecker, loc, bytes32(uint256(1)));\\n\\n        // Make sure our crvLocker is whitelisted\\n        assertTrue(\\n            ICurveSmartContractChecker(curveSmartContractChecker).wallets(\\n                address(crvLocker)\\n            )\\n        );\\n    }\\n\\n    function _getSCRV(uint256 daiAmount) internal {\\n        _getERC20(dai, daiAmount);\\n        uint256[4] memory liquidity;\\n        liquidity[0] = IERC20(dai).balanceOf(address(this));\\n        IERC20(dai).approve(susdv2_pool, liquidity[0]);\\n        ICurveFi_4(susdv2_pool).add_liquidity(liquidity, 0);\\n    }\\n\\n    // **** Tests ****\\n\\n    function test_scrv_v4_1_withdraw() public {\\n        _getSCRV(10000000 ether); // 1 million DAI\\n        uint256 _scrv = IERC20(scrv).balanceOf(address(this));\\n        IERC20(scrv).approve(address(pickleJar), _scrv);\\n        pickleJar.deposit(_scrv);\\n\\n        // Deposits to strategy\\n        pickleJar.earn();\\n\\n        // Fast forwards\\n        hevm.warp(block.timestamp + 1 weeks);\\n\\n        strategy.harvest();\\n\\n        // Withdraws back to pickleJar\\n        uint256 _before = IERC20(scrv).balanceOf(address(pickleJar));\\n        controller.withdrawAll(scrv);\\n        uint256 _after = IERC20(scrv).balanceOf(address(pickleJar));\\n\\n        assertTrue(_after > _before);\\n\\n        _before = IERC20(scrv).balanceOf(address(this));\\n        pickleJar.withdrawAll();\\n        _after = IERC20(scrv).balanceOf(address(this));\\n\\n        assertTrue(_after > _before);\\n\\n        // Gained some interest\\n        assertTrue(_after > _scrv);\\n    }\\n\\n    function test_scrv_v4_1_get_earn_harvest_rewards() public {\\n        address dev = controller.devfund();\\n\\n        // Deposit sCRV, and earn\\n        _getSCRV(10000000 ether); // 1 million DAI\\n        uint256 _scrv = IERC20(scrv).balanceOf(address(this));\\n        IERC20(scrv).approve(address(pickleJar), _scrv);\\n        pickleJar.deposit(_scrv);\\n        pickleJar.earn();\\n\\n        // Fast forward one week\\n        hevm.warp(block.timestamp + 1 weeks);\\n\\n        // Call the harvest function\\n        uint256 _before = pickleJar.balance();\\n        uint256 _rewardsBefore = IERC20(scrv).balanceOf(treasury);\\n        User(strategist).execute(address(strategy), 0, \\\"harvest()\\\", \\\"\\\");\\n        uint256 _after = pickleJar.balance();\\n        uint256 _rewardsAfter = IERC20(scrv).balanceOf(treasury);\\n\\n        uint256 earned = _after.sub(_before).mul(1000).div(955);\\n        uint256 earnedRewards = earned.mul(45).div(1000); // 4.5%\\n        uint256 actualRewardsEarned = _rewardsAfter.sub(_rewardsBefore);\\n\\n        // 4.5% performance fee is given\\n        assertEqApprox(earnedRewards, actualRewardsEarned);\\n\\n        // Withdraw\\n        uint256 _devBefore = IERC20(scrv).balanceOf(dev);\\n        uint256 _stratBal = strategy.balanceOf();\\n        pickleJar.withdrawAll();\\n        uint256 _devAfter = IERC20(scrv).balanceOf(dev);\\n\\n        // 0.175% goes to dev\\n        uint256 _devFund = _devAfter.sub(_devBefore);\\n        assertEq(_devFund, _stratBal.mul(175).div(100000));\\n    }\\n\\n    function test_scrv_v4_1_lock() public {\\n        // Deposit sCRV, and earn\\n        _getSCRV(10000000 ether); // 1 million DAI\\n        uint256 _scrv = IERC20(scrv).balanceOf(address(this));\\n        IERC20(scrv).approve(address(pickleJar), _scrv);\\n        pickleJar.deposit(_scrv);\\n        pickleJar.earn();\\n\\n        // Fast forward one week\\n        hevm.warp(block.timestamp + 1 weeks);\\n\\n        uint256 _before = IERC20(crv).balanceOf(address(crvLocker));\\n        // Call the harvest function\\n        strategy.harvest();\\n        // Make sure we can open lock\\n        uint256 _after = IERC20(crv).balanceOf(address(crvLocker));\\n        assertTrue(_after > _before);\\n\\n        // Create a lock\\n        crvLocker.createLock(_after, block.timestamp + 5 weeks);\\n\\n        // Harvest etc\\n        hevm.warp(block.timestamp + 1 weeks);\\n        strategy.harvest();\\n\\n        // Increase amount\\n        crvLocker.increaseAmount(IERC20(crv).balanceOf(address(crvLocker)));\\n\\n        // Increase unlockTime\\n        crvLocker.increaseUnlockTime(block.timestamp + 5 weeks);\\n\\n        // Fast forward\\n        hevm.warp(block.timestamp + 5 weeks + 1 hours);\\n\\n        // Withdraw\\n        _before = IERC20(crv).balanceOf(address(crvLocker));\\n        crvLocker.release();\\n        _after = IERC20(crv).balanceOf(address(crvLocker));\\n        assertTrue(_after > _before);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/curve/strategy-curve-scrv-v3_2.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/hevm.sol\\\";\\nimport \\\"../../lib/user.sol\\\";\\nimport \\\"../../lib/test-approx.sol\\\";\\nimport \\\"../../lib/test-defi-base.sol\\\";\\nimport \\\"../../lib/test-strategy-curve-farm-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\n\\nimport \\\"../../../strategies/curve/strategy-curve-scrv-v3_2.sol\\\";\\n\\ncontract StrategyCurveSCRVv3_2Test is StrategyCurveFarmTestBase {\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        want = scrv;\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = IStrategy(\\n            address(\\n                new StrategyCurveSCRVv3_2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        hevm.warp(startTime);\\n\\n        _getWant(10000000 ether);\\n    }\\n\\n    function _getWant(uint256 daiAmount) internal {\\n        _getERC20(dai, daiAmount);\\n        uint256[4] memory liquidity;\\n        liquidity[0] = IERC20(dai).balanceOf(address(this));\\n        IERC20(dai).approve(susdv2_pool, liquidity[0]);\\n        ICurveFi_4(susdv2_pool).add_liquidity(liquidity, 0);\\n    }\\n\\n    // **** Tests **** //\\n\\n    function test_scrv_v3_1_withdraw() public {\\n        _test_withdraw();\\n    }\\n\\n    function test_scrv_v3_1_earn_harvest_rewards() public {\\n        _test_get_earn_harvest_rewards();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/curve/strategy-curve-3crv-v2.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/hevm.sol\\\";\\nimport \\\"../../lib/user.sol\\\";\\nimport \\\"../../lib/test-approx.sol\\\";\\nimport \\\"../../lib/test-defi-base.sol\\\";\\nimport \\\"../../lib/test-strategy-curve-farm-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\n\\nimport \\\"../../../strategies/curve/strategy-curve-3crv-v2.sol\\\";\\n\\ncontract StrategyCurve3CRVv2Test is StrategyCurveFarmTestBase {\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        want = three_crv;\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = IStrategy(\\n            address(\\n                new StrategyCurve3CRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        hevm.warp(startTime);\\n\\n        _getWant(10000000 ether);\\n    }\\n\\n    function _getWant(uint256 daiAmount) internal {\\n        _getERC20(dai, daiAmount);\\n        uint256[3] memory liquidity;\\n        liquidity[0] = IERC20(dai).balanceOf(address(this));\\n        IERC20(dai).approve(three_pool, liquidity[0]);\\n        ICurveFi_3(three_pool).add_liquidity(liquidity, 0);\\n    }\\n\\n    // **** Tests **** //\\n\\n    function test_3crv_v1_withdraw() public {\\n        _test_withdraw();\\n    }\\n\\n    function test_3crv_v1_earn_harvest_rewards() public {\\n        _test_get_earn_harvest_rewards();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/curve/strategy-curve-rencrv-v2.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/hevm.sol\\\";\\nimport \\\"../../lib/user.sol\\\";\\nimport \\\"../../lib/test-approx.sol\\\";\\nimport \\\"../../lib/test-defi-base.sol\\\";\\nimport \\\"../../lib/test-strategy-curve-farm-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\n\\nimport \\\"../../../strategies/curve/strategy-curve-rencrv-v2.sol\\\";\\n\\ncontract StrategyCurveRenCRVv2Test is StrategyCurveFarmTestBase {\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        want = ren_crv;\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = IStrategy(\\n            address(\\n                new StrategyCurveRenCRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        hevm.warp(startTime);\\n\\n        _getWant(10e8); // 10 wbtc\\n    }\\n\\n    function _getWant(uint256 btcAmount) internal {\\n        _getERC20(wbtc, btcAmount);\\n        uint256[2] memory liquidity;\\n        liquidity[1] = IERC20(wbtc).balanceOf(address(this));\\n        IERC20(wbtc).approve(ren_pool, liquidity[1]);\\n        ICurveFi_2(ren_pool).add_liquidity(liquidity, 0);\\n    }\\n\\n    // **** Tests **** //\\n\\n    function test_rencrv_v1_withdraw() public {\\n        _test_withdraw();\\n    }\\n\\n    function test_rencrv_v1_earn_harvest_rewards() public {\\n        _test_get_earn_harvest_rewards();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/compound/strategy-cmpnd-dai-v2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\n\\nimport \\\"../../lib/hevm.sol\\\";\\nimport \\\"../../lib/user.sol\\\";\\nimport \\\"../../lib/test-approx.sol\\\";\\nimport \\\"../../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../../interfaces/compound.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\n\\nimport \\\"../../../strategies/compound/strategy-cmpd-dai-v2.sol\\\";\\n\\ncontract StrategyCmpndDaiV1 is DSTestDefiBase {\\n    StrategyCmpdDaiV2 strategy;\\n    ControllerV4 controller;\\n    PickleJar pickleJar;\\n\\n    address governance;\\n    address strategist;\\n    address timelock;\\n    address devfund;\\n    address treasury;\\n\\n    address want;\\n\\n    function setUp() public {\\n        want = dai;\\n\\n        governance = address(this);\\n        strategist = address(new User());\\n        timelock = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = new StrategyCmpdDaiV2(\\n            governance,\\n            strategist,\\n            address(controller),\\n            timelock\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n    }\\n\\n    function testFail_cmpnd_dai_v1_onlyKeeper_leverage() public {\\n        _getERC20(want, 100e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n\\n        User randomUser = new User();\\n        randomUser.execute(address(strategy), 0, \\\"leverageToMax()\\\", \\\"\\\");\\n    }\\n\\n    function testFail_cmpnd_dai_v1_onlyKeeper_deleverage() public {\\n        _getERC20(want, 100e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        strategy.leverageToMax();\\n\\n        User randomUser = new User();\\n        randomUser.execute(address(strategy), 0, \\\"deleverageToMin()\\\", \\\"\\\");\\n    }\\n\\n    function test_cmpnd_dai_v1_comp_accrued() public {\\n        _getERC20(want, 1000000e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n\\n        strategy.leverageToMax();\\n\\n        uint256 compAccrued = strategy.getCompAccrued();\\n\\n        assertEq(compAccrued, 0);\\n\\n        hevm.warp(block.timestamp + 1 days);\\n        hevm.roll(block.number + 6171); // Roughly number of blocks per day\\n\\n        compAccrued = strategy.getCompAccrued();\\n        assertTrue(compAccrued > 0);\\n    }\\n\\n    function test_cmpnd_dai_v1_comp_sync() public {\\n        _getERC20(want, 1000000e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n\\n        // Sets colFactor Buffer to be 3% (safeSync is 5%)\\n        strategy.setColFactorLeverageBuffer(30);\\n        strategy.leverageToMax();\\n        // Back to 10%\\n        strategy.setColFactorLeverageBuffer(100);\\n\\n        uint256 colFactor = strategy.getColFactor();\\n        uint256 safeColFactor = strategy.getSafeLeverageColFactor();\\n        assertTrue(colFactor > safeColFactor);\\n\\n        // Sync automatically fixes the colFactor for us\\n        bool shouldSync = strategy.sync();\\n        assertTrue(shouldSync);\\n\\n        colFactor = strategy.getColFactor();\\n        assertEqApprox(colFactor, safeColFactor);\\n\\n        shouldSync = strategy.sync();\\n        assertTrue(!shouldSync);\\n    }\\n\\n    function test_cmpnd_dai_v1_leverage() public {\\n        _getERC20(want, 100e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n\\n        uint256 _stratInitialBal = strategy.balanceOf();\\n\\n        uint256 _beforeCR = strategy.getColFactor();\\n        uint256 _beforeLev = strategy.getCurrentLeverage();\\n        strategy.leverageToMax();\\n        uint256 _afterCR = strategy.getColFactor();\\n        uint256 _afterLev = strategy.getCurrentLeverage();\\n        uint256 _safeLeverageColFactor = strategy.getSafeLeverageColFactor();\\n\\n        assertTrue(_afterCR > _beforeCR);\\n        assertTrue(_afterLev > _beforeLev);\\n        assertEqApprox(_safeLeverageColFactor, _afterCR);\\n\\n        uint256 _maxLeverage = strategy.getMaxLeverage();\\n        assertTrue(_maxLeverage > 2e18); // Should be ~2.6, depending on colFactorLeverageBuffer\\n\\n        uint256 leverageTarget = strategy.getLeveragedSupplyTarget(\\n            _stratInitialBal\\n        );\\n        uint256 leverageSupplied = strategy.getSupplied();\\n        assertEqApprox(\\n            leverageSupplied,\\n            _stratInitialBal.mul(_maxLeverage).div(1e18)\\n        );\\n        assertEqApprox(leverageSupplied, leverageTarget);\\n\\n        uint256 unleveragedSupplied = strategy.getSuppliedUnleveraged();\\n        assertEqApprox(unleveragedSupplied, _stratInitialBal);\\n    }\\n\\n    function test_cmpnd_dai_v1_deleverage() public {\\n        _getERC20(want, 100e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n        strategy.leverageToMax();\\n\\n        uint256 _beforeCR = strategy.getColFactor();\\n        uint256 _beforeLev = strategy.getCurrentLeverage();\\n        strategy.deleverageToMin();\\n        uint256 _afterCR = strategy.getColFactor();\\n        uint256 _afterLev = strategy.getCurrentLeverage();\\n\\n        assertTrue(_afterCR < _beforeCR);\\n        assertTrue(_afterLev < _beforeLev);\\n        assertEq(0, _afterCR); // 0 since we're not borrowing anything\\n\\n        uint256 unleveragedSupplied = strategy.getSuppliedUnleveraged();\\n        uint256 supplied = strategy.getSupplied();\\n        assertEqApprox(unleveragedSupplied, supplied);\\n    }\\n\\n    function test_cmpnd_dai_v1_withdrawSome() public {\\n        _getERC20(want, 100e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n        strategy.leverageToMax();\\n\\n        uint256 _before = IERC20(want).balanceOf(address(this));\\n        pickleJar.withdraw(25e18);\\n        uint256 _after = IERC20(want).balanceOf(address(this));\\n\\n        assertTrue(_after > _before);\\n        assertEqApprox(_after.sub(_before), 25e18);\\n\\n        _before = IERC20(want).balanceOf(address(this));\\n        pickleJar.withdraw(10e18);\\n        _after = IERC20(want).balanceOf(address(this));\\n\\n        assertTrue(_after > _before);\\n        assertEqApprox(_after.sub(_before), 10e18);\\n\\n        _before = IERC20(want).balanceOf(address(this));\\n        pickleJar.withdraw(30e18);\\n        _after = IERC20(want).balanceOf(address(this));\\n\\n        assertTrue(_after > _before);\\n        assertEqApprox(_after.sub(_before), 30e18);\\n\\n        // Make sure we're still leveraging\\n        uint256 _leverage = strategy.getCurrentLeverage();\\n        assertTrue(_leverage > 1e18);\\n    }\\n\\n    function test_cmpnd_dai_v1_withdrawAll() public {\\n        _getERC20(want, 100e18);\\n\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n\\n        strategy.leverageToMax();\\n\\n        hevm.warp(block.timestamp + 1 days);\\n        hevm.roll(block.number + 6171); // Roughly number of blocks per day\\n\\n        strategy.harvest();\\n\\n        // Withdraws back to pickleJar\\n        uint256 _before = IERC20(want).balanceOf(address(pickleJar));\\n        controller.withdrawAll(want);\\n        uint256 _after = IERC20(want).balanceOf(address(pickleJar));\\n\\n        assertTrue(_after > _before);\\n\\n        _before = IERC20(want).balanceOf(address(this));\\n        pickleJar.withdrawAll();\\n        _after = IERC20(want).balanceOf(address(this));\\n\\n        assertTrue(_after > _before);\\n\\n        // Gained some interest\\n        assertTrue(_after > _want);\\n    }\\n\\n    function test_cmpnd_dai_v1_earn_harvest_rewards() public {\\n        _getERC20(want, 100e18);\\n\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n\\n        // Fast forward one week\\n        hevm.warp(block.timestamp + 1 days);\\n        hevm.roll(block.number + 6171); // Roughly number of blocks per day\\n\\n        // Call the harvest function\\n        uint256 _before = strategy.getSupplied();\\n        uint256 _treasuryBefore = IERC20(want).balanceOf(treasury);\\n        strategy.harvest();\\n        uint256 _after = strategy.getSupplied();\\n        uint256 _treasuryAfter = IERC20(want).balanceOf(treasury);\\n\\n        uint256 earned = _after.sub(_before).mul(1000).div(955);\\n        uint256 earnedRewards = earned.mul(45).div(1000); // 4.5%\\n        uint256 actualRewardsEarned = _treasuryAfter.sub(_treasuryBefore);\\n\\n        // 4.5% performance fee is given\\n        assertEqApprox(earnedRewards, actualRewardsEarned);\\n\\n        // Withdraw\\n        uint256 _devBefore = IERC20(want).balanceOf(devfund);\\n        _treasuryBefore = IERC20(want).balanceOf(treasury);\\n        uint256 _stratBal = strategy.balanceOf();\\n        pickleJar.withdrawAll();\\n        uint256 _devAfter = IERC20(want).balanceOf(devfund);\\n        _treasuryAfter = IERC20(want).balanceOf(treasury);\\n\\n        // 0.175% goes to dev\\n        uint256 _devFund = _devAfter.sub(_devBefore);\\n        assertEq(_devFund, _stratBal.mul(175).div(100000));\\n\\n        // 0.325% goes to treasury\\n        uint256 _treasuryFund = _treasuryAfter.sub(_treasuryBefore);\\n        assertEq(_treasuryFund, _stratBal.mul(325).div(100000));\\n    }\\n\\n    function test_cmpnd_dai_v1_functions() public {\\n        _getERC20(want, 100e18);\\n\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n\\n        uint256 initialSupplied = strategy.getSupplied();\\n        uint256 initialBorrowed = strategy.getBorrowed();\\n        uint256 initialBorrowable = strategy.getBorrowable();\\n        uint256 marketColFactor = strategy.getMarketColFactor();\\n        uint256 maxLeverage = strategy.getMaxLeverage();\\n\\n        // Earn deposits 95% into strategy\\n        assertEqApprox(initialSupplied, 95e18);\\n        assertEqApprox(\\n            initialBorrowable,\\n            initialSupplied.mul(marketColFactor).div(1e18)\\n        );\\n        assertEqApprox(initialBorrowed, 0);\\n\\n        // Leverage to Max\\n        strategy.leverageToMax();\\n\\n        uint256 supplied = strategy.getSupplied();\\n        uint256 borrowed = strategy.getBorrowed();\\n        uint256 borrowable = strategy.getBorrowable();\\n        uint256 currentColFactor = strategy.getColFactor();\\n        uint256 safeLeverageColFactor = strategy.getSafeLeverageColFactor();\\n\\n        assertEqApprox(supplied, initialSupplied.mul(maxLeverage).div(1e18));\\n        assertEqApprox(borrowed, supplied.mul(safeLeverageColFactor).div(1e18));\\n        assertEqApprox(\\n            borrowable,\\n            supplied.mul(marketColFactor.sub(currentColFactor)).div(1e18)\\n        );\\n        assertEqApprox(currentColFactor, safeLeverageColFactor);\\n        assertTrue(marketColFactor > currentColFactor);\\n        assertTrue(marketColFactor > safeLeverageColFactor);\\n\\n        // Deleverage\\n        strategy.deleverageToMin();\\n\\n        uint256 deleverageSupplied = strategy.getSupplied();\\n        uint256 deleverageBorrowed = strategy.getBorrowed();\\n        uint256 deleverageBorrowable = strategy.getBorrowable();\\n\\n        assertEqApprox(deleverageSupplied, initialSupplied);\\n        assertEqApprox(deleverageBorrowed, initialBorrowed);\\n        assertEqApprox(deleverageBorrowable, initialBorrowable);\\n    }\\n\\n    function test_cmpnd_dai_v1_deleverage_stepping() public {\\n        _getERC20(want, 100e18);\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        IERC20(want).approve(address(pickleJar), _want);\\n        pickleJar.deposit(_want);\\n        pickleJar.earn();\\n        strategy.leverageToMax();\\n\\n        strategy.deleverageUntil(200e18);\\n        uint256 supplied = strategy.getSupplied();\\n        assertEqApprox(supplied, 200e18);\\n\\n        strategy.deleverageUntil(180e18);\\n        supplied = strategy.getSupplied();\\n        assertEqApprox(supplied, 180e18);\\n\\n        strategy.deleverageUntil(120e18);\\n        supplied = strategy.getSupplied();\\n        assertEqApprox(supplied, 120e18);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/uniswapv2/strategy-uni-eth-usdc-lp-v4.test.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/test-strategy-uni-farm-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\nimport \\\"../../../strategies/uniswapv2/strategy-uni-eth-usdc-lp-v4.sol\\\";\\n\\ncontract StrategyUniEthUsdcLpV4Test is StrategyUniFarmTestBase {\\n    function setUp() public {\\n        want = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;\\n        token1 = usdc;\\n\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = IStrategy(\\n            address(\\n                new StrategyUniEthUsdcLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        // Set time\\n        hevm.warp(startTime);\\n    }\\n\\n    // **** Tests ****\\n\\n    function test_ethusdcv3_1_timelock() public {\\n        _test_timelock();\\n    }\\n\\n    function test_ethusdcv3_1_withdraw_release() public {\\n        _test_withdraw_release();\\n    }\\n\\n    function test_ethusdcv3_1_get_earn_harvest_rewards() public {\\n        _test_get_earn_harvest_rewards();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/uniswapv2/strategy-uni-eth-dai-lp-v4.test.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/test-strategy-uni-farm-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\nimport \\\"../../../strategies/uniswapv2/strategy-uni-eth-dai-lp-v4.sol\\\";\\n\\ncontract StrategyUniEthDaiLpV4Test is StrategyUniFarmTestBase {\\n    function setUp() public {\\n        want = 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11;\\n        token1 = dai;\\n\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = IStrategy(\\n            address(\\n                new StrategyUniEthDaiLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        // Set time\\n        hevm.warp(startTime);\\n    }\\n\\n    // **** Tests ****\\n\\n    function test_ethdaiv3_1_timelock() public {\\n        _test_timelock();\\n    }\\n\\n    function test_ethdaiv3_1_withdraw_release() public {\\n        _test_withdraw_release();\\n    }\\n\\n    function test_ethdaiv3_1_get_earn_harvest_rewards() public {\\n        _test_get_earn_harvest_rewards();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/uniswapv2/strategy-uni-eth-usdt-lp-v4.test.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/test-strategy-uni-farm-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\nimport \\\"../../../strategies/uniswapv2/strategy-uni-eth-usdt-lp-v4.sol\\\";\\n\\ncontract StrategyUniEthUsdtLpV4Test is StrategyUniFarmTestBase {\\n    function setUp() public {\\n        want = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852;\\n        token1 = usdt;\\n\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = IStrategy(\\n            address(\\n                new StrategyUniEthUsdtLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        // Set time\\n        hevm.warp(startTime);\\n    }\\n\\n    // **** Tests ****\\n\\n    function test_ethusdtv3_1_timelock() public {\\n        _test_timelock();\\n    }\\n\\n    function test_ethusdtv3_1_withdraw_release() public {\\n        _test_withdraw_release();\\n    }\\n\\n    function test_ethusdtv3_1_get_earn_harvest_rewards() public {\\n        _test_get_earn_harvest_rewards();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/strategies/uniswapv2/strategy-uni-eth-wbtc-lp-v2.test.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\n\\n\\nimport \\\"../../lib/test-strategy-uni-farm-base.sol\\\";\\n\\nimport \\\"../../../interfaces/strategy.sol\\\";\\nimport \\\"../../../interfaces/curve.sol\\\";\\nimport \\\"../../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../../pickle-jar.sol\\\";\\nimport \\\"../../../controller-v4.sol\\\";\\nimport \\\"../../../strategies/uniswapv2/strategy-uni-eth-wbtc-lp-v2.sol\\\";\\n\\ncontract StrategyUniEthWBtcLpV2Test is StrategyUniFarmTestBase {\\n    function setUp() public {\\n        want = 0xBb2b8038a1640196FbE3e38816F3e67Cba72D940;\\n        token1 = wbtc;\\n\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        strategy = IStrategy(\\n            address(\\n                new StrategyUniEthWBtcLpV2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        pickleJar = new PickleJar(\\n            strategy.want(),\\n            governance,\\n            timelock,\\n            address(controller)\\n        );\\n\\n        controller.setJar(strategy.want(), address(pickleJar));\\n        controller.approveStrategy(strategy.want(), address(strategy));\\n        controller.setStrategy(strategy.want(), address(strategy));\\n\\n        // Set time\\n        hevm.warp(startTime);\\n    }\\n\\n    // **** Tests ****\\n\\n    function test_ethwbtcv1_timelock() public {\\n        _test_timelock();\\n    }\\n\\n    function test_ethwbtcv1_withdraw_release() public {\\n        _test_withdraw_release();\\n    }\\n\\n    function test_ethwbtcv1_get_earn_harvest_rewards() public {\\n        _test_get_earn_harvest_rewards();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/staking-rewards.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\n\\nimport \\\"../lib/safe-math.sol\\\";\\n\\nimport \\\"../staking-rewards.sol\\\";\\n\\nimport \\\"./lib/test.sol\\\";\\nimport \\\"./lib/mock-erc20.sol\\\";\\nimport \\\"./lib/hevm.sol\\\";\\n\\ncontract StakngRewardsTest is DSTest {\\n    using SafeMath for uint256;\\n\\n    MockERC20 stakingToken;\\n    MockERC20 rewardsToken;\\n\\n    StakingRewards stakingRewards;\\n\\n    address owner;\\n\\n    Hevm hevm = Hevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\\n\\n    function setUp() public {\\n        owner = address(this);\\n\\n        stakingToken = new MockERC20(\\\"staking\\\", \\\"STAKE\\\");\\n        rewardsToken = new MockERC20(\\\"rewards\\\", \\\"RWD\\\");\\n\\n        stakingRewards = new StakingRewards(\\n            owner,\\n            address(rewardsToken),\\n            address(stakingToken)\\n        );\\n    }\\n\\n    function test_staking() public {\\n        uint256 stakeAmount = 100 ether;\\n        uint256 rewardAmount = 100 ether;\\n\\n        stakingToken.mint(owner, stakeAmount);\\n        rewardsToken.mint(owner, rewardAmount);\\n\\n        stakingToken.approve(address(stakingRewards), stakeAmount);\\n        stakingRewards.stake(stakeAmount);\\n\\n        // // Make sure nothing is earned\\n        uint256 _before = stakingRewards.earned(owner);\\n        assertEq(_before, 0);\\n\\n        // Fast forward\\n        hevm.warp(block.timestamp + 1 days);\\n\\n        // No funds until we actually supply funds\\n        uint256 _after = stakingRewards.earned(owner);\\n        assertEq(_after, _before);\\n\\n        // Give rewards\\n        rewardsToken.transfer(address(stakingRewards), rewardAmount);\\n        stakingRewards.notifyRewardAmount(rewardAmount);\\n\\n        uint256 _rateBefore = stakingRewards.getRewardForDuration();\\n        assertTrue(_rateBefore > 0);\\n\\n        // Fast forward\\n        _before = stakingRewards.earned(owner);\\n        hevm.warp(block.timestamp + 1 days);\\n        _after = stakingRewards.earned(owner);\\n        assertTrue(_after > _before);\\n        assertTrue(_after > 0);\\n\\n        // Add more rewards, rate should increase\\n        rewardsToken.mint(owner, rewardAmount);\\n        rewardsToken.transfer(address(stakingRewards), rewardAmount);\\n        stakingRewards.notifyRewardAmount(rewardAmount);\\n\\n        uint256 _rateAfter = stakingRewards.getRewardForDuration();\\n        assertTrue(_rateAfter > _rateBefore);\\n\\n        // Warp to period finish\\n        hevm.warp(stakingRewards.periodFinish() + 1 days);\\n\\n        // Retrieve tokens\\n        stakingRewards.getReward();\\n\\n        _before = stakingRewards.earned(owner);\\n        hevm.warp(block.timestamp + 1 days);\\n        _after = stakingRewards.earned(owner);\\n\\n        // Earn 0 after period finished\\n        assertEq(_before, 0);\\n        assertEq(_after, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/jar-converters/curve-uni.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/hevm.sol\\\";\\nimport \\\"../lib/user.sol\\\";\\nimport \\\"../lib/test-approx.sol\\\";\\nimport \\\"../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../interfaces/strategy.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../pickle-jar.sol\\\";\\nimport \\\"../../controller-v4.sol\\\";\\n\\nimport \\\"../../proxy-logic/curve.sol\\\";\\nimport \\\"../../proxy-logic/uniswapv2.sol\\\";\\n\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-dai-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-usdt-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-usdc-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-wbtc-lp-v2.sol\\\";\\n\\nimport \\\"../../strategies/curve/strategy-curve-scrv-v3_2.sol\\\";\\nimport \\\"../../strategies/curve/strategy-curve-rencrv-v2.sol\\\";\\nimport \\\"../../strategies/curve/strategy-curve-3crv-v2.sol\\\";\\n\\ncontract StrategyCurveUniJarSwapTest is DSTestDefiBase {\\n    address governance;\\n    address strategist;\\n    address devfund;\\n    address treasury;\\n    address timelock;\\n\\n    IStrategy[] curveStrategies;\\n    IStrategy[] uniStrategies;\\n\\n    PickleJar[] curvePickleJars;\\n    PickleJar[] uniPickleJars;\\n\\n    ControllerV4 controller;\\n\\n    CurveProxyLogic curveProxyLogic;\\n    UniswapV2ProxyLogic uniswapV2ProxyLogic;\\n\\n    address[] curvePools;\\n    address[] curveLps;\\n\\n    address[] uniUnderlying;\\n\\n    // Contract wide variable to avoid stack too deep errors\\n    uint256 temp;\\n\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        // Curve Strategies\\n        curveStrategies = new IStrategy[](3);\\n        curvePickleJars = new PickleJar[](curveStrategies.length);\\n        curveLps = new address[](curveStrategies.length);\\n        curvePools = new address[](curveStrategies.length);\\n\\n        curveLps[0] = three_crv;\\n        curvePools[0] = three_pool;\\n        curveStrategies[0] = IStrategy(\\n            address(\\n                new StrategyCurve3CRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        curveLps[1] = scrv;\\n        curvePools[1] = susdv2_pool;\\n        curveStrategies[1] = IStrategy(\\n            address(\\n                new StrategyCurveSCRVv3_2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        curveLps[2] = ren_crv;\\n        curvePools[2] = ren_pool;\\n        curveStrategies[2] = IStrategy(\\n            address(\\n                new StrategyCurveRenCRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        // Create PICKLE Jars\\n        for (uint256 i = 0; i < curvePickleJars.length; i++) {\\n            curvePickleJars[i] = new PickleJar(\\n                curveStrategies[i].want(),\\n                governance,\\n                timelock,\\n                address(controller)\\n            );\\n\\n            controller.setJar(\\n                curveStrategies[i].want(),\\n                address(curvePickleJars[i])\\n            );\\n            controller.approveStrategy(\\n                curveStrategies[i].want(),\\n                address(curveStrategies[i])\\n            );\\n            controller.setStrategy(\\n                curveStrategies[i].want(),\\n                address(curveStrategies[i])\\n            );\\n        }\\n\\n        // Uni strategies\\n        uniStrategies = new IStrategy[](4);\\n        uniUnderlying = new address[](uniStrategies.length);\\n        uniPickleJars = new PickleJar[](uniStrategies.length);\\n\\n        uniUnderlying[0] = dai;\\n        uniStrategies[0] = IStrategy(\\n            address(\\n                new StrategyUniEthDaiLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[1] = usdc;\\n        uniStrategies[1] = IStrategy(\\n            address(\\n                new StrategyUniEthUsdcLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[2] = usdt;\\n        uniStrategies[2] = IStrategy(\\n            address(\\n                new StrategyUniEthUsdtLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[3] = wbtc;\\n        uniStrategies[3] = IStrategy(\\n            address(\\n                new StrategyUniEthWBtcLpV2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        for (uint256 i = 0; i < uniStrategies.length; i++) {\\n            uniPickleJars[i] = new PickleJar(\\n                uniStrategies[i].want(),\\n                governance,\\n                timelock,\\n                address(controller)\\n            );\\n\\n            controller.setJar(\\n                uniStrategies[i].want(),\\n                address(uniPickleJars[i])\\n            );\\n            controller.approveStrategy(\\n                uniStrategies[i].want(),\\n                address(uniStrategies[i])\\n            );\\n            controller.setStrategy(\\n                uniStrategies[i].want(),\\n                address(uniStrategies[i])\\n            );\\n        }\\n\\n        curveProxyLogic = new CurveProxyLogic();\\n        uniswapV2ProxyLogic = new UniswapV2ProxyLogic();\\n\\n        controller.approveJarConverter(address(curveProxyLogic));\\n        controller.approveJarConverter(address(uniswapV2ProxyLogic));\\n\\n        hevm.warp(startTime);\\n    }\\n\\n    function _getCurveLP(address curve, uint256 amount) internal {\\n        if (curve == ren_pool) {\\n            _getERC20(wbtc, amount);\\n            uint256 _wbtc = IERC20(wbtc).balanceOf(address(this));\\n            IERC20(wbtc).approve(curve, _wbtc);\\n\\n            uint256[2] memory liquidity;\\n            liquidity[1] = _wbtc;\\n            ICurveFi_2(curve).add_liquidity(liquidity, 0);\\n        } else {\\n            _getERC20(dai, amount);\\n            uint256 _dai = IERC20(dai).balanceOf(address(this));\\n            IERC20(dai).approve(curve, _dai);\\n\\n            if (curve == three_pool) {\\n                uint256[3] memory liquidity;\\n                liquidity[0] = _dai;\\n                ICurveFi_3(curve).add_liquidity(liquidity, 0);\\n            } else {\\n                uint256[4] memory liquidity;\\n                liquidity[0] = _dai;\\n                ICurveFi_4(curve).add_liquidity(liquidity, 0);\\n            }\\n        }\\n    }\\n\\n    function _get_primitive_to_lp_data(\\n        address from,\\n        address to,\\n        address dustRecipient\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"primitiveToLpTokens(address,address,address)\\\",\\n                from,\\n                to,\\n                dustRecipient\\n            );\\n    }\\n\\n    function _get_curve_remove_liquidity_data(\\n        address curve,\\n        address curveLP,\\n        int128 index\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"remove_liquidity_one_coin(address,address,int128)\\\",\\n                curve,\\n                curveLP,\\n                index\\n            );\\n    }\\n\\n    // Some post swap checks\\n    // Checks if there's any leftover funds in the converter contract\\n    function _post_swap_check(uint256 fromIndex, uint256 toIndex) internal {\\n        IERC20 token0 = curvePickleJars[fromIndex].token();\\n        IUniswapV2Pair token1 = IUniswapV2Pair(\\n            address(uniPickleJars[toIndex].token())\\n        );\\n\\n        uint256 MAX_DUST = 1000;\\n\\n        // No funds left behind\\n        assertEq(curvePickleJars[fromIndex].balanceOf(address(controller)), 0);\\n        assertEq(uniPickleJars[toIndex].balanceOf(address(controller)), 0);\\n        assertTrue(token0.balanceOf(address(controller)) < MAX_DUST);\\n        assertTrue(token1.balanceOf(address(controller)) < MAX_DUST);\\n\\n        // Curve -> UNI LP should be optimal supply\\n        // Note: We refund the access, which is why its checking this balance\\n        assertTrue(IERC20(token1.token0()).balanceOf(address(this)) < MAX_DUST);\\n        assertTrue(IERC20(token1.token1()).balanceOf(address(this)) < MAX_DUST);\\n\\n        // Make sure only controller can call 'withdrawForSwap'\\n        try curveStrategies[fromIndex].withdrawForSwap(0)  {\\n            revert(\\\"!withdraw-for-swap-only-controller\\\");\\n        } catch {}\\n    }\\n\\n    function _test_check_treasury_fee(uint256 _amount, uint256 earned)\\n        internal\\n    {\\n        assertEqApprox(\\n            _amount.mul(controller.convenienceFee()).div(\\n                controller.convenienceFeeMax()\\n            ),\\n            earned.mul(2)\\n        );\\n    }\\n\\n    function _test_swap_and_check_balances(\\n        address fromPickleJar,\\n        address toPickleJar,\\n        address fromPickleJarUnderlying,\\n        uint256 fromPickleJarUnderlyingAmount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) internal {\\n        uint256 _beforeTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _beforeFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _beforeDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _beforeTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 _ret = controller.swapExactJarForJar(\\n            fromPickleJar,\\n            toPickleJar,\\n            fromPickleJarUnderlyingAmount,\\n            0, // Min receive amount\\n            targets,\\n            data\\n        );\\n\\n        uint256 _afterTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _afterFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _afterDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _afterTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 treasuryEarned = _afterTreasury.sub(_beforeTreasury);\\n\\n        assertEq(treasuryEarned, _afterDev.sub(_beforeDev));\\n        assertTrue(treasuryEarned > 0);\\n        _test_check_treasury_fee(fromPickleJarUnderlyingAmount, treasuryEarned);\\n        assertTrue(_afterFrom < _beforeFrom);\\n        assertTrue(_afterTo > _beforeTo);\\n        assertTrue(_afterTo.sub(_beforeTo) > 0);\\n        assertEq(_afterTo.sub(_beforeTo), _ret);\\n        assertEq(_afterFrom, 0);\\n    }\\n\\n    function _test_curve_uni_swap(\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 amount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) internal {\\n        // Deposit into PickleJars\\n        address from = address(curvePickleJars[fromIndex].token());\\n\\n        _getCurveLP(curvePools[fromIndex], amount);\\n\\n        uint256 _from = IERC20(from).balanceOf(address(this));\\n        IERC20(from).approve(address(curvePickleJars[fromIndex]), _from);\\n        curvePickleJars[fromIndex].deposit(_from);\\n        curvePickleJars[fromIndex].earn();\\n\\n        // Swap!\\n        uint256 _fromPickleJar = IERC20(address(curvePickleJars[fromIndex]))\\n            .balanceOf(address(this));\\n        IERC20(address(curvePickleJars[fromIndex])).approve(\\n            address(controller),\\n            _fromPickleJar\\n        );\\n\\n        // Check minimum amount\\n        try\\n            controller.swapExactJarForJar(\\n                address(curvePickleJars[fromIndex]),\\n                address(uniPickleJars[toIndex]),\\n                _fromPickleJar,\\n                uint256(-1), // Min receive amount\\n                targets,\\n                data\\n            )\\n         {\\n            revert(\\\"min-amount-should-fail\\\");\\n        } catch {}\\n\\n        _test_swap_and_check_balances(\\n            address(curvePickleJars[fromIndex]),\\n            address(uniPickleJars[toIndex]),\\n            from,\\n            _fromPickleJar,\\n            targets,\\n            data\\n        );\\n\\n        _post_swap_check(fromIndex, toIndex);\\n    }\\n\\n    // **** Tests **** //\\n\\n    function test_jar_converter_curve_uni_0_0() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 0;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = dai;\\n        int128 fromUnderlyingIndex = 0;\\n\\n        address curvePool = curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_0_1() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 1;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = usdc;\\n        int128 fromUnderlyingIndex = 1;\\n\\n        address curvePool = curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_0_2() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 2;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = usdt;\\n        int128 fromUnderlyingIndex = 2;\\n\\n        address curvePool = curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_0_3() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 3;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = usdt;\\n        int128 fromUnderlyingIndex = 2;\\n\\n        address curvePool = curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_1_0() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 0;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = usdt;\\n        int128 fromUnderlyingIndex = 2;\\n\\n        address curvePool = susdv2_deposit; // curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_1_1() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 1;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = dai;\\n        int128 fromUnderlyingIndex = 0;\\n\\n        address curvePool = susdv2_deposit; // curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_1_2() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 2;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = dai;\\n        int128 fromUnderlyingIndex = 0;\\n\\n        address curvePool = susdv2_deposit; // curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_1_3() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 3;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = dai;\\n        int128 fromUnderlyingIndex = 0;\\n\\n        address curvePool = susdv2_deposit; // curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_uni_2_3() public {\\n        uint256 fromIndex = 2;\\n        uint256 toIndex = 3;\\n        uint256 amount = 4e6;\\n\\n        address fromUnderlying = wbtc;\\n        int128 fromUnderlyingIndex = 1;\\n\\n        address curvePool = curvePools[fromIndex];\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address toWant = univ2Factory.getPair(weth, toUnderlying);\\n\\n        bytes memory data0 = _get_curve_remove_liquidity_data(\\n            curvePool,\\n            curveLps[fromIndex],\\n            fromUnderlyingIndex\\n        );\\n\\n        bytes memory data1 = _get_primitive_to_lp_data(\\n            fromUnderlying,\\n            toWant,\\n            treasury\\n        );\\n\\n        _test_curve_uni_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/jar-converters/curve-curve.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/hevm.sol\\\";\\nimport \\\"../lib/user.sol\\\";\\nimport \\\"../lib/test-approx.sol\\\";\\nimport \\\"../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../interfaces/strategy.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../pickle-jar.sol\\\";\\nimport \\\"../../controller-v4.sol\\\";\\n\\nimport \\\"../../proxy-logic/curve.sol\\\";\\nimport \\\"../../proxy-logic/uniswapv2.sol\\\";\\n\\nimport \\\"../../strategies/curve/strategy-curve-scrv-v3_2.sol\\\";\\nimport \\\"../../strategies/curve/strategy-curve-rencrv-v2.sol\\\";\\nimport \\\"../../strategies/curve/strategy-curve-3crv-v2.sol\\\";\\n\\ncontract StrategyCurveCurveJarSwapTest is DSTestDefiBase {\\n    address governance;\\n    address strategist;\\n    address devfund;\\n    address treasury;\\n    address timelock;\\n\\n    IStrategy[] curveStrategies;\\n\\n    PickleJar[] curvePickleJars;\\n\\n    ControllerV4 controller;\\n\\n    CurveProxyLogic curveProxyLogic;\\n    UniswapV2ProxyLogic uniswapV2ProxyLogic;\\n\\n    address[] curvePools;\\n    address[] curveLps;\\n\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        // Curve Strategies\\n        curveStrategies = new IStrategy[](3);\\n        curvePickleJars = new PickleJar[](curveStrategies.length);\\n        curveLps = new address[](curveStrategies.length);\\n        curvePools = new address[](curveStrategies.length);\\n\\n        curveLps[0] = three_crv;\\n        curvePools[0] = three_pool;\\n        curveStrategies[0] = IStrategy(\\n            address(\\n                new StrategyCurve3CRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n        curveLps[1] = scrv;\\n        curvePools[1] = susdv2_pool;\\n        curveStrategies[1] = IStrategy(\\n            address(\\n                new StrategyCurveSCRVv3_2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n        curveLps[2] = ren_crv;\\n        curvePools[2] = ren_pool;\\n        curveStrategies[2] = IStrategy(\\n            address(\\n                new StrategyCurveRenCRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        // Create PICKLE Jars\\n        for (uint256 i = 0; i < curvePickleJars.length; i++) {\\n            curvePickleJars[i] = new PickleJar(\\n                curveStrategies[i].want(),\\n                governance,\\n                timelock,\\n                address(controller)\\n            );\\n\\n            controller.setJar(\\n                curveStrategies[i].want(),\\n                address(curvePickleJars[i])\\n            );\\n            controller.approveStrategy(\\n                curveStrategies[i].want(),\\n                address(curveStrategies[i])\\n            );\\n            controller.setStrategy(\\n                curveStrategies[i].want(),\\n                address(curveStrategies[i])\\n            );\\n        }\\n\\n        curveProxyLogic = new CurveProxyLogic();\\n        uniswapV2ProxyLogic = new UniswapV2ProxyLogic();\\n\\n        controller.approveJarConverter(address(curveProxyLogic));\\n        controller.approveJarConverter(address(uniswapV2ProxyLogic));\\n\\n        hevm.warp(startTime);\\n    }\\n\\n    function _getCurveLP(address curve, uint256 amount) internal {\\n        if (curve == ren_pool) {\\n            _getERC20(wbtc, amount);\\n            uint256 _wbtc = IERC20(wbtc).balanceOf(address(this));\\n            IERC20(wbtc).approve(curve, _wbtc);\\n\\n            uint256[2] memory liquidity;\\n            liquidity[1] = _wbtc;\\n            ICurveFi_2(curve).add_liquidity(liquidity, 0);\\n        } else {\\n            _getERC20(dai, amount);\\n            uint256 _dai = IERC20(dai).balanceOf(address(this));\\n            IERC20(dai).approve(curve, _dai);\\n\\n            if (curve == three_pool) {\\n                uint256[3] memory liquidity;\\n                liquidity[0] = _dai;\\n                ICurveFi_3(curve).add_liquidity(liquidity, 0);\\n            } else {\\n                uint256[4] memory liquidity;\\n                liquidity[0] = _dai;\\n                ICurveFi_4(curve).add_liquidity(liquidity, 0);\\n            }\\n        }\\n    }\\n\\n    // **** Internal functions **** //\\n    // Theres so many internal functions due to stack blowing up\\n\\n    // Some post swap checks\\n    // Checks if there's any leftover funds in the converter contract\\n    function _post_swap_check(uint256 fromIndex, uint256 toIndex) internal {\\n        IERC20 token0 = curvePickleJars[fromIndex].token();\\n        IERC20 token1 = curvePickleJars[toIndex].token();\\n\\n        uint256 MAX_DUST = 10;\\n\\n        // No funds left behind\\n        assertEq(curvePickleJars[fromIndex].balanceOf(address(controller)), 0);\\n        assertEq(curvePickleJars[toIndex].balanceOf(address(controller)), 0);\\n        assertTrue(token0.balanceOf(address(controller)) < MAX_DUST);\\n        assertTrue(token1.balanceOf(address(controller)) < MAX_DUST);\\n\\n        // Make sure only controller can call 'withdrawForSwap'\\n        try curveStrategies[fromIndex].withdrawForSwap(0)  {\\n            revert(\\\"!withdraw-for-swap-only-controller\\\");\\n        } catch {}\\n    }\\n\\n    function _test_check_treasury_fee(uint256 _amount, uint256 earned)\\n        internal\\n    {\\n        assertEqApprox(\\n            _amount.mul(controller.convenienceFee()).div(\\n                controller.convenienceFeeMax()\\n            ),\\n            earned.mul(2)\\n        );\\n    }\\n\\n    function _test_swap_and_check_balances(\\n        address fromPickleJar,\\n        address toPickleJar,\\n        address fromPickleJarUnderlying,\\n        uint256 fromPickleJarUnderlyingAmount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) internal {\\n        uint256 _beforeTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _beforeFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _beforeDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _beforeTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 _ret = controller.swapExactJarForJar(\\n            fromPickleJar,\\n            toPickleJar,\\n            fromPickleJarUnderlyingAmount,\\n            0, // Min receive amount\\n            targets,\\n            data\\n        );\\n\\n        uint256 _afterTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _afterFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _afterDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _afterTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 treasuryEarned = _afterTreasury.sub(_beforeTreasury);\\n\\n        assertEq(treasuryEarned, _afterDev.sub(_beforeDev));\\n        assertTrue(treasuryEarned > 0);\\n        _test_check_treasury_fee(fromPickleJarUnderlyingAmount, treasuryEarned);\\n        assertTrue(_afterFrom < _beforeFrom);\\n        assertTrue(_afterTo > _beforeTo);\\n        assertTrue(_afterTo.sub(_beforeTo) > 0);\\n        assertEq(_afterTo.sub(_beforeTo), _ret);\\n        assertEq(_afterFrom, 0);\\n    }\\n\\n    function _get_uniswap_pl_swap_data(address from, address to)\\n        internal pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodeWithSignature(\\\"swapUniswap(address,address)\\\", from, to);\\n    }\\n\\n    function _test_curve_curve(\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 amount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) public {\\n        // Get LP\\n        _getCurveLP(curvePools[fromIndex], amount);\\n\\n        // Deposit into pickle jars\\n        address from = address(curvePickleJars[fromIndex].token());\\n        uint256 _from = IERC20(from).balanceOf(address(this));\\n        IERC20(from).approve(address(curvePickleJars[fromIndex]), _from);\\n        curvePickleJars[fromIndex].deposit(_from);\\n        curvePickleJars[fromIndex].earn();\\n\\n        // Approve controller\\n        uint256 _fromPickleJar = IERC20(address(curvePickleJars[fromIndex]))\\n            .balanceOf(address(this));\\n        IERC20(address(curvePickleJars[fromIndex])).approve(\\n            address(controller),\\n            _fromPickleJar\\n        );\\n\\n        // Swap\\n        try\\n            controller.swapExactJarForJar(\\n                address(curvePickleJars[fromIndex]),\\n                address(curvePickleJars[toIndex]),\\n                _fromPickleJar,\\n                uint256(-1), // Min receive amount\\n                targets,\\n                data\\n            )\\n         {\\n            revert(\\\"min-receive-amount\\\");\\n        } catch {}\\n\\n        _test_swap_and_check_balances(\\n            address(curvePickleJars[fromIndex]),\\n            address(curvePickleJars[toIndex]),\\n            from,\\n            _fromPickleJar,\\n            targets,\\n            data\\n        );\\n\\n        _post_swap_check(fromIndex, toIndex);\\n    }\\n\\n    // **** Tests ****\\n\\n    function test_jar_converter_curve_curve_0() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 1;\\n        uint256 amount = 400e18;\\n\\n        int128 fromCurveUnderlyingIndex = 0;\\n\\n        bytes4 toCurveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[4],uint256)\\\"\\n        );\\n        uint256 toCurvePoolSize = 4;\\n        uint256 toCurveUnderlyingIndex = 0;\\n        address toCurveUnderlying = dai;\\n\\n        // Remove liquidity\\n        address fromCurve = curvePools[fromIndex];\\n        address fromCurveLp = curveLps[fromIndex];\\n\\n        address payable target0 = payable(address(curveProxyLogic));\\n        bytes memory data0 = abi.encodeWithSignature(\\n            \\\"remove_liquidity_one_coin(address,address,int128)\\\",\\n            fromCurve,\\n            fromCurveLp,\\n            fromCurveUnderlyingIndex\\n        );\\n\\n        // Add liquidity\\n        address toCurve = curvePools[toIndex];\\n\\n        address payable target1 = payable(address(curveProxyLogic));\\n        bytes memory data1 = abi.encodeWithSignature(\\n            \\\"add_liquidity(address,bytes4,uint256,uint256,address)\\\",\\n            toCurve,\\n            toCurveFunctionSig,\\n            toCurvePoolSize,\\n            toCurveUnderlyingIndex,\\n            toCurveUnderlying\\n        );\\n\\n        // Swap\\n        _test_curve_curve(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(target0, target1),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_curve_1() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 2;\\n        uint256 amount = 400e18;\\n\\n        int128 fromCurveUnderlyingIndex = 0;\\n\\n        bytes4 toCurveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[2],uint256)\\\"\\n        );\\n        uint256 toCurvePoolSize = 2;\\n        uint256 toCurveUnderlyingIndex = 1;\\n        address toCurveUnderlying = wbtc;\\n\\n        // Remove liquidity\\n        address fromCurve = curvePools[fromIndex];\\n        address fromCurveLp = curveLps[fromIndex];\\n\\n        bytes memory data0 = abi.encodeWithSignature(\\n            \\\"remove_liquidity_one_coin(address,address,int128)\\\",\\n            fromCurve,\\n            fromCurveLp,\\n            fromCurveUnderlyingIndex\\n        );\\n\\n        // Swap\\n        bytes memory data1 = _get_uniswap_pl_swap_data(dai, toCurveUnderlying);\\n\\n        // Add liquidity\\n        address toCurve = curvePools[toIndex];\\n\\n        bytes memory data2 = abi.encodeWithSignature(\\n            \\\"add_liquidity(address,bytes4,uint256,uint256,address)\\\",\\n            toCurve,\\n            toCurveFunctionSig,\\n            toCurvePoolSize,\\n            toCurveUnderlyingIndex,\\n            toCurveUnderlying\\n        );\\n\\n        _test_curve_curve(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1, data2)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_curve_2() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 0;\\n        uint256 amount = 400e18;\\n\\n        int128 fromCurveUnderlyingIndex = 1;\\n\\n        bytes4 toCurveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[3],uint256)\\\"\\n        );\\n        uint256 toCurvePoolSize = 3;\\n        uint256 toCurveUnderlyingIndex = 2;\\n        address toCurveUnderlying = usdt;\\n\\n        // Remove liquidity\\n        address fromCurve = susdv2_deposit; // curvePools[fromIndex];\\n        address fromCurveLp = curveLps[fromIndex];\\n\\n        bytes memory data0 = abi.encodeWithSignature(\\n            \\\"remove_liquidity_one_coin(address,address,int128)\\\",\\n            fromCurve,\\n            fromCurveLp,\\n            fromCurveUnderlyingIndex\\n        );\\n\\n        // Swap\\n        bytes memory data1 = _get_uniswap_pl_swap_data(usdc, usdt);\\n\\n        // Add liquidity\\n        address toCurve = curvePools[toIndex];\\n\\n        bytes memory data2 = abi.encodeWithSignature(\\n            \\\"add_liquidity(address,bytes4,uint256,uint256,address)\\\",\\n            toCurve,\\n            toCurveFunctionSig,\\n            toCurvePoolSize,\\n            toCurveUnderlyingIndex,\\n            toCurveUnderlying\\n        );\\n\\n        _test_curve_curve(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1, data2)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_curve_3() public {\\n        uint256 fromIndex = 2;\\n        uint256 toIndex = 0;\\n        uint256 amount = 4e6;\\n\\n        int128 fromCurveUnderlyingIndex = 1;\\n\\n        bytes4 toCurveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[3],uint256)\\\"\\n        );\\n        uint256 toCurvePoolSize = 3;\\n        uint256 toCurveUnderlyingIndex = 1;\\n        address toCurveUnderlying = usdc;\\n\\n        // Remove liquidity\\n        address fromCurve = curvePools[fromIndex];\\n        address fromCurveLp = curveLps[fromIndex];\\n\\n        bytes memory data0 = abi.encodeWithSignature(\\n            \\\"remove_liquidity_one_coin(address,address,int128)\\\",\\n            fromCurve,\\n            fromCurveLp,\\n            fromCurveUnderlyingIndex\\n        );\\n\\n        // Swap\\n        bytes memory data1 = _get_uniswap_pl_swap_data(wbtc, usdc);\\n\\n        // Add liquidity\\n        address toCurve = curvePools[toIndex];\\n\\n        bytes memory data2 = abi.encodeWithSignature(\\n            \\\"add_liquidity(address,bytes4,uint256,uint256,address)\\\",\\n            toCurve,\\n            toCurveFunctionSig,\\n            toCurvePoolSize,\\n            toCurveUnderlyingIndex,\\n            toCurveUnderlying\\n        );\\n\\n        _test_curve_curve(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1, data2)\\n        );\\n    }\\n\\n    function test_jar_converter_curve_curve_4() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 0;\\n        uint256 amount = 400e18;\\n\\n        int128 fromCurveUnderlyingIndex = 2;\\n\\n        bytes4 toCurveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[3],uint256)\\\"\\n        );\\n        uint256 toCurvePoolSize = 3;\\n        uint256 toCurveUnderlyingIndex = 1;\\n        address toCurveUnderlying = usdc;\\n\\n        // Remove liquidity\\n        address fromCurve = susdv2_deposit;\\n        address fromCurveLp = curveLps[fromIndex];\\n\\n        bytes memory data0 = abi.encodeWithSignature(\\n            \\\"remove_liquidity_one_coin(address,address,int128)\\\",\\n            fromCurve,\\n            fromCurveLp,\\n            fromCurveUnderlyingIndex\\n        );\\n\\n        // Swap\\n        bytes memory data1 = _get_uniswap_pl_swap_data(usdt, usdc);\\n\\n        // Add liquidity\\n        address toCurve = curvePools[toIndex];\\n\\n        bytes memory data2 = abi.encodeWithSignature(\\n            \\\"add_liquidity(address,bytes4,uint256,uint256,address)\\\",\\n            toCurve,\\n            toCurveFunctionSig,\\n            toCurvePoolSize,\\n            toCurveUnderlyingIndex,\\n            toCurveUnderlying\\n        );\\n\\n        _test_curve_curve(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(curveProxyLogic)),\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1, data2)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/jar-converters/uni-uni.test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/hevm.sol\\\";\\nimport \\\"../lib/user.sol\\\";\\nimport \\\"../lib/test-approx.sol\\\";\\nimport \\\"../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../interfaces/strategy.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../pickle-jar.sol\\\";\\nimport \\\"../../controller-v4.sol\\\";\\n\\nimport \\\"../../proxy-logic/curve.sol\\\";\\nimport \\\"../../proxy-logic/uniswapv2.sol\\\";\\n\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-dai-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-usdt-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-usdc-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-wbtc-lp-v2.sol\\\";\\n\\ncontract StrategyUniUniJarSwapTest is DSTestDefiBase {\\n    address governance;\\n    address strategist;\\n    address devfund;\\n    address treasury;\\n    address timelock;\\n\\n    IStrategy[] uniStrategies;\\n    PickleJar[] uniPickleJars;\\n\\n    ControllerV4 controller;\\n\\n    CurveProxyLogic curveProxyLogic;\\n    UniswapV2ProxyLogic uniswapV2ProxyLogic;\\n\\n    address[] uniUnderlying;\\n\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        // Uni strategies\\n        uniStrategies = new IStrategy[](4);\\n        uniUnderlying = new address[](uniStrategies.length);\\n        uniPickleJars = new PickleJar[](uniStrategies.length);\\n\\n        uniUnderlying[0] = dai;\\n        uniStrategies[0] = IStrategy(\\n            address(\\n                new StrategyUniEthDaiLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[1] = usdc;\\n        uniStrategies[1] = IStrategy(\\n            address(\\n                new StrategyUniEthUsdcLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[2] = usdt;\\n        uniStrategies[2] = IStrategy(\\n            address(\\n                new StrategyUniEthUsdtLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[3] = wbtc;\\n        uniStrategies[3] = IStrategy(\\n            address(\\n                new StrategyUniEthWBtcLpV2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        for (uint256 i = 0; i < uniStrategies.length; i++) {\\n            uniPickleJars[i] = new PickleJar(\\n                uniStrategies[i].want(),\\n                governance,\\n                timelock,\\n                address(controller)\\n            );\\n\\n            controller.setJar(\\n                uniStrategies[i].want(),\\n                address(uniPickleJars[i])\\n            );\\n            controller.approveStrategy(\\n                uniStrategies[i].want(),\\n                address(uniStrategies[i])\\n            );\\n            controller.setStrategy(\\n                uniStrategies[i].want(),\\n                address(uniStrategies[i])\\n            );\\n        }\\n\\n        curveProxyLogic = new CurveProxyLogic();\\n        uniswapV2ProxyLogic = new UniswapV2ProxyLogic();\\n\\n        controller.approveJarConverter(address(curveProxyLogic));\\n        controller.approveJarConverter(address(uniswapV2ProxyLogic));\\n\\n        hevm.warp(startTime);\\n    }\\n\\n    function _getUniLP(\\n        address lp,\\n        uint256 ethAmount,\\n        uint256 otherAmount\\n    ) internal {\\n        IUniswapV2Pair fromPair = IUniswapV2Pair(lp);\\n\\n        address other = fromPair.token0() != weth\\n            ? fromPair.token0()\\n            : fromPair.token1();\\n\\n        _getERC20(other, otherAmount);\\n\\n        uint256 _other = IERC20(other).balanceOf(address(this));\\n\\n        IERC20(other).safeApprove(address(univ2), 0);\\n        IERC20(other).safeApprove(address(univ2), _other);\\n\\n        univ2.addLiquidityETH{value: ethAmount}(\\n            other,\\n            _other,\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    function _get_swap_lp_data(\\n        address from,\\n        address to,\\n        address dustRecipient\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"swapUniLPTokens(address,address,address)\\\",\\n                from,\\n                to,\\n                dustRecipient\\n            );\\n    }\\n\\n    function _post_swap_check(uint256 fromIndex, uint256 toIndex) internal {\\n        IERC20 token0 = uniPickleJars[fromIndex].token();\\n        IERC20 token1 = uniPickleJars[toIndex].token();\\n\\n        uint256 MAX_DUST = 10;\\n\\n        // No funds left behind\\n        assertEq(uniPickleJars[fromIndex].balanceOf(address(controller)), 0);\\n        assertEq(uniPickleJars[toIndex].balanceOf(address(controller)), 0);\\n        assertTrue(token0.balanceOf(address(controller)) < MAX_DUST);\\n        assertTrue(token1.balanceOf(address(controller)) < MAX_DUST);\\n\\n        // Make sure only controller can call 'withdrawForSwap'\\n        try uniStrategies[fromIndex].withdrawForSwap(0)  {\\n            revert(\\\"!withdraw-for-swap-only-controller\\\");\\n        } catch {}\\n    }\\n\\n    function _test_check_treasury_fee(uint256 _amount, uint256 earned)\\n        internal\\n    {\\n        assertEqApprox(\\n            _amount.mul(controller.convenienceFee()).div(\\n                controller.convenienceFeeMax()\\n            ),\\n            earned.mul(2)\\n        );\\n    }\\n\\n    function _test_swap_and_check_balances(\\n        address fromPickleJar,\\n        address toPickleJar,\\n        address fromPickleJarUnderlying,\\n        uint256 fromPickleJarUnderlyingAmount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) internal {\\n        uint256 _beforeTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _beforeFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _beforeDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _beforeTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 _ret = controller.swapExactJarForJar(\\n            fromPickleJar,\\n            toPickleJar,\\n            fromPickleJarUnderlyingAmount,\\n            0, // Min receive amount\\n            targets,\\n            data\\n        );\\n\\n        uint256 _afterTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _afterFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _afterDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _afterTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 treasuryEarned = _afterTreasury.sub(_beforeTreasury);\\n\\n        assertEq(treasuryEarned, _afterDev.sub(_beforeDev));\\n        assertTrue(treasuryEarned > 0);\\n        _test_check_treasury_fee(fromPickleJarUnderlyingAmount, treasuryEarned);\\n        assertTrue(_afterFrom < _beforeFrom);\\n        assertTrue(_afterTo > _beforeTo);\\n        assertTrue(_afterTo.sub(_beforeTo) > 0);\\n        assertEq(_afterTo.sub(_beforeTo), _ret);\\n        assertEq(_afterFrom, 0);\\n    }\\n\\n    function _test_uni_uni(\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 amount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) internal {\\n        address from = address(uniPickleJars[fromIndex].token());\\n\\n        _getUniLP(from, 1e18, amount);\\n\\n        uint256 _from = IERC20(from).balanceOf(address(this));\\n        IERC20(from).approve(address(uniPickleJars[fromIndex]), _from);\\n        uniPickleJars[fromIndex].deposit(_from);\\n        uniPickleJars[fromIndex].earn();\\n\\n        // Swap!\\n        uint256 _fromPickleJar = IERC20(address(uniPickleJars[fromIndex]))\\n            .balanceOf(address(this));\\n        IERC20(address(uniPickleJars[fromIndex])).approve(\\n            address(controller),\\n            _fromPickleJar\\n        );\\n\\n        // Check minimum amount\\n        try\\n            controller.swapExactJarForJar(\\n                address(uniPickleJars[fromIndex]),\\n                address(uniPickleJars[toIndex]),\\n                _fromPickleJar,\\n                uint256(-1), // Min receive amount\\n                targets,\\n                data\\n            )\\n         {\\n            revert(\\\"min-amount-should-fail\\\");\\n        } catch {}\\n\\n        _test_swap_and_check_balances(\\n            address(uniPickleJars[fromIndex]),\\n            address(uniPickleJars[toIndex]),\\n            from,\\n            _fromPickleJar,\\n            targets,\\n            data\\n        );\\n\\n        _post_swap_check(fromIndex, toIndex);\\n    }\\n\\n    // **** Tests ****\\n\\n    function test_jar_converter_uni_uni_0() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 1;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n        address from = univ2Factory.getPair(weth, fromUnderlying);\\n\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address to = univ2Factory.getPair(weth, toUnderlying);\\n\\n        _test_uni_uni(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(payable(address(uniswapV2ProxyLogic))),\\n            _getDynamicArray(_get_swap_lp_data(from, to, treasury))\\n        );\\n    }\\n\\n    function test_jar_converter_uni_uni_1() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 2;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n        address from = univ2Factory.getPair(weth, fromUnderlying);\\n\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address to = univ2Factory.getPair(weth, toUnderlying);\\n\\n        _test_uni_uni(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(payable(address(uniswapV2ProxyLogic))),\\n            _getDynamicArray(_get_swap_lp_data(from, to, treasury))\\n        );\\n    }\\n\\n    function test_jar_converter_uni_uni_2() public {\\n        uint256 fromIndex = 2;\\n        uint256 toIndex = 3;\\n        uint256 amount = 400e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n        address from = univ2Factory.getPair(weth, fromUnderlying);\\n\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address to = univ2Factory.getPair(weth, toUnderlying);\\n\\n        _test_uni_uni(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(payable(address(uniswapV2ProxyLogic))),\\n            _getDynamicArray(_get_swap_lp_data(from, to, treasury))\\n        );\\n    }\\n\\n    function test_jar_converter_uni_uni_3() public {\\n        uint256 fromIndex = 3;\\n        uint256 toIndex = 2;\\n        uint256 amount = 4e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n        address from = univ2Factory.getPair(weth, fromUnderlying);\\n\\n        address toUnderlying = uniUnderlying[toIndex];\\n        address to = univ2Factory.getPair(weth, toUnderlying);\\n\\n        _test_uni_uni(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(payable(address(uniswapV2ProxyLogic))),\\n            _getDynamicArray(_get_swap_lp_data(from, to, treasury))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tests/jar-converters/uni-curve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/hevm.sol\\\";\\nimport \\\"../lib/user.sol\\\";\\nimport \\\"../lib/test-approx.sol\\\";\\nimport \\\"../lib/test-defi-base.sol\\\";\\n\\nimport \\\"../../interfaces/strategy.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\n\\nimport \\\"../../pickle-jar.sol\\\";\\nimport \\\"../../controller-v4.sol\\\";\\n\\nimport \\\"../../proxy-logic/curve.sol\\\";\\nimport \\\"../../proxy-logic/uniswapv2.sol\\\";\\n\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-dai-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-usdt-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-usdc-lp-v4.sol\\\";\\nimport \\\"../../strategies/uniswapv2/strategy-uni-eth-wbtc-lp-v2.sol\\\";\\n\\nimport \\\"../../strategies/curve/strategy-curve-scrv-v3_2.sol\\\";\\nimport \\\"../../strategies/curve/strategy-curve-rencrv-v2.sol\\\";\\nimport \\\"../../strategies/curve/strategy-curve-3crv-v2.sol\\\";\\n\\ncontract StrategyUniCurveJarSwapTest is DSTestDefiBase {\\n    address governance;\\n    address strategist;\\n    address devfund;\\n    address treasury;\\n    address timelock;\\n\\n    IStrategy[] curveStrategies;\\n    IStrategy[] uniStrategies;\\n\\n    PickleJar[] curvePickleJars;\\n    PickleJar[] uniPickleJars;\\n\\n    ControllerV4 controller;\\n\\n    CurveProxyLogic curveProxyLogic;\\n    UniswapV2ProxyLogic uniswapV2ProxyLogic;\\n\\n    address[] curvePools;\\n    address[] curveLps;\\n\\n    address[] uniUnderlying;\\n\\n    // Contract wide variable to avoid stack too deep errors\\n    uint256 temp;\\n\\n    function setUp() public {\\n        governance = address(this);\\n        strategist = address(this);\\n        devfund = address(new User());\\n        treasury = address(new User());\\n        timelock = address(this);\\n\\n        controller = new ControllerV4(\\n            governance,\\n            strategist,\\n            timelock,\\n            devfund,\\n            treasury\\n        );\\n\\n        // Curve Strategies\\n        curveStrategies = new IStrategy[](3);\\n        curvePickleJars = new PickleJar[](curveStrategies.length);\\n        curveLps = new address[](curveStrategies.length);\\n        curvePools = new address[](curveStrategies.length);\\n\\n        curveLps[0] = three_crv;\\n        curvePools[0] = three_pool;\\n        curveStrategies[0] = IStrategy(\\n            address(\\n                new StrategyCurve3CRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        curveLps[1] = scrv;\\n        curvePools[1] = susdv2_pool;\\n        curveStrategies[1] = IStrategy(\\n            address(\\n                new StrategyCurveSCRVv3_2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        curveLps[2] = ren_crv;\\n        curvePools[2] = ren_pool;\\n        curveStrategies[2] = IStrategy(\\n            address(\\n                new StrategyCurveRenCRVv2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        // Create PICKLE Jars\\n        for (uint256 i = 0; i < curvePickleJars.length; i++) {\\n            curvePickleJars[i] = new PickleJar(\\n                curveStrategies[i].want(),\\n                governance,\\n                timelock,\\n                address(controller)\\n            );\\n\\n            controller.setJar(\\n                curveStrategies[i].want(),\\n                address(curvePickleJars[i])\\n            );\\n            controller.approveStrategy(\\n                curveStrategies[i].want(),\\n                address(curveStrategies[i])\\n            );\\n            controller.setStrategy(\\n                curveStrategies[i].want(),\\n                address(curveStrategies[i])\\n            );\\n        }\\n\\n        // Uni strategies\\n        uniStrategies = new IStrategy[](4);\\n        uniUnderlying = new address[](uniStrategies.length);\\n        uniPickleJars = new PickleJar[](uniStrategies.length);\\n\\n        uniUnderlying[0] = dai;\\n        uniStrategies[0] = IStrategy(\\n            address(\\n                new StrategyUniEthDaiLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[1] = usdc;\\n        uniStrategies[1] = IStrategy(\\n            address(\\n                new StrategyUniEthUsdcLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[2] = usdt;\\n        uniStrategies[2] = IStrategy(\\n            address(\\n                new StrategyUniEthUsdtLpV4(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        uniUnderlying[3] = wbtc;\\n        uniStrategies[3] = IStrategy(\\n            address(\\n                new StrategyUniEthWBtcLpV2(\\n                    governance,\\n                    strategist,\\n                    address(controller),\\n                    timelock\\n                )\\n            )\\n        );\\n\\n        for (uint256 i = 0; i < uniStrategies.length; i++) {\\n            uniPickleJars[i] = new PickleJar(\\n                uniStrategies[i].want(),\\n                governance,\\n                timelock,\\n                address(controller)\\n            );\\n\\n            controller.setJar(\\n                uniStrategies[i].want(),\\n                address(uniPickleJars[i])\\n            );\\n            controller.approveStrategy(\\n                uniStrategies[i].want(),\\n                address(uniStrategies[i])\\n            );\\n            controller.setStrategy(\\n                uniStrategies[i].want(),\\n                address(uniStrategies[i])\\n            );\\n        }\\n\\n        curveProxyLogic = new CurveProxyLogic();\\n        uniswapV2ProxyLogic = new UniswapV2ProxyLogic();\\n\\n        controller.approveJarConverter(address(curveProxyLogic));\\n        controller.approveJarConverter(address(uniswapV2ProxyLogic));\\n\\n        hevm.warp(startTime);\\n    }\\n\\n    function _getUniLP(\\n        address lp,\\n        uint256 ethAmount,\\n        uint256 otherAmount\\n    ) internal {\\n        IUniswapV2Pair fromPair = IUniswapV2Pair(lp);\\n\\n        address other = fromPair.token0() != weth\\n            ? fromPair.token0()\\n            : fromPair.token1();\\n\\n        _getERC20(other, otherAmount);\\n\\n        uint256 _other = IERC20(other).balanceOf(address(this));\\n\\n        IERC20(other).safeApprove(address(univ2), 0);\\n        IERC20(other).safeApprove(address(univ2), _other);\\n\\n        univ2.addLiquidityETH{value: ethAmount}(\\n            other,\\n            _other,\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n    }\\n\\n    function _get_uniswap_remove_liquidity_data(address pair)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodeWithSignature(\\\"removeLiquidity(address)\\\", pair);\\n    }\\n\\n    function _get_uniswap_lp_tokens_to_primitive(address from, address to)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"lpTokensToPrimitive(address,address)\\\",\\n                from,\\n                to\\n            );\\n    }\\n\\n    function _get_curve_add_liquidity_data(\\n        address curve,\\n        bytes4 curveFunctionSig,\\n        uint256 curvePoolSize,\\n        uint256 curveUnderlyingIndex,\\n        address underlying\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodeWithSignature(\\n                \\\"add_liquidity(address,bytes4,uint256,uint256,address)\\\",\\n                curve,\\n                curveFunctionSig,\\n                curvePoolSize,\\n                curveUnderlyingIndex,\\n                underlying\\n            );\\n    }\\n\\n    // Some post swap checks\\n    // Checks if there's any leftover funds in the converter contract\\n    function _post_swap_check(uint256 fromIndex, uint256 toIndex) internal {\\n        IERC20 token0 = uniPickleJars[fromIndex].token();\\n        IERC20 token1 = curvePickleJars[toIndex].token();\\n\\n        // No funds left behind\\n        assertEq(uniPickleJars[fromIndex].balanceOf(address(controller)), 0);\\n        assertEq(curvePickleJars[toIndex].balanceOf(address(controller)), 0);\\n        assertEq(token0.balanceOf(address(controller)), 0);\\n        assertEq(token1.balanceOf(address(controller)), 0);\\n        assertEq(IERC20(wbtc).balanceOf(address(controller)), 0);\\n        // assertEq(IERC20(usdt).balanceOf(address(controller)), 0);\\n        // assertEq(IERC20(usdc).balanceOf(address(controller)), 0);\\n        // assertEq(IERC20(susd).balanceOf(address(controller)), 0);\\n        // assertEq(IERC20(dai).balanceOf(address(controller)), 0);\\n\\n        // No balance left behind!\\n        assertEq(token1.balanceOf(address(this)), 0);\\n\\n        // Make sure only controller can call 'withdrawForSwap'\\n        try uniStrategies[fromIndex].withdrawForSwap(0)  {\\n            revert(\\\"!withdraw-for-swap-only-controller\\\");\\n        } catch {}\\n    }\\n\\n    function _test_check_treasury_fee(uint256 _amount, uint256 earned)\\n        internal\\n    {\\n        assertEqApprox(\\n            _amount.mul(controller.convenienceFee()).div(\\n                controller.convenienceFeeMax()\\n            ),\\n            earned.mul(2)\\n        );\\n    }\\n\\n    function _test_swap_and_check_balances(\\n        address fromPickleJar,\\n        address toPickleJar,\\n        address fromPickleJarUnderlying,\\n        uint256 fromPickleJarUnderlyingAmount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) internal {\\n        uint256 _beforeTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _beforeFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _beforeDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _beforeTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 _ret = controller.swapExactJarForJar(\\n            fromPickleJar,\\n            toPickleJar,\\n            fromPickleJarUnderlyingAmount,\\n            0, // Min receive amount\\n            targets,\\n            data\\n        );\\n\\n        uint256 _afterTo = IERC20(toPickleJar).balanceOf(address(this));\\n        uint256 _afterFrom = IERC20(fromPickleJar).balanceOf(address(this));\\n\\n        uint256 _afterDev = IERC20(fromPickleJarUnderlying).balanceOf(devfund);\\n        uint256 _afterTreasury = IERC20(fromPickleJarUnderlying).balanceOf(\\n            treasury\\n        );\\n\\n        uint256 treasuryEarned = _afterTreasury.sub(_beforeTreasury);\\n\\n        assertEq(treasuryEarned, _afterDev.sub(_beforeDev));\\n        assertTrue(treasuryEarned > 0);\\n        _test_check_treasury_fee(fromPickleJarUnderlyingAmount, treasuryEarned);\\n        assertTrue(_afterFrom < _beforeFrom);\\n        assertTrue(_afterTo > _beforeTo);\\n        assertTrue(_afterTo.sub(_beforeTo) > 0);\\n        assertEq(_afterTo.sub(_beforeTo), _ret);\\n        assertEq(_afterFrom, 0);\\n    }\\n\\n    function _test_uni_curve_swap(\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 amount,\\n        address payable[] memory targets,\\n        bytes[] memory data\\n    ) internal {\\n        // Deposit into PickleJars\\n        address from = address(uniPickleJars[fromIndex].token());\\n\\n        _getUniLP(from, 1e18, amount);\\n\\n        uint256 _from = IERC20(from).balanceOf(address(this));\\n        IERC20(from).approve(address(uniPickleJars[fromIndex]), _from);\\n        uniPickleJars[fromIndex].deposit(_from);\\n        uniPickleJars[fromIndex].earn();\\n\\n        // Swap!\\n        uint256 _fromPickleJar = IERC20(address(uniPickleJars[fromIndex]))\\n            .balanceOf(address(this));\\n        IERC20(address(uniPickleJars[fromIndex])).approve(\\n            address(controller),\\n            _fromPickleJar\\n        );\\n\\n        // Check minimum amount\\n        try\\n            controller.swapExactJarForJar(\\n                address(uniPickleJars[fromIndex]),\\n                address(curvePickleJars[toIndex]),\\n                _fromPickleJar,\\n                uint256(-1), // Min receive amount\\n                targets,\\n                data\\n            )\\n         {\\n            revert(\\\"min-amount-should-fail\\\");\\n        } catch {}\\n\\n        _test_swap_and_check_balances(\\n            address(uniPickleJars[fromIndex]),\\n            address(curvePickleJars[toIndex]),\\n            from,\\n            _fromPickleJar,\\n            targets,\\n            data\\n        );\\n\\n        _post_swap_check(fromIndex, toIndex);\\n    }\\n\\n    // **** Tests **** //\\n\\n    function test_jar_converter_uni_curve_0_0() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 0;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 3;\\n        address curveUnderlying = dai;\\n        uint256 curveUnderlyingIndex = 0;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[3],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_1_0() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 0;\\n        uint256 amount = 400e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 3;\\n        address curveUnderlying = dai;\\n        uint256 curveUnderlyingIndex = 0;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[3],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_2_0() public {\\n        uint256 fromIndex = 2;\\n        uint256 toIndex = 0;\\n        uint256 amount = 400e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 3;\\n        address curveUnderlying = dai;\\n        uint256 curveUnderlyingIndex = 0;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[3],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_3_0() public {\\n        uint256 fromIndex = 3;\\n        uint256 toIndex = 0;\\n        uint256 amount = 4e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 3;\\n        address curveUnderlying = dai;\\n        uint256 curveUnderlyingIndex = 0;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[3],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_0_1() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 1;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 4;\\n        address curveUnderlying = usdt;\\n        uint256 curveUnderlyingIndex = 2;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[4],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_1_1() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 1;\\n        uint256 amount = 400e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 4;\\n        address curveUnderlying = usdt;\\n        uint256 curveUnderlyingIndex = 2;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[4],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_2_1() public {\\n        uint256 fromIndex = 2;\\n        uint256 toIndex = 1;\\n        uint256 amount = 400e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 4;\\n        address curveUnderlying = usdt;\\n        uint256 curveUnderlyingIndex = 2;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[4],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_3_1() public {\\n        uint256 fromIndex = 3;\\n        uint256 toIndex = 1;\\n        uint256 amount = 4e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 4;\\n        address curveUnderlying = usdt;\\n        uint256 curveUnderlyingIndex = 2;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[4],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_4_1() public {\\n        uint256 fromIndex = 3;\\n        uint256 toIndex = 1;\\n        uint256 amount = 4e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 4;\\n        address curveUnderlying = usdt;\\n        uint256 curveUnderlyingIndex = 2;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[4],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_0_2() public {\\n        uint256 fromIndex = 0;\\n        uint256 toIndex = 2;\\n        uint256 amount = 400e18;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 2;\\n        address curveUnderlying = wbtc;\\n        uint256 curveUnderlyingIndex = 1;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[2],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_1_2() public {\\n        uint256 fromIndex = 1;\\n        uint256 toIndex = 2;\\n        uint256 amount = 400e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 2;\\n        address curveUnderlying = wbtc;\\n        uint256 curveUnderlyingIndex = 1;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[2],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_2_2() public {\\n        uint256 fromIndex = 2;\\n        uint256 toIndex = 2;\\n        uint256 amount = 400e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 2;\\n        address curveUnderlying = wbtc;\\n        uint256 curveUnderlyingIndex = 1;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[2],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n    function test_jar_converter_uni_curve_3_2() public {\\n        uint256 fromIndex = 3;\\n        uint256 toIndex = 2;\\n        uint256 amount = 4e6;\\n\\n        address fromUnderlying = uniUnderlying[fromIndex];\\n\\n        address curvePool = curvePools[toIndex];\\n        uint256 curvePoolSize = 2;\\n        address curveUnderlying = wbtc;\\n        uint256 curveUnderlyingIndex = 1;\\n        bytes4 curveFunctionSig = _getFunctionSig(\\n            \\\"add_liquidity(uint256[2],uint256)\\\"\\n        );\\n\\n        bytes memory data0 = _get_uniswap_lp_tokens_to_primitive(\\n            univ2Factory.getPair(weth, fromUnderlying),\\n            curveUnderlying\\n        );\\n\\n        bytes memory data1 = _get_curve_add_liquidity_data(\\n            curvePool,\\n            curveFunctionSig,\\n            curvePoolSize,\\n            curveUnderlyingIndex,\\n            curveUnderlying\\n        );\\n\\n        _test_uni_curve_swap(\\n            fromIndex,\\n            toIndex,\\n            amount,\\n            _getDynamicArray(\\n                payable(address(uniswapV2ProxyLogic)),\\n                payable(address(curveProxyLogic))\\n            ),\\n            _getDynamicArray(data0, data1)\\n        );\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"src/uni-curve-converter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\n\\nimport \\\"./lib/safe-math.sol\\\";\\nimport \\\"./lib/erc20.sol\\\";\\n\\nimport \\\"./interfaces/uniswapv2.sol\\\";\\nimport \\\"./interfaces/curve.sol\\\";\\n\\n// Converts UNI LP Tokens to Curve LP Tokens\\n// Mainly for treasury\\ncontract UniCurveConverter {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    UniswapRouterV2 public router = UniswapRouterV2(\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n    );\\n\\n    // Stablecoins\\n    address public constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address public constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address public constant susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n\\n    // Wrapped stablecoins\\n    address public constant scrv = 0xC25a3A3b969415c80451098fa907EC722572917F;\\n\\n    // Weth\\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    // susd v2 pool\\n    ICurveFi_4 public curve = ICurveFi_4(\\n        0xA5407eAE9Ba41422680e2e00537571bcC53efBfD\\n    );\\n\\n    // UNI LP -> Curve LP\\n    // Assume th\\n    function convert(address _lp, uint256 _amount) public {\\n        // Get LP Tokens\\n        IERC20(_lp).safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        // Get Uniswap pair\\n        IUniswapV2Pair fromPair = IUniswapV2Pair(_lp);\\n\\n        // Only for WETH/<TOKEN> pairs\\n        if (!(fromPair.token0() == weth || fromPair.token1() == weth)) {\\n            revert(\\\"!eth-from\\\");\\n        }\\n\\n        // Remove liquidity\\n        IERC20(_lp).safeApprove(address(router), 0);\\n        IERC20(_lp).safeApprove(address(router), _amount);\\n        router.removeLiquidity(\\n            fromPair.token0(),\\n            fromPair.token1(),\\n            _amount,\\n            0,\\n            0,\\n            address(this),\\n            now + 60\\n        );\\n\\n        // Most premium stablecoin\\n        (address premiumStablecoin, ) = getMostPremium();\\n\\n        // Convert weth -> most premium stablecoin\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = premiumStablecoin;\\n\\n        IERC20(weth).safeApprove(address(router), 0);\\n        IERC20(weth).safeApprove(address(router), uint256(-1));\\n        router.swapExactTokensForTokens(\\n            IERC20(weth).balanceOf(address(this)),\\n            0,\\n            path,\\n            address(this),\\n            now + 60\\n        );\\n\\n        // Convert the other asset into stablecoin if its not a stablecoin\\n        address _from = fromPair.token0() != weth\\n            ? fromPair.token0()\\n            : fromPair.token1();\\n\\n        if (_from != dai && _from != usdc && _from != usdt && _from != susd) {\\n            path = new address[](3);\\n            path[0] = _from;\\n            path[1] = weth;\\n            path[2] = premiumStablecoin;\\n\\n            IERC20(_from).safeApprove(address(router), 0);\\n            IERC20(_from).safeApprove(address(router), uint256(-1));\\n            router.swapExactTokensForTokens(\\n                IERC20(_from).balanceOf(address(this)),\\n                0,\\n                path,\\n                address(this),\\n                now + 60\\n            );\\n        }\\n\\n        // Add liquidity to curve\\n        IERC20(dai).safeApprove(address(curve), 0);\\n        IERC20(dai).safeApprove(address(curve), uint256(-1));\\n\\n        IERC20(usdc).safeApprove(address(curve), 0);\\n        IERC20(usdc).safeApprove(address(curve), uint256(-1));\\n\\n        IERC20(usdt).safeApprove(address(curve), 0);\\n        IERC20(usdt).safeApprove(address(curve), uint256(-1));\\n\\n        IERC20(susd).safeApprove(address(curve), 0);\\n        IERC20(susd).safeApprove(address(curve), uint256(-1));\\n\\n        curve.add_liquidity(\\n            [\\n                IERC20(dai).balanceOf(address(this)),\\n                IERC20(usdc).balanceOf(address(this)),\\n                IERC20(usdt).balanceOf(address(this)),\\n                IERC20(susd).balanceOf(address(this))\\n            ],\\n            0\\n        );\\n\\n        // Sends token back to user\\n        IERC20(scrv).transfer(\\n            msg.sender,\\n            IERC20(scrv).balanceOf(address(this))\\n        );\\n    }\\n\\n    function getMostPremium() public view returns (address, uint256) {\\n        uint256[] memory balances = new uint256[](4);\\n        balances[0] = ICurveFi_4(curve).balances(0); // DAI\\n        balances[1] = ICurveFi_4(curve).balances(1).mul(10**12); // USDC\\n        balances[2] = ICurveFi_4(curve).balances(2).mul(10**12); // USDT\\n        balances[3] = ICurveFi_4(curve).balances(3); // sUSD\\n\\n        // DAI\\n        if (\\n            balances[0] < balances[1] &&\\n            balances[0] < balances[2] &&\\n            balances[0] < balances[3]\\n        ) {\\n            return (dai, 0);\\n        }\\n\\n        // USDC\\n        if (\\n            balances[1] < balances[0] &&\\n            balances[1] < balances[2] &&\\n            balances[1] < balances[3]\\n        ) {\\n            return (usdc, 1);\\n        }\\n\\n        // USDT\\n        if (\\n            balances[2] < balances[0] &&\\n            balances[2] < balances[1] &&\\n            balances[2] < balances[3]\\n        ) {\\n            return (usdt, 2);\\n        }\\n\\n        // SUSD\\n        if (\\n            balances[3] < balances[0] &&\\n            balances[3] < balances[1] &&\\n            balances[3] < balances[2]\\n        ) {\\n            return (susd, 3);\\n        }\\n\\n        // If they're somehow equal, we just want DAI\\n        return (dai, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/curve/crv-locker.sol\": {\r\n      \"content\": \"// CurveYCRVVoter: https://etherscan.io/address/0xF147b8125d2ef93FB6965Db97D6746952a133934#code\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\nimport \\\"../../lib/safe-math.sol\\\";\\n\\nimport \\\"../../interfaces/curve.sol\\\";\\n\\ncontract CRVLocker {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    address public constant mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\\n\\n    address public constant escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\\n\\n    address public governance;\\n    mapping(address => bool) public voters;\\n\\n    constructor(address _governance) public {\\n        governance = _governance;\\n    }\\n\\n    function getName() external pure returns (string memory) {\\n        return \\\"CRVLocker\\\";\\n    }\\n\\n    function addVoter(address _voter) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        voters[_voter] = true;\\n    }\\n\\n    function removeVoter(address _voter) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        voters[_voter] = false;\\n    }\\n\\n    function withdraw(address _asset) external returns (uint256 balance) {\\n        require(voters[msg.sender], \\\"!voter\\\");\\n        balance = IERC20(_asset).balanceOf(address(this));\\n        IERC20(_asset).safeTransfer(msg.sender, balance);\\n    }\\n\\n    function createLock(uint256 _value, uint256 _unlockTime) external {\\n        require(voters[msg.sender] || msg.sender == governance, \\\"!authorized\\\");\\n        IERC20(crv).safeApprove(escrow, 0);\\n        IERC20(crv).safeApprove(escrow, _value);\\n        ICurveVotingEscrow(escrow).create_lock(_value, _unlockTime);\\n    }\\n\\n    function increaseAmount(uint256 _value) external {\\n        require(voters[msg.sender] || msg.sender == governance, \\\"!authorized\\\");\\n        IERC20(crv).safeApprove(escrow, 0);\\n        IERC20(crv).safeApprove(escrow, _value);\\n        ICurveVotingEscrow(escrow).increase_amount(_value);\\n    }\\n\\n    function increaseUnlockTime(uint256 _unlockTime) external {\\n        require(voters[msg.sender] || msg.sender == governance, \\\"!authorized\\\");\\n        ICurveVotingEscrow(escrow).increase_unlock_time(_unlockTime);\\n    }\\n\\n    function release() external {\\n        require(voters[msg.sender] || msg.sender == governance, \\\"!authorized\\\");\\n        ICurveVotingEscrow(escrow).withdraw();\\n    }\\n\\n    function setGovernance(address _governance) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        governance = _governance;\\n    }\\n\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool, bytes memory) {\\n        require(voters[msg.sender] || msg.sender == governance, \\\"!governance\\\");\\n\\n        (bool success, bytes memory result) = to.call{value: value}(data);\\n        require(success, \\\"!execute-success\\\");\\n\\n        return (success, result);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/curve/strategy-curve-rencrv-v2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\nimport \\\"../../lib/safe-math.sol\\\";\\n\\nimport \\\"../../interfaces/jar.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\nimport \\\"../../interfaces/controller.sol\\\";\\n\\nimport \\\"../strategy-curve-base.sol\\\";\\n\\ncontract StrategyCurveRenCRVv2 is StrategyCurveBase {\\n    // https://www.curve.fi/ren\\n    // Curve stuff\\n    address public ren_pool = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\\n    address public ren_gauge = 0xB1F2cdeC61db658F091671F5f199635aEF202CAC;\\n    address public ren_crv = 0x49849C98ae39Fff122806C06791Fa73784FB3675;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyCurveBase(\\n            ren_pool,\\n            ren_gauge,\\n            ren_crv,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {}\\n\\n    // **** Views ****\\n\\n    function getMostPremium() public override view returns (address, uint256) {\\n        // Both 8 decimals, so doesn't matter\\n        uint256[] memory balances = new uint256[](3);\\n        balances[0] = ICurveFi_2(curve).balances(0); // RENBTC\\n        balances[1] = ICurveFi_2(curve).balances(1); // WBTC\\n\\n        // renbtc\\n        if (balances[0] < balances[1]) {\\n            return (renbtc, 0);\\n        }\\n\\n        // WBTC\\n        if (balances[1] < balances[0]) {\\n            return (wbtc, 1);\\n        }\\n\\n        // If they're somehow equal, we just want RENBTC\\n        return (renbtc, 0);\\n    }\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyCurveRenCRVv2\\\";\\n    }\\n\\n    // **** State Mutations ****\\n\\n    function harvest() public override onlyBenevolent {\\n        // Anyone can harvest it at any given time.\\n        // I understand the possibility of being frontrun\\n        // But ETH is a dark forest, and I wanna see how this plays out\\n        // i.e. will be be heavily frontrunned?\\n        //      if so, a new strategy will be deployed.\\n\\n        // stablecoin we want to convert to\\n        (address to, uint256 toIndex) = getMostPremium();\\n\\n        // Collects crv tokens\\n        // Don't bother voting in v1\\n        ICurveMintr(mintr).mint(gauge);\\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\\n        if (_crv > 0) {\\n            // x% is sent back to the rewards holder\\n            // to be used to lock up in as veCRV in a future date\\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\\n            if (_keepCRV > 0) {\\n                IERC20(crv).safeTransfer(\\n                    IController(controller).treasury(),\\n                    _keepCRV\\n                );\\n            }\\n            _crv = _crv.sub(_keepCRV);\\n            _swapUniswap(crv, to, _crv);\\n        }\\n\\n        // Adds liquidity to curve.fi's pool\\n        // to get back want (scrv)\\n        uint256 _to = IERC20(to).balanceOf(address(this));\\n        if (_to > 0) {\\n            IERC20(to).safeApprove(curve, 0);\\n            IERC20(to).safeApprove(curve, _to);\\n            uint256[2] memory liquidity;\\n            liquidity[toIndex] = _to;\\n            ICurveFi_2(curve).add_liquidity(liquidity, 0);\\n        }\\n\\n        _distributePerformanceFeesAndDeposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/curve/strategy-curve-3crv-v2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\nimport \\\"../../lib/safe-math.sol\\\";\\n\\nimport \\\"../../interfaces/jar.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\nimport \\\"../../interfaces/controller.sol\\\";\\n\\nimport \\\"../strategy-curve-base.sol\\\";\\n\\ncontract StrategyCurve3CRVv2 is StrategyCurveBase {\\n    // Curve stuff\\n    address public three_pool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\n    address public three_gauge = 0xbFcF63294aD7105dEa65aA58F8AE5BE2D9d0952A;\\n    address public three_crv = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyCurveBase(\\n            three_pool,\\n            three_gauge,\\n            three_crv,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {}\\n\\n    // **** Views ****\\n\\n    function getMostPremium()\\n        public\\n        override\\n        view\\n        returns (address, uint256)\\n    {\\n        uint256[] memory balances = new uint256[](3);\\n        balances[0] = ICurveFi_3(curve).balances(0); // DAI\\n        balances[1] = ICurveFi_3(curve).balances(1).mul(10**12); // USDC\\n        balances[2] = ICurveFi_3(curve).balances(2).mul(10**12); // USDT\\n\\n        // DAI\\n        if (\\n            balances[0] < balances[1] &&\\n            balances[0] < balances[2]\\n        ) {\\n            return (dai, 0);\\n        }\\n\\n        // USDC\\n        if (\\n            balances[1] < balances[0] &&\\n            balances[1] < balances[2]\\n        ) {\\n            return (usdc, 1);\\n        }\\n\\n        // USDT\\n        if (\\n            balances[2] < balances[0] &&\\n            balances[2] < balances[1]\\n        ) {\\n            return (usdt, 2);\\n        }\\n\\n        // If they're somehow equal, we just want DAI\\n        return (dai, 0);\\n    }\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyCurve3CRVv2\\\";\\n    }\\n\\n    // **** State Mutations ****\\n\\n    function harvest() public onlyBenevolent override {\\n        // Anyone can harvest it at any given time.\\n        // I understand the possibility of being frontrun\\n        // But ETH is a dark forest, and I wanna see how this plays out\\n        // i.e. will be be heavily frontrunned?\\n        //      if so, a new strategy will be deployed.\\n\\n        // stablecoin we want to convert to\\n        (address to, uint256 toIndex) = getMostPremium();\\n\\n        // Collects crv tokens\\n        // Don't bother voting in v1\\n        ICurveMintr(mintr).mint(gauge);\\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\\n        if (_crv > 0) {\\n            // x% is sent back to the rewards holder\\n            // to be used to lock up in as veCRV in a future date\\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\\n            if (_keepCRV > 0) {\\n                IERC20(crv).safeTransfer(\\n                    IController(controller).treasury(),\\n                    _keepCRV\\n                );\\n            }\\n            _crv = _crv.sub(_keepCRV);\\n            _swapUniswap(crv, to, _crv);\\n        }\\n\\n        // Adds liquidity to curve.fi's pool\\n        // to get back want (scrv)\\n        uint256 _to = IERC20(to).balanceOf(address(this));\\n        if (_to > 0) {\\n            IERC20(to).safeApprove(curve, 0);\\n            IERC20(to).safeApprove(curve, _to);\\n            uint256[3] memory liquidity;\\n            liquidity[toIndex] = _to;\\n            ICurveFi_3(curve).add_liquidity(liquidity, 0);\\n        }\\n\\n        _distributePerformanceFeesAndDeposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/curve/strategy-curve-scrv-v3_2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\nimport \\\"../../lib/safe-math.sol\\\";\\n\\nimport \\\"./scrv-voter.sol\\\";\\nimport \\\"./crv-locker.sol\\\";\\n\\nimport \\\"../../interfaces/jar.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\nimport \\\"../../interfaces/controller.sol\\\";\\n\\nimport \\\"../strategy-curve-base.sol\\\";\\n\\ncontract StrategyCurveSCRVv3_2 is StrategyCurveBase {\\n    // Curve stuff\\n    address public susdv2_pool = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\\n    address public susdv2_gauge = 0xA90996896660DEcC6E997655E065b23788857849;\\n    address public scrv = 0xC25a3A3b969415c80451098fa907EC722572917F;\\n\\n    // Harvesting\\n    address public snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyCurveBase(\\n            susdv2_pool,\\n            susdv2_gauge,\\n            scrv,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {}\\n\\n    // **** Views ****\\n\\n    function getMostPremium()\\n        public\\n        override\\n        view\\n        returns (address, uint256)\\n    {\\n        uint256[] memory balances = new uint256[](4);\\n        balances[0] = ICurveFi_4(curve).balances(0); // DAI\\n        balances[1] = ICurveFi_4(curve).balances(1).mul(10**12); // USDC\\n        balances[2] = ICurveFi_4(curve).balances(2).mul(10**12); // USDT\\n        balances[3] = ICurveFi_4(curve).balances(3); // sUSD\\n\\n        // DAI\\n        if (\\n            balances[0] < balances[1] &&\\n            balances[0] < balances[2] &&\\n            balances[0] < balances[3]\\n        ) {\\n            return (dai, 0);\\n        }\\n\\n        // USDC\\n        if (\\n            balances[1] < balances[0] &&\\n            balances[1] < balances[2] &&\\n            balances[1] < balances[3]\\n        ) {\\n            return (usdc, 1);\\n        }\\n\\n        // USDT\\n        if (\\n            balances[2] < balances[0] &&\\n            balances[2] < balances[1] &&\\n            balances[2] < balances[3]\\n        ) {\\n            return (usdt, 2);\\n        }\\n\\n        // SUSD\\n        if (\\n            balances[3] < balances[0] &&\\n            balances[3] < balances[1] &&\\n            balances[3] < balances[2]\\n        ) {\\n            return (susd, 3);\\n        }\\n\\n        // If they're somehow equal, we just want DAI\\n        return (dai, 0);\\n    }\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyCurveSCRVv3_2\\\";\\n    }\\n\\n    // **** State Mutations ****\\n\\n    function harvest() public onlyBenevolent override {\\n        // Anyone can harvest it at any given time.\\n        // I understand the possibility of being frontrun\\n        // But ETH is a dark forest, and I wanna see how this plays out\\n        // i.e. will be be heavily frontrunned?\\n        //      if so, a new strategy will be deployed.\\n\\n        // stablecoin we want to convert to\\n        (address to, uint256 toIndex) = getMostPremium();\\n\\n        // Collects crv tokens\\n        // Don't bother voting in v1\\n        ICurveMintr(mintr).mint(gauge);\\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\\n        if (_crv > 0) {\\n            // x% is sent back to the rewards holder\\n            // to be used to lock up in as veCRV in a future date\\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\\n            if (_keepCRV > 0) {\\n                IERC20(crv).safeTransfer(\\n                    IController(controller).treasury(),\\n                    _keepCRV\\n                );\\n            }\\n            _crv = _crv.sub(_keepCRV);\\n            _swapUniswap(crv, to, _crv);\\n        }\\n\\n        // Collects SNX tokens\\n        ICurveGauge(gauge).claim_rewards(address(this));\\n        uint256 _snx = IERC20(snx).balanceOf(address(this));\\n        if (_snx > 0) {\\n            _swapUniswap(snx, to, _snx);\\n        }\\n\\n        // Adds liquidity to curve.fi's susd pool\\n        // to get back want (scrv)\\n        uint256 _to = IERC20(to).balanceOf(address(this));\\n        if (_to > 0) {\\n            IERC20(to).safeApprove(curve, 0);\\n            IERC20(to).safeApprove(curve, _to);\\n            uint256[4] memory liquidity;\\n            liquidity[toIndex] = _to;\\n            ICurveFi_4(curve).add_liquidity(liquidity, 0);\\n        }\\n\\n        // We want to get back sCRV\\n        _distributePerformanceFeesAndDeposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/curve/scrv-voter.sol\": {\r\n      \"content\": \"// StrategyProxy: https://etherscan.io/address/0x5886e475e163f78cf63d6683abc7fe8516d12081#code\\npragma solidity ^0.6.7;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\nimport \\\"../../lib/safe-math.sol\\\";\\n\\nimport \\\"./crv-locker.sol\\\";\\n\\nimport \\\"../../interfaces/curve.sol\\\";\\n\\ncontract SCRVVoter {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    CRVLocker public crvLocker;\\n\\n    address public constant want = 0xC25a3A3b969415c80451098fa907EC722572917F;\\n    address public constant mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\\n    address public constant snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\\n    address\\n        public constant gaugeController = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB;\\n    address\\n        public constant scrvGauge = 0xA90996896660DEcC6E997655E065b23788857849;\\n\\n    mapping(address => bool) public strategies;\\n    address public governance;\\n\\n    constructor(address _governance, address _crvLocker) public {\\n        governance = _governance;\\n        crvLocker = CRVLocker(_crvLocker);\\n    }\\n\\n    function setGovernance(address _governance) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        governance = _governance;\\n    }\\n\\n    function approveStrategy(address _strategy) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        strategies[_strategy] = true;\\n    }\\n\\n    function revokeStrategy(address _strategy) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        strategies[_strategy] = false;\\n    }\\n\\n    function lock() external {\\n        crvLocker.increaseAmount(IERC20(crv).balanceOf(address(crvLocker)));\\n    }\\n\\n    function vote(address _gauge, uint256 _amount) public {\\n        require(strategies[msg.sender], \\\"!strategy\\\");\\n        crvLocker.execute(\\n            gaugeController,\\n            0,\\n            abi.encodeWithSignature(\\n                \\\"vote_for_gauge_weights(address,uint256)\\\",\\n                _gauge,\\n                _amount\\n            )\\n        );\\n    }\\n\\n    function max() external {\\n        require(strategies[msg.sender], \\\"!strategy\\\");\\n        vote(scrvGauge, 10000);\\n    }\\n\\n    function withdraw(\\n        address _gauge,\\n        address _token,\\n        uint256 _amount\\n    ) public returns (uint256) {\\n        require(strategies[msg.sender], \\\"!strategy\\\");\\n        uint256 _before = IERC20(_token).balanceOf(address(crvLocker));\\n        crvLocker.execute(\\n            _gauge,\\n            0,\\n            abi.encodeWithSignature(\\\"withdraw(uint256)\\\", _amount)\\n        );\\n        uint256 _after = IERC20(_token).balanceOf(address(crvLocker));\\n        uint256 _net = _after.sub(_before);\\n        crvLocker.execute(\\n            _token,\\n            0,\\n            abi.encodeWithSignature(\\n                \\\"transfer(address,uint256)\\\",\\n                msg.sender,\\n                _net\\n            )\\n        );\\n        return _net;\\n    }\\n\\n    function balanceOf(address _gauge) public view returns (uint256) {\\n        return IERC20(_gauge).balanceOf(address(crvLocker));\\n    }\\n\\n    function withdrawAll(address _gauge, address _token)\\n        external\\n        returns (uint256)\\n    {\\n        require(strategies[msg.sender], \\\"!strategy\\\");\\n        return withdraw(_gauge, _token, balanceOf(_gauge));\\n    }\\n\\n    function deposit(address _gauge, address _token) external {\\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(address(crvLocker), _balance);\\n\\n        _balance = IERC20(_token).balanceOf(address(crvLocker));\\n        crvLocker.execute(\\n            _token,\\n            0,\\n            abi.encodeWithSignature(\\\"approve(address,uint256)\\\", _gauge, 0)\\n        );\\n        crvLocker.execute(\\n            _token,\\n            0,\\n            abi.encodeWithSignature(\\n                \\\"approve(address,uint256)\\\",\\n                _gauge,\\n                _balance\\n            )\\n        );\\n        crvLocker.execute(\\n            _gauge,\\n            0,\\n            abi.encodeWithSignature(\\\"deposit(uint256)\\\", _balance)\\n        );\\n    }\\n\\n    function harvest(address _gauge) external {\\n        require(strategies[msg.sender], \\\"!strategy\\\");\\n        uint256 _before = IERC20(crv).balanceOf(address(crvLocker));\\n        crvLocker.execute(\\n            mintr,\\n            0,\\n            abi.encodeWithSignature(\\\"mint(address)\\\", _gauge)\\n        );\\n        uint256 _after = IERC20(crv).balanceOf(address(crvLocker));\\n        uint256 _balance = _after.sub(_before);\\n        crvLocker.execute(\\n            crv,\\n            0,\\n            abi.encodeWithSignature(\\n                \\\"transfer(address,uint256)\\\",\\n                msg.sender,\\n                _balance\\n            )\\n        );\\n    }\\n\\n    function claimRewards() external {\\n        require(strategies[msg.sender], \\\"!strategy\\\");\\n\\n        uint256 _before = IERC20(snx).balanceOf(address(crvLocker));\\n        crvLocker.execute(scrvGauge, 0, abi.encodeWithSignature(\\\"claim_rewards()\\\"));\\n        uint256 _after = IERC20(snx).balanceOf(address(crvLocker));\\n        uint256 _balance = _after.sub(_before);\\n\\n        crvLocker.execute(\\n            snx,\\n            0,\\n            abi.encodeWithSignature(\\n                \\\"transfer(address,uint256)\\\",\\n                msg.sender,\\n                _balance\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/curve/strategy-curve-scrv-v4_1.sol\": {\r\n      \"content\": \"// https://etherscan.io/address/0x594a198048501a304267e63b3bad0f0638da7628#code\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\nimport \\\"../../lib/safe-math.sol\\\";\\n\\nimport \\\"./scrv-voter.sol\\\";\\nimport \\\"./crv-locker.sol\\\";\\n\\nimport \\\"../../interfaces/jar.sol\\\";\\nimport \\\"../../interfaces/curve.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\nimport \\\"../../interfaces/controller.sol\\\";\\n\\nimport \\\"../strategy-base.sol\\\";\\n\\ncontract StrategyCurveSCRVv4_1 is StrategyBase {\\n    // Curve\\n    address public scrv = 0xC25a3A3b969415c80451098fa907EC722572917F;\\n    address public susdv2_gauge = 0xA90996896660DEcC6E997655E065b23788857849;\\n    address public susdv2_pool = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\\n    address public escrow = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2;\\n\\n    // curve dao\\n    address public gauge;\\n    address public curve;\\n    address public mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\\n\\n    // tokens we're farming\\n    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\\n    address public constant snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\\n\\n    // stablecoins\\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address public susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n\\n    // How much CRV tokens to keep\\n    uint256 public keepCRV = 500;\\n    uint256 public keepCRVMax = 10000;\\n\\n    // crv-locker and voter\\n    address public scrvVoter;\\n    address public crvLocker;\\n\\n    constructor(\\n        address _scrvVoter,\\n        address _crvLocker,\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyBase(scrv, _governance, _strategist, _controller, _timelock)\\n    {\\n        curve = susdv2_pool;\\n        gauge = susdv2_gauge;\\n\\n        scrvVoter = _scrvVoter;\\n        crvLocker = _crvLocker;\\n    }\\n\\n    // **** Getters ****\\n\\n    function balanceOfPool() public override view returns (uint256) {\\n        return SCRVVoter(scrvVoter).balanceOf(gauge);\\n    }\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyCurveSCRVv4_1\\\";\\n    }\\n\\n    function getHarvestable() external returns (uint256) {\\n        return ICurveGauge(gauge).claimable_tokens(crvLocker);\\n    }\\n\\n    function getMostPremium() public view returns (address, uint8) {\\n        uint256[] memory balances = new uint256[](4);\\n        balances[0] = ICurveFi_4(curve).balances(0); // DAI\\n        balances[1] = ICurveFi_4(curve).balances(1).mul(10**12); // USDC\\n        balances[2] = ICurveFi_4(curve).balances(2).mul(10**12); // USDT\\n        balances[3] = ICurveFi_4(curve).balances(3); // sUSD\\n\\n        // DAI\\n        if (\\n            balances[0] < balances[1] &&\\n            balances[0] < balances[2] &&\\n            balances[0] < balances[3]\\n        ) {\\n            return (dai, 0);\\n        }\\n\\n        // USDC\\n        if (\\n            balances[1] < balances[0] &&\\n            balances[1] < balances[2] &&\\n            balances[1] < balances[3]\\n        ) {\\n            return (usdc, 1);\\n        }\\n\\n        // USDT\\n        if (\\n            balances[2] < balances[0] &&\\n            balances[2] < balances[1] &&\\n            balances[2] < balances[3]\\n        ) {\\n            return (usdt, 2);\\n        }\\n\\n        // SUSD\\n        if (\\n            balances[3] < balances[0] &&\\n            balances[3] < balances[1] &&\\n            balances[3] < balances[2]\\n        ) {\\n            return (susd, 3);\\n        }\\n\\n        // If they're somehow equal, we just want DAI\\n        return (dai, 0);\\n    }\\n\\n    // **** Setters ****\\n\\n    function setKeepCRV(uint256 _keepCRV) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        keepCRV = _keepCRV;\\n    }\\n\\n    // **** State Mutations ****\\n\\n    function deposit() public override {\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        if (_want > 0) {\\n            IERC20(want).safeTransfer(scrvVoter, _want);\\n            SCRVVoter(scrvVoter).deposit(gauge, want);\\n        }\\n    }\\n\\n    function _withdrawSome(uint256 _amount)\\n        internal\\n        override\\n        returns (uint256)\\n    {\\n        return SCRVVoter(scrvVoter).withdraw(gauge, want, _amount);\\n    }\\n\\n    function harvest() public override onlyBenevolent {\\n        // Anyone can harvest it at any given time.\\n        // I understand the possibility of being frontrun / sandwiched\\n        // But ETH is a dark forest, and I wanna see how this plays out\\n        // i.e. will be be heavily frontrunned/sandwiched?\\n        //      if so, a new strategy will be deployed.\\n\\n        // stablecoin we want to convert to\\n        (address to, uint256 toIndex) = getMostPremium();\\n\\n        // Collects crv tokens\\n        // Don't bother voting in v1\\n        SCRVVoter(scrvVoter).harvest(gauge);\\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\\n        if (_crv > 0) {\\n            // How much CRV to keep to restake?\\n            uint256 _keepCRV = _crv.mul(keepCRV).div(keepCRVMax);\\n            IERC20(crv).safeTransfer(address(crvLocker), _keepCRV);\\n\\n            // How much CRV to swap?\\n            _crv = _crv.sub(_keepCRV);\\n            _swapUniswap(crv, to, _crv);\\n        }\\n\\n        // Collects SNX tokens\\n        SCRVVoter(scrvVoter).claimRewards();\\n        uint256 _snx = IERC20(snx).balanceOf(address(this));\\n        if (_snx > 0) {\\n            _swapUniswap(snx, to, _snx);\\n        }\\n\\n        // Adds liquidity to curve.fi's susd pool\\n        // to get back want (scrv)\\n        uint256 _to = IERC20(to).balanceOf(address(this));\\n        if (_to > 0) {\\n            IERC20(to).safeApprove(curve, 0);\\n            IERC20(to).safeApprove(curve, _to);\\n            uint256[4] memory liquidity;\\n            liquidity[toIndex] = _to;\\n            ICurveFi_4(curve).add_liquidity(liquidity, 0);\\n        }\\n\\n        // We want to get back sCRV\\n        _distributePerformanceFeesAndDeposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/strategy-curve-base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\nimport \\\"./strategy-base.sol\\\";\\n\\nimport \\\"../interfaces/curve.sol\\\";\\n\\n// Base contract for Curve based staking contract interfaces\\n\\nabstract contract StrategyCurveBase is StrategyBase {\\n    // curve dao\\n    address public gauge;\\n    address public curve;\\n    address public mintr = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\\n\\n    // stablecoins\\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address public susd = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n\\n    // bitcoins\\n    address public wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address public renbtc = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D;\\n\\n    // rewards\\n    address public crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\\n\\n    // How much CRV tokens to keep\\n    uint256 public keepCRV = 0;\\n    uint256 public keepCRVMax = 10000;\\n\\n    constructor(\\n        address _curve,\\n        address _gauge,\\n        address _want,\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyBase(_want, _governance, _strategist, _controller, _timelock)\\n    {\\n        curve = _curve;\\n        gauge = _gauge;\\n    }\\n\\n    // **** Getters ****\\n\\n    function balanceOfPool() public override view returns (uint256) {\\n        return ICurveGauge(gauge).balanceOf(address(this));\\n    }\\n\\n    function getHarvestable() external returns (uint256) {\\n        return ICurveGauge(gauge).claimable_tokens(address(this));\\n    }\\n\\n    function getMostPremium() public virtual view returns (address, uint256);\\n\\n    // **** Setters ****\\n\\n    function setKeepCRV(uint256 _keepCRV) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        keepCRV = _keepCRV;\\n    }\\n\\n    // **** State Mutation functions ****\\n\\n    function deposit() public override {\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        if (_want > 0) {\\n            IERC20(want).safeApprove(gauge, 0);\\n            IERC20(want).safeApprove(gauge, _want);\\n            ICurveGauge(gauge).deposit(_want);\\n        }\\n    }\\n\\n    function _withdrawSome(uint256 _amount)\\n        internal\\n        override\\n        returns (uint256)\\n    {\\n        ICurveGauge(gauge).withdraw(_amount);\\n        return _amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/compound/strategy-cmpd-dai-v2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../../lib/erc20.sol\\\";\\nimport \\\"../../lib/safe-math.sol\\\";\\nimport \\\"../../lib/exponential.sol\\\";\\n\\nimport \\\"../strategy-base.sol\\\";\\n\\nimport \\\"../../interfaces/jar.sol\\\";\\nimport \\\"../../interfaces/uniswapv2.sol\\\";\\nimport \\\"../../interfaces/controller.sol\\\";\\nimport \\\"../../interfaces/compound.sol\\\";\\n\\ncontract StrategyCmpdDaiV2 is StrategyBase, Exponential {\\n    address\\n        public constant comptroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n    address public constant lens = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\\n    address public constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\\n    address public constant cdai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\\n    address public constant cether = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\\n\\n    // Require a 0.1 buffer between\\n    // market collateral factor and strategy's collateral factor\\n    // when leveraging\\n    uint256 colFactorLeverageBuffer = 100;\\n    uint256 colFactorLeverageBufferMax = 1000;\\n\\n    // Allow a 0.05 buffer\\n    // between market collateral factor and strategy's collateral factor\\n    // until we have to deleverage\\n    // This is so we can hit max leverage and keep accruing interest\\n    uint256 colFactorSyncBuffer = 50;\\n    uint256 colFactorSyncBufferMax = 1000;\\n\\n    // Keeper bots\\n    // Maintain leverage within buffer\\n    mapping(address => bool) keepers;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyBase(dai, _governance, _strategist, _controller, _timelock)\\n    {\\n        // Enter cDAI Market\\n        address[] memory ctokens = new address[](1);\\n        ctokens[0] = cdai;\\n        IComptroller(comptroller).enterMarkets(ctokens);\\n    }\\n\\n    // **** Modifiers **** //\\n\\n    modifier onlyKeepers {\\n        require(\\n            keepers[msg.sender] ||\\n                msg.sender == address(this) ||\\n                msg.sender == strategist ||\\n                msg.sender == governance,\\n            \\\"!keepers\\\"\\n        );\\n        _;\\n    }\\n\\n    // **** Views **** //\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyCmpdDaiV2\\\";\\n    }\\n\\n    function getSuppliedView() public view returns (uint256) {\\n        (, uint256 cTokenBal, , uint256 exchangeRate) = ICToken(cdai)\\n            .getAccountSnapshot(address(this));\\n\\n        (, uint256 bal) = mulScalarTruncate(\\n            Exp({mantissa: exchangeRate}),\\n            cTokenBal\\n        );\\n\\n        return bal;\\n    }\\n\\n    function getBorrowedView() public view returns (uint256) {\\n        return ICToken(cdai).borrowBalanceStored(address(this));\\n    }\\n\\n    function balanceOfPool() public override view returns (uint256) {\\n        uint256 supplied = getSuppliedView();\\n        uint256 borrowed = getBorrowedView();\\n        return supplied.sub(borrowed);\\n    }\\n\\n    // Given an unleveraged supply balance, return the target\\n    // leveraged supply balance which is still within the safety buffer\\n    function getLeveragedSupplyTarget(uint256 supplyBalance)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 leverage = getMaxLeverage();\\n        return supplyBalance.mul(leverage).div(1e18);\\n    }\\n\\n    function getSafeLeverageColFactor() public view returns (uint256) {\\n        uint256 colFactor = getMarketColFactor();\\n\\n        // Collateral factor within the buffer\\n        uint256 safeColFactor = colFactor.sub(\\n            colFactorLeverageBuffer.mul(1e18).div(colFactorLeverageBufferMax)\\n        );\\n\\n        return safeColFactor;\\n    }\\n\\n    function getSafeSyncColFactor() public view returns (uint256) {\\n        uint256 colFactor = getMarketColFactor();\\n\\n        // Collateral factor within the buffer\\n        uint256 safeColFactor = colFactor.sub(\\n            colFactorSyncBuffer.mul(1e18).div(colFactorSyncBufferMax)\\n        );\\n\\n        return safeColFactor;\\n    }\\n\\n    function getMarketColFactor() public view returns (uint256) {\\n        (, uint256 colFactor) = IComptroller(comptroller).markets(cdai);\\n\\n        return colFactor;\\n    }\\n\\n    // Max leverage we can go up to, w.r.t safe buffer\\n    function getMaxLeverage() public view returns (uint256) {\\n        uint256 safeLeverageColFactor = getSafeLeverageColFactor();\\n\\n        // Infinite geometric series\\n        uint256 leverage = uint256(1e36).div(1e18 - safeLeverageColFactor);\\n        return leverage;\\n    }\\n\\n    // **** Pseudo-view functions (use `callStatic` on these) **** //\\n    /* The reason why these exists is because of the nature of the\\n       interest accruing supply + borrow balance. The \\\"view\\\" methods\\n       are technically snapshots and don't represent the real value.\\n       As such there are pseudo view methods where you can retrieve the\\n       results by calling `callStatic`.\\n    */\\n\\n    function getCompAccrued() public returns (uint256) {\\n        (, , , uint256 accrued) = ICompoundLens(lens).getCompBalanceMetadataExt(\\n            comp,\\n            comptroller,\\n            address(this)\\n        );\\n\\n        return accrued;\\n    }\\n\\n    function getColFactor() public returns (uint256) {\\n        uint256 supplied = getSupplied();\\n        uint256 borrowed = getBorrowed();\\n\\n        return borrowed.mul(1e18).div(supplied);\\n    }\\n\\n    function getSuppliedUnleveraged() public returns (uint256) {\\n        uint256 supplied = getSupplied();\\n        uint256 borrowed = getBorrowed();\\n\\n        return supplied.sub(borrowed);\\n    }\\n\\n    function getSupplied() public returns (uint256) {\\n        return ICToken(cdai).balanceOfUnderlying(address(this));\\n    }\\n\\n    function getBorrowed() public returns (uint256) {\\n        return ICToken(cdai).borrowBalanceCurrent(address(this));\\n    }\\n\\n    function getBorrowable() public returns (uint256) {\\n        uint256 supplied = getSupplied();\\n        uint256 borrowed = getBorrowed();\\n\\n        (, uint256 colFactor) = IComptroller(comptroller).markets(cdai);\\n\\n        // 99.99% just in case some dust accumulates\\n        return\\n            supplied.mul(colFactor).div(1e18).sub(borrowed).mul(9999).div(\\n                10000\\n            );\\n    }\\n\\n    function getCurrentLeverage() public returns (uint256) {\\n        uint256 supplied = getSupplied();\\n        uint256 borrowed = getBorrowed();\\n\\n        return supplied.mul(1e18).div(supplied.sub(borrowed));\\n    }\\n\\n    // **** Setters **** //\\n\\n    function addKeeper(address _keeper) public {\\n        require(\\n            msg.sender == governance || msg.sender == strategist,\\n            \\\"!governance\\\"\\n        );\\n        keepers[_keeper] = true;\\n    }\\n\\n    function removeKeeper(address _keeper) public {\\n        require(\\n            msg.sender == governance || msg.sender == strategist,\\n            \\\"!governance\\\"\\n        );\\n        keepers[_keeper] = false;\\n    }\\n\\n    function setColFactorLeverageBuffer(uint256 _colFactorLeverageBuffer)\\n        public\\n    {\\n        require(\\n            msg.sender == governance || msg.sender == strategist,\\n            \\\"!governance\\\"\\n        );\\n        colFactorLeverageBuffer = _colFactorLeverageBuffer;\\n    }\\n\\n    function setColFactorSyncBuffer(uint256 _colFactorSyncBuffer) public {\\n        require(\\n            msg.sender == governance || msg.sender == strategist,\\n            \\\"!governance\\\"\\n        );\\n        colFactorSyncBuffer = _colFactorSyncBuffer;\\n    }\\n\\n    // **** State mutations **** //\\n\\n    // Do a `callStatic` on this.\\n    // If it returns true then run it for realz. (i.e. eth_signedTx, not eth_call)\\n    function sync() public returns (bool) {\\n        uint256 colFactor = getColFactor();\\n        uint256 safeSyncColFactor = getSafeSyncColFactor();\\n\\n        // If we're not safe\\n        if (colFactor > safeSyncColFactor) {\\n            uint256 unleveragedSupply = getSuppliedUnleveraged();\\n            uint256 idealSupply = getLeveragedSupplyTarget(unleveragedSupply);\\n\\n            deleverageUntil(idealSupply);\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function leverageToMax() public {\\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\\n        uint256 idealSupply = getLeveragedSupplyTarget(unleveragedSupply);\\n        leverageUntil(idealSupply);\\n    }\\n\\n    // Leverages until we're supplying <x> amount\\n    // 1. Redeem <x> DAI\\n    // 2. Repay <x> DAI\\n    function leverageUntil(uint256 _supplyAmount) public onlyKeepers {\\n        // 1. Borrow out <X> DAI\\n        // 2. Supply <X> DAI\\n\\n        uint256 leverage = getMaxLeverage();\\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\\n        require(\\n            _supplyAmount >= unleveragedSupply &&\\n                _supplyAmount <= unleveragedSupply.mul(leverage).div(1e18),\\n            \\\"!leverage\\\"\\n        );\\n\\n        // Since we're only leveraging one asset\\n        // Supplied = borrowed\\n        uint256 _borrowAndSupply;\\n        uint256 supplied = getSupplied();\\n        while (supplied < _supplyAmount) {\\n            _borrowAndSupply = getBorrowable();\\n\\n            if (supplied.add(_borrowAndSupply) > _supplyAmount) {\\n                _borrowAndSupply = _supplyAmount.sub(supplied);\\n            }\\n\\n            ICToken(cdai).borrow(_borrowAndSupply);\\n            deposit();\\n\\n            supplied = supplied.add(_borrowAndSupply);\\n        }\\n    }\\n\\n    function deleverageToMin() public {\\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\\n        deleverageUntil(unleveragedSupply);\\n    }\\n\\n    // Deleverages until we're supplying <x> amount\\n    // 1. Redeem <x> DAI\\n    // 2. Repay <x> DAI\\n    function deleverageUntil(uint256 _supplyAmount) public onlyKeepers {\\n        uint256 unleveragedSupply = getSuppliedUnleveraged();\\n        uint256 supplied = getSupplied();\\n        require(\\n            _supplyAmount >= unleveragedSupply && _supplyAmount <= supplied,\\n            \\\"!deleverage\\\"\\n        );\\n\\n        // Since we're only leveraging on 1 asset\\n        // redeemable = borrowable\\n        uint256 _redeemAndRepay = getBorrowable();\\n        do {\\n            if (supplied.sub(_redeemAndRepay) < _supplyAmount) {\\n                _redeemAndRepay = supplied.sub(_supplyAmount);\\n            }\\n\\n            require(\\n                ICToken(cdai).redeemUnderlying(_redeemAndRepay) == 0,\\n                \\\"!redeem\\\"\\n            );\\n            IERC20(dai).safeApprove(cdai, 0);\\n            IERC20(dai).safeApprove(cdai, _redeemAndRepay);\\n            require(ICToken(cdai).repayBorrow(_redeemAndRepay) == 0, \\\"!repay\\\");\\n\\n            supplied = supplied.sub(_redeemAndRepay);\\n        } while (supplied > _supplyAmount);\\n    }\\n\\n    function harvest() public override onlyBenevolent {\\n        address[] memory ctokens = new address[](1);\\n        ctokens[0] = cdai;\\n\\n        IComptroller(comptroller).claimComp(address(this), ctokens);\\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\\n        if (_comp > 0) {\\n            _swapUniswap(comp, want, _comp);\\n        }\\n\\n        _distributePerformanceFeesAndDeposit();\\n    }\\n\\n    function deposit() public override {\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        if (_want > 0) {\\n            IERC20(want).safeApprove(cdai, 0);\\n            IERC20(want).safeApprove(cdai, _want);\\n            require(ICToken(cdai).mint(_want) == 0, \\\"!deposit\\\");\\n        }\\n    }\\n\\n    function _withdrawSome(uint256 _amount)\\n        internal\\n        override\\n        returns (uint256)\\n    {\\n        uint256 _want = balanceOfWant();\\n        if (_want < _amount) {\\n            uint256 _redeem = _amount.sub(_want);\\n\\n            // Make sure market can cover liquidity\\n            require(ICToken(cdai).getCash() >= _redeem, \\\"!cash-liquidity\\\");\\n\\n            // How much borrowed amount do we need to free?\\n            uint256 borrowed = getBorrowed();\\n            uint256 supplied = getSupplied();\\n            uint256 curLeverage = getCurrentLeverage();\\n            uint256 borrowedToBeFree = _redeem.mul(curLeverage).div(1e18);\\n\\n            // If the amount we need to free is > borrowed\\n            // Just free up all the borrowed amount\\n            if (borrowedToBeFree > borrowed) {\\n                this.deleverageToMin();\\n            } else {\\n                // Otherwise just keep freeing up borrowed amounts until\\n                // we hit a safe number to redeem our underlying\\n                this.deleverageUntil(supplied.sub(borrowedToBeFree));\\n            }\\n\\n            // Redeems underlying\\n            require(ICToken(cdai).redeemUnderlying(_redeem) == 0, \\\"!redeem\\\");\\n        }\\n\\n        return _amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/uniswapv2/strategy-uni-eth-wbtc-lp-v2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../strategy-uni-farm-base.sol\\\";\\n\\ncontract StrategyUniEthWBtcLpV2 is StrategyUniFarmBase {\\n    // Token addresses\\n    address public uni_rewards = 0xCA35e32e7926b96A9988f61d510E038108d8068e;\\n    address public uni_eth_wbtc_lp = 0xBb2b8038a1640196FbE3e38816F3e67Cba72D940;\\n    address public wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyUniFarmBase(\\n            wbtc,\\n            uni_rewards,\\n            uni_eth_wbtc_lp,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {}\\n\\n    // **** Views ****\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyUniEthWBtcLpV2\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/uniswapv2/strategy-uni-eth-usdt-lp-v4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../strategy-uni-farm-base.sol\\\";\\n\\ncontract StrategyUniEthUsdtLpV4 is StrategyUniFarmBase {\\n    // Token addresses\\n    address public uni_rewards = 0x6C3e4cb2E96B01F4b866965A91ed4437839A121a;\\n    address public uni_eth_usdt_lp = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852;\\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyUniFarmBase(\\n            usdt,\\n            uni_rewards,\\n            uni_eth_usdt_lp,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {}\\n\\n    // **** Views ****\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyUniEthUsdtLpV4\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/uniswapv2/strategy-uni-eth-usdc-lp-v4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"../strategy-uni-farm-base.sol\\\";\\n\\ncontract StrategyUniEthUsdcLpV4 is StrategyUniFarmBase {\\n    // Token addresses\\n    address public uni_rewards = 0x7FBa4B8Dc5E7616e59622806932DBea72537A56b;\\n    address public uni_eth_usdc_lp = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;\\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyUniFarmBase(\\n            usdc,\\n            uni_rewards,\\n            uni_eth_usdc_lp,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {}\\n\\n    // **** Views ****\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyUniEthUsdcLpV4\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/uniswapv2/strategy-uni-eth-dai-lp-v4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\nimport \\\"../strategy-uni-farm-base.sol\\\";\\n\\ncontract StrategyUniEthDaiLpV4 is StrategyUniFarmBase {\\n    // Token addresses\\n    address public uni_rewards = 0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711;\\n    address public uni_eth_dai_lp = 0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11;\\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\\n    constructor(\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyUniFarmBase(\\n            dai,\\n            uni_rewards,\\n            uni_eth_dai_lp,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {}\\n\\n    // **** Views ****\\n\\n    function getName() external override pure returns (string memory) {\\n        return \\\"StrategyUniEthDaiLpV4\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/strategy-base.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\nimport \\\"../lib/erc20.sol\\\";\\nimport \\\"../lib/safe-math.sol\\\";\\n\\nimport \\\"../interfaces/jar.sol\\\";\\nimport \\\"../interfaces/staking-rewards.sol\\\";\\nimport \\\"../interfaces/uniswapv2.sol\\\";\\nimport \\\"../interfaces/controller.sol\\\";\\n\\n// Strategy Contract Basics\\n\\nabstract contract StrategyBase {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    // Perfomance fees - start with 4.5%\\n    uint256 public performanceTreasuryFee = 450;\\n    uint256 public constant performanceTreasuryMax = 10000;\\n\\n    uint256 public performanceDevFee = 0;\\n    uint256 public constant performanceDevMax = 10000;\\n\\n    // Withdrawal fee 0.5%\\n    // - 0.325% to treasury\\n    // - 0.175% to dev fund\\n    uint256 public withdrawalTreasuryFee = 325;\\n    uint256 public constant withdrawalTreasuryMax = 100000;\\n\\n    uint256 public withdrawalDevFundFee = 175;\\n    uint256 public constant withdrawalDevFundMax = 100000;\\n\\n    // Tokens\\n    address public want;\\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    // User accounts\\n    address public governance;\\n    address public controller;\\n    address public strategist;\\n    address public timelock;\\n\\n    // Dex\\n    address public univ2Router2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n\\n    constructor(\\n        address _want,\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    ) public {\\n        require(_want != address(0));\\n        require(_governance != address(0));\\n        require(_strategist != address(0));\\n        require(_controller != address(0));\\n        require(_timelock != address(0));\\n\\n        want = _want;\\n        governance = _governance;\\n        strategist = _strategist;\\n        controller = _controller;\\n        timelock = _timelock;\\n    }\\n\\n    // **** Modifiers **** //\\n\\n    modifier onlyBenevolent {\\n        require(\\n            msg.sender == tx.origin ||\\n                msg.sender == governance ||\\n                msg.sender == strategist\\n        );\\n        _;\\n    }\\n\\n    // **** Views **** //\\n\\n    function balanceOfWant() public view returns (uint256) {\\n        return IERC20(want).balanceOf(address(this));\\n    }\\n\\n    function balanceOfPool() public virtual view returns (uint256);\\n\\n    function balanceOf() public view returns (uint256) {\\n        return balanceOfWant().add(balanceOfPool());\\n    }\\n\\n    function getName() external virtual pure returns (string memory);\\n\\n    // **** Setters **** //\\n\\n    function setWithdrawalDevFundFee(uint256 _withdrawalDevFundFee) external {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        withdrawalDevFundFee = _withdrawalDevFundFee;\\n    }\\n\\n    function setWithdrawalTreasuryFee(uint256 _withdrawalTreasuryFee) external {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        withdrawalTreasuryFee = _withdrawalTreasuryFee;\\n    }\\n\\n    function setPerformanceDevFee(uint256 _performanceDevFee) external {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        performanceDevFee = _performanceDevFee;\\n    }\\n\\n    function setPerformanceTreasuryFee(uint256 _performanceTreasuryFee)\\n        external\\n    {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        performanceTreasuryFee = _performanceTreasuryFee;\\n    }\\n\\n    function setStrategist(address _strategist) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        strategist = _strategist;\\n    }\\n\\n    function setGovernance(address _governance) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        governance = _governance;\\n    }\\n\\n    function setTimelock(address _timelock) external {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        timelock = _timelock;\\n    }\\n\\n    function setController(address _controller) external {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        controller = _controller;\\n    }\\n\\n    // **** State mutations **** //\\n    function deposit() public virtual;\\n\\n    // Controller only function for creating additional rewards from dust\\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\\n        require(msg.sender == controller, \\\"!controller\\\");\\n        require(want != address(_asset), \\\"want\\\");\\n        balance = _asset.balanceOf(address(this));\\n        _asset.safeTransfer(controller, balance);\\n    }\\n\\n    // Withdraw partial funds, normally used with a jar withdrawal\\n    function withdraw(uint256 _amount) external {\\n        require(msg.sender == controller, \\\"!controller\\\");\\n        uint256 _balance = IERC20(want).balanceOf(address(this));\\n        if (_balance < _amount) {\\n            _amount = _withdrawSome(_amount.sub(_balance));\\n            _amount = _amount.add(_balance);\\n        }\\n\\n        uint256 _feeDev = _amount.mul(withdrawalDevFundFee).div(\\n            withdrawalDevFundMax\\n        );\\n        IERC20(want).safeTransfer(IController(controller).devfund(), _feeDev);\\n\\n        uint256 _feeTreasury = _amount.mul(withdrawalTreasuryFee).div(\\n            withdrawalTreasuryMax\\n        );\\n        IERC20(want).safeTransfer(\\n            IController(controller).treasury(),\\n            _feeTreasury\\n        );\\n\\n        address _jar = IController(controller).jars(address(want));\\n        require(_jar != address(0), \\\"!jar\\\"); // additional protection so we don't burn the funds\\n\\n        IERC20(want).safeTransfer(_jar, _amount.sub(_feeDev).sub(_feeTreasury));\\n    }\\n\\n    // Withdraw funds, used to swap between strategies\\n    function withdrawForSwap(uint256 _amount)\\n        external\\n        returns (uint256 balance)\\n    {\\n        require(msg.sender == controller, \\\"!controller\\\");\\n        _withdrawSome(_amount);\\n\\n        balance = IERC20(want).balanceOf(address(this));\\n\\n        address _jar = IController(controller).jars(address(want));\\n        require(_jar != address(0), \\\"!jar\\\");\\n        IERC20(want).safeTransfer(_jar, balance);\\n    }\\n\\n    // Withdraw all funds, normally used when migrating strategies\\n    function withdrawAll() external returns (uint256 balance) {\\n        require(msg.sender == controller, \\\"!controller\\\");\\n        _withdrawAll();\\n\\n        balance = IERC20(want).balanceOf(address(this));\\n\\n        address _jar = IController(controller).jars(address(want));\\n        require(_jar != address(0), \\\"!jar\\\"); // additional protection so we don't burn the funds\\n        IERC20(want).safeTransfer(_jar, balance);\\n    }\\n\\n    function _withdrawAll() internal {\\n        _withdrawSome(balanceOfPool());\\n    }\\n\\n    function _withdrawSome(uint256 _amount) internal virtual returns (uint256);\\n\\n    function harvest() public virtual;\\n\\n    // **** Emergency functions ****\\n\\n    function execute(address _target, bytes memory _data)\\n        public\\n        payable\\n        returns (bytes memory response)\\n    {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        require(_target != address(0), \\\"!target\\\");\\n\\n        // call contract in current context\\n        assembly {\\n            let succeeded := delegatecall(\\n                sub(gas(), 5000),\\n                _target,\\n                add(_data, 0x20),\\n                mload(_data),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n\\n            response := mload(0x40)\\n            mstore(\\n                0x40,\\n                add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n            )\\n            mstore(response, size)\\n            returndatacopy(add(response, 0x20), 0, size)\\n\\n            switch iszero(succeeded)\\n                case 1 {\\n                    // throw if delegatecall failed\\n                    revert(add(response, 0x20), size)\\n                }\\n        }\\n    }\\n\\n    // **** Internal functions ****\\n    function _swapUniswap(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        require(_to != address(0));\\n\\n        // Swap with uniswap\\n        IERC20(_from).safeApprove(univ2Router2, 0);\\n        IERC20(_from).safeApprove(univ2Router2, _amount);\\n\\n        address[] memory path;\\n\\n        if (_from == weth || _to == weth) {\\n            path = new address[](2);\\n            path[0] = _from;\\n            path[1] = _to;\\n        } else {\\n            path = new address[](3);\\n            path[0] = _from;\\n            path[1] = weth;\\n            path[2] = _to;\\n        }\\n\\n        UniswapRouterV2(univ2Router2).swapExactTokensForTokens(\\n            _amount,\\n            0,\\n            path,\\n            address(this),\\n            now.add(60)\\n        );\\n    }\\n\\n    function _distributePerformanceFeesAndDeposit() internal {\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n\\n        if (_want > 0) {\\n            // Treasury fees\\n            IERC20(want).safeTransfer(\\n                IController(controller).treasury(),\\n                _want.mul(performanceTreasuryFee).div(performanceTreasuryMax)\\n            );\\n\\n            // Performance fee\\n            IERC20(want).safeTransfer(\\n                IController(controller).devfund(),\\n                _want.mul(performanceDevFee).div(performanceDevMax)\\n            );\\n\\n            deposit();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/strategy-uni-farm-base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.7;\\n\\nimport \\\"./strategy-staking-rewards-base.sol\\\";\\n\\nabstract contract StrategyUniFarmBase is StrategyStakingRewardsBase {\\n    // Token addresses\\n    address public uni = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\\n\\n    // WETH/<token1> pair\\n    address public token1;\\n\\n    // How much UNI tokens to keep?\\n    uint256 public keepUNI = 0;\\n    uint256 public constant keepUNIMax = 10000;\\n\\n    constructor(\\n        address _token1,\\n        address _rewards,\\n        address _lp,\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyStakingRewardsBase(\\n            _rewards,\\n            _lp,\\n            _governance,\\n            _strategist,\\n            _controller,\\n            _timelock\\n        )\\n    {\\n        token1 = _token1;\\n    }\\n\\n    // **** Setters ****\\n\\n    function setKeepUNI(uint256 _keepUNI) external {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        keepUNI = _keepUNI;\\n    }\\n\\n    // **** State Mutations ****\\n\\n    function harvest() public override onlyBenevolent {\\n        // Anyone can harvest it at any given time.\\n        // I understand the possibility of being frontrun\\n        // But ETH is a dark forest, and I wanna see how this plays out\\n        // i.e. will be be heavily frontrunned?\\n        //      if so, a new strategy will be deployed.\\n\\n        // Collects UNI tokens\\n        IStakingRewards(rewards).getReward();\\n        uint256 _uni = IERC20(uni).balanceOf(address(this));\\n        if (_uni > 0) {\\n            // 10% is locked up for future gov\\n            uint256 _keepUNI = _uni.mul(keepUNI).div(keepUNIMax);\\n            IERC20(uni).safeTransfer(\\n                IController(controller).treasury(),\\n                _keepUNI\\n            );\\n            _swapUniswap(uni, weth, _uni.sub(_keepUNI));\\n        }\\n\\n        // Swap half WETH for DAI\\n        uint256 _weth = IERC20(weth).balanceOf(address(this));\\n        if (_weth > 0) {\\n            _swapUniswap(weth, token1, _weth.div(2));\\n        }\\n\\n        // Adds in liquidity for ETH/DAI\\n        _weth = IERC20(weth).balanceOf(address(this));\\n        uint256 _token1 = IERC20(token1).balanceOf(address(this));\\n        if (_weth > 0 && _token1 > 0) {\\n            IERC20(weth).safeApprove(univ2Router2, 0);\\n            IERC20(weth).safeApprove(univ2Router2, _weth);\\n\\n            IERC20(token1).safeApprove(univ2Router2, 0);\\n            IERC20(token1).safeApprove(univ2Router2, _token1);\\n\\n            UniswapRouterV2(univ2Router2).addLiquidity(\\n                weth,\\n                token1,\\n                _weth,\\n                _token1,\\n                0,\\n                0,\\n                address(this),\\n                now + 60\\n            );\\n\\n            // Donates DUST\\n            IERC20(weth).transfer(\\n                IController(controller).treasury(),\\n                IERC20(weth).balanceOf(address(this))\\n            );\\n            IERC20(token1).safeTransfer(\\n                IController(controller).treasury(),\\n                IERC20(token1).balanceOf(address(this))\\n            );\\n        }\\n\\n        // We want to get back UNI LP tokens\\n        _distributePerformanceFeesAndDeposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/strategy-staking-rewards-base.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.7;\\n\\nimport \\\"./strategy-base.sol\\\";\\n\\n// Base contract for SNX Staking rewards contract interfaces\\n\\nabstract contract StrategyStakingRewardsBase is StrategyBase {\\n    address public rewards;\\n\\n    // **** Getters ****\\n    constructor(\\n        address _rewards,\\n        address _want,\\n        address _governance,\\n        address _strategist,\\n        address _controller,\\n        address _timelock\\n    )\\n        public\\n        StrategyBase(_want, _governance, _strategist, _controller, _timelock)\\n    {\\n        rewards = _rewards;\\n    }\\n\\n    function balanceOfPool() public override view returns (uint256) {\\n        return IStakingRewards(rewards).balanceOf(address(this));\\n    }\\n\\n    function getHarvestable() external view returns (uint256) {\\n        return IStakingRewards(rewards).earned(address(this));\\n    }\\n\\n    // **** Setters ****\\n\\n    function deposit() public override {\\n        uint256 _want = IERC20(want).balanceOf(address(this));\\n        if (_want > 0) {\\n            IERC20(want).safeApprove(rewards, 0);\\n            IERC20(want).safeApprove(rewards, _want);\\n            IStakingRewards(rewards).stake(_want);\\n        }\\n    }\\n\\n    function _withdrawSome(uint256 _amount)\\n        internal\\n        override\\n        returns (uint256)\\n    {\\n        IStakingRewards(rewards).withdraw(_amount);\\n        return _amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/yield-farming/masterchef.sol\": {\r\n      \"content\": \"pragma solidity 0.6.7;\\n\\nimport \\\"../lib/enumerableSet.sol\\\";\\nimport \\\"../lib/safe-math.sol\\\";\\nimport \\\"../lib/erc20.sol\\\";\\nimport \\\"../lib/ownable.sol\\\";\\nimport \\\"./pickle-token.sol\\\";\\n\\n// MasterChef was the master of pickle. He now governs over PICKLES. He can make Pickles and he is a fair guy.\\n//\\n// Note that it's ownable and the owner wields tremendous power. The ownership\\n// will be transferred to a governance smart contract once PICKLES is sufficiently\\n// distributed and the community can show to govern itself.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract MasterChef is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount; // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        //\\n        // We do some fancy math here. Basically, any point in time, the amount of PICKLEs\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   pending reward = (user.amount * pool.accPicklePerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n        //   1. The pool's `accPicklePerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 lpToken; // Address of LP token contract.\\n        uint256 allocPoint; // How many allocation points assigned to this pool. PICKLEs to distribute per block.\\n        uint256 lastRewardBlock; // Last block number that PICKLEs distribution occurs.\\n        uint256 accPicklePerShare; // Accumulated PICKLEs per share, times 1e12. See below.\\n    }\\n\\n    // The PICKLE TOKEN!\\n    PickleToken public pickle;\\n    // Dev fund (2%, initially)\\n    uint256 public devFundDivRate = 50;\\n    // Dev address.\\n    address public devaddr;\\n    // Block number when bonus PICKLE period ends.\\n    uint256 public bonusEndBlock;\\n    // PICKLE tokens created per block.\\n    uint256 public picklePerBlock;\\n    // Bonus muliplier for early pickle makers.\\n    uint256 public constant BONUS_MULTIPLIER = 10;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n    // The block number when PICKLE mining starts.\\n    uint256 public startBlock;\\n\\n    // Events\\n    event Recovered(address token, uint256 amount);\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount\\n    );\\n\\n    constructor(\\n        PickleToken _pickle,\\n        address _devaddr,\\n        uint256 _picklePerBlock,\\n        uint256 _startBlock,\\n        uint256 _bonusEndBlock\\n    ) public {\\n        pickle = _pickle;\\n        devaddr = _devaddr;\\n        picklePerBlock = _picklePerBlock;\\n        bonusEndBlock = _bonusEndBlock;\\n        startBlock = _startBlock;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    function add(\\n        uint256 _allocPoint,\\n        IERC20 _lpToken,\\n        bool _withUpdate\\n    ) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock\\n            ? block.number\\n            : startBlock;\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        poolInfo.push(\\n            PoolInfo({\\n                lpToken: _lpToken,\\n                allocPoint: _allocPoint,\\n                lastRewardBlock: lastRewardBlock,\\n                accPicklePerShare: 0\\n            })\\n        );\\n    }\\n\\n    // Update the given pool's PICKLE allocation point. Can only be called by the owner.\\n    function set(\\n        uint256 _pid,\\n        uint256 _allocPoint,\\n        bool _withUpdate\\n    ) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\\n            _allocPoint\\n        );\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_to <= bonusEndBlock) {\\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\\n        } else if (_from >= bonusEndBlock) {\\n            return _to.sub(_from);\\n        } else {\\n            return\\n                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\\n                    _to.sub(bonusEndBlock)\\n                );\\n        }\\n    }\\n\\n    // View function to see pending PICKLEs on frontend.\\n    function pendingPickle(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accPicklePerShare = pool.accPicklePerShare;\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 multiplier = getMultiplier(\\n                pool.lastRewardBlock,\\n                block.number\\n            );\\n            uint256 pickleReward = multiplier\\n                .mul(picklePerBlock)\\n                .mul(pool.allocPoint)\\n                .div(totalAllocPoint);\\n            accPicklePerShare = accPicklePerShare.add(\\n                pickleReward.mul(1e12).div(lpSupply)\\n            );\\n        }\\n        return\\n            user.amount.mul(accPicklePerShare).div(1e12).sub(user.rewardDebt);\\n    }\\n\\n    // Update reward vairables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 pickleReward = multiplier\\n            .mul(picklePerBlock)\\n            .mul(pool.allocPoint)\\n            .div(totalAllocPoint);\\n        pickle.mint(devaddr, pickleReward.div(devFundDivRate));\\n        pickle.mint(address(this), pickleReward);\\n        pool.accPicklePerShare = pool.accPicklePerShare.add(\\n            pickleReward.mul(1e12).div(lpSupply)\\n        );\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    // Deposit LP tokens to MasterChef for PICKLE allocation.\\n    function deposit(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 pending = user\\n                .amount\\n                .mul(pool.accPicklePerShare)\\n                .div(1e12)\\n                .sub(user.rewardDebt);\\n            safePickleTransfer(msg.sender, pending);\\n        }\\n        pool.lpToken.safeTransferFrom(\\n            address(msg.sender),\\n            address(this),\\n            _amount\\n        );\\n        user.amount = user.amount.add(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accPicklePerShare).div(1e12);\\n        emit Deposit(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens from MasterChef.\\n    function withdraw(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        updatePool(_pid);\\n        uint256 pending = user.amount.mul(pool.accPicklePerShare).div(1e12).sub(\\n            user.rewardDebt\\n        );\\n        safePickleTransfer(msg.sender, pending);\\n        user.amount = user.amount.sub(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accPicklePerShare).div(1e12);\\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\\n        emit Withdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n    }\\n\\n    // Safe pickle transfer function, just in case if rounding error causes pool to not have enough PICKLEs.\\n    function safePickleTransfer(address _to, uint256 _amount) internal {\\n        uint256 pickleBal = pickle.balanceOf(address(this));\\n        if (_amount > pickleBal) {\\n            pickle.transfer(_to, pickleBal);\\n        } else {\\n            pickle.transfer(_to, _amount);\\n        }\\n    }\\n\\n    // Update dev address by the previous dev.\\n    function dev(address _devaddr) public {\\n        require(msg.sender == devaddr, \\\"dev: wut?\\\");\\n        devaddr = _devaddr;\\n    }\\n\\n    // **** Additional functions separate from the original masterchef contract ****\\n\\n    function setPicklePerBlock(uint256 _picklePerBlock) public onlyOwner {\\n        require(_picklePerBlock > 0, \\\"!picklePerBlock-0\\\");\\n\\n        picklePerBlock = _picklePerBlock;\\n    }\\n\\n    function setBonusEndBlock(uint256 _bonusEndBlock) public onlyOwner {\\n        bonusEndBlock = _bonusEndBlock;\\n    }\\n\\n    function setDevFundDivRate(uint256 _devFundDivRate) public onlyOwner {\\n        require(_devFundDivRate > 0, \\\"!devFundDivRate-0\\\");\\n        devFundDivRate = _devFundDivRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/yield-farming/pickle-token.sol\": {\r\n      \"content\": \"pragma solidity 0.6.7;\\n\\nimport \\\"../lib/erc20.sol\\\";\\nimport \\\"../lib/ownable.sol\\\";\\n\\n// PickleToken with Governance.\\ncontract PickleToken is ERC20(\\\"PickleToken\\\", \\\"PICKLE\\\"), Ownable {\\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\\n    function mint(address _to, uint256 _amount) public onlyOwner {\\n        _mint(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/staking-rewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.7;\\n\\nimport \\\"./lib/reentrancy-guard.sol\\\";\\nimport \\\"./lib/pausable.sol\\\";\\nimport \\\"./lib/erc20.sol\\\";\\nimport \\\"./lib/safe-math.sol\\\";\\n\\ncontract StakingRewards is ReentrancyGuard, Pausable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IERC20 public rewardsToken;\\n    IERC20 public stakingToken;\\n    uint256 public periodFinish = 0;\\n    uint256 public rewardRate = 0;\\n    uint256 public rewardsDuration = 7 days;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address _owner,\\n        address _rewardsToken,\\n        address _stakingToken\\n    ) public Owned(_owner) {\\n        rewardsToken = IERC20(_rewardsToken);\\n        stakingToken = IERC20(_stakingToken);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return min(block.timestamp, periodFinish);\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (_totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored.add(\\n                lastTimeRewardApplicable()\\n                    .sub(lastUpdateTime)\\n                    .mul(rewardRate)\\n                    .mul(1e18)\\n                    .div(_totalSupply)\\n            );\\n    }\\n\\n    function earned(address account) public view returns (uint256) {\\n        return\\n            _balances[account]\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n                .div(1e18)\\n                .add(rewards[account]);\\n    }\\n\\n    function getRewardForDuration() external view returns (uint256) {\\n        return rewardRate.mul(rewardsDuration);\\n    }\\n\\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function stake(uint256 amount)\\n        external\\n        nonReentrant\\n        notPaused\\n        updateReward(msg.sender)\\n    {\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    function withdraw(uint256 amount)\\n        public\\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function getReward() public nonReentrant updateReward(msg.sender) {\\n        uint256 reward = rewards[msg.sender];\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n            rewardsToken.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function exit() external {\\n        withdraw(_balances[msg.sender]);\\n        getReward();\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function notifyRewardAmount(uint256 reward)\\n        external\\n        onlyOwner\\n        updateReward(address(0))\\n    {\\n        if (block.timestamp >= periodFinish) {\\n            rewardRate = reward.div(rewardsDuration);\\n        } else {\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\n            uint256 leftover = remaining.mul(rewardRate);\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\n        }\\n\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\n        require(\\n            rewardRate <= balance.div(rewardsDuration),\\n            \\\"Provided reward too high\\\"\\n        );\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp.add(rewardsDuration);\\n        emit RewardAdded(reward);\\n    }\\n\\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\\n        external\\n        onlyOwner\\n    {\\n        // Cannot recover the staking token or the rewards token\\n        require(\\n            tokenAddress != address(stakingToken) &&\\n                tokenAddress != address(rewardsToken),\\n            \\\"Cannot withdraw the staking or rewards tokens\\\"\\n        );\\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\\n        emit Recovered(tokenAddress, tokenAmount);\\n    }\\n\\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\\n        require(\\n            block.timestamp > periodFinish,\\n            \\\"Previous rewards period must be complete before changing the duration for the new period\\\"\\n        );\\n        rewardsDuration = _rewardsDuration;\\n        emit RewardsDurationUpdated(rewardsDuration);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event RewardsDurationUpdated(uint256 newDuration);\\n    event Recovered(address token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"src/pickle-jar.sol\": {\r\n      \"content\": \"// https://github.com/iearn-finance/vaults/blob/master/contracts/vaults/yVault.sol\\n\\npragma solidity ^0.6.7;\\n\\nimport \\\"./interfaces/controller.sol\\\";\\n\\nimport \\\"./lib/erc20.sol\\\";\\nimport \\\"./lib/safe-math.sol\\\";\\n\\ncontract PickleJar is ERC20 {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    IERC20 public token;\\n\\n    uint256 public min = 9500;\\n    uint256 public constant max = 10000;\\n\\n    address public governance;\\n    address public timelock;\\n    address public controller;\\n\\n    constructor(address _token, address _governance, address _timelock, address _controller)\\n        public\\n        ERC20(\\n            string(abi.encodePacked(\\\"pickling \\\", ERC20(_token).name())),\\n            string(abi.encodePacked(\\\"p\\\", ERC20(_token).symbol()))\\n        )\\n    {\\n        _setupDecimals(ERC20(_token).decimals());\\n        token = IERC20(_token);\\n        governance = _governance;\\n        timelock = _timelock;\\n        controller = _controller;\\n    }\\n\\n    function balance() public view returns (uint256) {\\n        return\\n            token.balanceOf(address(this)).add(\\n                IController(controller).balanceOf(address(token))\\n            );\\n    }\\n\\n    function setMin(uint256 _min) external {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        min = _min;\\n    }\\n\\n    function setGovernance(address _governance) public {\\n        require(msg.sender == governance, \\\"!governance\\\");\\n        governance = _governance;\\n    }\\n\\n    function setTimelock(address _timelock) public {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        timelock = _timelock;\\n    }\\n\\n    function setController(address _controller) public {\\n        require(msg.sender == timelock, \\\"!timelock\\\");\\n        controller = _controller;\\n    }\\n\\n    // Custom logic in here for how much the jars allows to be borrowed\\n    // Sets minimum required on-hand to keep small withdrawals cheap\\n    function available() public view returns (uint256) {\\n        return token.balanceOf(address(this)).mul(min).div(max);\\n    }\\n\\n    function earn() public {\\n        uint256 _bal = available();\\n        token.safeTransfer(controller, _bal);\\n        IController(controller).earn(address(token), _bal);\\n    }\\n\\n    function depositAll() external {\\n        deposit(token.balanceOf(msg.sender));\\n    }\\n\\n    function deposit(uint256 _amount) public {\\n        uint256 _pool = balance();\\n        uint256 _before = token.balanceOf(address(this));\\n        token.safeTransferFrom(msg.sender, address(this), _amount);\\n        uint256 _after = token.balanceOf(address(this));\\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\\n        uint256 shares = 0;\\n        if (totalSupply() == 0) {\\n            shares = _amount;\\n        } else {\\n            shares = (_amount.mul(totalSupply())).div(_pool);\\n        }\\n        _mint(msg.sender, shares);\\n    }\\n\\n    function withdrawAll() external {\\n        withdraw(balanceOf(msg.sender));\\n    }\\n\\n    // Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\\n    function harvest(address reserve, uint256 amount) external {\\n        require(msg.sender == controller, \\\"!controller\\\");\\n        require(reserve != address(token), \\\"token\\\");\\n        IERC20(reserve).safeTransfer(controller, amount);\\n    }\\n\\n    // No rebalance implementation for lower fees and faster swaps\\n    function withdraw(uint256 _shares) public {\\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\\n        _burn(msg.sender, _shares);\\n\\n        // Check balance\\n        uint256 b = token.balanceOf(address(this));\\n        if (b < r) {\\n            uint256 _withdraw = r.sub(b);\\n            IController(controller).withdraw(address(token), _withdraw);\\n            uint256 _after = token.balanceOf(address(this));\\n            uint256 _diff = _after.sub(b);\\n            if (_diff < _withdraw) {\\n                r = b.add(_diff);\\n            }\\n        }\\n\\n        token.safeTransfer(msg.sender, r);\\n    }\\n\\n    function getRatio() public view returns (uint256) {\\n        return balance().mul(1e18).div(totalSupply());\\n    }\\n}\\n\"\r\n    },\r\n    \"src/governance/timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.7;\\n\\nimport \\\"../lib/safe-math.sol\\\";\\n\\ncontract Timelock {\\n    using SafeMath for uint;\\n\\n    event NewAdmin(address indexed newAdmin);\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\n    event NewDelay(uint indexed newDelay);\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\\n\\n    uint public constant GRACE_PERIOD = 14 days;\\n    uint public constant MINIMUM_DELAY = 2 days;\\n    uint public constant MAXIMUM_DELAY = 30 days;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    uint public delay;\\n    bool public admin_initialized;\\n\\n    mapping (bytes32 => bool) public queuedTransactions;\\n\\n\\n    constructor(address admin_, uint delay_) public {\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::constructor: Delay must not exceed maximum delay.\\\");\\n\\n        admin = admin_;\\n        delay = delay_;\\n        admin_initialized = false;\\n    }\\n\\n    // XXX: function() external payable { }\\n    receive() external payable { }\\n\\n    function setDelay(uint delay_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n        delay = delay_;\\n\\n        emit NewDelay(delay);\\n    }\\n\\n    function acceptAdmin() public {\\n        require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n        admin = msg.sender;\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(admin);\\n    }\\n\\n    function setPendingAdmin(address pendingAdmin_) public {\\n        // allows one time setting of admin for deployment purposes\\n        if (admin_initialized) {\\n            require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\n        } else {\\n            require(msg.sender == admin, \\\"Timelock::setPendingAdmin: First call must come from admin.\\\");\\n            admin_initialized = true;\\n        }\\n        pendingAdmin = pendingAdmin_;\\n\\n        emit NewPendingAdmin(pendingAdmin);\\n    }\\n\\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\\n        require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n        require(eta >= getBlockTimestamp().add(delay), \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = true;\\n\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\n        return txHash;\\n    }\\n\\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\\n        require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = false;\\n\\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\\n    }\\n\\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\\n        require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\");\\n        require(getBlockTimestamp() >= eta, \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\");\\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n        queuedTransactions[txHash] = false;\\n\\n        bytes memory callData;\\n\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n        return returnData;\\n    }\\n\\n    function getBlockTimestamp() internal view returns (uint) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"}
{"address": "0x6684977bbed67e101bb80fc07fccfba655c0a64f", "attacktype": "Other unsafe DeFi protocol dependency", "sourcecode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/uniswapv2/interfaces/IUniswapV2ERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n// File: contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function migrator() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setMigrator(address) external;\r\n}\r\n\r\n// File: contracts/SushiMaker.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SushiMaker {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IUniswapV2Factory public factory;\r\n    address public bar;\r\n    address public sushi;\r\n    address public weth;\r\n\r\n    constructor(IUniswapV2Factory _factory, address _bar, address _sushi, address _weth) public {\r\n        factory = _factory;\r\n        sushi = _sushi;\r\n        bar = _bar;\r\n        weth = _weth;\r\n    }\r\n\r\n    function convert(address token0, address token1) public {\r\n        // At least we try to make front-running harder to do.\r\n        require(msg.sender == tx.origin, \"do not convert from contract\");\r\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));\r\n        pair.transfer(address(pair), pair.balanceOf(address(this)));\r\n        pair.burn(address(this));\r\n        uint256 wethAmount = _toWETH(token0) + _toWETH(token1);\r\n        _toSUSHI(wethAmount);\r\n    }\r\n\r\n    function _toWETH(address token) internal returns (uint256) {\r\n        if (token == sushi) {\r\n            uint amount = IERC20(token).balanceOf(address(this));\r\n            _safeTransfer(token, bar, amount);\r\n            return 0;\r\n        }\r\n        if (token == weth) {\r\n            uint amount = IERC20(token).balanceOf(address(this));\r\n            _safeTransfer(token, factory.getPair(weth, sushi), amount);\r\n            return amount;\r\n        }\r\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token, weth));\r\n        if (address(pair) == address(0)) {\r\n            return 0;\r\n        }\r\n        (uint reserve0, uint reserve1,) = pair.getReserves();\r\n        address token0 = pair.token0();\r\n        (uint reserveIn, uint reserveOut) = token0 == token ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        uint amountIn = IERC20(token).balanceOf(address(this));\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        uint amountOut = numerator / denominator;\r\n        (uint amount0Out, uint amount1Out) = token0 == token ? (uint(0), amountOut) : (amountOut, uint(0));\r\n        _safeTransfer(token, address(pair), amountIn);\r\n        pair.swap(amount0Out, amount1Out, factory.getPair(weth, sushi), new bytes(0));\r\n        return amountOut;\r\n    }\r\n\r\n    function _toSUSHI(uint256 amountIn) internal {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(weth, sushi));\r\n        (uint reserve0, uint reserve1,) = pair.getReserves();\r\n        address token0 = pair.token0();\r\n        (uint reserveIn, uint reserveOut) = token0 == weth ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        uint amountOut = numerator / denominator;\r\n        (uint amount0Out, uint amount1Out) = token0 == weth ? (uint(0), amountOut) : (amountOut, uint(0));\r\n        pair.swap(amount0Out, amount1Out, bar, new bytes(0));\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint256 amount) internal {\r\n        IERC20(token).safeTransfer(to, amount);\r\n    }\r\n}"}
{"address": "0x35c674c288577df3e9b5dafef945795b741c7810", "attacktype": "Flash liquidity borrow, purchase, mint or deposit, Absence of code logic or sanity check", "sourcecode": "//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMaths {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Memefund {\r\n\r\n    using SafeMaths for uint256;\r\n\r\n    address public rebaseOracle;       // Used for authentication\r\n    address public owner;              // Used for authentication\r\n    address public newOwner;\r\n\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n\r\n    uint256 private constant MAX_UINT256 = ~uint256(0);   // (2^256) - 1\r\n    uint256 private constant MAXSUPPLY = ~uint128(0);  // (2^128) - 1\r\n\r\n    uint256 private totalAtoms;\r\n    uint256 private atomsPerMolecule;\r\n\r\n    mapping (address => uint256) private atomBalances;\r\n    mapping (address => mapping (address => uint256)) private allowedMolecules;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event LogRebase(uint256 _totalSupply);\r\n    event LogNewRebaseOracle(address _rebaseOracle);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public\r\n    {\r\n        decimals = 9;                               // decimals  \r\n        totalSupply = 100000000*10**9;                // initialSupply\r\n        name = \"Memefund\";                         // Set the name for display purposes\r\n        symbol = \"MFUND\";                            // Set the symbol for display purposes\r\n\r\n        owner = msg.sender;\r\n        totalAtoms = MAX_UINT256 - (MAX_UINT256 % totalSupply);     // totalAtoms is a multiple of totalSupply so that atomsPerMolecule is an integer.\r\n        atomBalances[msg.sender] = totalAtoms;\r\n        atomsPerMolecule = totalAtoms.div(totalSupply);\r\n\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @param newRebaseOracle The address of the new oracle for rebasement (used for authentication).\r\n     */\r\n    function setRebaseOracle(address newRebaseOracle) external {\r\n        require(msg.sender == owner, \"Can only be executed by owner.\");\r\n        rebaseOracle = newRebaseOracle;\r\n\r\n        emit LogNewRebaseOracle(rebaseOracle);\r\n    }\r\n\r\n    /**\r\n     * @dev Propose a new owner.\r\n     * @param _newOwner The address of the new owner.\r\n     */\r\n    function transferOwnership(address _newOwner) public\r\n    {\r\n        require(msg.sender == owner, \"Can only be executed by owner.\");\r\n        require(_newOwner != address(0), \"0x00 address not allowed.\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Accept new owner.\r\n     */\r\n    function acceptOwnership() public\r\n    {\r\n        require(msg.sender == newOwner, \"Sender not authorized.\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Notifies Benchmark contract about a new rebase cycle.\r\n     * @param supplyDelta The number of new molecule tokens to add into or remove from circulation.\r\n     * @param increaseSupply Whether to increase or decrease the total supply.\r\n     * @return The total number of molecules after the supply adjustment.\r\n     */\r\n    function rebase(uint256 supplyDelta, bool increaseSupply) external returns (uint256) {\r\n        require(msg.sender == rebaseOracle, \"Can only be executed by rebaseOracle.\");\r\n        \r\n        if (supplyDelta == 0) {\r\n            emit LogRebase(totalSupply);\r\n            return totalSupply;\r\n        }\r\n\r\n        if (increaseSupply == true) {\r\n            totalSupply = totalSupply.add(supplyDelta);\r\n        } else {\r\n            totalSupply = totalSupply.sub(supplyDelta);\r\n        }\r\n\r\n        if (totalSupply > MAXSUPPLY) {\r\n            totalSupply = MAXSUPPLY;\r\n        }\r\n\r\n        atomsPerMolecule = totalAtoms.div(totalSupply);\r\n\r\n        emit LogRebase(totalSupply);\r\n        return totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @param who The address to query.\r\n     * @return The balance of the specified address.\r\n     */\r\n    function balanceOf(address who) public view returns (uint256) {\r\n        return atomBalances[who].div(atomsPerMolecule);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified address.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     * @return True on success, false otherwise.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        require(to != address(0),\"Invalid address.\");\r\n        require(to != address(this),\"Molecules contract can't receive MARK.\");\r\n\r\n        uint256 atomValue = value.mul(atomsPerMolecule);\r\n\r\n        atomBalances[msg.sender] = atomBalances[msg.sender].sub(atomValue);\r\n        atomBalances[to] = atomBalances[to].add(atomValue);\r\n\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\r\n     * @param owner_ The address which owns the funds.\r\n     * @param spender The address which will spend the funds.\r\n     * @return The number of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner_, address spender) public view returns (uint256) {\r\n        return allowedMolecules[owner_][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * @param from The address you want to send tokens from.\r\n     * @param to The address you want to transfer to.\r\n     * @param value The amount of tokens to be transferred.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        require(to != address(0),\"Invalid address.\");\r\n        require(to != address(this),\"Molecules contract can't receive MARK.\");\r\n\r\n        allowedMolecules[from][msg.sender] = allowedMolecules[from][msg.sender].sub(value);\r\n\r\n        uint256 atomValue = value.mul(atomsPerMolecule);\r\n        atomBalances[from] = atomBalances[from].sub(atomValue);\r\n        atomBalances[to] = atomBalances[to].add(atomValue);\r\n        \r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\r\n     * msg.sender. This method is included for ERC20 compatibility.\r\n     * IncreaseAllowance and decreaseAllowance should be used instead.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        allowedMolecules[msg.sender][spender] = value;\r\n\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\r\n     * This method should be used instead of approve() to avoid the double approval vulnerability.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        allowedMolecules[msg.sender][spender] = allowedMolecules[msg.sender][spender].add(addedValue);\r\n\r\n        emit Approval(msg.sender, spender, allowedMolecules[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        uint256 oldValue = allowedMolecules[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            allowedMolecules[msg.sender][spender] = 0;\r\n        } else {\r\n            allowedMolecules[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, allowedMolecules[msg.sender][spender]);\r\n        return true;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Memestake is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20; \r\n    \r\n       \r\n    struct UserInfo{\r\n        uint256 amount; // How many tokens got staked by user.\r\n        uint256 rewardDebt; // Reward debt. See Explanation below.\r\n\r\n        // We do some fancy math here. Basically, any point in time, the amount of \r\n        // claimable MFUND by a user is:\r\n        //\r\n        //   pending reward = (user.amount * pool.accMFundPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n        //   1. The pool's `accMfundPerShare` (and `lastRewardedBlock`) gets updated.\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n    }\r\n\r\n    struct PoolInfo {\r\n        IERC20 tokenContract; // Address of Token contract.\r\n        uint256 allocPoint; // Allocation points from the pool\r\n        uint256 lastRewardBlock; // Last block number where MFUND got distributed.\r\n        uint256 accMfundPerShare; // Accumulated MFUND per share.\r\n    }\r\n\r\n    Memefund public mFundToken;\r\n    uint256 public mFundPerBlock;\r\n\r\n    PoolInfo[] public poolInfo;\r\n\r\n    mapping (uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    mapping (address => bool) isTokenContractAdded;\r\n\r\n    uint256 public totalAllocPoint;\r\n\r\n    uint256 public totalMfund;\r\n\r\n    uint256 public startBlock;\r\n\r\n    uint256 public endBlock;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n\r\n\r\n    constructor(Memefund _mFundToken,\r\n                uint256 _totalMfund,\r\n                uint256 _startBlock,\r\n                uint256 _endBlock) public{\r\n                require(address(_mFundToken) != address(0), \"constructor: _mFundToken must not be zero address!\");\r\n                require(_totalMfund > 0, \"constructor: _totalMfund must be greater than 0\");\r\n\r\n                mFundToken = _mFundToken;\r\n                totalMfund = _totalMfund;\r\n                startBlock = _startBlock;\r\n                endBlock = _endBlock;\r\n                \r\n                uint256 numberOfBlocksForFarming = endBlock.sub(startBlock);\r\n                mFundPerBlock = totalMfund.div(numberOfBlocksForFarming);\r\n    }\r\n    \r\n    /// @notice Returns the number of pools that have been added by the owner\r\n    /// @return Number of pools\r\n    function numberOfPools() external view returns(uint256){\r\n        return poolInfo.length;\r\n    }\r\n    \r\n\r\n    /// @notice Create a new LPT pool by whitelisting a new ERC20 token.\r\n    /// @dev Can only be called by the contract owner\r\n    /// @param _allocPoint Governs what percentage of the total LPT rewards this pool and other pools will get\r\n    /// @param _tokenContract Address of the staking token being whitelisted\r\n    /// @param _withUpdate Set to true for updating all pools before adding this one\r\n    function add(uint256 _allocPoint, IERC20 _tokenContract, bool _withUpdate) public onlyOwner {\r\n        require(block.number < endBlock, \"add: must be before end\");\r\n        address tokenContractAddress = address(_tokenContract);\r\n        require(tokenContractAddress != address(0), \"add: _tokenConctract must not be zero address\");\r\n        require(isTokenContractAdded[tokenContractAddress] == false, \"add: already whitelisted\");\r\n\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n            tokenContract : _tokenContract,\r\n            allocPoint : _allocPoint,\r\n            lastRewardBlock : lastRewardBlock,\r\n            accMfundPerShare : 0\r\n        }));\r\n\r\n        isTokenContractAdded[tokenContractAddress] = true;\r\n    }\r\n\r\n    /// @notice Update a pool's allocation point to increase or decrease its share of contract-level rewards\r\n    /// @notice Can also update the max amount that can be staked per user\r\n    /// @dev Can only be called by the owner\r\n    /// @param _pid ID of the pool being updated\r\n    /// @param _allocPoint New allocation point\r\n    /// @param _withUpdate Set to true if you want to update all pools before making this change - it will checkpoint those rewards\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        require(block.number < endBlock, \"set: must be before end\");\r\n        require(_pid < poolInfo.length, \"set: invalid _pid\");\r\n\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    /// @notice View function to see pending and unclaimed Mfunds for a given user\r\n    /// @param _pid ID of the pool where a user has a stake\r\n    /// @param _user Account being queried\r\n    /// @return Amount of MFUND tokens due to a user\r\n    function pendingRewards(uint256 _pid, address _user) external view returns (uint256) {\r\n        require(_pid < poolInfo.length, \"pendingMfund: invalid _pid\");\r\n\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n\r\n        uint256 accMfundPerShare = pool.accMfundPerShare;\r\n        uint256 lpSupply = pool.tokenContract.balanceOf(address(this));\r\n\r\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 maxBlock = block.number <= endBlock ? block.number : endBlock;\r\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, maxBlock);\r\n            uint256 mFundReward = multiplier.mul(mFundPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n            accMfundPerShare = accMfundPerShare.add(mFundReward.mul(1e18).div(lpSupply));\r\n        }\r\n\r\n        return user.amount.mul(accMfundPerShare).div(1e18).sub(user.rewardDebt);\r\n    }\r\n    \r\n    \r\n    function claimRewards(uint256 _pid) public{\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n        uint256 pending = user.amount.mul(pool.accMfundPerShare).div(1e24).sub(user.rewardDebt);\r\n        require(pending > 0, \"harvest: no reward owed\");\r\n        user.rewardDebt = user.amount.mul(pool.accMfundPerShare).div(1e24);\r\n        safeMfundTransfer(msg.sender, pending);\r\n        emit Claim(msg.sender, _pid, pending);\r\n    }\r\n        /// @notice Cycles through the pools to update all of the rewards accrued\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n\r\n    /// @notice Updates a specific pool to track all of the rewards accrued up to the TX block\r\n    /// @param _pid ID of the pool\r\n    function updatePool(uint256 _pid) public {\r\n        require(_pid < poolInfo.length, \"updatePool: invalid _pid\");\r\n\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n\r\n        uint256 tokenContractSupply = pool.tokenContract.balanceOf(address(this));\r\n        if (tokenContractSupply == 0) {\r\n            pool.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n\r\n        uint256 maxEndBlock = block.number <= endBlock ? block.number : endBlock;\r\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, maxEndBlock);\r\n\r\n        // No point in doing any more logic as the rewards have ended\r\n        if (multiplier == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 mFundReward = multiplier.mul(mFundPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n\r\n        pool.accMfundPerShare = pool.accMfundPerShare.add(mFundReward.mul(1e18).div(tokenContractSupply));\r\n        pool.lastRewardBlock = maxEndBlock;\r\n    }\r\n\r\n    /// @notice Where any user can stake their ERC20 tokens into a pool in order to farm $LPT\r\n    /// @param _pid ID of the pool\r\n    /// @param _amount Amount of ERC20 being staked\r\n    function deposit(uint256 _pid, uint256 _amount) external {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.amount.mul(pool.accMfundPerShare).div(1e18).sub(user.rewardDebt);\r\n            if (pending > 0) {\r\n                safeMfundTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n\r\n        if (_amount > 0) {\r\n            pool.tokenContract.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n        }\r\n\r\n        user.rewardDebt = user.amount.mul(pool.accMfundPerShare).div(1e18);\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    /// @notice Allows a user to withdraw any ERC20 tokens staked in a pool\r\n    /// @dev Partial withdrawals permitted\r\n    /// @param _pid Pool ID\r\n    /// @param _amount Being withdrawn\r\n    function withdraw(uint256 _pid, uint256 _amount) external {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n\r\n        require(user.amount >= _amount, \"withdraw: _amount not good\");\r\n\r\n        updatePool(_pid);\r\n\r\n        uint256 pending = user.amount.mul(pool.accMfundPerShare).div(1e18).sub(user.rewardDebt);\r\n        if (pending > 0) {\r\n            safeMfundTransfer(msg.sender, pending);\r\n        }\r\n\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.tokenContract.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n\r\n        user.rewardDebt = user.amount.mul(pool.accMfundPerShare).div(1e18);\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    /// @notice Emergency only. Should the rewards issuance mechanism fail, people can still withdraw their stake\r\n    /// @param _pid Pool ID\r\n    function emergencyWithdraw(uint256 _pid) external {\r\n        require(_pid < poolInfo.length, \"updatePool: invalid _pid\");\r\n\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n\r\n        pool.tokenContract.safeTransfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\r\n    }\r\n\r\n    ////////////\r\n    // Private /\r\n    ////////////\r\n\r\n    /// @dev Safe MFUND transfer function, just in case if rounding error causes pool to not have enough LPTs.\r\n    /// @param _to Whom to send MFUND into\r\n    /// @param _amount of MFUND to send\r\n    function safeMfundTransfer(address _to, uint256 _amount) internal {\r\n        uint256 mFundBal = mFundToken.balanceOf(address(this));\r\n        if (_amount > mFundBal) {\r\n            mFundToken.transfer(_to, mFundBal);\r\n        } else {\r\n            mFundToken.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Return reward multiplier over the given _from to _to block.\r\n    /// @param _from Block number\r\n    /// @param _to Block number\r\n    /// @return Number of blocks that have passed\r\n    function getMultiplier(uint256 _from, uint256 _to) private view returns (uint256) {\r\n        return _to.sub(_from);\r\n    }\r\n}"}
{"address": "0x66e7d7839333f502df355f5bd87aea24bac2ee63", "attacktype": "Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Monoswap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"./interfaces/IMonoXPool.sol\\\";\\nimport './interfaces/IWETH.sol';\\nimport './libraries/MonoXLibrary.sol';\\n\\ninterface IvCash is IERC20 {\\n  function mint (address account, uint256 amount) external;\\n\\n  function burn (address account, uint256 amount) external;\\n}\\n\\n\\n/**\\n * The Monoswap is ERC1155 contract does this and that...\\n */\\ncontract Monoswap is Initializable, OwnableUpgradeable {\\n  using SafeMath for uint256;\\n  using SafeMath for uint112;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for IvCash;\\n\\n  IvCash vCash;\\n  address WETH;\\n  address feeTo;\\n  uint16 fees; // over 1e5, 300 means 0.3%\\n  uint16 devFee; // over 1e5, 50 means 0.05%\\n\\n  uint256 constant MINIMUM_LIQUIDITY=100;\\n  \\n  struct PoolInfo {\\n    uint256 pid;\\n    uint256 lastPoolValue;\\n    address token;\\n    PoolStatus status;\\n    uint112 vcashDebt;\\n    uint112 vcashCredit;\\n    uint112 tokenBalance;\\n    uint256 price; // over 1e18\\n    uint256 createdAt; // timestamp\\n  }\\n\\n  enum TxType {\\n    SELL,\\n    BUY\\n  }\\n\\n  enum PoolStatus {\\n    UNLISTED,\\n    LISTED,\\n    OFFICIAL,\\n    SYNTHETIC,\\n    PAUSED\\n  }\\n  \\n  mapping (address => PoolInfo) public pools;\\n  // tokenStatus is for token lock/transfer. exempt means no need to verify post tx\\n  mapping (address => uint8) private tokenStatus; //0=unlocked, 1=locked, 2=exempt\\n\\n  // token poool status is to track if the pool has already been created for the token\\n  mapping (address => uint8) public tokenPoolStatus; //0=undefined, 1=exists\\n  \\n  // negative vCash balance allowed for each token\\n  mapping (address => uint) public tokenInsurance;\\n\\n  uint256 public poolSize;\\n\\n  uint private unlocked;\\n  modifier lock() {\\n    require(unlocked == 1, 'MonoX:LOCKED');\\n    unlocked = 0;\\n    _;\\n    unlocked = 1;\\n  }\\n\\n  modifier lockToken(address _token) { \\n    uint8 originalState = tokenStatus[_token];\\n    require(originalState!=1, 'MonoX:POOL_LOCKED');\\n    if(originalState==0) {\\n      tokenStatus[_token] = 1;\\n    }\\n    _;\\n    if(originalState==0) {\\n      tokenStatus[_token] = 0;\\n    }\\n  }\\n\\n  modifier ensure(uint deadline) {\\n    require(deadline >= block.timestamp, 'MonoX:EXPIRED');\\n    _;\\n  }  \\n\\n  modifier onlyPriceAdjuster(){\\n    require(priceAdjusterRole[msg.sender]==true,\\\"MonoX:BAD_ROLE\\\");\\n    _;\\n  }\\n\\n  event AddLiquidity(address indexed provider, \\n    uint indexed pid,\\n    address indexed token,\\n    uint liquidityAmount,\\n    uint vcashAmount, uint tokenAmount, uint price);\\n\\n  event RemoveLiquidity(address indexed provider, \\n    uint indexed pid,\\n    address indexed token,\\n    uint liquidityAmount,\\n    uint vcashAmount, uint tokenAmount, uint price);\\n\\n  event Swap(\\n    address indexed user,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint amountIn,\\n    uint amountOut,\\n    uint swapVcashValue\\n  );\\n\\n  // event PriceAdjusterChanged(\\n  //   address indexed priceAdjuster,\\n  //   bool added\\n  // );\\n\\n  event PoolBalanced(\\n    address _token,\\n    uint vcashIn\\n  );\\n\\n  event SyntheticPoolPriceChanged(\\n    address _token,\\n    uint price\\n  );\\n\\n  event PoolStatusChanged(\\n    address _token,\\n    PoolStatus oldStatus,\\n    PoolStatus newStatus\\n  );\\n\\n  IMonoXPool public monoXPool;\\n  \\n  // mapping (token address => block number of the last trade)\\n  mapping (address => uint) public lastTradedBlock; \\n\\n  uint256 constant MINIMUM_POOL_VALUE = 10000 * 1e18;\\n  mapping (address=>bool) public priceAdjusterRole;\\n\\n  // ------------\\n  uint public poolSizeMinLimit;\\n\\n\\n  function initialize(IMonoXPool _monoXPool, IvCash _vcash) public initializer {\\n    OwnableUpgradeable.__Ownable_init();\\n    monoXPool = _monoXPool;\\n    vCash = _vcash;\\n    WETH = _monoXPool.WETH();\\n    fees = 300;\\n    devFee = 50;\\n    poolSize = 0;\\n    unlocked = 1;\\n  }\\n\\n  // receive() external payable {\\n  //   assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n  // }\\n\\n  function setFeeTo (address _feeTo) onlyOwner external {\\n    feeTo = _feeTo;\\n  }\\n  \\n  function setFees (uint16 _fees) onlyOwner external {\\n    require(_fees<1e3);\\n    fees = _fees;\\n  }\\n\\n  function setDevFee (uint16 _devFee) onlyOwner external {\\n    require(_devFee<1e3);\\n    devFee = _devFee;\\n  }\\n\\n  function setPoolSizeMinLimit(uint _poolSizeMinLimit) onlyOwner external {\\n    poolSizeMinLimit = _poolSizeMinLimit;\\n  }\\n\\n  function setTokenInsurance (address _token, uint _insurance) onlyOwner external {\\n    tokenInsurance[_token] = _insurance;\\n  }\\n\\n  // when safu, setting token status to 2 can achieve significant gas savings \\n  function setTokenStatus (address _token, uint8 _status) onlyOwner external {\\n    tokenStatus[_token] = _status;\\n  } \\n\\n  // update status of a pool. onlyOwner.\\n  function updatePoolStatus(address _token, PoolStatus _status) external onlyOwner {    \\n\\n    PoolStatus poolStatus = pools[_token].status;\\n    if(poolStatus==PoolStatus.PAUSED){\\n      require(block.number > lastTradedBlock[_token].add(6000), \\\"MonoX:TOO_EARLY\\\");\\n    }\\n    else{\\n      // okay to pause an official pool, wait 6k blocks and then convert it to synthetic\\n      require(_status!=PoolStatus.SYNTHETIC,\\\"MonoX:NO_SYNT\\\");\\n    }\\n      \\n    emit PoolStatusChanged(_token, poolStatus,_status);\\n    pools[_token].status = _status;\\n\\n    // unlisting a token allows creating a new pool of the same token. \\n    // should move it to PAUSED if the goal is to blacklist the token forever\\n    if(_status==PoolStatus.UNLISTED) {\\n      tokenPoolStatus[_token] = 0;\\n    }\\n  }\\n  \\n  /**\\n    @dev update pools price if there were no active trading for the last 6000 blocks\\n    @notice Only owner callable, new price can neither be 0 nor be equal to old one\\n    @param _token pool identifider (token address)\\n    @param _newPrice new price in wei (uint112)\\n   */\\n  function updatePoolPrice(address _token, uint _newPrice) external onlyOwner {\\n    require(_newPrice > 0, 'MonoX:0_PRICE');\\n    require(tokenPoolStatus[_token] != 0, \\\"MonoX:NO_POOL\\\");\\n\\n    require(block.number > lastTradedBlock[_token].add(6000), \\\"MonoX:TOO_EARLY\\\");\\n    pools[_token].price = _newPrice;\\n    lastTradedBlock[_token] = block.number;\\n  }\\n\\n  function updatePriceAdjuster(address account, bool _status) external onlyOwner{\\n    priceAdjusterRole[account]=_status;\\n    //emit PriceAdjusterChanged(account,_status);\\n  }\\n\\n  function setSynthPoolPrice(address _token, uint price) external onlyPriceAdjuster {\\n    require(pools[_token].status==PoolStatus.SYNTHETIC,\\\"MonoX:NOT_SYNT\\\");\\n    require(price > 0, \\\"MonoX:ZERO_PRICE\\\");\\n    pools[_token].price=price;\\n    emit SyntheticPoolPriceChanged(_token,price);\\n  }\\n\\n  function rebalancePool(address _token) external lockToken(_token) onlyOwner{\\n      // // PoolInfo memory pool = pools[_token];\\n      // uint poolPrice = pools[_token].price;\\n      // require(vcashIn <= pools[_token].vcashDebt,\\\"MonoX:NO_CREDIT\\\");\\n      // require((pools[_token].tokenBalance * poolPrice).div(1e18) >= vcashIn,\\\"MonoX:INSUF_TOKEN_VAL\\\");\\n      // // uint rebalancedAmount = vcashIn.mul(1e18).div(pool.price);\\n      // monoXPool.safeTransferERC20Token(_token, msg.sender, vcashIn.mul(1e18).div(poolPrice));\\n      // _syncPoolInfo(_token, vcashIn, 0);\\n      // emit PoolBalanced(_token, vcashIn);\\n\\n      _internalRebalance(_token);\\n  }\\n\\n  // must be called from a method with token lock to prevent reentry\\n  function _internalRebalance(address _token) internal {\\n    uint poolPrice = pools[_token].price;\\n    uint vcashIn = pools[_token].vcashDebt;\\n    if(poolPrice.mul(pools[_token].tokenBalance) / 1e18 < vcashIn){\\n      vcashIn = poolPrice.mul(pools[_token].tokenBalance) / 1e18;\\n    }\\n\\n    if(tokenStatus[_token]==2){\\n      monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));\\n    }else{\\n      uint256 balanceIn0 = IERC20(_token).balanceOf(address(monoXPool));\\n      monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));\\n      uint256 balanceIn1 = IERC20(_token).balanceOf(address(monoXPool));\\n      uint realAmount = balanceIn0.sub(balanceIn1);\\n\\n      vcashIn = realAmount.mul(poolPrice) / 1e18;\\n    }\\n    \\n    _syncPoolInfo(_token, vcashIn, 0);\\n    emit PoolBalanced(_token,vcashIn);\\n  }\\n\\n  // creates a pool\\n  function _createPool (address _token, uint _price, PoolStatus _status) lock internal returns(uint256 _pid)  {\\n    require(tokenPoolStatus[_token]==0, \\\"MonoX:POOL_EXISTS\\\");\\n    require (_token != address(vCash), \\\"MonoX:NO_vCash\\\");\\n    _pid = poolSize;\\n    pools[_token] = PoolInfo({\\n      token: _token,\\n      pid: _pid,\\n      vcashCredit: 0,\\n      vcashDebt: 0,\\n      tokenBalance: 0,\\n      lastPoolValue: 0,\\n      status: _status,\\n      price: _price,\\n      createdAt: block.timestamp\\n    });\\n\\n    poolSize = _pid.add(1);\\n    tokenPoolStatus[_token]=1;\\n\\n    // initialze pool's lasttradingblocknumber as the block number on which the pool is created\\n    lastTradedBlock[_token] = block.number;\\n  }\\n\\n  // creates a pool with special status\\n  function addSpecialToken (address _token, uint _price, PoolStatus _status) onlyOwner external returns(uint256 _pid)  {\\n    _pid = _createPool(_token, _price, _status);\\n  }\\n\\n  // internal func to pay contract owner\\n  function _mintFee (uint256 pid, uint256 lastPoolValue, uint256 newPoolValue) internal {\\n    \\n    // dropping tx fees for now\\n    return;\\n    \\n  }\\n\\n  // util func to get some basic pool info\\n  function getPool (address _token) view public returns (uint256 poolValue, \\n    uint256 tokenBalanceVcashValue, uint256 vcashCredit, uint256 vcashDebt) {\\n    // PoolInfo memory pool = pools[_token];\\n    vcashCredit = pools[_token].vcashCredit;\\n    vcashDebt = pools[_token].vcashDebt;\\n    tokenBalanceVcashValue = pools[_token].price.mul(pools[_token].tokenBalance)/1e18;\\n\\n    poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);\\n  }\\n\\n  // trustless listing pool creation. always creates unofficial pool\\n  function listNewToken (address _token, uint _price, \\n    uint256 vcashAmount, \\n    uint256 tokenAmount,\\n    address to) external returns(uint _pid, uint256 liquidity) {\\n    _pid = _createPool(_token, _price, PoolStatus.LISTED);\\n    liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);\\n  }\\n\\n  // add liquidity pair to a pool. allows adding vcash.\\n  function addLiquidityPair (address _token, \\n    uint256 vcashAmount, \\n    uint256 tokenAmount,\\n    address to) external returns(uint256 liquidity) {\\n    liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);\\n  }\\n\\n    // add liquidity pair to a pool. allows adding vcash.\\n  function _addLiquidityPair (address _token, \\n    uint256 vcashAmount, \\n    uint256 tokenAmount,\\n    address from,\\n    address to) internal lockToken(_token) returns(uint256 liquidity) {\\n    require (tokenAmount>0, \\\"MonoX:BAD_AMOUNT\\\");\\n\\n    require(tokenPoolStatus[_token]==1, \\\"MonoX:NO_POOL\\\");\\n    \\n    // (uint256 poolValue, , ,) = getPool(_token);\\n    PoolInfo memory pool = pools[_token];\\n    IMonoXPool monoXPoolLocal = monoXPool;\\n    \\n    uint256 poolValue = pool.price.mul(pool.tokenBalance)/1e18;\\n    poolValue = poolValue.add(pool.vcashCredit).sub(pool.vcashDebt);\\n\\n    \\n    _mintFee(pool.pid, pool.lastPoolValue, poolValue);\\n\\n    tokenAmount = transferAndCheck(from,address(monoXPoolLocal),_token,tokenAmount);\\n\\n    if(vcashAmount>0){\\n      vCash.safeTransferFrom(msg.sender, address(monoXPoolLocal), vcashAmount);\\n      vCash.burn(address(monoXPool), vcashAmount);\\n    }\\n\\n    // this is to avoid stack too deep\\n    {\\n      uint256 _totalSupply = monoXPoolLocal.totalSupplyOf(pool.pid);\\n      uint256 liquidityVcashValue = vcashAmount.add(tokenAmount.mul(pool.price)/1e18);\\n\\n      if(_totalSupply==0){\\n        liquidityVcashValue = liquidityVcashValue/1e6; // so $1m would get you 1e18\\n        liquidity = liquidityVcashValue.sub(MINIMUM_LIQUIDITY);\\n        // sorry, oz doesn't allow minting to address(0)\\n        monoXPoolLocal.mintLp(feeTo, pool.pid, MINIMUM_LIQUIDITY, pool.status == PoolStatus.LISTED); \\n      }else{\\n        liquidity = _totalSupply.mul(liquidityVcashValue).div(poolValue);\\n      }\\n    }\\n    \\n    monoXPoolLocal.mintLp(to, pool.pid, liquidity, pool.status == PoolStatus.LISTED);\\n    _syncPoolInfo(_token, vcashAmount, 0);\\n\\n    emit AddLiquidity(to, \\n    pool.pid,\\n    _token,\\n    liquidity, \\n    vcashAmount, tokenAmount, pool.price);\\n  }\\n  \\n  // add one-sided liquidity to a pool. no vcash\\n  function addLiquidity (address _token, uint256 _amount, address to) external returns(uint256 liquidity)  {\\n    liquidity = _addLiquidityPair(_token, 0, _amount, msg.sender, to);\\n  }  \\n\\n  // add one-sided ETH liquidity to a pool. no vcash\\n  function addLiquidityETH (address to) external payable returns(uint256 liquidity)  {\\n    MonoXLibrary.safeTransferETH(address(monoXPool), msg.value);\\n    monoXPool.depositWETH(msg.value);\\n    liquidity = _addLiquidityPair(WETH, 0, msg.value, address(this), to);\\n  }  \\n\\n  // updates pool vcash balance, token balance and last pool value.\\n  // this function requires others to do the input validation\\n  function _syncPoolInfo (address _token, uint256 vcashIn, uint256 vcashOut) internal {\\n    // PoolInfo memory pool = pools[_token];\\n    uint256 tokenPoolPrice = pools[_token].price;\\n    (uint256 vcashCredit, uint256 vcashDebt) = _updateVcashBalance(_token, vcashIn, vcashOut);\\n\\n    uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));\\n    uint256 tokenBalanceVcashValue = tokenPoolPrice.mul(tokenReserve)/1e18;\\n\\n    require(tokenReserve <= uint112(-1));\\n    pools[_token].tokenBalance = uint112(tokenReserve);\\n    // poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);\\n    pools[_token].lastPoolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);\\n  }\\n  \\n  // view func for removing liquidity\\n  function _removeLiquidity (address _token, uint256 liquidity,\\n    address to) view public returns(\\n    uint256 poolValue, uint256 liquidityIn, uint256 vcashOut, uint256 tokenOut) {\\n    \\n    require (liquidity>0, \\\"MonoX:BAD_AMOUNT\\\");\\n    uint256 tokenBalanceVcashValue;\\n    uint256 vcashCredit;\\n    uint256 vcashDebt;\\n    PoolInfo memory pool = pools[_token];\\n    IMonoXPool monoXPoolLocal = monoXPool;\\n    uint256 lastAdded = monoXPoolLocal.liquidityLastAddedOf(pool.pid, msg.sender);\\n    \\n    require((lastAdded + (pool.status == PoolStatus.OFFICIAL ? 4 hours : pool.status == PoolStatus.LISTED ? 24 hours : 0)) <= block.timestamp, \\\"MonoX:WRONG_TIME\\\"); // Users are not allowed to remove liquidity right after adding\\n    address topLPHolder = monoXPoolLocal.topLPHolderOf(pool.pid);\\n    require(pool.status != PoolStatus.LISTED || msg.sender != topLPHolder || pool.createdAt + 90 days < block.timestamp, \\\"MonoX:TOP_HOLDER & WRONG_TIME\\\"); // largest LP holder is not allowed to remove LP within 90 days after pool creation\\n\\n    (poolValue, tokenBalanceVcashValue, vcashCredit, vcashDebt) = getPool(_token);\\n    uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);\\n\\n    liquidityIn = monoXPool.balanceOf(to, pool.pid)>liquidity?liquidity:monoXPool.balanceOf(to, pool.pid);\\n    uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));\\n    \\n    if(tokenReserve < pool.tokenBalance){\\n      tokenBalanceVcashValue = tokenReserve.mul(pool.price)/1e18;\\n    }\\n\\n    if(vcashDebt>0){\\n      tokenReserve = (tokenBalanceVcashValue.sub(vcashDebt)).mul(1e18).div(pool.price);\\n    }\\n\\n    // if vcashCredit==0, vcashOut will be 0 as well\\n    vcashOut = liquidityIn.mul(vcashCredit).div(_totalSupply);\\n\\n    tokenOut = liquidityIn.mul(tokenReserve).div(_totalSupply);\\n\\n  }\\n  \\n  // actually removes liquidity\\n  function removeLiquidity (address _token, uint256 liquidity, address to, \\n    uint256 minVcashOut, \\n    uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {\\n    (vcashOut, tokenOut) = _removeLiquidityHelper (_token, liquidity, to, minVcashOut, minTokenOut, false);\\n  }\\n\\n  // actually removes liquidity\\n  function _removeLiquidityHelper (address _token, uint256 liquidity, address to, \\n    uint256 minVcashOut, \\n    uint256 minTokenOut,\\n    bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut)  {\\n    require (tokenPoolStatus[_token]==1, \\\"MonoX:NO_TOKEN\\\");\\n    PoolInfo memory pool = pools[_token];\\n    uint256 poolValue;\\n    uint256 liquidityIn;\\n    (poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to);\\n    _mintFee(pool.pid, pool.lastPoolValue, poolValue);\\n    require (vcashOut>=minVcashOut, \\\"MonoX:INSUFF_vCash\\\");\\n    require (tokenOut>=minTokenOut, \\\"MonoX:INSUFF_TOKEN\\\");\\n\\n    if (vcashOut>0){\\n      vCash.mint(to, vcashOut);\\n    }\\n    if (!isETH) {\\n      monoXPool.safeTransferERC20Token(_token, to, tokenOut);\\n    } else {\\n      monoXPool.withdrawWETH(tokenOut);\\n      monoXPool.safeTransferETH(to, tokenOut);\\n    }\\n\\n    monoXPool.burn(to, pool.pid, liquidityIn);\\n\\n    _syncPoolInfo(_token, 0, vcashOut);\\n\\n    emit RemoveLiquidity(to, \\n      pool.pid,\\n      _token,\\n      liquidityIn, \\n      vcashOut, tokenOut, pool.price);\\n  }\\n\\n  // actually removes ETH liquidity\\n  function removeLiquidityETH (uint256 liquidity, address to, \\n    uint256 minVcashOut, \\n    uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {\\n\\n    (vcashOut, tokenOut) = _removeLiquidityHelper (WETH, liquidity, to, minVcashOut, minTokenOut, true);\\n  }\\n\\n  // util func to compute new price\\n  function _getNewPrice (uint256 originalPrice, uint256 reserve, \\n    uint256 delta, uint256 deltaBlocks, TxType txType) pure internal returns(uint256 price) {\\n    if(txType==TxType.SELL) {\\n      // no risk of being div by 0\\n      price = originalPrice.mul(reserve)/(reserve.add(delta));\\n    }else{ // BUY\\n      price = originalPrice.mul(reserve).div(reserve.sub(delta));\\n    }\\n  }\\n\\n  // util func to compute new price\\n  function _getAvgPrice (uint256 originalPrice, uint256 newPrice) pure internal returns(uint256 price) {\\n    price = originalPrice.add(newPrice.mul(4))/5;\\n  }\\n\\n  // standard swap interface implementing uniswap router V2\\n  \\n  function swapExactETHForToken(\\n    address tokenOut,\\n    uint amountOutMin,\\n    address to,\\n    uint deadline\\n  ) external virtual payable ensure(deadline) returns (uint amountOut) {\\n    uint amountIn = msg.value;\\n    MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);\\n    monoXPool.depositWETH(amountIn);\\n    amountOut = swapIn(WETH, tokenOut, address(this), to, amountIn);\\n    require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');\\n  }\\n  \\n  function swapExactTokenForETH(\\n    address tokenIn,\\n    uint amountIn,\\n    uint amountOutMin,\\n    address to,\\n    uint deadline\\n  ) external virtual ensure(deadline) returns (uint amountOut) {\\n    IMonoXPool monoXPoolLocal = monoXPool;\\n    amountOut = swapIn(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountIn);\\n    require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');\\n    monoXPoolLocal.withdrawWETH(amountOut);\\n    monoXPoolLocal.safeTransferETH(to, amountOut);\\n  }\\n\\n  function swapETHForExactToken(\\n    address tokenOut,\\n    uint amountInMax,\\n    uint amountOut,\\n    address to,\\n    uint deadline\\n  ) external virtual payable ensure(deadline) returns (uint amountIn) {\\n    uint amountSentIn = msg.value;\\n    ( , , amountIn, ) = getAmountIn(WETH, tokenOut, amountOut);\\n    MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);\\n    monoXPool.depositWETH(amountIn);\\n    amountIn = swapOut(WETH, tokenOut, address(this), to, amountOut);\\n    require(amountIn <= amountSentIn, 'MonoX:BAD_INPUT');\\n    require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');\\n    if (amountSentIn > amountIn) {\\n      MonoXLibrary.safeTransferETH(msg.sender, amountSentIn.sub(amountIn));\\n    }\\n  }\\n\\n  function swapTokenForExactETH(\\n    address tokenIn,\\n    uint amountInMax,\\n    uint amountOut,\\n    address to,\\n    uint deadline\\n  ) external virtual ensure(deadline) returns (uint amountIn) {\\n    IMonoXPool monoXPoolLocal = monoXPool;\\n    amountIn = swapOut(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountOut);\\n    require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');\\n    monoXPoolLocal.withdrawWETH(amountOut);\\n    monoXPoolLocal.safeTransferETH(to, amountOut);\\n  }\\n\\n  function swapExactTokenForToken(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amountIn,\\n    uint amountOutMin,\\n    address to,\\n    uint deadline\\n  ) external virtual ensure(deadline) returns (uint amountOut) {\\n    amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn);\\n    require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');\\n  }\\n\\n  function swapTokenForExactToken(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amountInMax,\\n    uint amountOut,\\n    address to,\\n    uint deadline\\n  ) external virtual ensure(deadline) returns (uint amountIn) {\\n    amountIn = swapOut(tokenIn, tokenOut, msg.sender, to, amountOut);\\n    require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');\\n  }\\n\\n  // util func to manipulate vcash balance\\n  function _updateVcashBalance (address _token, \\n    uint _vcashIn, uint _vcashOut) internal returns (uint _vcashCredit, uint _vcashDebt) {\\n    if(_vcashIn>_vcashOut){\\n      _vcashIn = _vcashIn - _vcashOut;\\n      _vcashOut = 0;\\n    }else{\\n      _vcashOut = _vcashOut - _vcashIn;\\n      _vcashIn = 0;\\n    }\\n\\n    // PoolInfo memory _pool = pools[_token];\\n    uint _poolVcashCredit = pools[_token].vcashCredit;\\n    uint _poolVcashDebt = pools[_token].vcashDebt;\\n    PoolStatus _poolStatus = pools[_token].status;\\n    \\n    if(_vcashOut>0){\\n      (_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceSub(\\n        _poolVcashCredit, _poolVcashDebt, _vcashOut);\\n      require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));\\n      pools[_token].vcashCredit = uint112(_vcashCredit);\\n      pools[_token].vcashDebt = uint112(_vcashDebt);\\n    }\\n\\n    if(_vcashIn>0){\\n      (_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceAdd(\\n        _poolVcashCredit, _poolVcashDebt, _vcashIn);\\n      require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));\\n      pools[_token].vcashCredit = uint112(_vcashCredit);\\n      pools[_token].vcashDebt = uint112(_vcashDebt);\\n    }\\n\\n    if(_poolStatus == PoolStatus.LISTED){\\n\\n      require (_vcashDebt<=tokenInsurance[_token], \\\"MonoX:INSUFF_vCash\\\");\\n    }\\n  }\\n  \\n  // updates pool token balance and price.\\n  function _updateTokenInfo (address _token, uint256 _price,\\n      uint256 _vcashIn, uint256 _vcashOut, uint256 _ETHDebt) internal {\\n    uint256 _balance = IERC20(_token).balanceOf(address(monoXPool));\\n    _balance = _balance.sub(_ETHDebt);\\n    require(pools[_token].status!=PoolStatus.PAUSED,\\\"MonoX:PAUSED\\\");\\n    require(_balance <= uint112(-1));\\n    (uint initialPoolValue, , ,) = getPool(_token);\\n    pools[_token].tokenBalance = uint112(_balance);\\n    pools[_token].price = _price;\\n\\n    // record last trade's block number in mapping: lastTradedBlock\\n    lastTradedBlock[_token] = block.number;\\n\\n    _updateVcashBalance(_token, _vcashIn, _vcashOut);\\n\\n    (uint poolValue, , ,) = getPool(_token);\\n\\n    require(initialPoolValue <= poolValue || poolValue >= poolSizeMinLimit,\\n      \\\"MonoX:MIN_POOL_SIZE\\\");\\n    \\n    \\n  }\\n\\n  function directSwapAllowed(uint tokenInPoolPrice,uint tokenOutPoolPrice, \\n                              uint tokenInPoolTokenBalance, uint tokenOutPoolTokenBalance, PoolStatus status, bool getsAmountOut) internal pure returns(bool){\\n      uint tokenInValue  = tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18);\\n      uint tokenOutValue = tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18);\\n      bool priceExists   = getsAmountOut?tokenInPoolPrice>0:tokenOutPoolPrice>0;\\n      \\n      // only if it's official pool with similar size\\n      return priceExists&&status==PoolStatus.OFFICIAL&&tokenInValue>0&&tokenOutValue>0&&\\n        ((tokenInValue/tokenOutValue)+(tokenOutValue/tokenInValue)==1);\\n        \\n  }\\n\\n  // view func to compute amount required for tokenIn to get fixed amount of tokenOut\\n  function getAmountIn(address tokenIn, address tokenOut, \\n    uint256 amountOut) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice, \\n    uint256 amountIn, uint256 tradeVcashValue) {\\n    require(amountOut > 0, 'MonoX:INSUFF_INPUT');\\n    \\n    uint256 amountOutWithFee = amountOut.mul(1e5).div(1e5 - fees);\\n    address vcashAddress = address(vCash);\\n    uint tokenOutPoolPrice = pools[tokenOut].price;\\n    uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;\\n    if(tokenOut==vcashAddress){\\n      tradeVcashValue = amountOutWithFee;\\n      tokenOutPrice = 1e18;\\n    }else{\\n      require (tokenPoolStatus[tokenOut]==1, \\\"MonoX:NO_POOL\\\");\\n      // PoolInfo memory tokenOutPool = pools[tokenOut];\\n      PoolStatus tokenOutPoolStatus = pools[tokenOut].status;\\n      \\n      require (tokenOutPoolStatus != PoolStatus.UNLISTED, \\\"MonoX:POOL_UNLST\\\");\\n      tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance, \\n        amountOutWithFee, 0, TxType.BUY);\\n\\n      tradeVcashValue = _getAvgPrice(tokenOutPoolPrice, tokenOutPrice).mul(amountOutWithFee)/1e18;\\n    }\\n\\n    if(tokenIn==vcashAddress){\\n      amountIn = tradeVcashValue;\\n      tokenInPrice = 1e18;\\n    }else{\\n      require (tokenPoolStatus[tokenIn]==1, \\\"MonoX:NO_POOL\\\");\\n      // PoolInfo memory tokenInPool = pools[tokenIn];\\n      PoolStatus tokenInPoolStatus = pools[tokenIn].status;\\n      uint tokenInPoolPrice = pools[tokenIn].price;\\n      uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;\\n      require (tokenInPoolStatus != PoolStatus.UNLISTED, \\\"MonoX:POOL_UNLST\\\");\\n\\n      amountIn = tradeVcashValue.add(tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18));\\n      amountIn = tradeVcashValue.mul(tokenInPoolTokenBalance).div(amountIn);\\n\\n\\n      bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenInPoolStatus,false);\\n\\n      // assuming p1*p2 = k, equivalent to uniswap's x * y = k\\n      uint directSwapTokenInPrice = allowDirectSwap?tokenOutPoolPrice.mul(tokenInPoolPrice).div(tokenOutPrice):1;\\n\\n      tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance, \\n        amountIn, 0, TxType.SELL);\\n\\n      tokenInPrice = directSwapTokenInPrice > tokenInPrice?directSwapTokenInPrice:tokenInPrice;\\n\\n      amountIn = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenInPoolPrice, tokenInPrice));\\n    }\\n  }\\n\\n  // view func to compute amount required for tokenOut to get fixed amount of tokenIn\\n  function getAmountOut(address tokenIn, address tokenOut, \\n    uint256 amountIn) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice, \\n    uint256 amountOut, uint256 tradeVcashValue) {\\n    require(amountIn > 0, 'MonoX:INSUFF_INPUT');\\n    \\n    uint256 amountInWithFee = amountIn.mul(1e5-fees)/1e5;\\n    address vcashAddress = address(vCash);\\n    uint tokenInPoolPrice = pools[tokenIn].price;\\n    uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;\\n\\n    if(tokenIn==vcashAddress){\\n      tradeVcashValue = amountInWithFee;\\n      tokenInPrice = 1e18;\\n    }else{\\n      require (tokenPoolStatus[tokenIn]==1, \\\"MonoX:NO_POOL\\\");\\n      // PoolInfo memory tokenInPool = pools[tokenIn];\\n      PoolStatus tokenInPoolStatus = pools[tokenIn].status;\\n      \\n      require (tokenInPoolStatus != PoolStatus.UNLISTED, \\\"MonoX:POOL_UNLST\\\");\\n      \\n      tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance, \\n        amountInWithFee, 0, TxType.SELL);\\n      tradeVcashValue = _getAvgPrice(tokenInPoolPrice, tokenInPrice).mul(amountInWithFee)/1e18;\\n    }\\n\\n    if(tokenOut==vcashAddress){\\n      amountOut = tradeVcashValue;\\n      tokenOutPrice = 1e18;\\n    }else{\\n      require (tokenPoolStatus[tokenOut]==1, \\\"MonoX:NO_POOL\\\");\\n      // PoolInfo memory tokenOutPool = pools[tokenOut];\\n      PoolStatus tokenOutPoolStatus = pools[tokenOut].status;\\n      uint tokenOutPoolPrice = pools[tokenOut].price;\\n      uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;\\n\\n      require (tokenOutPoolStatus != PoolStatus.UNLISTED, \\\"MonoX:POOL_UNLST\\\");\\n      \\n      amountOut = tradeVcashValue.add(tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18));\\n      amountOut = tradeVcashValue.mul(tokenOutPoolTokenBalance).div(amountOut);\\n\\n      bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenOutPoolStatus,true);\\n\\n      // assuming p1*p2 = k, equivalent to uniswap's x * y = k\\n      uint directSwapTokenOutPrice = allowDirectSwap?tokenInPoolPrice.mul(tokenOutPoolPrice).div(tokenInPrice):uint(-1);\\n\\n      // prevent the attack where user can use a small pool to update price in a much larger pool\\n      tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance, \\n        amountOut, 0, TxType.BUY);\\n      tokenOutPrice = directSwapTokenOutPrice < tokenOutPrice?directSwapTokenOutPrice:tokenOutPrice;\\n\\n      amountOut = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenOutPoolPrice, tokenOutPrice));\\n    }\\n  }\\n\\n\\n  // swap from tokenIn to tokenOut with fixed tokenIn amount.\\n  function swapIn (address tokenIn, address tokenOut, address from, address to,\\n      uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {\\n\\n    address monoXPoolLocal = address(monoXPool);\\n\\n    amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn); \\n    \\n    // uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;\\n\\n    uint256 tokenInPrice;\\n    uint256 tokenOutPrice;\\n    uint256 tradeVcashValue;\\n    \\n    (tokenInPrice, tokenOutPrice, amountOut, tradeVcashValue) = getAmountOut(tokenIn, tokenOut, amountIn);\\n\\n    uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;\\n\\n    // trading in\\n    if(tokenIn==address(vCash)){\\n      vCash.burn(monoXPoolLocal, amountIn);\\n      // all fees go to the other side\\n      oneSideFeesInVcash = oneSideFeesInVcash.mul(2);\\n    }else{\\n      _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);\\n    }\\n\\n    // trading out\\n    if(tokenOut==address(vCash)){\\n      vCash.mint(to, amountOut);\\n    }else{\\n      if (to != monoXPoolLocal) {\\n        IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);\\n      }\\n      _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, \\n        to == monoXPoolLocal ? amountOut : 0);\\n    }\\n\\n    if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){\\n      _internalRebalance(tokenIn);\\n    }\\n\\n    emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);\\n    \\n  }\\n\\n  \\n  // swap from tokenIn to tokenOut with fixed tokenOut amount.\\n  function swapOut (address tokenIn, address tokenOut, address from, address to, \\n      uint256 amountOut) internal lockToken(tokenIn) returns(uint256 amountIn)  {\\n    uint256 tokenInPrice;\\n    uint256 tokenOutPrice;\\n    uint256 tradeVcashValue;\\n    (tokenInPrice, tokenOutPrice, amountIn, tradeVcashValue) = getAmountIn(tokenIn, tokenOut, amountOut);\\n    \\n    address monoXPoolLocal = address(monoXPool);\\n\\n    amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);\\n\\n    // uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;\\n\\n    uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;\\n\\n    // trading in\\n    if(tokenIn==address(vCash)){\\n      vCash.burn(monoXPoolLocal, amountIn);\\n      // all fees go to buy side\\n      oneSideFeesInVcash = oneSideFeesInVcash.mul(2);\\n    }else {\\n      _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);\\n    }\\n\\n    // trading out\\n    if(tokenOut==address(vCash)){\\n      vCash.mint(to, amountOut);\\n      // all fees go to sell side\\n      _updateVcashBalance(tokenIn, oneSideFeesInVcash, 0);\\n    }else{\\n      if (to != monoXPoolLocal) {\\n        IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);\\n      }\\n      _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, \\n        to == monoXPoolLocal ? amountOut:0 );\\n    }\\n\\n     \\n    if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){\\n      _internalRebalance(tokenIn);\\n    }\\n  \\n\\n    emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);\\n\\n  }\\n  // function balanceOf(address account, uint256 id) public view returns (uint256) {\\n  //   return monoXPool.balanceOf(account, id);\\n  // }\\n\\n  function getConfig() public view returns (address _vCash, address _weth, address _feeTo, uint16 _fees, uint16 _devFee) {\\n    _vCash = address(vCash);\\n    _weth = WETH;\\n    _feeTo = feeTo;\\n    _fees = fees;\\n    _devFee = devFee;\\n  }\\n\\n  function transferAndCheck(address from,address to,address _token,uint amount) internal returns (uint256){\\n    if(from == address(this)){\\n      return amount; // if it's ETH\\n    }\\n\\n    // if it's not ETH\\n    if(tokenStatus[_token]==2){\\n      IERC20(_token).safeTransferFrom(from, to, amount);\\n      return amount;\\n    }else{\\n      uint256 balanceIn0 = IERC20(_token).balanceOf(to);\\n      IERC20(_token).safeTransferFrom(from, to, amount);\\n      uint256 balanceIn1 = IERC20(_token).balanceOf(to);\\n      return balanceIn1.sub(balanceIn0);\\n    }   \\n\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri_) public {\\n        _setURI(uri_);\\n\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) external view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        _balances[id][account] = _balances[id][account].sub(\\n            amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\\n                amounts[i],\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal\\n        virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMonoXPool.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ninterface IMonoXPool is IERC1155 {\\n    function mint (address account, uint256 id, uint256 amount) external;\\n\\n    function burn (address account, uint256 id, uint256 amount) external;\\n\\n    function totalSupplyOf(uint256 pid) external view returns (uint256);\\n\\n    function depositWETH(uint256 amount) external;\\n\\n    function withdrawWETH(uint256 amount) external;\\n\\n    function safeTransferETH(address to, uint amount) external;\\n\\n    function safeTransferERC20Token(address token, address to, uint256 amount) external;\\n\\n    function WETH() external view returns (address);\\n\\n    function liquidityLastAddedOf(uint256 pid, address account) external view returns(uint256);\\n\\n    function topLPHolderOf(uint256 pid) external view returns (address);\\n\\n    function mintLp(address account, uint256 id, uint256 amount, bool _isOfficial) external;\\n\\n    function setWhitelist(address _whitelister, bool _isWhitelister) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MonoXLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary MonoXLibrary {\\r\\n  using SafeMath for uint;\\r\\n\\r\\n  // from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\\r\\n  function safeTransferETH(address to, uint256 value) internal {\\r\\n      (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n      require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\r\\n  }\\r\\n\\r\\n  // util func to manipulate vcash balance\\r\\n  function vcashBalanceAdd (uint256 _credit, uint256 _debt, \\r\\n    uint256 delta) internal pure returns (uint256 _newCredit, uint256 _newDebt) {\\r\\n    if(_debt>0){\\r\\n      if(delta>_debt){\\r\\n        _newDebt = 0;\\r\\n        _newCredit = _credit.add(delta - _debt);\\r\\n      }else{\\r\\n        _newCredit = 0;\\r\\n        _newDebt = _debt - delta;\\r\\n      }\\r\\n    }else{\\r\\n      _newCredit = _credit.add(delta);\\r\\n      _newDebt = 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // util func to manipulate vcash balance\\r\\n  function vcashBalanceSub (uint256 _credit, uint256 _debt, \\r\\n    uint256 delta) internal pure returns (uint256 _newCredit, uint256 _newDebt) {\\r\\n    if(_credit>0){\\r\\n      if(delta>_credit){\\r\\n        _newCredit = 0;\\r\\n        _newDebt = delta - _credit;\\r\\n      }else{\\r\\n        _newCredit = _credit - delta;\\r\\n        _newDebt = 0;\\r\\n      }\\r\\n    }else{\\r\\n      _newCredit = 0;\\r\\n      _newDebt = _debt.add(delta);\\r\\n    }\\r\\n  } \\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x55dbb68f69337fcabe261f296b50b4723d333830", "attacktype": "On-chain oracle manipulation, Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/xSNXAdmin.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"synthetix/contracts/interfaces/IFeePool.sol\\\";\\n\\nimport \\\"./TradeAccounting.sol\\\";\\n\\nimport \\\"./interface/IRebalancingSetIssuanceModule.sol\\\";\\nimport \\\"./interface/IxSNX.sol\\\";\\n\\nimport \\\"./DebtRepayment.sol\\\";\\n\\ncontract xSNXAdmin is Ownable, DebtRepayment {\\n    using SafeMath for uint256;\\n\\n    address\\n        private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private susdAddress;\\n    address private setAddress;\\n    address private snxAddress;\\n    address private setTransferProxy;\\n\\n    address private xsnxTokenAddress;\\n\\n    address private manager;\\n\\n    bytes32 constant susd = \\\"sUSD\\\";\\n\\n    bytes32 constant feePoolName = \\\"FeePool\\\";\\n    bytes32 constant synthetixName = \\\"Synthetix\\\";\\n    bytes32 constant rewardEscrowName = \\\"RewardEscrow\\\";\\n\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private constant LIQUIDATION_WAIT_PERIOD = 3 weeks;\\n\\n    ISynthetix private synthetix;\\n    TradeAccounting private tradeAccounting;\\n    IAddressResolver private addressResolver;\\n    IRebalancingSetIssuanceModule private rebalancingModule;\\n\\n    uint256 public lastClaimedTimestamp;\\n\\n    event RebalanceToSnx(uint256 timestamp, uint256 setSold);\\n    event RebalanceToHedge(uint256 timestamp, uint256 snxSold);\\n\\n    bytes32 constant rewardEscrowV2Name = \\\"RewardEscrowV2\\\";\\n\\n    bool newTokenAddressSet;\\n\\n    function initialize(\\n        address payable _tradeAccountingAddress,\\n        address _setAddress,\\n        address _snxAddress,\\n        address _susdAddress,\\n        address _setTransferProxy,\\n        address _addressResolver,\\n        address _rebalancingModule,\\n        address _ownerAddress\\n    ) public initializer {\\n        Ownable.initialize(_ownerAddress);\\n\\n        //Set parameters\\n        tradeAccounting = TradeAccounting(_tradeAccountingAddress);\\n        setAddress = _setAddress;\\n        snxAddress = _snxAddress;\\n        susdAddress = _susdAddress;\\n        setTransferProxy = _setTransferProxy;\\n        addressResolver = IAddressResolver(_addressResolver);\\n        rebalancingModule = IRebalancingSetIssuanceModule(_rebalancingModule);\\n\\n        lastClaimedTimestamp = block.timestamp;\\n    }\\n\\n    /*\\n     * @dev Function to transfer ETH to token contract on burn\\n     * @param valueToSend: token burn redemption value\\n     */\\n    function sendEthOnRedemption(uint256 valueToSend) public onlyTokenContract {\\n        (bool success, ) = xsnxTokenAddress.call.value(valueToSend)(\\\"\\\");\\n        require(success, \\\"Redeem transfer failed\\\");\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                   Fund Management                                         */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @notice Hedge strategy management function callable by admin\\n     * @dev Issues synths on Synthetix\\n     * @dev Exchanges sUSD for Set and ETH in terms defined by tradeAccounting.ETH_TARGET\\n     * @param mintAmount: sUSD to mint\\n     * @param minKyberRates: kyber.getExpectedRate([usdc=>eth, usdc=>currentSetAsset])\\n     * @param minCurveReturns: curve.get_dy_underlying([(ethAllocation, susd=>usdc), ((mintAmount.sub(ethAllocation)), susd>usdc)])\\n     * @param ethAllocation: tradeAccounting.getEthAllocationOnHedge(mintAmount)\\n     */\\n    function hedge(\\n        uint256 mintAmount,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        uint256 ethAllocation\\n    ) external onlyOwnerOrManager {\\n        _stake(mintAmount);\\n\\n        _allocateToEth(ethAllocation, minKyberRates[0], minCurveReturns[0]);\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _issueMaxSet(\\n            mintAmount.sub(ethAllocation),\\n            minKyberRates[1],\\n            activeAsset,\\n            minCurveReturns[1]\\n        );\\n    }\\n\\n    function _allocateToEth(\\n        uint256 _susdValue,\\n        uint256 _minKyberRate,\\n        uint256 _minCurveReturn\\n    ) private {\\n        _swapTokenToEther(\\n            susdAddress,\\n            _susdValue,\\n            _minKyberRate,\\n            _minCurveReturn\\n        );\\n    }\\n\\n    function _stake(uint256 mintAmount) private {\\n        ISynthetix(addressResolver.getAddress(synthetixName)).issueSynths(\\n            mintAmount\\n        );\\n    }\\n\\n    /*\\n     * @notice Claims weekly sUSD and SNX rewards\\n     * @notice Fixes c-ratio if necessary\\n     * @param susdToBurnToFixCollat: tradeAccounting.calculateSusdToBurnToFixRatioExternal()\\n     * @param minKyberRates: kyber.getExpectedRate[setAsset => usdc, usdc => eth]\\n     * @param minCurveReturns: curve.get_dy_underlying([(setAssetBalance, usdc=>susd), (susdBalance susd=>usdc)])\\n     * @param feesClaimable: feePool.isFeesClaimable(address(this)) - on Synthetix contract\\n     */\\n    function claim(\\n        uint256 susdToBurnToFixCollat,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        bool feesClaimable\\n    ) external onlyOwnerOrManager {\\n        lastClaimedTimestamp = block.timestamp;\\n\\n        if (!feesClaimable) {\\n            _redeemSet(susdToBurnToFixCollat);\\n            _swapTokenToToken(\\n                getAssetCurrentlyActiveInSet(),\\n                getActiveSetAssetBalance(),\\n                susdAddress,\\n                minKyberRates[0],\\n                minCurveReturns[0]\\n            );\\n            _burnSynths(getSusdBalance());\\n        }\\n\\n        IFeePool(addressResolver.getAddress(feePoolName)).claimFees();\\n\\n        // fee collection\\n        uint256 feeDivisor = IxSNX(xsnxTokenAddress).getClaimFeeDivisor();\\n        IERC20(susdAddress).transfer(\\n            xsnxTokenAddress,\\n            getSusdBalance().div(feeDivisor)\\n        );\\n\\n        _swapTokenToEther(\\n            susdAddress,\\n            getSusdBalance(),\\n            minKyberRates[1],\\n            minCurveReturns[1]\\n        );\\n    }\\n\\n    function _burnSynths(uint256 _amount) private {\\n        ISynthetix(addressResolver.getAddress(synthetixName)).burnSynths(\\n            _amount\\n        );\\n    }\\n\\n    function _swapTokenToEther(\\n        address _fromToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate,\\n        uint256 _minCurveReturn\\n    ) private {\\n        if (_amount > 0) {\\n            IERC20(_fromToken).transfer(address(tradeAccounting), _amount);\\n            tradeAccounting.swapTokenToEther(\\n                _fromToken,\\n                _amount,\\n                _minKyberRate,\\n                _minCurveReturn\\n            );\\n        }\\n    }\\n\\n    function _swapTokenToToken(\\n        address _fromToken,\\n        uint256 _amount,\\n        address _toToken,\\n        uint256 _minKyberRate,\\n        uint256 _minCurveReturn\\n    ) private {\\n        IERC20(_fromToken).transfer(address(tradeAccounting), _amount);\\n        tradeAccounting.swapTokenToToken(\\n            _fromToken,\\n            _amount,\\n            _toToken,\\n            _minKyberRate,\\n            _minCurveReturn\\n        );\\n    }\\n\\n    function _swapEtherToToken(\\n        address _toToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate\\n    ) private {\\n        if (_amount > 0) {\\n            (bool success, ) = address(tradeAccounting).call.value(_amount)(\\\"\\\");\\n            require(success, \\\"Not enough eth in contract\\\");\\n            tradeAccounting.swapEtherToToken(_toToken, _amount, _minKyberRate);\\n        }\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                      Rebalances                                           */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @notice Called when hedge assets value meaningfully exceeds debt liabilities\\n     * @dev Hedge assets (Set + ETH) > liabilities (debt) by more than rebalance threshold\\n     * @param: minRate: kyber.getExpectedRate(activeAsset=>snx)\\n     */\\n    function rebalanceTowardsSnx(uint256 minRate) external onlyOwnerOrManager {\\n        require(\\n            tradeAccounting.isRebalanceTowardsSnxRequired(),\\n            \\\"Rebalance unnecessary\\\"\\n        );\\n        (uint256 setToSell, address activeAsset) = tradeAccounting\\n            .getRebalanceTowardsSnxUtils();\\n\\n        _redeemRebalancingSet(setToSell);\\n\\n        _swapTokenToToken(\\n            activeAsset,\\n            getActiveSetAssetBalance(),\\n            snxAddress,\\n            minRate,\\n            0\\n        );\\n\\n        emit RebalanceToSnx(block.timestamp, setToSell);\\n    }\\n\\n    /*\\n     * @notice Called when debt value meaningfully exceeds value of hedge assets\\n     * @notice Allocates fully to ETH reserve\\n     * @dev `Liabilities (debt) > assets (Set + ETH)` by more than rebalance threshold\\n     * @param: totalSusdToBurn: tradeAccounting.getRebalanceTowardsHedgeUtils()\\n     * @param: minKyberRates: kyber.getExpectedRate([activeSetAsset => usdc, snx => eth])\\n     * @param: minCurveReturns: curve.get_dy_underlying([(expectedUsdcBalance, usdc=>susd), (0)])\\n     * @param: snxToSell: tradeAccounting.getRebalanceTowardsHedgeUtils()\\n     */\\n    function rebalanceTowardsHedge(\\n        uint256 totalSusdToBurn,\\n        uint256[] memory minKyberRates,\\n        uint256[] memory minCurveReturns,\\n        uint256 snxToSell\\n    ) public onlyOwnerOrManager {\\n        require(\\n            tradeAccounting.isRebalanceTowardsHedgeRequired(),\\n            \\\"Rebalance unnecessary\\\"\\n        );\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _unwindStakedPosition(\\n            totalSusdToBurn,\\n            activeAsset,\\n            minKyberRates,\\n            minCurveReturns,\\n            snxToSell\\n        );\\n        emit RebalanceToHedge(block.timestamp, snxToSell);\\n    }\\n\\n    /*\\n     * @notice Callable whenever ETH bal is less than (hedgeAssets / ETH_TARGET)\\n     * @dev Rebalances Set holdings to ETH holdings\\n     * @param minRate: kyber.getExpectedRate(activeAsset => ETH)\\n     */\\n    function rebalanceSetToEth(uint256 minRate) external onlyOwnerOrManager {\\n        uint256 redemptionQuantity = tradeAccounting\\n            .calculateSetToSellForRebalanceSetToEth();\\n        _redeemRebalancingSet(redemptionQuantity);\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        uint256 activeAssetBalance = getActiveSetAssetBalance();\\n        _swapTokenToEther(activeAsset, activeAssetBalance, minRate, 0);\\n    }\\n\\n    function _unwindStakedPosition(\\n        uint256 _totalSusdToBurn,\\n        address _activeAsset,\\n        uint256[] memory _minKyberRates,\\n        uint256[] memory _minCurveReturns,\\n        uint256 _snxToSell\\n    ) private {\\n        if (_totalSusdToBurn > 0) {\\n            _redeemSet(_totalSusdToBurn);\\n            _swapTokenToToken(\\n                _activeAsset,\\n                getActiveSetAssetBalance(),\\n                susdAddress,\\n                _minKyberRates[0],\\n                _minCurveReturns[0]\\n            );\\n            _burnSynths(getSusdBalance());\\n        }\\n\\n        _swapTokenToEther(snxAddress, _snxToSell, _minKyberRates[1], 0);\\n    }\\n\\n    /*\\n     * @notice Exit valve to reduce staked position in favor of liquid ETH\\n     * @notice Unlikely to be called in the normal course of mgmt\\n     * @params: refer to `rebalanceToHedge` for descriptions, however params here are discretionary\\n     */\\n    function unwindStakedPosition(\\n        uint256 totalSusdToBurn,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        uint256 snxToSell\\n    ) external onlyOwnerOrManager {\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _unwindStakedPosition(\\n            totalSusdToBurn,\\n            activeAsset,\\n            minKyberRates,\\n            minCurveReturns,\\n            snxToSell\\n        );\\n    }\\n\\n    /*\\n     * @notice Emergency exit valve to reduce staked position in favor of liquid ETH\\n     * in the event of operator failure/incapacitation\\n     * @dev: Params will depend on current C-RATIO, i.e., may not immediately be able\\n     * to liquidate all debt and SNX\\n     * @dev: May be callable multiple times as SNX escrow vests\\n     */\\n    function liquidationUnwind(\\n        uint256 totalSusdToBurn,\\n        uint256[] calldata minKyberRates,\\n        uint256[] calldata minCurveReturns,\\n        uint256 snxToSell\\n    ) external {\\n        require(\\n            lastClaimedTimestamp.add(LIQUIDATION_WAIT_PERIOD) < block.timestamp,\\n            \\\"Liquidation not available\\\"\\n        );\\n\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        _unwindStakedPosition(\\n            totalSusdToBurn,\\n            activeAsset,\\n            minKyberRates,\\n            minCurveReturns,\\n            snxToSell\\n        );\\n\\n        uint256 susdBalRemaining = getSusdBalance();\\n        _swapTokenToEther(susdAddress, susdBalRemaining, 0, 0);\\n    }\\n\\n    /*\\n     * @dev Unlock escrowed SNX rewards\\n     * @param entryIDs: vesting entries\\n     */\\n    function vest(uint256[] memory entryIDs) public {\\n        IRewardEscrowV2 rewardEscrow = IRewardEscrowV2(\\n            addressResolver.getAddress(rewardEscrowV2Name)\\n        );\\n        rewardEscrow.vest(entryIDs);\\n    }\\n\\n    function setNewXsnxTokenAddress(address _newXsnxTokenAddress) external onlyOwnerOrManager {\\n        require(!newTokenAddressSet, \\\"New address already set\\\");\\n        newTokenAddressSet = true;\\n        xsnxTokenAddress = _newXsnxTokenAddress;\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                     Set Protocol                                          */\\n    /* ========================================================================================= */\\n\\n    function _issueMaxSet(\\n        uint256 _susdAmount,\\n        uint256 _minRate,\\n        address _activeAsset,\\n        uint256 _minCurveReturn\\n    ) private {\\n        if(_susdAmount > 0) {\\n            _swapTokenToToken(\\n                susdAddress,\\n                _susdAmount,\\n                _activeAsset,\\n                _minRate,\\n                _minCurveReturn\\n            );\\n\\n            uint256 issuanceQuantity = tradeAccounting\\n                .calculateSetIssuanceQuantity();\\n            rebalancingModule.issueRebalancingSet(\\n                setAddress,\\n                issuanceQuantity,\\n                false\\n            );\\n        }\\n    }\\n\\n    function _redeemSet(uint256 _totalSusdToBurn) private {\\n        uint256 redemptionQuantity = tradeAccounting\\n            .calculateSetRedemptionQuantity(_totalSusdToBurn);\\n        _redeemRebalancingSet(redemptionQuantity);\\n    }\\n\\n    function _redeemRebalancingSet(uint256 _redemptionQuantity) private {\\n        rebalancingModule.redeemRebalancingSet(\\n            setAddress,\\n            _redemptionQuantity,\\n            false\\n        );\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                        Utils                                              */\\n    /* ========================================================================================= */\\n\\n    function getAssetCurrentlyActiveInSet() internal view returns (address) {\\n        return tradeAccounting.getAssetCurrentlyActiveInSet();\\n    }\\n\\n    function getActiveSetAssetBalance() internal view returns (uint256) {\\n        return tradeAccounting.getActiveSetAssetBalance();\\n    }\\n\\n    function getSusdBalance() internal view returns (uint256) {\\n        return tradeAccounting.getSusdBalance();\\n    }\\n\\n    function setManagerAddress(address _manager) public onlyOwner {\\n        manager = _manager;\\n    }\\n\\n    modifier onlyOwnerOrManager {\\n        require(isOwner() || msg.sender == manager, \\\"Non-admin caller\\\");\\n        _;\\n    }\\n\\n    modifier onlyTokenContract {\\n        require(msg.sender == xsnxTokenAddress, \\\"Non token caller\\\");\\n        _;\\n    }\\n\\n    // approve [setComponentA, setComponentB] on deployment\\n    function approveSetTransferProxy(address tokenAddress) public onlyOwner {\\n        IERC20(tokenAddress).approve(setTransferProxy, MAX_UINT);\\n    }\\n\\n     /**\\n     * Swap snx for eth in contract\\n     */\\n    function swapSnxForEth(\\n        uint256 snxAmount,\\n        uint256 minKyberRate,\\n        uint256 minCurveReturn\\n    ) public onlyOwnerOrManager {\\n        _swapTokenToEther(snxAddress, snxAmount, minKyberRate, minCurveReturn);\\n    }\\n\\n    /**\\n     * Swap eth for snx in contract\\n     */\\n    function swapEthForSnx(\\n        uint256 ethAmount,\\n        uint256 minKyberRate\\n    ) public onlyOwnerOrManager {\\n        _swapEtherToToken(snxAddress, ethAmount, minKyberRate);\\n    }\\n\\n    /**\\n     * Repay sUSD debt with ETH in the contract\\n     */\\n    function repayDebtWithEth(uint256 amount, uint256 minKyberRate) public onlyOwnerOrManager {\\n        _swapEtherToToken(susdAddress, amount, minKyberRate);\\n        uint256 susdBalance = IERC20(susdAddress).balanceOf(address(this));\\n        _burnSynths(susdBalance);\\n    }\\n\\n    // Debt repayment logic\\n    // Used when c-ratio is below a certain threshold\\n    // And debt cannot be repaid due to locked SNX\\n\\n    function repayDebt(uint256 loanAmount, uint256 snxAmount) public onlyOwnerOrManager {\\n        super.repayDebt(loanAmount, snxAmount);\\n    }\\n\\n    function approveUsdc() external onlyOwnerOrManager {\\n        address soloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\\n        IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\n        USDC.approve(soloMargin, uint(-1));\\n    }\\n\\n    /**\\n    * Called as a callback to repayDebt()\\n    * Flash loan function which burns sUSD debt\\n    */\\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) public {\\n        (\\n            address payable actualSender,\\n            uint256 loanAmount,\\n            uint256 snxAmount\\n        ) = abi.decode(data, (\\n            address, uint256, uint256\\n        ));\\n        require(sender == address(this), \\\"Must be called using repayDebt\\\");\\n\\n        address usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n        // swap \\\"loanAmount\\\" USDC for sUSD\\n        _swapTokenToToken(usdcAddress, loanAmount, susdAddress, 0, 0);\\n\\n        uint256 susdBalance = IERC20(susdAddress).balanceOf(address(this));\\n        _burnSynths(susdBalance);\\n\\n        // swap SNX to sUSD and sUSD back to USDC to repay loan\\n        _swapTokenToToken(snxAddress, snxAmount, susdAddress, 0, 0);\\n        susdBalance = IERC20(susdAddress).balanceOf(address(this));\\n        // swap sUSD to USDC\\n        _swapTokenToToken(susdAddress, susdBalance, usdcAddress, 0, 0);\\n\\n        uint256 usdcBalance = IERC20(usdcAddress).balanceOf(address(this));\\n        \\n        require(usdcBalance > loanAmount + 2, \\\"cannot repay loan\\\");\\n    }\\n\\n    function() external payable {}\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Initializable, Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function initialize(address sender) public initializer {\\n        _owner = sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IFeePool.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\\ninterface IFeePool {\\n    // Views\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function FEE_ADDRESS() external view returns (address);\\n\\n    function feesAvailable(address account) external view returns (uint, uint);\\n\\n    function feePeriodDuration() external view returns (uint);\\n\\n    function isFeesClaimable(address account) external view returns (bool);\\n\\n    function targetThreshold() external view returns (uint);\\n\\n    function totalFeesAvailable() external view returns (uint);\\n\\n    function totalRewardsAvailable() external view returns (uint);\\n\\n    // Mutative Functions\\n    function claimFees() external returns (bool);\\n\\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\\n\\n    function closeCurrentFeePeriod() external;\\n\\n    // Restricted: used internally to Synthetix\\n    function appendAccountIssuanceRecord(\\n        address account,\\n        uint lockedAmount,\\n        uint debtEntryIndex\\n    ) external;\\n\\n    function recordFeePaid(uint sUSDAmount) external;\\n\\n    function setRewardsToDistribute(uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/TradeAccounting.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"synthetix/contracts/interfaces/ISynthetix.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IRewardEscrowV2.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IExchangeRates.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/ISynthetixState.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IAddressResolver.sol\\\";\\n\\nimport \\\"./interface/ISystemSettings.sol\\\";\\n\\nimport \\\"./interface/ICurveFi.sol\\\";\\nimport \\\"./interface/ISetToken.sol\\\";\\nimport \\\"./interface/IKyberNetworkProxy.sol\\\";\\nimport \\\"./interface/ISetAssetBaseCollateral.sol\\\";\\n\\n/* \\n\\txSNX Target Allocation (assuming 800% C-RATIO)\\n\\t----------------------\\n\\tAllocation         |  NAV   | % NAV\\n\\t--------------------------------------\\n\\t800 SNX @ $1/token | $800   | 100%\\n\\t100 sUSD Debt\\t   | ($100)\\t| (12.5%)\\n\\t75 USD equiv Set   | $75    | 9.375%\\n\\t25 USD equiv ETH   | $25    | 3.125%\\n\\t--------------------------------------\\n\\tTotal                $800   | 100%   \\n */\\n\\n/* \\n\\tConditions for `isRebalanceTowardsHedgeRequired` to return true\\n\\tAssuming 5% rebalance threshold\\n\\n\\tAllocation         |  NAV   | % NAV\\n\\t--------------------------------------\\n\\t800 SNX @ $1/token | $800   | 100.63%\\n\\t105 sUSD Debt\\t   | ($105)\\t| (13.21%)\\n\\t75 USD equiv Set   | $75    | 9.43%\\n\\t25 USD equiv ETH   | $25    | 3.14%\\n\\t--------------------------------------\\n\\tTotal                $795   | 100%   \\n\\n\\tDebt value\\t\\t   | $105\\n\\tHedge Assets\\t   | $100\\n\\t-------------------------\\n\\tDebt/hedge ratio   | 105%\\n  */\\n\\n/* \\n\\tConditions for `isRebalanceTowardsSnxRequired` to return true\\n\\tAssuming 5% rebalance threshold\\n\\n\\tAllocation         |  NAV   | % NAV\\n\\t--------------------------------------\\n\\t800 SNX @ $1/token | $800   | 99.37%\\n\\t100 sUSD Debt\\t   | ($100)\\t| (12.42%)\\n\\t75 USD equiv Set   | $75    | 9.31%\\n\\t30 USD equiv ETH   | $30    | 3.72%\\n\\t--------------------------------------\\n\\tTotal                $805   | 100%   \\n\\n\\tHedge Assets\\t   | $105\\n\\tDebt value\\t\\t   | $100\\n\\t-------------------------\\n\\tHedge/debt ratio   | 105%\\n  */\\n\\ncontract TradeAccounting is Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant TEN = 10;\\n    uint256 private constant DEC_18 = 1e18;\\n    uint256 private constant PERCENT = 100;\\n    uint256 private constant ETH_TARGET = 4; // targets 1/4th of hedge portfolio\\n    uint256 private constant SLIPPAGE_RATE = 99;\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private constant RATE_STALE_TIME = 28800; // 8 hours\\n    uint256 private constant REBALANCE_THRESHOLD = 105; // 5%\\n    uint256 private constant INITIAL_SUPPLY_MULTIPLIER = 10;\\n\\n    int128 usdcIndex;\\n    int128 susdIndex;\\n\\n    ICurveFi private curveFi;\\n    ISynthetixState private synthetixState;\\n    IAddressResolver private addressResolver;\\n    IKyberNetworkProxy private kyberNetworkProxy;\\n\\n    address private xSNXAdminInstance;\\n    address private addressValidator;\\n\\n    address private setAddress;\\n    address private susdAddress;\\n    address private usdcAddress;\\n\\n    address private nextCurveAddress;\\n\\n    bytes32 constant snx = \\\"SNX\\\";\\n    bytes32 constant susd = \\\"sUSD\\\";\\n    bytes32 constant seth = \\\"sETH\\\";\\n\\n    bytes32[2] synthSymbols;\\n\\n    address[2] setComponentAddresses;\\n\\n    bytes32 constant rewardEscrowName = \\\"RewardEscrow\\\";\\n    bytes32 constant exchangeRatesName = \\\"ExchangeRates\\\";\\n    bytes32 constant synthetixName = \\\"Synthetix\\\";\\n    bytes32 constant systemSettingsName = \\\"SystemSettings\\\";\\n    bytes32 constant rewardEscrowV2Name = \\\"RewardEscrowV2\\\";\\n\\n    uint256 private constant RATE_STALE_TIME_NEW = 86400; // 24 hours\\n\\n    function initialize(\\n        address _setAddress,\\n        address _kyberProxyAddress,\\n        address _addressResolver,\\n        address _susdAddress,\\n        address _usdcAddress,\\n        address _addressValidator,\\n        bytes32[2] memory _synthSymbols,\\n        address[2] memory _setComponentAddresses,\\n        address _ownerAddress\\n    ) public initializer {\\n        Ownable.initialize(_ownerAddress);\\n\\n        setAddress = _setAddress;\\n        kyberNetworkProxy = IKyberNetworkProxy(_kyberProxyAddress);\\n        addressResolver = IAddressResolver(_addressResolver);\\n        susdAddress = _susdAddress;\\n        usdcAddress = _usdcAddress;\\n        addressValidator = _addressValidator;\\n        synthSymbols = _synthSymbols;\\n        setComponentAddresses = _setComponentAddresses;\\n    }\\n\\n    modifier onlyXSNXAdmin {\\n        require(\\n            msg.sender == xSNXAdminInstance,\\n            \\\"Only xSNXAdmin contract can call\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                         Kyber/Curve                                       */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Function that processes all token to token exchanges,\\n     * sometimes via Kyber and sometimes via a combination of Kyber & Curve\\n     * @dev Only callable by xSNXAdmin contract\\n     */\\n    function swapTokenToToken(\\n        address fromToken,\\n        uint256 amount,\\n        address toToken,\\n        uint256 minKyberRate,\\n        uint256 minCurveReturn\\n    ) public onlyXSNXAdmin {\\n        if (fromToken == susdAddress) {\\n            _exchangeUnderlying(susdIndex, usdcIndex, amount, minCurveReturn);\\n\\n            if (toToken != usdcAddress) {\\n                uint256 usdcBal = getUsdcBalance();\\n                _swapTokenToToken(usdcAddress, usdcBal, toToken, minKyberRate);\\n            }\\n        } else if (toToken == susdAddress) {\\n            if (fromToken != usdcAddress) {\\n                _swapTokenToToken(fromToken, amount, usdcAddress, minKyberRate);\\n            }\\n\\n            uint256 usdcBal = getUsdcBalance();\\n            _exchangeUnderlying(usdcIndex, susdIndex, usdcBal, minCurveReturn);\\n        } else {\\n            _swapTokenToToken(fromToken, amount, toToken, minKyberRate);\\n        }\\n\\n        IERC20(toToken).transfer(\\n            xSNXAdminInstance,\\n            IERC20(toToken).balanceOf(address(this))\\n        );\\n    }\\n\\n    function _swapTokenToToken(\\n        address _fromToken,\\n        uint256 _amount,\\n        address _toToken,\\n        uint256 _minKyberRate\\n    ) private {\\n        kyberNetworkProxy.swapTokenToToken(\\n            ERC20(_fromToken),\\n            _amount,\\n            ERC20(_toToken),\\n            _minKyberRate\\n        );\\n    }\\n\\n    /*\\n     * @dev Function that processes all token to ETH exchanges,\\n     * sometimes via Kyber and sometimes via a combination of Kyber & Curve\\n     * @dev Only callable by xSNXAdmin contract\\n     */\\n    function swapTokenToEther(\\n        address fromToken,\\n        uint256 amount,\\n        uint256 minKyberRate,\\n        uint256 minCurveReturn\\n    ) public onlyXSNXAdmin {\\n        if (fromToken == susdAddress) {\\n            _exchangeUnderlying(susdIndex, usdcIndex, amount, minCurveReturn);\\n\\n            uint256 usdcBal = getUsdcBalance();\\n            _swapTokenToEther(usdcAddress, usdcBal, minKyberRate);\\n        } else {\\n            _swapTokenToEther(fromToken, amount, minKyberRate);\\n        }\\n\\n        uint256 ethBal = address(this).balance;\\n        (bool success, ) = msg.sender.call.value(ethBal)(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function _swapTokenToEther(\\n        address _fromToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate\\n    ) private {\\n        kyberNetworkProxy.swapTokenToEther(\\n            ERC20(_fromToken),\\n            _amount,\\n            _minKyberRate\\n        );\\n    }\\n\\n    /*\\n     * @dev Function that processes all ETH to token exchanges\\n     * @dev Processed using kyber\\n     * @dev Only callable by xSNXAdmin contract\\n     */\\n    function swapEtherToToken(\\n        address toToken,\\n        uint256 amount,\\n        uint256 minKyberRate\\n    ) public onlyXSNXAdmin {\\n        _swapEtherToToken(toToken, amount, minKyberRate);\\n        IERC20(toToken).transfer(\\n            xSNXAdminInstance,\\n            IERC20(toToken).balanceOf(address(this))\\n        );\\n    }\\n\\n    function _swapEtherToToken(\\n        address _toToken,\\n        uint256 _amount,\\n        uint256 _minKyberRate\\n    ) private {\\n        kyberNetworkProxy.swapEtherToToken.value(_amount)(\\n            ERC20(_toToken),\\n            _minKyberRate\\n        );\\n    }\\n\\n    function _exchangeUnderlying(\\n        int128 _inputIndex,\\n        int128 _outputIndex,\\n        uint256 _amount,\\n        uint256 _minReturn\\n    ) private {\\n        curveFi.exchange_underlying(\\n            _inputIndex,\\n            _outputIndex,\\n            _amount,\\n            _minReturn\\n        );\\n    }\\n\\n    function getUsdcBalance() internal view returns (uint256) {\\n        return IERC20(usdcAddress).balanceOf(address(this));\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                          NAV                                              */\\n    /* ========================================================================================= */\\n\\n    function getEthBalance() public view returns (uint256) {\\n        return address(xSNXAdminInstance).balance;\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.burn` that outputs NAV\\n     * redemption value in ETH terms\\n     * @param totalSupply: xSNX.totalSupply()\\n     * @param tokensToRedeem: xSNX to burn\\n     */\\n    function calculateRedemptionValue(\\n        uint256 totalSupply,\\n        uint256 tokensToRedeem\\n    ) public view returns (uint256 valueToRedeem) {\\n        uint256 snxBalanceOwned = getSnxBalanceOwned();\\n        uint256 contractDebtValue = getContractDebtValue();\\n\\n        uint256 pricePerToken = calculateRedeemTokenPrice(\\n            totalSupply,\\n            snxBalanceOwned,\\n            contractDebtValue\\n        );\\n\\n        valueToRedeem = pricePerToken.mul(tokensToRedeem).div(DEC_18);\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.mint` that\\n     * 1) determines whether ETH contribution should be maintained in ETH or exchanged for SNX and\\n     * 2) outputs the `nonSnxAssetValue` value to be used in NAV calculation\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function getMintWithEthUtils(uint256 totalSupply)\\n        public\\n        view\\n        returns (bool allocateToEth, uint256 nonSnxAssetValue)\\n    {\\n        uint256 setHoldingsInWei = getSetHoldingsValueInWei();\\n\\n        // called before eth transferred from xSNX to xSNXAdmin\\n        uint256 ethBalBefore = getEthBalance();\\n        \\n        allocateToEth = shouldAllocateEthToEthReserve(\\n            setHoldingsInWei,\\n            ethBalBefore,\\n            totalSupply\\n        );\\n        nonSnxAssetValue = setHoldingsInWei.add(ethBalBefore);\\n    }\\n\\n    /*\\n     * @notice xSNX system targets 25% of hedge portfolio to be maintained in ETH\\n     * @dev Function produces binary yes allocate/no allocate decision point\\n     * determining whether ETH sent on xSNX.mint() is held or exchanged\\n     * @param setHoldingsInWei: value of Set portfolio in ETH terms\\n     * @param ethBalBefore: value of ETH reserve prior to tx\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function shouldAllocateEthToEthReserve(\\n        uint256 setHoldingsInWei,\\n        uint256 ethBalBefore,\\n        uint256 totalSupply\\n    ) public pure returns (bool allocateToEth) {\\n        if (totalSupply == 0) return false;\\n\\n        if (ethBalBefore.mul(ETH_TARGET) < ethBalBefore.add(setHoldingsInWei)) {\\n            // ETH reserve is under target\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /*\\n     * @dev Helper function for calculateIssueTokenPrice\\n     * @dev Called indirectly by `xSNX.mint` and `xSNX.mintWithSnx`\\n     * @dev Calculates NAV of the fund, including value of escrowed SNX, in ETH terms\\n     * @param weiPerOneSnx: SNX price in ETH terms\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param nonSnxAssetValue: NAV of non-SNX slice of fund\\n     */\\n    function calculateNetAssetValueOnMint(\\n        uint256 weiPerOneSnx,\\n        uint256 snxBalanceBefore,\\n        uint256 nonSnxAssetValue\\n    ) internal view returns (uint256) {\\n        uint256 snxTokenValueInWei = snxBalanceBefore.mul(weiPerOneSnx).div(\\n            DEC_18\\n        );\\n        uint256 contractDebtValue = getContractDebtValue();\\n        uint256 contractDebtValueInWei = calculateDebtValueInWei(\\n            contractDebtValue\\n        );\\n        return\\n            snxTokenValueInWei.add(nonSnxAssetValue).sub(\\n                contractDebtValueInWei\\n            );\\n    }\\n\\n    /*\\n     * @dev Helper function for calculateRedeemTokenPrice\\n     * @dev Called indirectly by `xSNX.burn`\\n     * @dev Calculates NAV of the fund, excluding value of escrowed SNX, in ETH terms\\n     * @param weiPerOneSnx: SNX price in ETH terms\\n     * @param snxBalanceOwned: non-escrowed SNX balance\\n     * @param contractDebtValueInWei: sUSD debt balance of fund in ETH terms\\n     */\\n    function calculateNetAssetValueOnRedeem(\\n        uint256 weiPerOneSnx,\\n        uint256 snxBalanceOwned,\\n        uint256 contractDebtValueInWei\\n    ) internal view returns (uint256) {\\n        uint256 snxTokenValueInWei = snxBalanceOwned.mul(weiPerOneSnx).div(\\n            DEC_18\\n        );\\n        uint256 nonSnxAssetValue = calculateNonSnxAssetValue();\\n        return\\n            snxTokenValueInWei.add(nonSnxAssetValue).sub(\\n                contractDebtValueInWei\\n            );\\n    }\\n\\n    /*\\n     * @dev NAV value of non-SNX assets, computed in ETH terms\\n     */\\n    function calculateNonSnxAssetValue() internal view returns (uint256) {\\n        return getSetHoldingsValueInWei().add(getEthBalance());\\n    }\\n\\n    /*\\n     * @dev SNX price in ETH terms, calculated for purposes of redemption NAV\\n     * @notice Return value discounted slightly to better represent liquidation price\\n     */\\n    function getWeiPerOneSnxOnRedeem()\\n        internal\\n        view\\n        returns (uint256 weiPerOneSnx)\\n    {\\n        uint256 snxUsdPrice = getSnxPrice();\\n        uint256 ethUsdPrice = getSynthPrice(seth);\\n        weiPerOneSnx = snxUsdPrice\\n            .mul(DEC_18)\\n            .div(ethUsdPrice)\\n            .mul(SLIPPAGE_RATE) // used to better represent liquidation price as volume scales\\n            .div(PERCENT);\\n    }\\n\\n    /*\\n     * @dev Returns Synthetix synth symbol for asset currently held in TokenSet (e.g., sETH for WETH)\\n     * @notice xSNX contract complex only compatible with Sets that hold a single asset at a time\\n     */\\n    function getActiveAssetSynthSymbol()\\n        internal\\n        view\\n        returns (bytes32 synthSymbol)\\n    {\\n        synthSymbol = getAssetCurrentlyActiveInSet() == setComponentAddresses[0]\\n            ? (synthSymbols[0])\\n            : (synthSymbols[1]);\\n    }\\n\\n    /*\\n     * @dev Returns SNX price in ETH terms, calculated for purposes of issuance NAV (when allocateToEth)\\n     */\\n    function getWeiPerOneSnxOnMint() internal view returns (uint256) {\\n        uint256 snxUsd = getSynthPrice(snx);\\n        uint256 ethUsd = getSynthPrice(seth);\\n        return snxUsd.mul(DEC_18).div(ethUsd);\\n    }\\n\\n    /*\\n     * @dev Single use function to define initial xSNX issuance\\n     */\\n    function getInitialSupply() internal view returns (uint256) {\\n        return\\n            IERC20(addressResolver.getAddress(synthetixName))\\n                .balanceOf(xSNXAdminInstance)\\n                .mul(INITIAL_SUPPLY_MULTIPLIER);\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.mint` that calculates token issuance\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param ethContributed: ETH payable on mint, less fees\\n     * @param nonSnxAssetValue: NAV of non-SNX slice of fund\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function calculateTokensToMintWithEth(\\n        uint256 snxBalanceBefore,\\n        uint256 ethContributed,\\n        uint256 nonSnxAssetValue,\\n        uint256 totalSupply\\n    ) public view returns (uint256) {\\n        if (totalSupply == 0) {\\n            return getInitialSupply();\\n        }\\n\\n        uint256 pricePerToken = calculateIssueTokenPrice(\\n            getWeiPerOneSnxOnMint(),\\n            snxBalanceBefore,\\n            nonSnxAssetValue,\\n            totalSupply\\n        );\\n\\n        return ethContributed.mul(DEC_18).div(pricePerToken);\\n    }\\n\\n    /*\\n     * @dev Helper function for `xSNX.mintWithSnx` that calculates token issuance\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param snxAddedToBalance: SNX contributed by mint\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function calculateTokensToMintWithSnx(\\n        uint256 snxBalanceBefore,\\n        uint256 snxAddedToBalance,\\n        uint256 totalSupply\\n    ) public view returns (uint256) {\\n        if (totalSupply == 0) {\\n            return getInitialSupply();\\n        }\\n\\n        uint256 weiPerOneSnx = getWeiPerOneSnxOnMint();\\n        // need to derive snx contribution in eth terms for NAV calc\\n        uint256 proxyEthContribution = weiPerOneSnx.mul(snxAddedToBalance).div(\\n            DEC_18\\n        );\\n        uint256 nonSnxAssetValue = calculateNonSnxAssetValue();\\n        uint256 pricePerToken = calculateIssueTokenPrice(\\n            weiPerOneSnx,\\n            snxBalanceBefore,\\n            nonSnxAssetValue,\\n            totalSupply\\n        );\\n        return proxyEthContribution.mul(DEC_18).div(pricePerToken);\\n    }\\n\\n    /*\\n     * @dev Called indirectly by `xSNX.mint` and `xSNX.mintWithSnx`\\n     * @dev Calculates token price on issuance, including value of escrowed SNX\\n     * @param weiPerOneSnx: SNX price in ETH terms\\n     * @param snxBalanceBefore: SNX balance pre-mint\\n     * @param nonSnxAssetValue: Non-SNX slice of fund\\n     * @param totalSupply: xSNX.totalSupply()\\n     */\\n    function calculateIssueTokenPrice(\\n        uint256 weiPerOneSnx,\\n        uint256 snxBalanceBefore,\\n        uint256 nonSnxAssetValue,\\n        uint256 totalSupply\\n    ) public view returns (uint256 pricePerToken) {\\n        pricePerToken = calculateNetAssetValueOnMint(\\n            weiPerOneSnx,\\n            snxBalanceBefore,\\n            nonSnxAssetValue\\n        )\\n            .mul(DEC_18)\\n            .div(totalSupply);\\n    }\\n\\n    /*\\n     * @dev Called indirectly by `xSNX.burn`\\n     * @dev Calculates token price on redemption, excluding value of escrowed SNX\\n     * @param totalSupply: xSNX.totalSupply()\\n     * @param snxBalanceOwned: non-escrowed SNX balance\\n     * @param contractDebtValue: sUSD debt in USD terms\\n     */\\n    function calculateRedeemTokenPrice(\\n        uint256 totalSupply,\\n        uint256 snxBalanceOwned,\\n        uint256 contractDebtValue\\n    ) public view returns (uint256 pricePerToken) {\\n        // SNX won't actually be sold (burns are only distributed in available ETH) but\\n        // this is a proxy for the return value of SNX that would be sold\\n        uint256 weiPerOneSnx = getWeiPerOneSnxOnRedeem();\\n\\n        uint256 debtValueInWei = calculateDebtValueInWei(contractDebtValue);\\n        pricePerToken = calculateNetAssetValueOnRedeem(\\n            weiPerOneSnx,\\n            snxBalanceOwned,\\n            debtValueInWei\\n        )\\n            .mul(DEC_18)\\n            .div(totalSupply);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                          Set                                              */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Balance of underlying asset \\\"active\\\" in Set (e.g., WETH or USDC)\\n     */\\n    function getActiveSetAssetBalance() public view returns (uint256) {\\n        return\\n            IERC20(getAssetCurrentlyActiveInSet()).balanceOf(xSNXAdminInstance);\\n    }\\n\\n    /*\\n     * @dev Calculates quantity of Set Token equivalent to quantity of underlying asset token\\n     * @notice rebalancingSetQuantity return value is reduced slightly to ensure successful execution\\n     * @param componentQuantity: balance of underlying Set asset, e.g., WETH\\n     */\\n    function calculateSetQuantity(uint256 componentQuantity)\\n        public\\n        view\\n        returns (uint256 rebalancingSetQuantity)\\n    {\\n        uint256 baseSetNaturalUnit = getBaseSetNaturalUnit();\\n        uint256 baseSetComponentUnits = getBaseSetComponentUnits();\\n        uint256 baseSetIssuable = componentQuantity.mul(baseSetNaturalUnit).div(\\n            baseSetComponentUnits\\n        );\\n\\n        uint256 rebalancingSetNaturalUnit = getSetNaturalUnit();\\n        uint256 unitShares = getSetUnitShares();\\n        rebalancingSetQuantity = baseSetIssuable\\n            .mul(rebalancingSetNaturalUnit)\\n            .div(unitShares)\\n            .mul(99) // ensure sufficient balance in underlying asset\\n            .div(100)\\n            .div(rebalancingSetNaturalUnit)\\n            .mul(rebalancingSetNaturalUnit);\\n    }\\n\\n    /*\\n     * @dev Calculates mintable quantity of Set Token given asset holdings\\n     */\\n    function calculateSetIssuanceQuantity()\\n        public\\n        view\\n        returns (uint256 rebalancingSetIssuable)\\n    {\\n        uint256 componentQuantity = getActiveSetAssetBalance();\\n        rebalancingSetIssuable = calculateSetQuantity(componentQuantity);\\n    }\\n\\n    /*\\n     * @dev Calculates Set token to sell given sUSD burn requirements\\n     * @param totalSusdToBurn: sUSD to burn to fix ratio or unlock staked SNX\\n     */\\n    function calculateSetRedemptionQuantity(uint256 totalSusdToBurn)\\n        public\\n        view\\n        returns (uint256 rebalancingSetRedeemable)\\n    {\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n\\n        bytes32 activeAssetSynthSymbol = getActiveAssetSynthSymbol();\\n        uint256 synthUsd = getSynthPrice(activeAssetSynthSymbol);\\n\\n        // expectedSetAssetRate = amount of current set asset needed to redeem for 1 sUSD\\n        uint256 expectedSetAssetRate = DEC_18.mul(DEC_18).div(synthUsd);\\n\\n        uint256 setAssetCollateralToSell = expectedSetAssetRate\\n            .mul(totalSusdToBurn)\\n            .div(DEC_18)\\n            .mul(103) // err on the high side\\n            .div(PERCENT);\\n\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        setAssetCollateralToSell = setAssetCollateralToSell.mul(decimals).div(\\n            DEC_18\\n        );\\n\\n        rebalancingSetRedeemable = calculateSetQuantity(\\n            setAssetCollateralToSell\\n        );\\n    }\\n\\n    /*\\n     * @dev Calculates value of a single 1e18 Set unit in ETH terms\\n     */\\n    function calculateEthValueOfOneSetUnit()\\n        internal\\n        view\\n        returns (uint256 ethValue)\\n    {\\n        uint256 unitShares = getSetUnitShares();\\n        uint256 rebalancingSetNaturalUnit = getSetNaturalUnit();\\n        uint256 baseSetRequired = DEC_18.mul(unitShares).div(\\n            rebalancingSetNaturalUnit\\n        );\\n\\n        uint256 unitsOfUnderlying = getBaseSetComponentUnits();\\n        uint256 baseSetNaturalUnit = getBaseSetNaturalUnit();\\n        uint256 componentRequired = baseSetRequired.mul(unitsOfUnderlying).div(\\n            baseSetNaturalUnit\\n        );\\n\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        componentRequired = componentRequired.mul(DEC_18).div(decimals);\\n\\n        bytes32 activeAssetSynthSymbol = getActiveAssetSynthSymbol();\\n\\n        uint256 synthUsd = getSynthPrice(activeAssetSynthSymbol);\\n        uint256 ethUsd = getSynthPrice(seth);\\n        ethValue = componentRequired.mul(synthUsd).div(ethUsd);\\n    }\\n\\n    /*\\n     * @dev Calculates value of Set Holdings in ETH terms\\n     */\\n    function getSetHoldingsValueInWei()\\n        public\\n        view\\n        returns (uint256 setValInWei)\\n    {\\n        uint256 setCollateralTokens = getSetCollateralTokens();\\n        bytes32 synthSymbol = getActiveAssetSynthSymbol();\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n\\n        uint256 synthUsd = getSynthPrice(synthSymbol);\\n        uint256 ethUsd = getSynthPrice(seth);\\n\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        setCollateralTokens = setCollateralTokens.mul(DEC_18).div(decimals);\\n        setValInWei = setCollateralTokens.mul(synthUsd).div(ethUsd);\\n    }\\n\\n    function getBaseSetNaturalUnit() internal view returns (uint256) {\\n        return getCurrentCollateralSet().naturalUnit();\\n    }\\n\\n    /*\\n     * @dev Outputs current active Set asset\\n     * @notice xSNX contracts complex only compatible with Sets that hold a single asset at a time\\n     */\\n    function getAssetCurrentlyActiveInSet() public view returns (address) {\\n        address[] memory currentAllocation = getCurrentCollateralSet()\\n            .getComponents();\\n        return currentAllocation[0];\\n    }\\n\\n    function getCurrentCollateralSet()\\n        internal\\n        view\\n        returns (ISetAssetBaseCollateral)\\n    {\\n        return ISetAssetBaseCollateral(getCurrentSet());\\n    }\\n\\n    function getCurrentSet() internal view returns (address) {\\n        return ISetToken(setAddress).currentSet();\\n    }\\n\\n    /*\\n     * @dev Returns the number of underlying tokens in the current Set asset\\n     * e.g., the contract's Set holdings are collateralized by 10.4 WETH\\n     */\\n    function getSetCollateralTokens() internal view returns (uint256) {\\n        return\\n            getSetBalanceCollateral().mul(getBaseSetComponentUnits()).div(\\n                getBaseSetNaturalUnit()\\n            );\\n    }\\n\\n    function getSetBalanceCollateral() internal view returns (uint256) {\\n        uint256 unitShares = getSetUnitShares();\\n        uint256 naturalUnit = getSetNaturalUnit();\\n        return getContractSetBalance().mul(unitShares).div(naturalUnit);\\n    }\\n\\n    function getSetUnitShares() internal view returns (uint256) {\\n        return ISetToken(setAddress).unitShares();\\n    }\\n\\n    function getSetNaturalUnit() internal view returns (uint256) {\\n        return ISetToken(setAddress).naturalUnit();\\n    }\\n\\n    function getContractSetBalance() internal view returns (uint256) {\\n        return IERC20(setAddress).balanceOf(xSNXAdminInstance);\\n    }\\n\\n    function getBaseSetComponentUnits() internal view returns (uint256) {\\n        return ISetAssetBaseCollateral(getCurrentSet()).getUnits()[0];\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                         Synthetix\\t                                     */\\n    /* ========================================================================================= */\\n\\n    function getSusdBalance() public view returns (uint256) {\\n        return IERC20(susdAddress).balanceOf(xSNXAdminInstance);\\n    }\\n\\n    function getSnxBalance() public view returns (uint256) {\\n        return getSnxBalanceOwned().add(getSnxBalanceEscrowed());\\n    }\\n\\n    function getSnxBalanceOwned() internal view returns (uint256) {\\n        return\\n            IERC20(addressResolver.getAddress(synthetixName)).balanceOf(\\n                xSNXAdminInstance\\n            );\\n    }\\n\\n    function getSnxBalanceEscrowed() internal view returns (uint256) {\\n        return\\n            IRewardEscrowV2(addressResolver.getAddress(rewardEscrowV2Name))\\n                .balanceOf(xSNXAdminInstance);\\n    }\\n\\n    function getContractEscrowedSnxValue() internal view returns (uint256) {\\n        return getSnxBalanceEscrowed().mul(getSnxPrice()).div(DEC_18);\\n    }\\n\\n    function getContractOwnedSnxValue() internal view returns (uint256) {\\n        return getSnxBalanceOwned().mul(getSnxPrice()).div(DEC_18);\\n    }\\n\\n    function getSnxPrice() internal view returns (uint256) {\\n        (uint256 rate, uint256 time) = IExchangeRates(\\n            addressResolver.getAddress(exchangeRatesName)\\n        )\\n            .rateAndUpdatedTime(snx);\\n        require(time.add(RATE_STALE_TIME_NEW) > block.timestamp, \\\"Rate stale\\\");\\n        return rate;\\n    }\\n\\n    function getSynthPrice(bytes32 synth) internal view returns (uint256) {\\n        (uint256 rate, uint256 time) = IExchangeRates(\\n            addressResolver.getAddress(exchangeRatesName)\\n        )\\n            .rateAndUpdatedTime(synth);\\n        if (synth != susd) {\\n            require(time.add(RATE_STALE_TIME_NEW) > block.timestamp, \\\"Rate stale\\\");\\n        }\\n        return rate;\\n    }\\n\\n    /*\\n     * @dev Converts sUSD debt value into ETH terms\\n     * @param debtValue: sUSD-denominated debt value\\n     */\\n    function calculateDebtValueInWei(uint256 debtValue)\\n        internal\\n        view\\n        returns (uint256 debtBalanceInWei)\\n    {\\n        uint256 ethUsd = getSynthPrice(seth);\\n        debtBalanceInWei = debtValue.mul(DEC_18).div(ethUsd);\\n    }\\n\\n    function getContractDebtValue() internal view returns (uint256) {\\n        return\\n            ISynthetix(addressResolver.getAddress(synthetixName)).debtBalanceOf(\\n                xSNXAdminInstance,\\n                susd\\n            );\\n    }\\n\\n    /*\\n     * @notice Returns inverse of target C-RATIO\\n     */\\n    function getIssuanceRatio() internal view returns (uint256) {\\n        return\\n            ISystemSettings(addressResolver.getAddress(systemSettingsName))\\n                .issuanceRatio();\\n    }\\n\\n    /*\\n     * @notice Returns NAV contribution of SNX holdings in USD terms\\n     */\\n    function getContractSnxValue() internal view returns (uint256) {\\n        return getSnxBalance().mul(getSnxPrice()).div(DEC_18);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                       Burning sUSD                                        */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Calculates sUSD to burn to restore C-RATIO\\n     * @param snxValueHeld: USD value of SNX\\n     * @param contractDebtValue: USD value of sUSD debt\\n     * @param issuanceRatio: Synthetix C-RATIO requirement\\n     */\\n    function calculateSusdToBurnToFixRatio(\\n        uint256 snxValueHeld,\\n        uint256 contractDebtValue,\\n        uint256 issuanceRatio\\n    ) internal pure returns (uint256) {\\n        uint256 subtractor = issuanceRatio.mul(snxValueHeld).div(DEC_18);\\n\\n        if (subtractor > contractDebtValue) return 0;\\n        return contractDebtValue.sub(subtractor);\\n    }\\n\\n    /*\\n     * @dev Calculates sUSD to burn to restore C-RATIO\\n     */\\n    function calculateSusdToBurnToFixRatioExternal()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 snxValueHeld = getContractSnxValue();\\n        uint256 debtValue = getContractDebtValue();\\n        uint256 issuanceRatio = getIssuanceRatio();\\n        return\\n            calculateSusdToBurnToFixRatio(\\n                snxValueHeld,\\n                debtValue,\\n                issuanceRatio\\n            );\\n    }\\n\\n    /*\\n     * @dev Calculates sUSD to burn to eclipse value of escrowed SNX\\n     * @notice Synthetix system requires escrowed SNX to be \\\"unlocked\\\" first\\n     * @param issuanceRatio: Synthetix C-RATIO requirement\\n     */\\n    function calculateSusdToBurnToEclipseEscrowed(uint256 issuanceRatio)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 escrowedSnxValue = getContractEscrowedSnxValue();\\n        if (escrowedSnxValue == 0) return 0;\\n\\n        return escrowedSnxValue.mul(issuanceRatio).div(DEC_18);\\n    }\\n\\n    /*\\n     * @dev Helper function to calculate sUSD burn required for a potential redemption\\n     * @param tokensToRedeem: potential tokens to burn\\n     * @param totalSupply: xSNX.totalSupply()\\n     * @param contractDebtValue: sUSD debt value\\n     * @param issuanceRatio: Synthetix C-RATIO requirement\\n     */\\n    function calculateSusdToBurnForRedemption(\\n        uint256 tokensToRedeem,\\n        uint256 totalSupply,\\n        uint256 contractDebtValue,\\n        uint256 issuanceRatio\\n    ) public view returns (uint256 susdToBurn) {\\n        uint256 nonEscrowedSnxValue = getContractOwnedSnxValue();\\n        uint256 lockedSnxValue = contractDebtValue.mul(DEC_18).div(\\n            issuanceRatio\\n        );\\n        uint256 valueOfSnxToSell = nonEscrowedSnxValue.mul(tokensToRedeem).div(\\n            totalSupply\\n        );\\n        susdToBurn = (\\n            lockedSnxValue.add(valueOfSnxToSell).sub(nonEscrowedSnxValue)\\n        )\\n            .mul(issuanceRatio)\\n            .div(DEC_18);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                        Rebalances                                         */\\n    /* ========================================================================================= */\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsHedge()\\n     */\\n    function calculateAssetChangesForRebalanceToHedge()\\n        internal\\n        view\\n        returns (uint256 totalSusdToBurn, uint256 snxToSell)\\n    {\\n        uint256 snxValueHeld = getContractSnxValue();\\n        uint256 debtValueInUsd = getContractDebtValue();\\n        uint256 issuanceRatio = getIssuanceRatio();\\n\\n        uint256 susdToBurnToFixRatio = calculateSusdToBurnToFixRatio(\\n            snxValueHeld,\\n            debtValueInUsd,\\n            issuanceRatio\\n        );\\n\\n\\n            uint256 susdToBurnToEclipseEscrowed\\n         = calculateSusdToBurnToEclipseEscrowed(issuanceRatio);\\n\\n        uint256 hedgeAssetsValueInUsd = calculateHedgeAssetsValueInUsd();\\n        uint256 valueToUnlockInUsd = debtValueInUsd.sub(hedgeAssetsValueInUsd);\\n\\n        uint256 susdToBurnToUnlockTransfer = valueToUnlockInUsd\\n            .mul(issuanceRatio)\\n            .div(DEC_18);\\n\\n        totalSusdToBurn = (\\n            susdToBurnToFixRatio.add(susdToBurnToEclipseEscrowed).add(\\n                susdToBurnToUnlockTransfer\\n            )\\n        );\\n        snxToSell = valueToUnlockInUsd.mul(DEC_18).div(getSnxPrice());\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsSnx()\\n     */\\n    function calculateAssetChangesForRebalanceToSnx()\\n        public\\n        view\\n        returns (uint256 setToSell)\\n    {\\n        (\\n            uint256 debtValueInWei,\\n            uint256 hedgeAssetsBalance\\n        ) = getRebalanceUtils();\\n        uint256 setValueToSell = hedgeAssetsBalance.sub(debtValueInWei);\\n        uint256 ethValueOfOneSet = calculateEthValueOfOneSetUnit();\\n        setToSell = setValueToSell.mul(DEC_18).div(ethValueOfOneSet);\\n\\n        // Set quantity must be multiple of natural unit\\n        uint256 naturalUnit = getSetNaturalUnit();\\n        setToSell = setToSell.div(naturalUnit).mul(naturalUnit);\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsSnx()\\n     */\\n    function getRebalanceTowardsSnxUtils()\\n        public\\n        view\\n        returns (uint256 setToSell, address activeAsset)\\n    {\\n        setToSell = calculateAssetChangesForRebalanceToSnx();\\n        activeAsset = getAssetCurrentlyActiveInSet();\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsSnx(), xSNXAdmin.rebalanceTowardsHedge()\\n     * @dev Denominated in ETH terms\\n     */\\n    function getRebalanceUtils()\\n        public\\n        view\\n        returns (uint256 debtValueInWei, uint256 hedgeAssetsBalance)\\n    {\\n        uint256 setHoldingsInWei = getSetHoldingsValueInWei();\\n        uint256 ethBalance = getEthBalance();\\n\\n        uint256 debtValue = getContractDebtValue();\\n        debtValueInWei = calculateDebtValueInWei(debtValue);\\n        hedgeAssetsBalance = setHoldingsInWei.add(ethBalance);\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsHedge()\\n     * @dev Denominated in USD terms\\n     */\\n    function calculateHedgeAssetsValueInUsd()\\n        internal\\n        view\\n        returns (uint256 hedgeAssetsValueInUsd)\\n    {\\n        address currentSetAsset = getAssetCurrentlyActiveInSet();\\n        uint256 decimals = (TEN**ERC20Detailed(currentSetAsset).decimals());\\n        uint256 setCollateralTokens = getSetCollateralTokens();\\n        setCollateralTokens = setCollateralTokens.mul(DEC_18).div(decimals);\\n\\n        bytes32 activeAssetSynthSymbol = getActiveAssetSynthSymbol();\\n\\n        uint256 synthUsd = getSynthPrice(activeAssetSynthSymbol);\\n        uint256 setValueUsd = setCollateralTokens.mul(synthUsd).div(DEC_18);\\n\\n        uint256 ethBalance = getEthBalance();\\n        uint256 ethUsd = getSynthPrice(seth);\\n        uint256 ethValueUsd = ethBalance.mul(ethUsd).div(DEC_18);\\n\\n        hedgeAssetsValueInUsd = setValueUsd.add(ethValueUsd);\\n    }\\n\\n    /*\\n     * @dev Helper function to determine whether xSNXAdmin.rebalanceTowardsSnx() is required\\n     */\\n    function isRebalanceTowardsSnxRequired() public view returns (bool) {\\n        (\\n            uint256 debtValueInWei,\\n            uint256 hedgeAssetsBalance\\n        ) = getRebalanceUtils();\\n\\n        if (\\n            debtValueInWei.mul(REBALANCE_THRESHOLD).div(PERCENT) <\\n            hedgeAssetsBalance\\n        ) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /*\\n     * @dev Helper function to determine whether xSNXAdmin.rebalanceTowardsHedge() is required\\n     */\\n    function isRebalanceTowardsHedgeRequired() public view returns (bool) {\\n        (\\n            uint256 debtValueInWei,\\n            uint256 hedgeAssetsBalance\\n        ) = getRebalanceUtils();\\n\\n        if (\\n            hedgeAssetsBalance.mul(REBALANCE_THRESHOLD).div(PERCENT) <\\n            debtValueInWei\\n        ) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceTowardsHedge()\\n     * @notice Will fail if !isRebalanceTowardsHedgeRequired()\\n     */\\n    function getRebalanceTowardsHedgeUtils()\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            address\\n        )\\n    {\\n        (\\n            uint256 totalSusdToBurn,\\n            uint256 snxToSell\\n        ) = calculateAssetChangesForRebalanceToHedge();\\n        address activeAsset = getAssetCurrentlyActiveInSet();\\n        return (totalSusdToBurn, snxToSell, activeAsset);\\n    }\\n\\n    /*\\n     * @dev Helper for `hedge` function\\n     * @dev Determines share of sUSD to allocate to ETH\\n     * @dev Implicitly determines Set allocation as well\\n     * @param susdBal: sUSD balance post minting\\n     */\\n    function getEthAllocationOnHedge(uint256 susdBal)\\n        public\\n        view\\n        returns (uint256 ethAllocation)\\n    {\\n        uint256 ethUsd = getSynthPrice(seth);\\n\\n        uint256 setHoldingsInUsd = getSetHoldingsValueInWei().mul(ethUsd).div(\\n            DEC_18\\n        );\\n        uint256 ethBalInUsd = getEthBalance().mul(ethUsd).div(DEC_18);\\n        uint256 hedgeAssets = setHoldingsInUsd.add(ethBalInUsd);\\n\\n        if (ethBalInUsd.mul(ETH_TARGET) >= hedgeAssets.add(susdBal)) {\\n            // full bal directed toward Set\\n            // eth allocation is 0\\n        } else if ((ethBalInUsd.add(susdBal)).mul(ETH_TARGET) < hedgeAssets) {\\n            // full bal directed toward Eth\\n            ethAllocation = susdBal;\\n        } else {\\n            // fractionate allocation\\n            ethAllocation = ((hedgeAssets.add(susdBal)).div(ETH_TARGET)).sub(\\n                ethBalInUsd\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @dev Helper function to facilitate xSNXAdmin.rebalanceSetToEth()\\n     */\\n    function calculateSetToSellForRebalanceSetToEth()\\n        public\\n        view\\n        returns (uint256 setQuantityToSell)\\n    {\\n        uint256 setHoldingsInWei = getSetHoldingsValueInWei();\\n        uint256 ethBal = getEthBalance();\\n        uint256 hedgeAssets = setHoldingsInWei.add(ethBal);\\n        require(\\n            ethBal.mul(ETH_TARGET) < hedgeAssets,\\n            \\\"Rebalance not necessary\\\"\\n        );\\n\\n        uint256 ethToAdd = ((hedgeAssets.div(ETH_TARGET)).sub(ethBal));\\n        setQuantityToSell = getContractSetBalance().mul(ethToAdd).div(\\n            setHoldingsInWei\\n        );\\n\\n        uint256 naturalUnit = getSetNaturalUnit();\\n        setQuantityToSell = setQuantityToSell.div(naturalUnit).mul(naturalUnit);\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                     Address Setters                                       */\\n    /* ========================================================================================= */\\n\\n    function setAdminInstanceAddress(address _xSNXAdminInstance)\\n        public\\n        onlyOwner\\n    {\\n        if (xSNXAdminInstance == address(0)) {\\n            xSNXAdminInstance = _xSNXAdminInstance;\\n        }\\n    }\\n\\n    function setCurve(\\n        address curvePoolAddress,\\n        int128 _usdcIndex,\\n        int128 _susdIndex\\n    ) public onlyOwner {\\n        if (address(curveFi) == address(0)) {\\n            // if initial set on deployment, immediately activate Curve address\\n            curveFi = ICurveFi(curvePoolAddress);\\n            nextCurveAddress = curvePoolAddress;\\n        } else {\\n            // if updating Curve address (i.e., not initial setting of address on deployment),\\n            // store nextCurveAddress but don't activate until addressValidator has confirmed\\n            nextCurveAddress = curvePoolAddress;\\n        }\\n        usdcIndex = _usdcIndex;\\n        susdIndex = _susdIndex;\\n    }\\n\\n    /* ========================================================================================= */\\n    /*                                   \\t\\t Utils           \\t\\t                         */\\n    /* ========================================================================================= */\\n\\n    // admin on deployment approve [snx, susd, setComponentA, setComponentB]\\n    function approveKyber(address tokenAddress) public onlyOwner {\\n        IERC20(tokenAddress).approve(address(kyberNetworkProxy), MAX_UINT);\\n    }\\n\\n    // admin on deployment approve [susd, usdc]\\n    function approveCurve(address tokenAddress) public onlyOwner {\\n        IERC20(tokenAddress).approve(address(curveFi), MAX_UINT);\\n    }\\n\\n    function confirmCurveAddress(address _nextCurveAddress) public {\\n        require(msg.sender == addressValidator, \\\"Incorrect caller\\\");\\n        require(nextCurveAddress == _nextCurveAddress, \\\"Addresses don't match\\\");\\n        curveFi = ICurveFi(nextCurveAddress);\\n    }\\n\\n    function() external payable {}\\n}\"\r\n    },\r\n    \"contracts/interface/IRebalancingSetIssuanceModule.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface IRebalancingSetIssuanceModule {\\n    //  call if eth is active asset in eth20smaco\\n    function issueRebalancingSetWrappingEther(\\n        address _rebalancingSetAddress,\\n        uint256 _rebalancingSetQuantity,\\n        bool _keepChangeInVault\\n    ) external payable;\\n\\n    //  call with usdc if usdc is active asset in eth20smaco\\n    function issueRebalancingSet(\\n        address _rebalancingSetAddress,\\n        uint256 _rebalancingSetQuantity,\\n        bool _keepChangeInVault\\n    ) external;\\n\\n    function redeemRebalancingSet(\\n        address _rebalancingSetAddress,\\n        uint256 _rebalancingSetQuantity,\\n        bool _keepChangeInVault\\n    )\\n    external;\\n}\"\r\n    },\r\n    \"contracts/interface/IxSNX.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ncontract IxSNX {\\n    function getClaimFeeDivisor() external view returns(uint);\\n}\"\r\n    },\r\n    \"contracts/DebtRepayment.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Types {\\n    enum AssetDenomination {\\n        Wei,\\n        Par\\n    }\\n    enum AssetReference {\\n        Delta,\\n        Target\\n    }\\n    struct AssetAmount {\\n        bool sign;\\n        AssetDenomination denomination;\\n        AssetReference ref;\\n        uint256 value;\\n    }\\n}\\n\\nlibrary Account {\\n    struct Info {\\n        address owner;\\n        uint256 number;\\n    }\\n}\\n\\nlibrary Actions {\\n    enum ActionType {\\n        Deposit,\\n        Withdraw,\\n        Transfer,\\n        Buy,\\n        Sell,\\n        Trade,\\n        Liquidate,\\n        Vaporize,\\n        Call\\n    }\\n    struct ActionArgs {\\n        ActionType actionType;\\n        uint256 accountId;\\n        Types.AssetAmount amount;\\n        uint256 primaryMarketId;\\n        uint256 secondaryMarketId;\\n        address otherAddress;\\n        uint256 otherAccountId;\\n        bytes data;\\n    }\\n}\\n\\ninterface ISoloMargin {\\n    function operate(\\n        Account.Info[] calldata accounts,\\n        Actions.ActionArgs[] calldata actions\\n    ) external;\\n}\\n\\n// The interface for a contract to be callable after receiving a flash loan\\ninterface ICallee {\\n    function callFunction(\\n        address sender,\\n        Account.Info calldata accountInfo,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ncontract DebtRepayment is ICallee {\\n    /**\\n     * Debt repayment function\\n     * Called when c-ratio is below a certain point\\n     * And SNX collateral is locked\\n     * Takes flash loan from dydx in USDC\\n     * Calls callFunction in xSNXAdmin.sol\\n     */\\n    function repayDebt(uint256 loanAmount, uint256 snxAmount) public {\\n        ISoloMargin soloMargin = ISoloMargin(\\n            0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e\\n        );\\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\\n\\n        operations[0] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Withdraw,\\n            accountId: 0,\\n            amount: Types.AssetAmount({\\n                sign: false,\\n                denomination: Types.AssetDenomination.Wei,\\n                ref: Types.AssetReference.Delta,\\n                value: loanAmount // Amount to borrow\\n            }),\\n            primaryMarketId: 2, // USDC\\n            secondaryMarketId: 0,\\n            otherAddress: address(this),\\n            otherAccountId: 0,\\n            data: \\\"\\\"\\n        });\\n\\n        operations[1] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Call,\\n            accountId: 0,\\n            amount: Types.AssetAmount({\\n                sign: false,\\n                denomination: Types.AssetDenomination.Wei,\\n                ref: Types.AssetReference.Delta,\\n                value: 0\\n            }),\\n            primaryMarketId: 2,\\n            secondaryMarketId: 0,\\n            otherAddress: address(this),\\n            otherAccountId: 0,\\n            data: abi.encode(\\n                msg.sender,\\n                loanAmount,\\n                snxAmount // snx amount to swap to repay the loan\\n            )\\n        });\\n\\n        operations[2] = Actions.ActionArgs({\\n            actionType: Actions.ActionType.Deposit,\\n            accountId: 0,\\n            amount: Types.AssetAmount({\\n                sign: true,\\n                denomination: Types.AssetDenomination.Wei,\\n                ref: Types.AssetReference.Delta,\\n                value: loanAmount + 2 // Repayment amount with 2 wei fee\\n            }),\\n            primaryMarketId: 2, // USDC\\n            secondaryMarketId: 0,\\n            otherAddress: address(this),\\n            otherAccountId: 0,\\n            data: \\\"\\\"\\n        });\\n\\n        Account.Info[] memory accountInfos = new Account.Info[](1);\\n        accountInfos[0] = Account.Info({owner: address(this), number: 1});\\n\\n        soloMargin.operate(accountInfos, operations);\\n    }\\n\\n    function() external payable {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is Initializable, IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/ISynthetix.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\nimport \\\"./ISynth.sol\\\";\\nimport \\\"./IVirtualSynth.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\\ninterface ISynthetix {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\\n\\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\\n\\n    function totalIssuedSynthsExcludeEtherCollateral(bytes32 currencyKey) external view returns (uint);\\n\\n    function transferableSynthetix(address account) external view returns (uint transferable);\\n\\n    // Mutative Functions\\n    function burnSynths(uint amount) external;\\n\\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\\n\\n    function burnSynthsToTarget() external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\\n\\n    function exchange(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalf(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTracking(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address originator,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalfWithTracking(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address originator,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithVirtual(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\\n\\n    function issueMaxSynths() external;\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\\n\\n    function issueSynths(uint amount) external;\\n\\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\\n\\n    function mint() external returns (bool);\\n\\n    function settle(bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    // Liquidations\\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\\n\\n    // Restricted Functions\\n\\n    function mintSecondary(address account, uint amount) external;\\n\\n    function mintSecondaryRewards(uint amount) external;\\n\\n    function burnSecondary(address account, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IRewardEscrowV2.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\npragma experimental ABIEncoderV2;\\n\\nlibrary VestingEntries {\\n    struct VestingEntry {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n    }\\n    struct VestingEntryWithID {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n        uint256 entryID;\\n    }\\n}\\n\\ninterface IRewardEscrowV2 {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function numVestingEntries(address account) external view returns (uint);\\n\\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\\n\\n    function totalVestedAccountBalance(address account) external view returns (uint);\\n\\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\\n\\n    function getVestingSchedules(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\\n\\n    function getAccountVestingEntryIDs(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (uint256[] memory);\\n\\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\\n\\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\\n\\n    // Mutative functions\\n    function vest(uint256[] calldata entryIDs) external;\\n\\n    function createEscrowEntry(\\n        address beneficiary,\\n        uint256 deposit,\\n        uint256 duration\\n    ) external;\\n\\n    function appendVestingEntry(\\n        address account,\\n        uint256 quantity,\\n        uint256 duration\\n    ) external;\\n\\n    function migrateVestingSchedule(address _addressToMigrate) external;\\n\\n    function migrateAccountEscrowBalances(\\n        address[] calldata accounts,\\n        uint256[] calldata escrowBalances,\\n        uint256[] calldata vestedBalances\\n    ) external;\\n\\n    // Account Merging\\n    function startMergingWindow() external;\\n\\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\\n\\n    function nominateAccountToMerge(address account) external;\\n\\n    function accountMergingIsOpen() external view returns (bool);\\n\\n    // L2 Migration\\n    function importVestingEntries(\\n        address account,\\n        uint256 escrowedAmount,\\n        VestingEntries.VestingEntry[] calldata vestingEntries\\n    ) external;\\n\\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\\n    function burnForMigration(address account, uint256[] calldata entryIDs)\\n        external\\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IExchangeRates.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\\ninterface IExchangeRates {\\n    // Structs\\n    struct RateAndUpdatedTime {\\n        uint216 rate;\\n        uint40 time;\\n    }\\n\\n    struct InversePricing {\\n        uint entryPoint;\\n        uint upperLimit;\\n        uint lowerLimit;\\n        bool frozenAtUpperLimit;\\n        bool frozenAtLowerLimit;\\n    }\\n\\n    // Views\\n    function aggregators(bytes32 currencyKey) external view returns (address);\\n\\n    function aggregatorWarningFlags() external view returns (address);\\n\\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\\n\\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\\n\\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\\n\\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\\n\\n    function effectiveValue(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external view returns (uint value);\\n\\n    function effectiveValueAndRates(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint value,\\n            uint sourceRate,\\n            uint destinationRate\\n        );\\n\\n    function effectiveValueAtRound(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external view returns (uint value);\\n\\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\\n\\n    function getLastRoundIdBeforeElapsedSecs(\\n        bytes32 currencyKey,\\n        uint startingRoundId,\\n        uint startingTimestamp,\\n        uint timediff\\n    ) external view returns (uint);\\n\\n    function inversePricing(bytes32 currencyKey)\\n        external\\n        view\\n        returns (\\n            uint entryPoint,\\n            uint upperLimit,\\n            uint lowerLimit,\\n            bool frozenAtUpperLimit,\\n            bool frozenAtLowerLimit\\n        );\\n\\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\\n\\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\\n\\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\\n\\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\\n\\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateStalePeriod() external view returns (uint);\\n\\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\\n        external\\n        view\\n        returns (uint[] memory rates, uint[] memory times);\\n\\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\\n        external\\n        view\\n        returns (uint[] memory rates, bool anyRateInvalid);\\n\\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\\n\\n    // Mutative functions\\n    function freezeRate(bytes32 currencyKey) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/ISynthetixState.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixstate\\ninterface ISynthetixState {\\n    // Views\\n    function debtLedger(uint index) external view returns (uint);\\n\\n    function issuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\\n\\n    function debtLedgerLength() external view returns (uint);\\n\\n    function hasIssued(address account) external view returns (bool);\\n\\n    function lastDebtLedgerEntry() external view returns (uint);\\n\\n    // Mutative functions\\n    function incrementTotalIssuerCount() external;\\n\\n    function decrementTotalIssuerCount() external;\\n\\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\\n\\n    function appendDebtLedgerValue(uint value) external;\\n\\n    function clearIssuanceData(address account) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IAddressResolver.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getSynth(bytes32 key) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ISystemSettings.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ISystemSettings {\\n    function issuanceRatio() external view returns(uint);\\n}\"\r\n    },\r\n    \"contracts/interface/ICurveFi.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ICurveFi {\\n  function exchange(\\n    int128 i,\\n    int128 j,\\n    uint256 dx,\\n    uint256 min_dy\\n  ) external;\\n  function exchange_underlying(\\n    int128 i,\\n    int128 j,\\n    uint256 dx,\\n    uint256 min_dy\\n  ) external;\\n  function get_dx_underlying(\\n    int128 i,\\n    int128 j,\\n    uint256 dy\\n  ) external view returns (uint256);\\n  function get_dy_underlying(\\n    int128 i,\\n    int128 j,\\n    uint256 dx\\n  ) external view returns (uint256);\\n  function get_dx(\\n    int128 i,\\n    int128 j,\\n    uint256 dy\\n  ) external view returns (uint256);\\n  function get_dy(\\n    int128 i,\\n    int128 j,\\n    uint256 dx\\n  ) external view returns (uint256);\\n  function get_virtual_price() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interface/ISetToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ISetToken {\\n    function unitShares() external view returns(uint);\\n    function naturalUnit() external view returns(uint);\\n    function currentSet() external view returns(address);\\n    // function getUnits() external view returns (uint256[] memory);\\n}\"\r\n    },\r\n    \"contracts/interface/IKyberNetworkProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract IKyberNetworkProxy {\\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\\n    function swapEtherToToken(ERC20 token, uint minConversionRate) external payable returns(uint);\\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external payable returns(uint);\\n    function swapTokenToToken(ERC20 src, uint srcAmount, ERC20 dest, uint minConversionRate) public returns(uint);\\n}\"\r\n    },\r\n    \"contracts/interface/ISetAssetBaseCollateral.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ninterface ISetAssetBaseCollateral {\\n    function getComponents() external view returns(address[] memory);\\n    function naturalUnit() external view returns(uint);\\n    function getUnits() external view returns (uint256[] memory);\\n}\"\r\n    },\r\n    \"synthetix/contracts/interfaces/ISynth.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\\ninterface ISynth {\\n    // Views\\n    function currencyKey() external view returns (bytes32);\\n\\n    function transferableSynths(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function transferAndSettle(address to, uint value) external returns (bool);\\n\\n    function transferFromAndSettle(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Restricted: used internally to Synthetix\\n    function burn(address account, uint amount) external;\\n\\n    function issue(address account, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IVirtualSynth.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\nimport \\\"./ISynth.sol\\\";\\n\\ninterface IVirtualSynth {\\n    // Views\\n    function balanceOfUnderlying(address account) external view returns (uint);\\n\\n    function rate() external view returns (uint);\\n\\n    function readyToSettle() external view returns (bool);\\n\\n    function secsLeftInWaitingPeriod() external view returns (uint);\\n\\n    function settled() external view returns (bool);\\n\\n    function synth() external view returns (ISynth);\\n\\n    // Mutative functions\\n    function settle(address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Initializable, Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0xddd7df28b1fb668b77860b473af819b03db61101", "attacktype": "On-chain oracle manipulation", "sourcecode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to use in the initializer function of a contract.\r\n     */\r\n    modifier initializer() {\r\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        assembly { cs := extcodesize(self) }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract ContextUpgradeSafe is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {\r\n\r\n\r\n    }\r\n\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20MinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20UpgradeSafe is Initializable, ContextUpgradeSafe, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n\r\n    function __ERC20_init(string memory name, string memory symbol) internal initializer {\r\n        __Context_init_unchained();\r\n        __ERC20_init_unchained(name, symbol);\r\n    }\r\n\r\n    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\r\n\r\n\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n\r\n    uint256[44] private __gap;\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface Converter {\r\n    function convert(address) external returns (uint);\r\n}\r\n\r\ninterface IValueMultiVault {\r\n    function cap() external view returns (uint);\r\n    function getConverter(address _want) external view returns (address);\r\n    function getVaultMaster() external view returns (address);\r\n    function balance() external view returns (uint);\r\n    function token() external view returns (address);\r\n    function available(address _want) external view returns (uint);\r\n    function accept(address _input) external view returns (bool);\r\n\r\n    function claimInsurance() external;\r\n    function earn(address _want) external;\r\n    function harvest(address reserve, uint amount) external;\r\n\r\n    function withdraw_fee(uint _shares) external view returns (uint);\r\n    function calc_token_amount_deposit(uint[] calldata _amounts) external view returns (uint);\r\n    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint);\r\n    function convert_rate(address _input, uint _amount) external view returns (uint);\r\n    function getPricePerFullShare() external view returns (uint);\r\n    function get_virtual_price() external view returns (uint); // average dollar value of vault share token\r\n\r\n    function deposit(address _input, uint _amount, uint _min_mint_amount) external returns (uint _mint_amount);\r\n    function depositFor(address _account, address _to, address _input, uint _amount, uint _min_mint_amount) external returns (uint _mint_amount);\r\n    function depositAll(uint[] calldata _amounts, uint _min_mint_amount) external returns (uint _mint_amount);\r\n    function depositAllFor(address _account, address _to, uint[] calldata _amounts, uint _min_mint_amount) external returns (uint _mint_amount);\r\n    function withdraw(uint _shares, address _output, uint _min_output_amount) external returns (uint);\r\n    function withdrawFor(address _account, uint _shares, address _output, uint _min_output_amount) external returns (uint _output_amount);\r\n\r\n    function harvestStrategy(address _strategy) external;\r\n    function harvestWant(address _want) external;\r\n    function harvestAllStrategies() external;\r\n}\r\n\r\ninterface IValueVaultMaster {\r\n    function bank(address) view external returns (address);\r\n    function isVault(address) view external returns (bool);\r\n    function isController(address) view external returns (bool);\r\n    function isStrategy(address) view external returns (bool);\r\n\r\n    function slippage(address) view external returns (uint);\r\n    function convertSlippage(address _input, address _output) view external returns (uint);\r\n\r\n    function valueToken() view external returns (address);\r\n    function govVault() view external returns (address);\r\n    function insuranceFund() view external returns (address);\r\n    function performanceReward() view external returns (address);\r\n\r\n    function govVaultProfitShareFee() view external returns (uint);\r\n    function gasFee() view external returns (uint);\r\n    function insuranceFee() view external returns (uint);\r\n    function withdrawalProtectionFee() view external returns (uint);\r\n}\r\n\r\ninterface IMultiVaultController {\r\n    function vault() external view returns (address);\r\n\r\n    function wantQuota(address _want) external view returns (uint);\r\n    function wantStrategyLength(address _want) external view returns (uint);\r\n    function wantStrategyBalance(address _want) external view returns (uint);\r\n\r\n    function getStrategyCount() external view returns(uint);\r\n    function strategies(address _want, uint _stratId) external view returns (address _strategy, uint _quota, uint _percent);\r\n    function getBestStrategy(address _want) external view returns (address _strategy);\r\n\r\n    function basedWant() external view returns (address);\r\n    function want() external view returns (address);\r\n    function wantLength() external view returns (uint);\r\n\r\n    function balanceOf(address _want, bool _sell) external view returns (uint);\r\n    function withdraw_fee(address _want, uint _amount) external view returns (uint); // eg. 3CRV => pJar: 0.5% (50/10000)\r\n    function investDisabled(address _want) external view returns (bool);\r\n\r\n    function withdraw(address _want, uint) external returns (uint _withdrawFee);\r\n    function earn(address _token, uint _amount) external;\r\n\r\n    function harvestStrategy(address _strategy) external;\r\n    function harvestWant(address _want) external;\r\n    function harvestAllStrategies() external;\r\n}\r\n\r\ninterface IMultiVaultConverter {\r\n    function token() external returns (address);\r\n    function get_virtual_price() external view returns (uint);\r\n\r\n    function convert_rate(address _input, address _output, uint _inputAmount) external view returns (uint _outputAmount);\r\n    function calc_token_amount_deposit(uint[] calldata _amounts) external view returns (uint _shareAmount);\r\n    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint _outputAmount);\r\n\r\n    function convert(address _input, address _output, uint _inputAmount) external returns (uint _outputAmount);\r\n    function convertAll(uint[] calldata _amounts) external returns (uint _outputAmount);\r\n}\r\n\r\ninterface IShareConverter {\r\n    function convert_shares_rate(address _input, address _output, uint _inputAmount) external view returns (uint _outputAmount);\r\n\r\n    function convert_shares(address _input, address _output, uint _inputAmount) external returns (uint _outputAmount);\r\n}\r\n\r\ncontract MultiStablesVault is ERC20UpgradeSafe, IValueMultiVault {\r\n    using Address for address;\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Curve Pools\r\n    // 0. 3pool [DAI, USDC, USDT]\r\n    // 1. BUSD [(y)DAI, (y)USDC, (y)USDT, (y)BUSD]\r\n    // 2. sUSD [DAI, USDC, USDT, sUSD]\r\n    // 3. husd [HUSD, 3pool]\r\n    // 4. Compound [(c)DAI, (c)USDC]\r\n    // 5. Y [(y)DAI, (y)USDC, (y)USDT, (y)TUSD]\r\n    IERC20 public basedToken; // [3CRV] (used for center-metric price: share value will based on this)\r\n\r\n    IERC20[] public inputTokens; // DAI, USDC, USDT, 3CRV, BUSD, sUSD, husd\r\n    IERC20[] public wantTokens; // [3CRV], [yDAI+yUSDC+yUSDT+yBUSD], [crvPlain3andSUSD], [husd3CRV], [cDAI+cUSDC], [yDAI+yUSDC+yUSDT+yTUSD]\r\n\r\n    mapping(address => uint) public inputTokenIndex; // input_token_address => (index + 1)\r\n    mapping(address => uint) public wantTokenIndex; // want_token_address => (index + 1)\r\n    mapping(address => address) public input2Want; // eg. BUSD => [yDAI+yUSDC+yUSDT+yBUSD], sUSD => [husd3CRV]\r\n    mapping(address => bool) public allowWithdrawFromOtherWant; // we allow to withdraw from others if based want strategies have not enough balance\r\n\r\n    uint public min = 9500;\r\n    uint public constant max = 10000;\r\n\r\n    uint public earnLowerlimit = 10 ether; // minimum to invest is 10 3CRV\r\n    uint totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\r\n\r\n    address public governance;\r\n    address public controller;\r\n    uint public insurance;\r\n    IValueVaultMaster vaultMaster;\r\n    IMultiVaultConverter public basedConverter; // converter for 3CRV\r\n    IShareConverter public shareConverter; // converter for shares (3CRV <-> BCrv, etc ...)\r\n\r\n    mapping(address => IMultiVaultConverter) public converters; // want_token_address => converter\r\n    mapping(address => address) public converterMap; // non-core token => converter\r\n\r\n    bool public acceptContractDepositor = false;\r\n    mapping(address => bool) public whitelistedContract;\r\n\r\n    event Deposit(address indexed user, uint amount);\r\n    event Withdraw(address indexed user, uint amount);\r\n    event RewardPaid(address indexed user, uint reward);\r\n\r\n    function initialize(IERC20 _basedToken, IValueVaultMaster _vaultMaster) public initializer {\r\n        __ERC20_init(\"ValueDefi:MultiVault:Stables\", \"mvUSD\");\r\n        basedToken = _basedToken;\r\n        vaultMaster = _vaultMaster;\r\n        governance = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by a not-whitelisted contract while we do not accept contract depositor.\r\n     */\r\n    modifier checkContract() {\r\n        if (!acceptContractDepositor && !whitelistedContract[msg.sender]) {\r\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"contract not support\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function setAcceptContractDepositor(bool _acceptContractDepositor) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        acceptContractDepositor = _acceptContractDepositor;\r\n    }\r\n\r\n    function whitelistContract(address _contract) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        whitelistedContract[_contract] = true;\r\n    }\r\n\r\n    function unwhitelistContract(address _contract) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        whitelistedContract[_contract] = false;\r\n    }\r\n\r\n    function cap() external override view returns (uint) {\r\n        return totalDepositCap;\r\n    }\r\n\r\n    function getConverter(address _want) external override view returns (address) {\r\n        return address(converters[_want]);\r\n    }\r\n\r\n    function getVaultMaster() external override view returns (address) {\r\n        return address(vaultMaster);\r\n    }\r\n\r\n    function accept(address _input) external override view returns (bool) {\r\n        return inputTokenIndex[_input] > 0;\r\n    }\r\n\r\n    // Ignore insurance fund for balance calculations\r\n    function balance() public override view returns (uint) {\r\n        uint bal = basedToken.balanceOf(address(this));\r\n        if (controller != address(0)) bal = bal.add(IMultiVaultController(controller).balanceOf(address(basedToken), false));\r\n        return bal.sub(insurance);\r\n    }\r\n\r\n    // sub a small percent (~0.02%) for not-based strategy balance when selling shares\r\n    function balance_to_sell() public view returns (uint) {\r\n        uint bal = basedToken.balanceOf(address(this));\r\n        if (controller != address(0)) bal = bal.add(IMultiVaultController(controller).balanceOf(address(basedToken), true));\r\n        return bal.sub(insurance);\r\n    }\r\n\r\n    function setMin(uint _min) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        min = _min;\r\n    }\r\n\r\n    function setGovernance(address _governance) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        governance = _governance;\r\n    }\r\n\r\n    function setController(address _controller) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        controller = _controller;\r\n    }\r\n\r\n    function setConverter(address _want, IMultiVaultConverter _converter) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(_converter.token() == _want, \"!_want\");\r\n        converters[_want] = _converter;\r\n        if (_want == address(basedToken)) basedConverter = _converter;\r\n    }\r\n\r\n    function setShareConverter(IShareConverter _shareConverter) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        shareConverter = _shareConverter;\r\n    }\r\n\r\n    function setConverterMap(address _token, address _converter) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        converterMap[_token] = _converter;\r\n    }\r\n\r\n    function setVaultMaster(IValueVaultMaster _vaultMaster) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        vaultMaster = _vaultMaster;\r\n    }\r\n\r\n    function setEarnLowerlimit(uint _earnLowerlimit) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        earnLowerlimit = _earnLowerlimit;\r\n    }\r\n\r\n    function setCap(uint _cap) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        totalDepositCap = _cap;\r\n    }\r\n\r\n    // claim by controller: auto-compounding\r\n    // claim by governance: send the fund to insuranceFund\r\n    function claimInsurance() external override {\r\n        if (msg.sender != controller) {\r\n            require(msg.sender == governance, \"!governance\");\r\n            basedToken.safeTransfer(vaultMaster.insuranceFund(), insurance);\r\n        }\r\n        insurance = 0;\r\n    }\r\n\r\n    function setInputTokens(IERC20[] memory _inputTokens) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        for (uint256 i = 0; i < inputTokens.length; ++i) {\r\n            inputTokenIndex[address(inputTokens[i])] = 0;\r\n        }\r\n        delete inputTokens;\r\n        for (uint256 i = 0; i < _inputTokens.length; ++i) {\r\n            inputTokens.push(_inputTokens[i]);\r\n            inputTokenIndex[address(_inputTokens[i])] = i + 1;\r\n        }\r\n    }\r\n\r\n    function setInputToken(uint _index, IERC20 _inputToken) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        inputTokenIndex[address(inputTokens[_index])] = 0;\r\n        inputTokens[_index] = _inputToken;\r\n        inputTokenIndex[address(_inputToken)] = _index + 1;\r\n    }\r\n\r\n    function setWantTokens(IERC20[] memory _wantTokens) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        for (uint256 i = 0; i < wantTokens.length; ++i) {\r\n            wantTokenIndex[address(wantTokens[i])] = 0;\r\n        }\r\n        delete wantTokens;\r\n        for (uint256 i = 0; i < _wantTokens.length; ++i) {\r\n            wantTokens.push(_wantTokens[i]);\r\n            wantTokenIndex[address(_wantTokens[i])] = i + 1;\r\n        }\r\n    }\r\n\r\n    function setInput2Want(address _inputToken, address _wantToken) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        input2Want[_inputToken] = _wantToken;\r\n    }\r\n\r\n    function setAllowWithdrawFromOtherWant(address _token, bool _allow) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        allowWithdrawFromOtherWant[_token] = _allow;\r\n    }\r\n\r\n    function token() public override view returns (address) {\r\n        return address(basedToken);\r\n    }\r\n\r\n    // Custom logic in here for how much the vault allows to be borrowed\r\n    // Sets minimum required on-hand to keep small withdrawals cheap\r\n    function available(address _want) public override view returns (uint) {\r\n        uint _bal = IERC20(_want).balanceOf(address(this));\r\n        return (_want == address(basedToken)) ? _bal.mul(min).div(max) : _bal;\r\n    }\r\n\r\n    function earn(address _want) public override {\r\n        if (controller != address(0)) {\r\n            IMultiVaultController _contrl = IMultiVaultController(controller);\r\n            if (!_contrl.investDisabled(_want)) {\r\n                uint _bal = available(_want);\r\n                if ((_bal > 0) && (_want != address(basedToken) || _bal >= earnLowerlimit)) {\r\n                    IERC20(_want).safeTransfer(controller, _bal);\r\n                    _contrl.earn(_want, _bal);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // if some want (nonbased) stay idle and we want to convert to based-token to re-invest\r\n    function convert_nonbased_want(address _want, uint _amount) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(_want != address(basedToken), \"basedToken\");\r\n        require(address(shareConverter) != address(0), \"!shareConverter\");\r\n        require(shareConverter.convert_shares_rate(_want, address(basedToken), _amount) > 0, \"rate=0\");\r\n        IERC20(_want).safeTransfer(address(shareConverter), _amount);\r\n        shareConverter.convert_shares(_want, address(basedToken), _amount);\r\n    }\r\n\r\n    // Only allows to earn some extra yield from non-core tokens\r\n    function earnExtra(address _token) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(converterMap[_token] != address(0), \"!converter\");\r\n        require(address(_token) != address(basedToken), \"3crv\");\r\n        require(address(_token) != address(this), \"mvUSD\");\r\n        require(wantTokenIndex[_token] == 0, \"wantToken\");\r\n        uint _amount = IERC20(_token).balanceOf(address(this));\r\n        address _converter = converterMap[_token];\r\n        IERC20(_token).safeTransfer(_converter, _amount);\r\n        Converter(_converter).convert(_token);\r\n    }\r\n\r\n    function withdraw_fee(uint _shares) public override view returns (uint) {\r\n        return (controller == address(0)) ? 0 : IMultiVaultController(controller).withdraw_fee(address(basedToken), _shares);\r\n    }\r\n\r\n    function calc_token_amount_deposit(uint[] calldata _amounts) external override view returns (uint) {\r\n        return basedConverter.calc_token_amount_deposit(_amounts).mul(1e18).div(getPricePerFullShare());\r\n    }\r\n\r\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\r\n        uint _withdrawFee = withdraw_fee(_shares);\r\n        if (_withdrawFee > 0) {\r\n            _shares = _shares.sub(_withdrawFee);\r\n        }\r\n        uint _totalSupply = totalSupply();\r\n        uint r = (_totalSupply == 0) ? _shares : (balance().mul(_shares)).div(_totalSupply);\r\n        if (_output == address(basedToken)) {\r\n            return r;\r\n        }\r\n        return basedConverter.calc_token_amount_withdraw(r, _output).mul(1e18).div(getPricePerFullShare());\r\n    }\r\n\r\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\r\n        return basedConverter.convert_rate(_input, address(basedToken), _amount).mul(1e18).div(getPricePerFullShare());\r\n    }\r\n\r\n    function deposit(address _input, uint _amount, uint _min_mint_amount) external override checkContract returns (uint) {\r\n        return depositFor(msg.sender, msg.sender, _input, _amount, _min_mint_amount);\r\n    }\r\n\r\n    function depositFor(address _account, address _to, address _input, uint _amount, uint _min_mint_amount) public override checkContract returns (uint _mint_amount) {\r\n        require(msg.sender == _account || msg.sender == vaultMaster.bank(address(this)), \"!bank && !yourself\");\r\n        uint _pool = balance();\r\n        require(totalDepositCap == 0 || _pool <= totalDepositCap, \">totalDepositCap\");\r\n        uint _before = 0;\r\n        uint _after = 0;\r\n        address _want = address(0);\r\n        address _ctrlWant = IMultiVaultController(controller).want();\r\n        if (_input == address(basedToken) || _input == _ctrlWant) {\r\n            _want = _want;\r\n            _before = IERC20(_input).balanceOf(address(this));\r\n            basedToken.safeTransferFrom(_account, address(this), _amount);\r\n            _after = IERC20(_input).balanceOf(address(this));\r\n            _amount = _after.sub(_before); // additional check for deflationary tokens\r\n        } else {\r\n            _want = input2Want[_input];\r\n            if (_want == address(0)) {\r\n                _want = _ctrlWant;\r\n            }\r\n            IMultiVaultConverter _converter = converters[_want];\r\n            require(_converter.convert_rate(_input, _want, _amount) > 0, \"rate=0\");\r\n            _before = IERC20(_want).balanceOf(address(this));\r\n            IERC20(_input).safeTransferFrom(_account, address(_converter), _amount);\r\n            _converter.convert(_input, _want, _amount);\r\n            _after = IERC20(_want).balanceOf(address(this));\r\n            _amount = _after.sub(_before); // additional check for deflationary tokens\r\n        }\r\n        require(_amount > 0, \"no _want\");\r\n        _mint_amount = _deposit(_to, _pool, _amount, _want);\r\n        require(_mint_amount >= _min_mint_amount, \"slippage\");\r\n    }\r\n\r\n    function depositAll(uint[] calldata _amounts, uint _min_mint_amount) external override checkContract returns (uint) {\r\n        return depositAllFor(msg.sender, msg.sender, _amounts, _min_mint_amount);\r\n    }\r\n\r\n    // Transfers tokens of all kinds\r\n    // 0: DAI, 1: USDC, 2: USDT, 3: 3CRV, 4: BUSD, 5: sUSD, 6: husd\r\n    function depositAllFor(address _account, address _to, uint[] calldata _amounts, uint _min_mint_amount) public override checkContract returns (uint _mint_amount) {\r\n        require(msg.sender == _account || msg.sender == vaultMaster.bank(address(this)), \"!bank && !yourself\");\r\n        uint _pool = balance();\r\n        require(totalDepositCap == 0 || _pool <= totalDepositCap, \">totalDepositCap\");\r\n        address _want = IMultiVaultController(controller).want();\r\n        IMultiVaultConverter _converter = converters[_want];\r\n        require(address(_converter) != address(0), \"!converter\");\r\n        uint _length = _amounts.length;\r\n        for (uint8 i = 0; i < _length; i++) {\r\n            uint _inputAmount = _amounts[i];\r\n            if (_inputAmount > 0) {\r\n                inputTokens[i].safeTransferFrom(_account, address(_converter), _inputAmount);\r\n            }\r\n        }\r\n        uint _before = IERC20(_want).balanceOf(address(this));\r\n        _converter.convertAll(_amounts);\r\n        uint _after = IERC20(_want).balanceOf(address(this));\r\n        uint _totalDepositAmount = _after.sub(_before); // additional check for deflationary tokens\r\n        _mint_amount = (_totalDepositAmount > 0) ? _deposit(_to, _pool, _totalDepositAmount, _want) : 0;\r\n        require(_mint_amount >= _min_mint_amount, \"slippage\");\r\n    }\r\n\r\n    function _deposit(address _mintTo, uint _pool, uint _amount, address _want) internal returns (uint _shares) {\r\n        uint _insuranceFee = vaultMaster.insuranceFee();\r\n        if (_insuranceFee > 0) {\r\n            uint _insurance = _amount.mul(_insuranceFee).div(10000);\r\n            _amount = _amount.sub(_insurance);\r\n            insurance = insurance.add(_insurance);\r\n        }\r\n\r\n        if (_want != address(basedToken)) {\r\n            _amount = shareConverter.convert_shares_rate(_want, address(basedToken), _amount);\r\n            if (_amount == 0) {\r\n                _amount = basedConverter.convert_rate(_want, address(basedToken), _amount); // try [stables_2_basedWant] if [share_2_share] failed\r\n            }\r\n        }\r\n\r\n        if (totalSupply() == 0) {\r\n            _shares = _amount;\r\n        } else {\r\n            _shares = (_amount.mul(totalSupply())).div(_pool);\r\n        }\r\n\r\n        if (_shares > 0) {\r\n            earn(_want);\r\n            _mint(_mintTo, _shares);\r\n        }\r\n    }\r\n\r\n    // Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\r\n    function harvest(address reserve, uint amount) external override {\r\n        require(msg.sender == controller, \"!controller\");\r\n        require(reserve != address(basedToken), \"basedToken\");\r\n        IERC20(reserve).safeTransfer(controller, amount);\r\n    }\r\n\r\n    function harvestStrategy(address _strategy) external override {\r\n        require(msg.sender == governance || msg.sender == vaultMaster.bank(address(this)), \"!governance && !bank\");\r\n        IMultiVaultController(controller).harvestStrategy(_strategy);\r\n    }\r\n\r\n    function harvestWant(address _want) external override {\r\n        require(msg.sender == governance || msg.sender == vaultMaster.bank(address(this)), \"!governance && !bank\");\r\n        IMultiVaultController(controller).harvestWant(_want);\r\n    }\r\n\r\n    function harvestAllStrategies() external override {\r\n        require(msg.sender == governance || msg.sender == vaultMaster.bank(address(this)), \"!governance && !bank\");\r\n        IMultiVaultController(controller).harvestAllStrategies();\r\n    }\r\n\r\n    function withdraw(uint _shares, address _output, uint _min_output_amount) external override returns (uint) {\r\n        return withdrawFor(msg.sender, _shares, _output, _min_output_amount);\r\n    }\r\n\r\n    // No rebalance implementation for lower fees and faster swaps\r\n    function withdrawFor(address _account, uint _shares, address _output, uint _min_output_amount) public override returns (uint _output_amount) {\r\n        _output_amount = (balance_to_sell().mul(_shares)).div(totalSupply());\r\n        _burn(msg.sender, _shares);\r\n\r\n        uint _withdrawalProtectionFee = vaultMaster.withdrawalProtectionFee();\r\n        if (_withdrawalProtectionFee > 0) {\r\n            uint _withdrawalProtection = _output_amount.mul(_withdrawalProtectionFee).div(10000);\r\n            _output_amount = _output_amount.sub(_withdrawalProtection);\r\n        }\r\n\r\n        // Check balance\r\n        uint b = basedToken.balanceOf(address(this));\r\n        if (b < _output_amount) {\r\n            uint _toWithdraw = _output_amount.sub(b);\r\n            uint _wantBal = IMultiVaultController(controller).wantStrategyBalance(address(basedToken));\r\n            if (_wantBal < _toWithdraw && allowWithdrawFromOtherWant[_output]) {\r\n                // if balance is not enough and we allow withdrawing from other wants\r\n                address _otherWant = input2Want[_output];\r\n                if (_otherWant != address(0) && _otherWant != address(basedToken)) {\r\n                    IMultiVaultConverter otherConverter = converters[_otherWant];\r\n                    if (address(otherConverter) != address(0)) {\r\n                        uint _toWithdrawOtherWant = shareConverter.convert_shares_rate(address(basedToken), _otherWant, _output_amount);\r\n                        _wantBal = IMultiVaultController(controller).wantStrategyBalance(_otherWant);\r\n                        if (_wantBal >= _toWithdrawOtherWant) {\r\n                            {\r\n                                uint _before = IERC20(_otherWant).balanceOf(address(this));\r\n                                uint _withdrawFee = IMultiVaultController(controller).withdraw(_otherWant, _toWithdrawOtherWant);\r\n                                uint _after = IERC20(_otherWant).balanceOf(address(this));\r\n                                _output_amount = _after.sub(_before);\r\n                                if (_withdrawFee > 0) {\r\n                                    _output_amount = _output_amount.sub(_withdrawFee, \"_output_amount < _withdrawFee\");\r\n                                }\r\n                            }\r\n                            if (_output != _otherWant) {\r\n                                require(otherConverter.convert_rate(_otherWant, _output, _output_amount) > 0, \"rate=0\");\r\n                                IERC20(_otherWant).safeTransfer(address(otherConverter), _output_amount);\r\n                                _output_amount = otherConverter.convert(_otherWant, _output, _output_amount);\r\n                            }\r\n                            require(_output_amount >= _min_output_amount, \"slippage\");\r\n                            IERC20(_output).safeTransfer(_account, _output_amount);\r\n                            return _output_amount;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            uint _withdrawFee = IMultiVaultController(controller).withdraw(address(basedToken), _toWithdraw);\r\n            uint _after = basedToken.balanceOf(address(this));\r\n            uint _diff = _after.sub(b);\r\n            if (_diff < _toWithdraw) {\r\n                _output_amount = b.add(_diff);\r\n            }\r\n            if (_withdrawFee > 0) {\r\n                _output_amount = _output_amount.sub(_withdrawFee, \"_output_amount < _withdrawFee\");\r\n            }\r\n        }\r\n\r\n        if (_output == address(basedToken)) {\r\n            require(_output_amount >= _min_output_amount, \"slippage\");\r\n            basedToken.safeTransfer(_account, _output_amount);\r\n        } else {\r\n            require(basedConverter.convert_rate(address(basedToken), _output, _output_amount) > 0, \"rate=0\");\r\n            basedToken.safeTransfer(address(basedConverter), _output_amount);\r\n            uint _outputAmount = basedConverter.convert(address(basedToken), _output, _output_amount);\r\n            require(_outputAmount >= _min_output_amount, \"slippage\");\r\n            IERC20(_output).safeTransfer(_account, _outputAmount);\r\n        }\r\n    }\r\n\r\n    function getPricePerFullShare() public override view returns (uint) {\r\n        return (totalSupply() == 0) ? 1e18 : balance().mul(1e18).div(totalSupply());\r\n    }\r\n\r\n    // @dev average dollar value of vault share token\r\n    function get_virtual_price() external override view returns (uint) {\r\n        return basedConverter.get_virtual_price().mul(getPricePerFullShare()).div(1e18);\r\n    }\r\n\r\n    /**\r\n     * This function allows governance to take unsupported tokens out of the contract. This is in an effort to make someone whole, should they seriously mess up.\r\n     * There is no guarantee governance will vote to return these. It also allows for removal of airdropped tokens.\r\n     */\r\n    function governanceRecoverUnsupported(IERC20 _token, uint amount, address to) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(address(_token) != address(basedToken), \"3crv\");\r\n        require(address(_token) != address(this), \"mvUSD\");\r\n        require(wantTokenIndex[address(_token)] == 0, \"wantToken\");\r\n        _token.safeTransfer(to, amount);\r\n    }\r\n}"}
{"address": "0xc9f27a50f82571c1c8423a42970613b8dbda14ef", "attacktype": "Reentrancy, Visibility errors, including unrestricted action, Delegatecall injection", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RewardsHypervisor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IVisor.sol\\\";\\nimport \\\"./vVISR.sol\\\";\\n\\n// @title Rewards Hypervisor\\n// @notice fractionalize balance \\ncontract RewardsHypervisor {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    address public owner;\\n    IERC20 public visr;\\n    vVISR public vvisr;\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _visr,\\n        address _vvisr\\n    ) {\\n        visr = IERC20(_visr);\\n        vvisr = vVISR(_vvisr);\\n        owner = msg.sender;\\n    }\\n\\n    // @param visr Amount of VISR transfered from sender to Hypervisor\\n    // @param to Address to which liquidity tokens are minted\\n    // @param from Address from which tokens are transferred \\n    // @return shares Quantity of liquidity tokens minted as a result of deposit\\n    function deposit(\\n        uint256 visrDeposit,\\n        address payable from,\\n        address to\\n    ) external returns (uint256 shares) {\\n        require(visrDeposit > 0, \\\"deposits must be nonzero\\\");\\n        require(to != address(0) && to != address(this), \\\"to\\\");\\n        require(from != address(0) && from != address(this), \\\"from\\\");\\n\\n        shares = visrDeposit;\\n        if (vvisr.totalSupply() != 0) {\\n          uint256 visrBalance = visr.balanceOf(address(this));\\n          shares = shares.mul(vvisr.totalSupply()).div(visrBalance);\\n        }\\n\\n        if(isContract(from)) {\\n          require(IVisor(from).owner() == msg.sender); \\n          IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);\\n        }\\n        else {\\n          visr.safeTransferFrom(from, address(this), visrDeposit);\\n        }\\n\\n        vvisr.mint(to, shares);\\n    }\\n\\n    // @param shares Number of rewards shares to redeem for VISR\\n    // @param to Address to which redeemed pool assets are sent\\n    // @param from Address from which liquidity tokens are sent\\n    // @return rewards Amount of visr redeemed by the submitted liquidity tokens\\n    function withdraw(\\n        uint256 shares,\\n        address to,\\n        address payable from\\n    ) external returns (uint256 rewards) {\\n        require(shares > 0, \\\"shares\\\");\\n        require(to != address(0), \\\"to\\\");\\n        require(from != address(0), \\\"from\\\");\\n\\n        rewards = visr.balanceOf(address(this)).mul(shares).div(vvisr.totalSupply());\\n        visr.safeTransfer(to, rewards);\\n\\n        require(from == msg.sender || IVisor(from).owner() == msg.sender, \\\"Sender must own the tokens\\\");\\n        vvisr.burn(from, shares);\\n    }\\n\\n    function snapshot() external onlyOwner {\\n      vvisr.snapshot();\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n      owner = newOwner;\\n    }\\n\\n    function transferTokenOwnership(address newOwner) external onlyOwner {\\n      vvisr.transferOwnership(newOwner); \\n    }\\n\\n    function isContract(address _addr) private returns (bool isContract){\\n\\t\\t\\t\\tuint32 size;\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tsize := extcodesize(_addr)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn (size > 0);\\n\\t\\t}\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVisor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\ninterface IVisor {\\n    function owner() external returns(address);\\n    function delegatedTransferERC20( address token, address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vVISR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/drafts/ERC20Permit.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol\\\";\\n\\ncontract vVISR is ERC20Permit, ERC20Snapshot {\\n\\n    address public owner;\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals\\n    ) ERC20Permit(name) ERC20(name, symbol){\\n      owner = msg.sender;\\n      _setupDecimals(decimals);\\n    }\\n\\n    function mint(address account, uint256 amount) onlyOwner external {\\n      _mint(account, amount);\\n    }\\n\\n    function burn(address account, uint256 amount) onlyOwner external {\\n      _burn(account, amount);\\n    }\\n\\n    function snapshot() onlyOwner external {\\n      _snapshot();\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n      owner = newOwner;\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override(ERC20, ERC20Snapshot) {\\n      super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/drafts/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.5 <0.8.0;\\n\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"../cryptography/ECDSA.sol\\\";\\nimport \\\"../utils/Counters.sol\\\";\\nimport \\\"./EIP712.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping (address => Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) internal EIP712(name, \\\"1\\\") {\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\\n        // solhint-disable-next-line not-rely-on-time\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                _PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                value,\\n                _nonces[owner].current(),\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _nonces[owner].increment();\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Arrays.sol\\\";\\nimport \\\"../../utils/Counters.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\nabstract contract ERC20Snapshot is ERC20 {\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using SafeMath for uint256;\\n    using Arrays for uint256[];\\n    using Counters for Counters.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping (address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    Counters.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _currentSnapshotId.current();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns(uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n      super._beforeTokenTransfer(from, to, amount);\\n\\n      if (from == address(0)) {\\n        // mint\\n        _updateAccountSnapshot(to);\\n        _updateTotalSupplySnapshot();\\n      } else if (to == address(0)) {\\n        // burn\\n        _updateAccountSnapshot(from);\\n        _updateTotalSupplySnapshot();\\n      } else {\\n        // transfer\\n        _updateAccountSnapshot(from);\\n        _updateAccountSnapshot(to);\\n      }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\\n        private view returns (bool, uint256)\\n    {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(snapshotId <= _currentSnapshotId.current(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _currentSnapshotId.current();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/drafts/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/drafts/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) internal {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = _getChainId();\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\\n        if (_getChainId() == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                typeHash,\\n                name,\\n                version,\\n                _getChainId(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparatorV4(), structHash));\\n    }\\n\\n    function _getChainId() private view returns (uint256 chainId) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n   /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x0eee3e3828a45f7601d5f54bf49bb01d1a9df5ea", "attacktype": "Token standard incompatibility, Reentrancy", "sourcecode": "pragma solidity ^0.4.24;\r\ncontract PriceOracleInterface {\r\n\r\n    /**\r\n      * @notice Gets the price of a given asset\r\n      * @dev fetches the price of a given asset\r\n      * @param asset Asset to get the price of\r\n      * @return the price scaled by 10**18, or zero if the price is not available\r\n      */\r\n    function assetPrices(address asset) public view returns (uint);\r\n}\r\ncontract ErrorReporter {\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\r\n        UNAUTHORIZED,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW,\r\n        DIVISION_BY_ZERO,\r\n        BAD_INPUT,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_TRANSFER_FAILED,\r\n        MARKET_NOT_SUPPORTED,\r\n        SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_RATE_CALCULATION_FAILED,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_OUT_FAILED,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INSUFFICIENT_BALANCE,\r\n        INVALID_COLLATERAL_RATIO,\r\n        MISSING_ASSET_PRICE,\r\n        EQUITY_INSUFFICIENT_BALANCE,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        ASSET_NOT_PRICED,\r\n        INVALID_LIQUIDATION_DISCOUNT,\r\n        INVALID_COMBINED_RISK_PARAMETERS,\r\n        ZERO_ORACLE_ADDRESS,\r\n        CONTRACT_PAUSED\r\n    }\r\n\r\n    /*\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        BORROW_CONTRACT_PAUSED,\r\n        BORROW_MARKET_NOT_SUPPORTED,\r\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\r\n        BORROW_TRANSFER_OUT_FAILED,\r\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\r\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\r\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\r\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\r\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\r\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\r\n        LIQUIDATE_CONTRACT_PAUSED,\r\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\r\n        LIQUIDATE_TRANSFER_IN_FAILED,\r\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_CONTRACT_PAUSED,\r\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_ASSET_PRICE_CHECK_ORACLE,\r\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_ORACLE_OWNER_CHECK,\r\n        SET_ORIGINATION_FEE_OWNER_CHECK,\r\n        SET_PAUSED_OWNER_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_VALIDATION,\r\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_CONTRACT_PAUSED,\r\n        SUPPLY_MARKET_NOT_SUPPORTED,\r\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        SUPPLY_TRANSFER_IN_FAILED,\r\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\r\n        SUPPORT_MARKET_FETCH_PRICE_FAILED,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SUPPORT_MARKET_PRICE_CHECK,\r\n        SUSPEND_MARKET_OWNER_CHECK,\r\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\r\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\r\n        WITHDRAW_CONTRACT_PAUSED,\r\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\r\n    }\r\n\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\r\n\r\n        return uint(Error.OPAQUE_ERROR);\r\n    }\r\n\r\n}\r\ncontract InterestRateModel {\r\n\r\n    /**\r\n      * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\r\n      * @dev The return value should be scaled by 1e18, thus a return value of\r\n      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n      * @param asset The asset to get the interest rate of\r\n      * @param cash The total cash of the asset in the market\r\n      * @param borrows The total borrows of the asset in the market\r\n      * @return Success or failure and the supply interest rate per block scaled by 10e18\r\n      */\r\n    function getSupplyRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\r\n\r\n    /**\r\n      * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\r\n      * @dev The return value should be scaled by 1e18, thus a return value of\r\n      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n      * @param asset The asset to get the interest rate of\r\n      * @param cash The total cash of the asset in the market\r\n      * @param borrows The total borrows of the asset in the market\r\n      * @return Success or failure and the borrow interest rate per block scaled by 10e18\r\n      */\r\n    function getBorrowRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\r\n}\r\ncontract EIP20Interface {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract EIP20NonStandardInterface {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public;\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public;\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract CarefulMath is ErrorReporter {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (a == 0) {\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (b == 0) {\r\n            return (Error.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\r\n        if (b <= a) {\r\n            return (Error.NO_ERROR, a - b);\r\n        } else {\r\n            return (Error.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function add(uint a, uint b) internal pure returns (Error, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (Error.NO_ERROR, c);\r\n        } else {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\r\n        (Error err0, uint sum) = add(a, b);\r\n\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return sub(sum, c);\r\n    }\r\n}\r\ncontract SafeToken is ErrorReporter {\r\n\r\n    /**\r\n      * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and\r\n      *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.\r\n      */\r\n    function checkTransferIn(address asset, address from, uint amount) internal view returns (Error) {\r\n\r\n        EIP20Interface token = EIP20Interface(asset);\r\n\r\n        if (token.allowance(from, address(this)) < amount) {\r\n            return Error.TOKEN_INSUFFICIENT_ALLOWANCE;\r\n        }\r\n\r\n        if (token.balanceOf(from) < amount) {\r\n            return Error.TOKEN_INSUFFICIENT_BALANCE;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and returns an explanatory\r\n      *      error code rather than reverting.  If caller has not called `checkTransferIn`, this may revert due to\r\n      *      insufficient balance or insufficient allowance. If caller has called `checkTransferIn` prior to this call,\r\n      *      and it returned Error.NO_ERROR, this should not revert in normal conditions.\r\n      *\r\n      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n      */\r\n    function doTransferIn(address asset, address from, uint amount) internal returns (Error) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\r\n\r\n        bool result;\r\n\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard ERC-20\r\n                    result := not(0)          // set result to true\r\n                }\r\n                case 32 {                     // This is a complaint ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)        // Set `result = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n\r\n        if (!result) {\r\n            return Error.TOKEN_TRANSFER_FAILED;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n      * @dev Checks balance of this contract in asset\r\n      */\r\n    function getCash(address asset) internal view returns (uint) {\r\n        EIP20Interface token = EIP20Interface(asset);\r\n\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n      * @dev Checks balance of `from` in `asset`\r\n      */\r\n    function getBalanceOf(address asset, address from) internal view returns (uint) {\r\n        EIP20Interface token = EIP20Interface(asset);\r\n\r\n        return token.balanceOf(from);\r\n    }\r\n\r\n    /**\r\n      * @dev Similar to EIP20 transfer, except it handles a False result from `transfer` and returns an explanatory\r\n      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\r\n      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\r\n      *      it is >= amount, this should not revert in normal conditions.\r\n      *\r\n      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n      */\r\n    function doTransferOut(address asset, address to, uint amount) internal returns (Error) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\r\n\r\n        bool result;\r\n\r\n        token.transfer(to, amount);\r\n\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard ERC-20\r\n                    result := not(0)          // set result to true\r\n                }\r\n                case 32 {                     // This is a complaint ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    result := mload(0)        // Set `result = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n\r\n        if (!result) {\r\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\r\n        }\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n}\r\ncontract Exponential is ErrorReporter, CarefulMath {\r\n\r\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\r\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\r\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\r\n    uint constant expScale = 10**18;\r\n\r\n    // See TODO on expScale\r\n    uint constant halfExpScale = expScale/2;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    uint constant mantissaOne = 10**18;\r\n    uint constant mantissaOneTenth = 10**17;\r\n\r\n    /**\r\n    * @dev Creates an exponential from numerator and denominator values.\r\n    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n    *            or if `denom` is zero.\r\n    */\r\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err1, uint rational) = div(scaledNumerator, denom);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two exponentials, returning a new exponential.\r\n    */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two exponentials, returning a new exponential.\r\n    */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n    * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n    */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n    * @dev Divide an Exp by a scalar, returning a new Exp.\r\n    */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\r\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n    * @dev Divide a scalar by an Exp, returning a new Exp.\r\n    */\r\n    function divScalarByExp(uint scalar, Exp divisor) pure internal returns (Error, Exp memory) {\r\n        /*\r\n            We are doing this as:\r\n            getExp(mul(expScale, scalar), divisor.mantissa)\r\n\r\n            How it works:\r\n            Exp = a / b;\r\n            Scalar = s;\r\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (Error err0, uint numerator) = mul(expScale, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two exponentials, returning a new exponential.\r\n    */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n\r\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == Error.NO_ERROR);\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n      * @dev Divides two exponentials, returning a new exponential.\r\n      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n      */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n      * @dev Truncates the given exp to a whole number value.\r\n      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\r\n      */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / 10**18;\r\n    }\r\n\r\n    /**\r\n      * @dev Checks if first Exp is less than second Exp.\r\n      */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\r\n    }\r\n\r\n    /**\r\n      * @dev Checks if left Exp <= right Exp.\r\n      */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if Exp is exactly zero\r\n      */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\ncontract MoneyMarket is Exponential, SafeToken {\r\n\r\n    uint constant initialInterestIndex = 10 ** 18;\r\n    uint constant defaultOriginationFee = 0; // default is zero bps\r\n\r\n    uint constant minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\r\n    uint constant maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\r\n\r\n    /**\r\n      * @notice `MoneyMarket` is the core Compound MoneyMarket contract\r\n      */\r\n    constructor() public {\r\n        admin = msg.sender;\r\n        collateralRatio = Exp({mantissa: 2 * mantissaOne});\r\n        originationFee = Exp({mantissa: defaultOriginationFee});\r\n        liquidationDiscount = Exp({mantissa: 0});\r\n        // oracle must be configured via _setOracle\r\n    }\r\n\r\n    /**\r\n      * @notice Do not pay directly into MoneyMarket, please use `supply`.\r\n      */\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n      * @dev pending Administrator for this contract.\r\n      */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n      * @dev Administrator for this contract. Initially set in constructor, but can\r\n      *      be changed by the admin itself.\r\n      */\r\n    address public admin;\r\n\r\n    /**\r\n      * @dev Account allowed to set oracle prices for this contract. Initially set\r\n      *      in constructor, but can be changed by the admin.\r\n      */\r\n    address public oracle;\r\n\r\n    /**\r\n      * @dev Container for customer balance information written to storage.\r\n      *\r\n      *      struct Balance {\r\n      *        principal = customer total balance with accrued interest after applying the customer's most recent balance-changing action\r\n      *        interestIndex = the total interestIndex as calculated after applying the customer's most recent balance-changing action\r\n      *      }\r\n      */\r\n    struct Balance {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    /**\r\n      * @dev 2-level map: customerAddress -> assetAddress -> balance for supplies\r\n      */\r\n    mapping(address => mapping(address => Balance)) public supplyBalances;\r\n\r\n\r\n    /**\r\n      * @dev 2-level map: customerAddress -> assetAddress -> balance for borrows\r\n      */\r\n    mapping(address => mapping(address => Balance)) public borrowBalances;\r\n\r\n\r\n    /**\r\n      * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\r\n      *\r\n      *      struct Market {\r\n      *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\r\n      *         blockNumber = when the other values in this struct were calculated\r\n      *         totalSupply = total amount of this asset supplied (in asset wei)\r\n      *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\r\n      *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\r\n      *         totalBorrows = total amount of this asset borrowed (in asset wei)\r\n      *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\r\n      *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\r\n      *     }\r\n      */\r\n    struct Market {\r\n        bool isSupported;\r\n        uint blockNumber;\r\n        InterestRateModel interestRateModel;\r\n\r\n        uint totalSupply;\r\n        uint supplyRateMantissa;\r\n        uint supplyIndex;\r\n\r\n        uint totalBorrows;\r\n        uint borrowRateMantissa;\r\n        uint borrowIndex;\r\n    }\r\n\r\n    /**\r\n      * @dev map: assetAddress -> Market\r\n      */\r\n    mapping(address => Market) public markets;\r\n\r\n    /**\r\n      * @dev list: collateralMarkets\r\n      */\r\n    address[] public collateralMarkets;\r\n\r\n    /**\r\n      * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\r\n      *      is initially set in the constructor, but can be changed by the admin.\r\n      */\r\n    Exp public collateralRatio;\r\n\r\n    /**\r\n      * @dev originationFee for new borrows.\r\n      *\r\n      */\r\n    Exp public originationFee;\r\n\r\n    /**\r\n      * @dev liquidationDiscount for collateral when liquidating borrows\r\n      *\r\n      */\r\n    Exp public liquidationDiscount;\r\n\r\n    /**\r\n      * @dev flag for whether or not contract is paused\r\n      *\r\n      */\r\n    bool public paused;\r\n\r\n\r\n    /**\r\n      * @dev emitted when a supply is received\r\n      *      Note: newBalance - amount - startingBalance = interest accumulated since last change\r\n      */\r\n    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\r\n\r\n    /**\r\n      * @dev emitted when a supply is withdrawn\r\n      *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\r\n      */\r\n    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\r\n\r\n    /**\r\n      * @dev emitted when a new borrow is taken\r\n      *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\r\n      */\r\n    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\r\n\r\n    /**\r\n      * @dev emitted when a borrow is repaid\r\n      *      Note: newBalance - amount - startingBalance = interest accumulated since last change\r\n      */\r\n    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\r\n\r\n    /**\r\n      * @dev emitted when a borrow is liquidated\r\n      *      targetAccount = user whose borrow was liquidated\r\n      *      assetBorrow = asset borrowed\r\n      *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\r\n      *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\r\n      *      amountRepaid = amount of borrow repaid\r\n      *      liquidator = account requesting the liquidation\r\n      *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\r\n      *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\r\n      *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\r\n      *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\r\n      *      amountSeized = amount of collateral seized by liquidator\r\n      *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\r\n      */\r\n    event BorrowLiquidated(address targetAccount,\r\n        address assetBorrow,\r\n        uint borrowBalanceBefore,\r\n        uint borrowBalanceAccumulated,\r\n        uint amountRepaid,\r\n        uint borrowBalanceAfter,\r\n        address liquidator,\r\n        address assetCollateral,\r\n        uint collateralBalanceBefore,\r\n        uint collateralBalanceAccumulated,\r\n        uint amountSeized,\r\n        uint collateralBalanceAfter);\r\n\r\n    /**\r\n      * @dev emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @dev emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    /**\r\n      * @dev newOracle - address of new oracle\r\n      */\r\n    event NewOracle(address oldOracle, address newOracle);\r\n\r\n    /**\r\n      * @dev emitted when new market is supported by admin\r\n      */\r\n    event SupportedMarket(address asset, address interestRateModel);\r\n\r\n    /**\r\n      * @dev emitted when risk parameters are changed by admin\r\n      */\r\n    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa);\r\n\r\n    /**\r\n      * @dev emitted when origination fee is changed by admin\r\n      */\r\n    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\r\n\r\n    /**\r\n      * @dev emitted when market has new interest rate model set\r\n      */\r\n    event SetMarketInterestRateModel(address asset, address interestRateModel);\r\n\r\n    /**\r\n      * @dev emitted when admin withdraws equity\r\n      * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\r\n      */\r\n    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\r\n\r\n    /**\r\n      * @dev emitted when a supported market is suspended by admin\r\n      */\r\n    event SuspendedMarket(address asset);\r\n\r\n    /**\r\n      * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\r\n      */\r\n    event SetPaused(bool newState);\r\n\r\n    /**\r\n      * @dev Simple function to calculate min between two numbers.\r\n      */\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        if (a < b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev Function to simply retrieve block number\r\n      *      This exists mainly for inheriting test contracts to stub this result.\r\n      */\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n      * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\r\n      *      Note: this will not add the asset if it already exists.\r\n      */\r\n    function addCollateralMarket(address asset) internal {\r\n        for (uint i = 0; i < collateralMarkets.length; i++) {\r\n            if (collateralMarkets[i] == asset) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        collateralMarkets.push(asset);\r\n    }\r\n\r\n    /**\r\n      * @notice return the number of elements in `collateralMarkets`\r\n      * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\r\n      * @return the length of `collateralMarkets`\r\n      */\r\n    function getCollateralMarketsLength() public view returns (uint) {\r\n        return collateralMarkets.length;\r\n    }\r\n\r\n    /**\r\n      * @dev Calculates a new supply index based on the prevailing interest rates applied over time\r\n      *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\r\n      */\r\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\r\n\r\n        // Get the block delta\r\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        // Scale the interest rate times number of blocks\r\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\r\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, 0);\r\n        }\r\n\r\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\r\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\r\n        if (err2 != Error.NO_ERROR) {\r\n            return (err2, 0);\r\n        }\r\n\r\n        // Then scale that accumulated interest by the old interest index to get the new interest index\r\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\r\n        if (err3 != Error.NO_ERROR) {\r\n            return (err3, 0);\r\n        }\r\n\r\n        // Finally, truncate the interest index. This works only if interest index starts large enough\r\n        // that is can be accurately represented with a whole number.\r\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\r\n    }\r\n\r\n    /**\r\n      * @dev Calculates a new balance based on a previous balance and a pair of interest indices\r\n      *      This is defined as: `The user's last balance checkpoint is multiplied by the currentSupplyIndex\r\n      *      value and divided by the user's checkpoint index value`\r\n      *\r\n      *      TODO: Is there a way to handle this that is less likely to overflow?\r\n      */\r\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\r\n        if (startingBalance == 0) {\r\n            // We are accumulating interest on any previous balance; if there's no previous balance, then there is\r\n            // nothing to accumulate.\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return div(balanceTimesIndex, interestIndexStart);\r\n    }\r\n\r\n    /**\r\n      * @dev Gets the price for the amount specified of the given asset.\r\n      */\r\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\r\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, Exp({mantissa: 0}));\r\n        }\r\n\r\n        if (isZeroExp(assetPrice)) {\r\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\r\n    }\r\n\r\n    /**\r\n      * @dev Gets the price for the amount specified of the given asset multiplied by the current\r\n      *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\r\n      *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\r\n      */\r\n    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\r\n        Error err;\r\n        Exp memory assetPrice;\r\n        Exp memory scaledPrice;\r\n        (err, assetPrice) = fetchAssetPrice(asset);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, Exp({mantissa: 0}));\r\n        }\r\n\r\n        if (isZeroExp(assetPrice)) {\r\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // Now, multiply the assetValue by the collateral ratio\r\n        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // Get the price for the given asset amount\r\n        return mulScalar(scaledPrice, assetAmount);\r\n    }\r\n\r\n    /**\r\n      * @dev Calculates the origination fee added to a given borrowAmount\r\n      *      This is simply `(1 + originationFee) * borrowAmount`\r\n      *\r\n      *      TODO: Track at what magnitude this fee rounds down to zero?\r\n      */\r\n    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\r\n        // When origination fee is zero, the amount with fee is simply equal to the amount\r\n        if (isZeroExp(originationFee)) {\r\n            return (Error.NO_ERROR, borrowAmount);\r\n        }\r\n\r\n        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\r\n    }\r\n\r\n    /**\r\n      * @dev fetches the price of asset from the PriceOracle and converts it to Exp\r\n      * @param asset asset whose price should be fetched\r\n      */\r\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\r\n        if (oracle == address(0)) {\r\n            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\r\n        }\r\n\r\n        PriceOracleInterface oracleInterface = PriceOracleInterface(oracle);\r\n        uint priceMantissa = oracleInterface.assetPrices(asset);\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\r\n    }\r\n\r\n    /**\r\n      * @notice Reads scaled price of specified asset from the price oracle\r\n      * @dev Reads scaled price of specified asset from the price oracle.\r\n      *      The plural name is to match a previous storage mapping that this function replaced.\r\n      * @param asset Asset whose price should be retrieved\r\n      * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\r\n      */\r\n    function assetPrices(address asset) public view returns (uint) {\r\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\r\n        if (err != Error.NO_ERROR) {\r\n            return 0;\r\n        }\r\n        return result.mantissa;\r\n    }\r\n\r\n    /**\r\n      * @dev Gets the amount of the specified asset given the specified Eth value\r\n      *      ethValue / oraclePrice = assetAmountWei\r\n      *      If there's no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\r\n      */\r\n    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\r\n        Error err;\r\n        Exp memory assetPrice;\r\n        Exp memory assetAmount;\r\n\r\n        (err, assetPrice) = fetchAssetPrice(asset);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, assetAmount) = divExp(ethValue, assetPrice);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, truncate(assetAmount));\r\n    }\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      *\r\n      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n        // Store pendingAdmin = newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller = pendingAdmin\r\n        // msg.sender can't be zero\r\n        if (msg.sender != pendingAdmin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldAdmin = admin;\r\n        // Store admin = pendingAdmin\r\n        admin = pendingAdmin;\r\n        // Clear the pending value\r\n        pendingAdmin = 0;\r\n\r\n        emit NewAdmin(oldAdmin, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Set new oracle, who can set asset prices\r\n      * @dev Admin function to change oracle\r\n      * @param newOracle New oracle address\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setOracle(address newOracle) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify contract at newOracle address supports assetPrices call.\r\n        // This will revert if it doesn't.\r\n        PriceOracleInterface oracleInterface = PriceOracleInterface(newOracle);\r\n        oracleInterface.assetPrices(address(0));\r\n\r\n        address oldOracle = oracle;\r\n\r\n        // Store oracle = newOracle\r\n        oracle = newOracle;\r\n\r\n        emit NewOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice set `paused` to the specified state\r\n      * @dev Admin function to pause or resume the market\r\n      * @param requestedState value to assign to `paused`\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPaused(bool requestedState) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\r\n        }\r\n\r\n        paused = requestedState;\r\n        emit SetPaused(requestedState);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice returns the liquidity for given account.\r\n      *         a positive result indicates ability to borrow, whereas\r\n      *         a negative result indicates a shortfall which may be liquidated\r\n      * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\r\n      *      note: this includes interest trued up on all balances\r\n      * @param account the account to examine\r\n      * @return signed integer in terms of eth-wei (negative indicates a shortfall)\r\n      */\r\n    function getAccountLiquidity(address account) public view returns (int) {\r\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        if (isZeroExp(accountLiquidity)) {\r\n            return -1 * int(truncate(accountShortfall));\r\n        } else {\r\n            return int(truncate(accountLiquidity));\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\r\n      * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\r\n      * @param account the account to examine\r\n      * @param asset the market asset whose supply balance belonging to `account` should be checked\r\n      * @return uint supply balance on success, throws on failed assertion otherwise\r\n      */\r\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\r\n        Error err;\r\n        uint newSupplyIndex;\r\n        uint userSupplyCurrent;\r\n\r\n        Market storage market = markets[asset];\r\n        Balance storage supplyBalance = supplyBalances[account][asset];\r\n\r\n        // Calculate the newSupplyIndex, needed to calculate user's supplyCurrent\r\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\r\n        require(err == Error.NO_ERROR);\r\n\r\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\r\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        return userSupplyCurrent;\r\n    }\r\n\r\n    /**\r\n      * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\r\n      * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\r\n      * @param account the account to examine\r\n      * @param asset the market asset whose borrow balance belonging to `account` should be checked\r\n      * @return uint borrow balance on success, throws on failed assertion otherwise\r\n      */\r\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\r\n        Error err;\r\n        uint newBorrowIndex;\r\n        uint userBorrowCurrent;\r\n\r\n        Market storage market = markets[asset];\r\n        Balance storage borrowBalance = borrowBalances[account][asset];\r\n\r\n        // Calculate the newBorrowIndex, needed to calculate user's borrowCurrent\r\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\r\n        require(err == Error.NO_ERROR);\r\n\r\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\r\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\r\n        require(err == Error.NO_ERROR);\r\n\r\n        return userBorrowCurrent;\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Supports a given market (asset) for use with Compound\r\n      * @dev Admin function to add support for a market\r\n      * @param asset Asset to support; MUST already have a non-zero price set\r\n      * @param interestRateModel InterestRateModel to use for the asset\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        }\r\n\r\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\r\n        }\r\n\r\n        if (isZeroExp(assetPrice)) {\r\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\r\n        }\r\n\r\n        // Set the interest rate model to `modelAddress`\r\n        markets[asset].interestRateModel = interestRateModel;\r\n\r\n        // Append asset to collateralAssets if not set\r\n        addCollateralMarket(asset);\r\n\r\n        // Set market isSupported to true\r\n        markets[asset].isSupported = true;\r\n\r\n        // Default supply and borrow index to 1e18\r\n        if (markets[asset].supplyIndex == 0) {\r\n            markets[asset].supplyIndex = initialInterestIndex;\r\n        }\r\n\r\n        if (markets[asset].borrowIndex == 0) {\r\n            markets[asset].borrowIndex = initialInterestIndex;\r\n        }\r\n\r\n        emit SupportedMarket(asset, interestRateModel);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Suspends a given *supported* market (asset) from use with Compound.\r\n      *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\r\n      *         and liquidate the asset. The liquidate function no longer checks collateralization.\r\n      * @dev Admin function to suspend a market\r\n      * @param asset Asset to suspend\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _suspendMarket(address asset) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\r\n        }\r\n\r\n        // If the market is not configured at all, we don't want to add any configuration for it.\r\n        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\r\n        // has already been marked as unsupported. We can just return without doing anything.\r\n        // Caller is responsible for knowing the difference between not-configured and already unsupported.\r\n        if (!markets[asset].isSupported) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        // If we get here, we know market is configured and is supported, so set isSupported to false\r\n        markets[asset].isSupported = false;\r\n\r\n        emit SuspendedMarket(asset);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the risk parameters: collateral ratio and liquidation discount\r\n      * @dev Owner function to set the risk parameters\r\n      * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be >= 1.1\r\n      * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be <= 0.1 and must be less than (descaled collateral ratio minus 1)\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\r\n        }\r\n\r\n        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\r\n        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\r\n        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\r\n        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\r\n\r\n        Error err;\r\n        Exp memory newLiquidationDiscountPlusOne;\r\n\r\n        // Make sure new collateral ratio value is not below minimum value\r\n        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\r\n            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\r\n        }\r\n\r\n        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\r\n        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\r\n        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\r\n            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\r\n        }\r\n\r\n        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\r\n        // C < L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\r\n        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\r\n        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\r\n\r\n        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\r\n            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\r\n        }\r\n\r\n        // Save current values so we can emit them in log.\r\n        Exp memory oldCollateralRatio = collateralRatio;\r\n        Exp memory oldLiquidationDiscount = liquidationDiscount;\r\n\r\n        // Store new values\r\n        collateralRatio = newCollateralRatio;\r\n        liquidationDiscount = newLiquidationDiscount;\r\n\r\n        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the origination fee (which is a multiplier on new borrows)\r\n      * @dev Owner function to set the origination fee\r\n      * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be >= 1.1\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value so we can emit it in log.\r\n        Exp memory oldOriginationFee = originationFee;\r\n\r\n        originationFee = Exp({mantissa: originationFeeMantissa});\r\n\r\n        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the interest rate model for a given market\r\n      * @dev Admin function to set interest rate model\r\n      * @param asset Asset to support\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\r\n        }\r\n\r\n        // Set the interest rate model to `modelAddress`\r\n        markets[asset].interestRateModel = interestRateModel;\r\n\r\n        emit SetMarketInterestRateModel(asset, interestRateModel);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` <= equity. Equity= cash - (supply + borrows)\r\n      * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount <= cash - (supply + borrows)\r\n      * @param asset asset whose equity should be withdrawn\r\n      * @param amount amount of equity to withdraw; must not exceed equity available\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _withdrawEquity(address asset, uint amount) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\r\n        }\r\n\r\n        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\r\n        uint cash = getCash(asset);\r\n        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\r\n        }\r\n\r\n        if (amount > equity) {\r\n            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // We ERC-20 transfer the asset out of the protocol to the admin\r\n        Error err2 = doTransferOut(asset, admin, amount);\r\n        if (err2 != Error.NO_ERROR) {\r\n            // This is safe since it's our first interaction and it didn't do anything if it failed\r\n            return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\r\n        }\r\n\r\n        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\r\n        emit EquityWithdrawn(asset, equity, amount, admin);\r\n\r\n        return uint(Error.NO_ERROR); // success\r\n    }\r\n\r\n    /**\r\n      * The `SupplyLocalVars` struct is used internally in the `supply` function.\r\n      *\r\n      * To avoid solidity limits on the number of local variables we:\r\n      * 1. Use a struct to hold local computation localResults\r\n      * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\r\n      *    requires either both to be declared inline or both to be previously declared.\r\n      * 3. Re-use a boolean error-like return variable.\r\n      */\r\n    struct SupplyLocalVars {\r\n        uint startingBalance;\r\n        uint newSupplyIndex;\r\n        uint userSupplyCurrent;\r\n        uint userSupplyUpdated;\r\n        uint newTotalSupply;\r\n        uint currentCash;\r\n        uint updatedCash;\r\n        uint newSupplyRateMantissa;\r\n        uint newBorrowIndex;\r\n        uint newBorrowRateMantissa;\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\r\n      * @dev add amount of supported asset to msg.sender's account\r\n      * @param asset The market asset to supply\r\n      * @param amount The amount to supply\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function supply(address asset, uint amount) public returns (uint) {\r\n        if (paused) {\r\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\r\n        }\r\n\r\n        Market storage market = markets[asset];\r\n        Balance storage balance = supplyBalances[msg.sender][asset];\r\n\r\n        SupplyLocalVars memory localResults; // Holds all our uint calculation results\r\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\r\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\r\n\r\n        // Fail if market not supported\r\n        if (!market.isSupported) {\r\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\r\n        }\r\n\r\n        // Fail gracefully if asset is not approved or has insufficient balance\r\n        err = checkTransferIn(asset, msg.sender, amount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\r\n        }\r\n\r\n        // We calculate the newSupplyIndex, user's supplyCurrent and supplyUpdated for the asset\r\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply\r\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We need to calculate what the updated cash will be after we transfer in from user\r\n        localResults.currentCash = getCash(asset);\r\n\r\n        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\r\n        }\r\n\r\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\r\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        // We calculate the newBorrowIndex (we already had newSupplyIndex)\r\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\r\n        err = doTransferIn(asset, msg.sender, amount);\r\n        if (err != Error.NO_ERROR) {\r\n            // This is safe since it's our first interaction and it didn't do anything if it failed\r\n            return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\r\n        }\r\n\r\n        // Save market updates\r\n        market.blockNumber = getBlockNumber();\r\n        market.totalSupply =  localResults.newTotalSupply;\r\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\r\n        market.supplyIndex = localResults.newSupplyIndex;\r\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\r\n        market.borrowIndex = localResults.newBorrowIndex;\r\n\r\n        // Save user updates\r\n        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\r\n        balance.principal = localResults.userSupplyUpdated;\r\n        balance.interestIndex = localResults.newSupplyIndex;\r\n\r\n        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\r\n\r\n        return uint(Error.NO_ERROR); // success\r\n    }\r\n\r\n    struct WithdrawLocalVars {\r\n        uint withdrawAmount;\r\n        uint startingBalance;\r\n        uint newSupplyIndex;\r\n        uint userSupplyCurrent;\r\n        uint userSupplyUpdated;\r\n        uint newTotalSupply;\r\n        uint currentCash;\r\n        uint updatedCash;\r\n        uint newSupplyRateMantissa;\r\n        uint newBorrowIndex;\r\n        uint newBorrowRateMantissa;\r\n\r\n        Exp accountLiquidity;\r\n        Exp accountShortfall;\r\n        Exp ethValueOfWithdrawal;\r\n        uint withdrawCapacity;\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice withdraw `amount` of `asset` from sender's account to sender's address\r\n      * @dev withdraw `amount` of `asset` from msg.sender's account to msg.sender\r\n      * @param asset The market asset to withdraw\r\n      * @param requestedAmount The amount to withdraw (or -1 for max)\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function withdraw(address asset, uint requestedAmount) public returns (uint) {\r\n        if (paused) {\r\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\r\n        }\r\n\r\n        Market storage market = markets[asset];\r\n        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\r\n\r\n        WithdrawLocalVars memory localResults; // Holds all our calculation results\r\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\r\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\r\n\r\n        // We calculate the user's accountLiquidity and accountShortfall.\r\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We calculate the newSupplyIndex, user's supplyCurrent and supplyUpdated for the asset\r\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // If the user specifies -1 amount to withdraw (\"max\"),  withdrawAmount => the lesser of withdrawCapacity and supplyCurrent\r\n        if (requestedAmount == uint(-1)) {\r\n            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\r\n            if (err != Error.NO_ERROR) {\r\n                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\r\n            }\r\n            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\r\n        } else {\r\n            localResults.withdrawAmount = requestedAmount;\r\n        }\r\n\r\n        // From here on we should NOT use requestedAmount.\r\n\r\n        // Fail gracefully if protocol has insufficient cash\r\n        // If protocol has insufficient cash, the sub operation will underflow.\r\n        localResults.currentCash = getCash(asset);\r\n        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\r\n        }\r\n\r\n        // We check that the amount is less than or equal to supplyCurrent\r\n        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\r\n        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // Fail if customer already has a shortfall\r\n        if (!isZeroExp(localResults.accountShortfall)) {\r\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\r\n        }\r\n\r\n        // We want to know the user's withdrawCapacity, denominated in the asset\r\n        // Customer's withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\r\n        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\r\n        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\r\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\r\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\r\n        }\r\n\r\n        // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply.\r\n        // Note that, even though the customer is withdrawing, if they've accumulated a lot of interest since their last\r\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\r\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\r\n        }\r\n\r\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\r\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        // We calculate the newBorrowIndex\r\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\r\n        err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            // This is safe since it's our first interaction and it didn't do anything if it failed\r\n            return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\r\n        }\r\n\r\n        // Save market updates\r\n        market.blockNumber = getBlockNumber();\r\n        market.totalSupply =  localResults.newTotalSupply;\r\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\r\n        market.supplyIndex = localResults.newSupplyIndex;\r\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\r\n        market.borrowIndex = localResults.newBorrowIndex;\r\n\r\n        // Save user updates\r\n        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\r\n        supplyBalance.principal = localResults.userSupplyUpdated;\r\n        supplyBalance.interestIndex = localResults.newSupplyIndex;\r\n\r\n        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\r\n\r\n        return uint(Error.NO_ERROR); // success\r\n    }\r\n\r\n    struct AccountValueLocalVars {\r\n        address assetAddress;\r\n        uint collateralMarketsLength;\r\n\r\n        uint newSupplyIndex;\r\n        uint userSupplyCurrent;\r\n        Exp supplyTotalValue;\r\n        Exp sumSupplies;\r\n\r\n        uint newBorrowIndex;\r\n        uint userBorrowCurrent;\r\n        Exp borrowTotalValue;\r\n        Exp sumBorrows;\r\n    }\r\n\r\n    /**\r\n      * @dev Gets the user's account liquidity and account shortfall balances. This includes\r\n      *      any accumulated interest thus far but does NOT actually update anything in\r\n      *      storage, it simply calculates the account liquidity and shortfall with liquidity being\r\n      *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\r\n      */\r\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\r\n        Error err;\r\n        uint sumSupplyValuesMantissa;\r\n        uint sumBorrowValuesMantissa;\r\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\r\n        if (err != Error.NO_ERROR) {\r\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        Exp memory result;\r\n        \r\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\r\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\r\n\r\n        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        // if sumSupplies < sumBorrows, then the user is under collateralized and has account shortfall.\r\n        // else the user meets the collateral ratio and has account liquidity.\r\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\r\n            // accountShortfall = borrows - supplies\r\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\r\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\r\n\r\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\r\n        } else {\r\n            // accountLiquidity = supplies - borrows\r\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\r\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\r\n\r\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @notice Gets the ETH values of the user's accumulated supply and borrow balances, scaled by 10e18.\r\n      *         This includes any accumulated interest thus far but does NOT actually update anything in\r\n      *         storage\r\n      * @dev Gets ETH values of accumulated supply and borrow balances\r\n      * @param userAddress account for which to sum values\r\n      * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\r\n      * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\r\n      * TODO: To help save gas we could think about using the current Market.interestIndex\r\n      *       accumulate interest rather than calculating it\r\n      */\r\n    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\r\n        \r\n        /** By definition, all collateralMarkets are those that contribute to the user's\r\n          * liquidity and shortfall so we need only loop through those markets.\r\n          * To handle avoiding intermediate negative results, we will sum all the user's\r\n          * supply balances and borrow balances (with collateral ratio) separately and then\r\n          * subtract the sums at the end.\r\n          */\r\n\r\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\r\n        localResults.sumSupplies = Exp({mantissa: 0});\r\n        localResults.sumBorrows = Exp({mantissa: 0});\r\n        Error err; // Re-used for all intermediate errors\r\n        localResults.collateralMarketsLength = collateralMarkets.length;\r\n\r\n        for (uint i = 0; i < localResults.collateralMarketsLength; i++) {\r\n            localResults.assetAddress = collateralMarkets[i];\r\n            Market storage currentMarket = markets[localResults.assetAddress];\r\n            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\r\n            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\r\n\r\n            if (supplyBalance.principal > 0) {\r\n                // We calculate the newSupplyIndex and user\u2019s supplyCurrent (includes interest)\r\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // We have the user's supply balance with interest so let's multiply by the asset price to get the total value\r\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // Add this to our running sum of supplies\r\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n            }\r\n\r\n            if (borrowBalance.principal > 0) {\r\n                // We perform a similar actions to get the user's borrow balance\r\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\r\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n\r\n                // Add this to our running sum of borrows\r\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\r\n                if (err != Error.NO_ERROR) {\r\n                    return (err, 0, 0);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\r\n    }\r\n\r\n    /**\r\n      * @notice Gets the ETH values of the user's accumulated supply and borrow balances, scaled by 10e18.\r\n      *         This includes any accumulated interest thus far but does NOT actually update anything in\r\n      *         storage\r\n      * @dev Gets ETH values of accumulated supply and borrow balances\r\n      * @param userAddress account for which to sum values\r\n      * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\r\n      *          sum ETH value of supplies scaled by 10e18,\r\n      *          sum ETH value of borrows scaled by 10e18)\r\n      */\r\n    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\r\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\r\n        if (err != Error.NO_ERROR) {\r\n\r\n            return (uint(err), 0, 0);\r\n        }\r\n\r\n        return (0, supplyValue, borrowValue);\r\n    }\r\n\r\n    struct PayBorrowLocalVars {\r\n        uint newBorrowIndex;\r\n        uint userBorrowCurrent;\r\n        uint repayAmount;\r\n\r\n        uint userBorrowUpdated;\r\n        uint newTotalBorrows;\r\n        uint currentCash;\r\n        uint updatedCash;\r\n\r\n        uint newSupplyIndex;\r\n        uint newSupplyRateMantissa;\r\n        uint newBorrowRateMantissa;\r\n\r\n        uint startingBalance;\r\n    }\r\n\r\n    /**\r\n      * @notice Users repay borrowed assets from their own address to the protocol.\r\n      * @param asset The market asset to repay\r\n      * @param amount The amount to repay (or -1 for max)\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function repayBorrow(address asset, uint amount) public returns (uint) {\r\n        if (paused) {\r\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\r\n        }\r\n        PayBorrowLocalVars memory localResults;\r\n        Market storage market = markets[asset];\r\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\r\n        Error err;\r\n        uint rateCalculationResultCode;\r\n\r\n        // We calculate the newBorrowIndex, user's borrowCurrent and borrowUpdated for the asset\r\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // If the user specifies -1 amount to repay (\u201cmax\u201d), repayAmount =>\r\n        // the lesser of the senders ERC-20 balance and borrowCurrent\r\n        if (amount == uint(-1)) {\r\n            localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\r\n        } else {\r\n            localResults.repayAmount = amount;\r\n        }\r\n\r\n        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\r\n        // Note: this checks that repayAmount is less than borrowCurrent\r\n        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // Fail gracefully if asset is not approved or has insufficient balance\r\n        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\r\n        err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\r\n        }\r\n\r\n        // We calculate the protocol's totalBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow\r\n        // Note that, even though the customer is paying some of their borrow, if they've accumulated a lot of interest since their last\r\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\r\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We need to calculate what the updated cash will be after we transfer in from user\r\n        localResults.currentCash = getCash(asset);\r\n\r\n        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\r\n        }\r\n\r\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\r\n\r\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\r\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\r\n        err = doTransferIn(asset, msg.sender, localResults.repayAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            // This is safe since it's our first interaction and it didn't do anything if it failed\r\n            return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\r\n        }\r\n\r\n        // Save market updates\r\n        market.blockNumber = getBlockNumber();\r\n        market.totalBorrows =  localResults.newTotalBorrows;\r\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\r\n        market.supplyIndex = localResults.newSupplyIndex;\r\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\r\n        market.borrowIndex = localResults.newBorrowIndex;\r\n\r\n        // Save user updates\r\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\r\n        borrowBalance.principal = localResults.userBorrowUpdated;\r\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\r\n\r\n        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\r\n\r\n        return uint(Error.NO_ERROR); // success\r\n    }\r\n\r\n    struct BorrowLocalVars {\r\n        uint newBorrowIndex;\r\n        uint userBorrowCurrent;\r\n        uint borrowAmountWithFee;\r\n\r\n        uint userBorrowUpdated;\r\n        uint newTotalBorrows;\r\n        uint currentCash;\r\n        uint updatedCash;\r\n\r\n        uint newSupplyIndex;\r\n        uint newSupplyRateMantissa;\r\n        uint newBorrowRateMantissa;\r\n\r\n        uint startingBalance;\r\n\r\n        Exp accountLiquidity;\r\n        Exp accountShortfall;\r\n        Exp ethValueOfBorrowAmountWithFee;\r\n    }\r\n\r\n    struct LiquidateLocalVars {\r\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\r\n        address targetAccount;\r\n        address assetBorrow;\r\n        address liquidator;\r\n        address assetCollateral;\r\n\r\n        // borrow index and supply index are global to the asset, not specific to the user\r\n        uint newBorrowIndex_UnderwaterAsset;\r\n        uint newSupplyIndex_UnderwaterAsset;\r\n        uint newBorrowIndex_CollateralAsset;\r\n        uint newSupplyIndex_CollateralAsset;\r\n\r\n        // the target borrow's full balance with accumulated interest\r\n        uint currentBorrowBalance_TargetUnderwaterAsset;\r\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\r\n        uint updatedBorrowBalance_TargetUnderwaterAsset;\r\n\r\n        uint newTotalBorrows_ProtocolUnderwaterAsset;\r\n\r\n        uint startingBorrowBalance_TargetUnderwaterAsset;\r\n        uint startingSupplyBalance_TargetCollateralAsset;\r\n        uint startingSupplyBalance_LiquidatorCollateralAsset;\r\n\r\n        uint currentSupplyBalance_TargetCollateralAsset;\r\n        uint updatedSupplyBalance_TargetCollateralAsset;\r\n\r\n        // If liquidator already has a balance of collateralAsset, we will accumulate\r\n        // interest on it before transferring seized collateral from the borrower.\r\n        uint currentSupplyBalance_LiquidatorCollateralAsset;\r\n        // This will be the liquidator's accumulated balance of collateral asset before the liquidation (if any)\r\n        // plus the amount seized from the borrower.\r\n        uint updatedSupplyBalance_LiquidatorCollateralAsset;\r\n\r\n        uint newTotalSupply_ProtocolCollateralAsset;\r\n        uint currentCash_ProtocolUnderwaterAsset;\r\n        uint updatedCash_ProtocolUnderwaterAsset;\r\n\r\n        // cash does not change for collateral asset\r\n\r\n        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\r\n        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\r\n\r\n        // Why no variables for the interest rates for the collateral asset?\r\n        // We don't need to calculate new rates for the collateral asset since neither cash nor borrows change\r\n\r\n        uint discountedRepayToEvenAmount;\r\n\r\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\r\n        uint discountedBorrowDenominatedCollateral;\r\n\r\n        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n        uint closeBorrowAmount_TargetUnderwaterAsset;\r\n        uint seizeSupplyAmount_TargetCollateralAsset;\r\n\r\n        Exp collateralPrice;\r\n        Exp underwaterAssetPrice;\r\n    }\r\n\r\n    /**\r\n      * @notice users repay all or some of an underwater borrow and receive collateral\r\n      * @param targetAccount The account whose borrow should be liquidated\r\n      * @param assetBorrow The market asset to repay\r\n      * @param assetCollateral The borrower's market asset to receive in exchange\r\n      * @param requestedAmountClose The amount to repay (or -1 for max)\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) public returns (uint) {\r\n        if (paused) {\r\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\r\n        }\r\n        LiquidateLocalVars memory localResults;\r\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\r\n        // We'll use localResults.liquidator inside this function for clarity vs using msg.sender.\r\n        localResults.targetAccount = targetAccount;\r\n        localResults.assetBorrow = assetBorrow;\r\n        localResults.liquidator = msg.sender;\r\n        localResults.assetCollateral = assetCollateral;\r\n\r\n        Market storage borrowMarket = markets[assetBorrow];\r\n        Market storage collateralMarket = markets[assetCollateral];\r\n        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\r\n        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\r\n\r\n        // Liquidator might already hold some of the collateral asset\r\n        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\r\n\r\n        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\r\n        Error err; // re-used for all intermediate errors\r\n\r\n        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\r\n        if(err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\r\n        }\r\n\r\n        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\r\n        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\r\n        assert(err == Error.NO_ERROR);\r\n\r\n        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\r\n        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\r\n        }\r\n\r\n        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\r\n        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\r\n        }\r\n\r\n        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\r\n        }\r\n\r\n        // Liquidator may or may not already have some collateral asset.\r\n        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\r\n        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\r\n        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\r\n        }\r\n\r\n        // We update the protocol's totalSupply for assetCollateral in 2 steps, first by adding target user's accumulated\r\n        // interest and then by adding the liquidator's accumulated interest.\r\n\r\n        // Step 1 of 2: We add the target user's supplyCurrent and subtract their checkpointedBalance\r\n        // (which has the desired effect of adding accrued interest from the target user)\r\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\r\n        }\r\n\r\n        // Step 2 of 2: We add the liquidator's supplyCurrent of collateral asset and subtract their checkpointedBalance\r\n        // (which has the desired effect of adding accrued interest from the calling user)\r\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\r\n        }\r\n\r\n        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\r\n        // This is equal to the lesser of\r\n        // 1. borrowCurrent; (already calculated)\r\n        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\r\n        // discountedRepayToEvenAmount=\r\n        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\r\n        // 3. discountedBorrowDenominatedCollateral\r\n        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\r\n\r\n        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\r\n        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\r\n        (err, localResults.discountedBorrowDenominatedCollateral) =\r\n        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\r\n        }\r\n\r\n        if (borrowMarket.isSupported) {\r\n            // Market is supported, so we calculate item 2 from above.\r\n            (err, localResults.discountedRepayToEvenAmount) =\r\n            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\r\n            if (err != Error.NO_ERROR) {\r\n                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\r\n            }\r\n\r\n            // We need to do a two-step min to select from all 3 values\r\n            // min1&3 = min(item 1, item 3)\r\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\r\n\r\n            // min1&3&2 = min(min1&3, 2)\r\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\r\n        } else {\r\n            // Market is not supported, so we don't need to calculate item 2.\r\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\r\n        }\r\n\r\n        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\r\n        if (requestedAmountClose == uint(-1)) {\r\n            localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\r\n        } else {\r\n            localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\r\n        }\r\n\r\n        // From here on, no more use of `requestedAmountClose`\r\n\r\n        // Verify closeBorrowAmount_TargetUnderwaterAsset <= maxCloseableBorrowAmount_TargetUnderwaterAsset\r\n        if (localResults.closeBorrowAmount_TargetUnderwaterAsset > localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\r\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\r\n        }\r\n\r\n        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\r\n        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into Compound\r\n        // Fail gracefully if asset is not approved or has insufficient balance\r\n        err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\r\n        }\r\n\r\n        // We are going to repay the target user's borrow using the calling user's funds\r\n        // We update the protocol's totalBorrow for assetBorrow, by subtracting the target user's prior checkpointed balance,\r\n        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\r\n\r\n        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\r\n        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\r\n        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset <= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can't underflow\r\n        assert(err == Error.NO_ERROR);\r\n\r\n        // We calculate the protocol's totalBorrow for assetBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow\r\n        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\r\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\r\n        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\r\n        }\r\n\r\n        // We need to calculate what the updated cash will be after we transfer in from liquidator\r\n        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\r\n        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\r\n        }\r\n\r\n        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\r\n        // (Please note that we don't need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\r\n\r\n        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don't recalculate it.\r\n        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\r\n        }\r\n\r\n        // Now we look at collateral. We calculated target user's accumulated supply balance and the supply index above.\r\n        // Now we need to calculate the borrow index.\r\n        // We don't need to calculate new rates for the collateral asset because we have not changed utilization:\r\n        //  - accumulating interest on the target user's collateral does not change cash or borrows\r\n        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\r\n        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\r\n        }\r\n\r\n        // We checkpoint the target user's assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\r\n        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\r\n        // The sub won't underflow because because seizeSupplyAmount_TargetCollateralAsset <= target user's collateral balance\r\n        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\r\n        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\r\n        assert (err == Error.NO_ERROR);\r\n\r\n        // We checkpoint the liquidating user's assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\r\n        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\r\n        // We can't overflow here because if this would overflow, then we would have already overflowed above and failed\r\n        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\r\n        assert (err == Error.NO_ERROR);\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\r\n        err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            // This is safe since it's our first interaction and it didn't do anything if it failed\r\n            return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\r\n        }\r\n\r\n        // Save borrow market updates\r\n        borrowMarket.blockNumber = getBlockNumber();\r\n        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\r\n        // borrowMarket.totalSupply does not need to be updated\r\n        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\r\n        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\r\n        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\r\n        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\r\n\r\n        // Save collateral market updates\r\n        // We didn't calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\r\n        collateralMarket.blockNumber = getBlockNumber();\r\n        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\r\n        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\r\n        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\r\n\r\n        // Save user updates\r\n\r\n        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\r\n        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\r\n        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\r\n\r\n        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\r\n        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\r\n        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\r\n\r\n        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\r\n        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\r\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\r\n\r\n        emitLiquidationEvent(localResults);\r\n\r\n        return uint(Error.NO_ERROR); // success\r\n    }\r\n\r\n    /**\r\n      * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\r\n      */\r\n    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\r\n        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\r\n        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\r\n        emit BorrowLiquidated(localResults.targetAccount,\r\n            localResults.assetBorrow,\r\n            localResults.startingBorrowBalance_TargetUnderwaterAsset,\r\n            localResults.currentBorrowBalance_TargetUnderwaterAsset,\r\n            localResults.closeBorrowAmount_TargetUnderwaterAsset,\r\n            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\r\n            localResults.liquidator,\r\n            localResults.assetCollateral,\r\n            localResults.startingSupplyBalance_TargetCollateralAsset,\r\n            localResults.currentSupplyBalance_TargetCollateralAsset,\r\n            localResults.seizeSupplyAmount_TargetCollateralAsset,\r\n            localResults.updatedSupplyBalance_TargetCollateralAsset);\r\n    }\r\n\r\n    /**\r\n      * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\r\n      *      If the market isn't supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\r\n      *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\r\n      **/\r\n    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\r\n        Error err;\r\n        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\r\n        Exp memory accountShortfall_TargetUser;\r\n        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\r\n        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\r\n        Exp memory discountedPrice_UnderwaterAsset;\r\n        Exp memory rawResult;\r\n\r\n        // we calculate the target user's shortfall, denominated in Ether, that the user is below the collateral ratio\r\n        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\r\n        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\r\n        // discountedCollateralRatioMinusOne < collateralRatio\r\n        // so if underwaterAssetPrice * collateralRatio did not overflow then\r\n        // underwaterAssetPrice * discountedCollateralRatioMinusOne can't overflow either\r\n        assert(err == Error.NO_ERROR);\r\n\r\n        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\r\n        // It's theoretically possible an asset could have such a low price that it truncates to zero when discounted.\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, truncate(rawResult));\r\n    }\r\n\r\n    /**\r\n      * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\r\n      */\r\n    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\r\n        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\r\n        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\r\n        Error err;\r\n        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\r\n        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\r\n        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\r\n        Exp memory rawResult;\r\n\r\n        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, truncate(rawResult));\r\n    }\r\n\r\n\r\n    /**\r\n      * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\r\n      **/\r\n    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\r\n        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\r\n        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\r\n\r\n        // re-used for all intermediate errors\r\n        Error err;\r\n\r\n        // (1+liquidationDiscount)\r\n        Exp memory liquidationMultiplier;\r\n\r\n        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\r\n        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\r\n\r\n        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\r\n        // or, expanded:\r\n        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\r\n        Exp memory finalNumerator;\r\n\r\n        // finalNumerator / priceCollateral\r\n        Exp memory rawResult;\r\n\r\n        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\r\n        // liquidation discount will be enforced < 1, so 1 + liquidationDiscount can't overflow.\r\n        assert(err == Error.NO_ERROR);\r\n\r\n        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        (err, rawResult) = divExp(finalNumerator, collateralPrice);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, truncate(rawResult));\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Users borrow assets from the protocol to their own address\r\n      * @param asset The market asset to borrow\r\n      * @param amount The amount to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(address asset, uint amount) public returns (uint) {\r\n        if (paused) {\r\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\r\n        }\r\n        BorrowLocalVars memory localResults;\r\n        Market storage market = markets[asset];\r\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\r\n\r\n        Error err;\r\n        uint rateCalculationResultCode;\r\n\r\n        // Fail if market not supported\r\n        if (!market.isSupported) {\r\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\r\n        }\r\n\r\n        // We calculate the newBorrowIndex, user's borrowCurrent and borrowUpdated for the asset\r\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // Calculate origination fee.\r\n        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\r\n        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\r\n        }\r\n\r\n        // We calculate the protocol's totalBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow with fee\r\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\r\n        }\r\n\r\n        // Check customer liquidity\r\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\r\n        }\r\n\r\n        // Fail if customer already has a shortfall\r\n        if (!isZeroExp(localResults.accountShortfall)) {\r\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\r\n        }\r\n\r\n        // Would the customer have a shortfall after this borrow (including origination fee)?\r\n        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\r\n        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] > accountLiquidity`\r\n        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\r\n        }\r\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\r\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\r\n        }\r\n\r\n        // Fail gracefully if protocol has insufficient cash\r\n        localResults.currentCash = getCash(asset);\r\n        // We need to calculate what the updated cash will be after we transfer out to the user\r\n        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\r\n        if (err != Error.NO_ERROR) {\r\n            // Note: we ignore error here and call this token insufficient cash\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\r\n        }\r\n\r\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\r\n\r\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\r\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\r\n        if (err != Error.NO_ERROR) {\r\n            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\r\n        if (rateCalculationResultCode != 0) {\r\n            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\r\n        err = doTransferOut(asset, msg.sender, amount);\r\n        if (err != Error.NO_ERROR) {\r\n            // This is safe since it's our first interaction and it didn't do anything if it failed\r\n            return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\r\n        }\r\n\r\n        // Save market updates\r\n        market.blockNumber = getBlockNumber();\r\n        market.totalBorrows =  localResults.newTotalBorrows;\r\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\r\n        market.supplyIndex = localResults.newSupplyIndex;\r\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\r\n        market.borrowIndex = localResults.newBorrowIndex;\r\n\r\n        // Save user updates\r\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\r\n        borrowBalance.principal = localResults.userBorrowUpdated;\r\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\r\n\r\n        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\r\n\r\n        return uint(Error.NO_ERROR); // success\r\n    }\r\n}"}
{"address": "0x88cc4aa0dd6cf126b00c012dda9f6f4fd9388b17", "attacktype": "Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"./ERC20Upgradeable.sol\\\";\\nimport \\\"../../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC20Burnable_init_unchained();\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal initializer {\\n    }\\n    using SafeMathUpgradeable for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"../../math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AmplificationUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./SwapUtils.sol\\\";\\n\\n/**\\n * @title AmplificationUtils library\\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\\n * This library assumes the struct is fully validated.\\n */\\nlibrary AmplificationUtils {\\n    using SafeMath for uint256;\\n\\n    event RampA(\\n        uint256 oldA,\\n        uint256 newA,\\n        uint256 initialTime,\\n        uint256 futureTime\\n    );\\n    event StopRampA(uint256 currentA, uint256 time);\\n\\n    // Constant values used in ramping A calculations\\n    uint256 public constant A_PRECISION = 100;\\n    uint256 public constant MAX_A = 10**6;\\n    uint256 private constant MAX_A_CHANGE = 2;\\n    uint256 private constant MIN_RAMP_TIME = 14 days;\\n\\n    /**\\n     * @notice Return A, the amplification coefficient * n * (n - 1)\\n     * @dev See the StableSwap paper for details\\n     * @param self Swap struct to read from\\n     * @return A parameter\\n     */\\n    function getA(SwapUtils.Swap storage self) external view returns (uint256) {\\n        return _getAPrecise(self).div(A_PRECISION);\\n    }\\n\\n    /**\\n     * @notice Return A in its raw precision\\n     * @dev See the StableSwap paper for details\\n     * @param self Swap struct to read from\\n     * @return A parameter in its raw precision form\\n     */\\n    function getAPrecise(SwapUtils.Swap storage self)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _getAPrecise(self);\\n    }\\n\\n    /**\\n     * @notice Return A in its raw precision\\n     * @dev See the StableSwap paper for details\\n     * @param self Swap struct to read from\\n     * @return A parameter in its raw precision form\\n     */\\n    function _getAPrecise(SwapUtils.Swap storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 t1 = self.futureATime; // time when ramp is finished\\n        uint256 a1 = self.futureA; // final A value when ramp is finished\\n\\n        if (block.timestamp < t1) {\\n            uint256 t0 = self.initialATime; // time when ramp is started\\n            uint256 a0 = self.initialA; // initial A value when ramp is started\\n            if (a1 > a0) {\\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\\n                return\\n                    a0.add(\\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\\n                    );\\n            } else {\\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\\n                return\\n                    a0.sub(\\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\\n                    );\\n            }\\n        } else {\\n            return a1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\\n     * the limit range.\\n     * @param self Swap struct to update\\n     * @param futureA_ the new A to ramp towards\\n     * @param futureTime_ timestamp when the new A should be reached\\n     */\\n    function rampA(\\n        SwapUtils.Swap storage self,\\n        uint256 futureA_,\\n        uint256 futureTime_\\n    ) external {\\n        require(\\n            block.timestamp >= self.initialATime.add(1 days),\\n            \\\"Wait 1 day before starting ramp\\\"\\n        );\\n        require(\\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\\n            \\\"Insufficient ramp time\\\"\\n        );\\n        require(\\n            futureA_ > 0 && futureA_ < MAX_A,\\n            \\\"futureA_ must be > 0 and < MAX_A\\\"\\n        );\\n\\n        uint256 initialAPrecise = _getAPrecise(self);\\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\\n\\n        if (futureAPrecise < initialAPrecise) {\\n            require(\\n                futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise,\\n                \\\"futureA_ is too small\\\"\\n            );\\n        } else {\\n            require(\\n                futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE),\\n                \\\"futureA_ is too large\\\"\\n            );\\n        }\\n\\n        self.initialA = initialAPrecise;\\n        self.futureA = futureAPrecise;\\n        self.initialATime = block.timestamp;\\n        self.futureATime = futureTime_;\\n\\n        emit RampA(\\n            initialAPrecise,\\n            futureAPrecise,\\n            block.timestamp,\\n            futureTime_\\n        );\\n    }\\n\\n    /**\\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\\n     * cannot be called for another 24 hours\\n     * @param self Swap struct to update\\n     */\\n    function stopRampA(SwapUtils.Swap storage self) external {\\n        require(self.futureATime > block.timestamp, \\\"Ramp is already stopped\\\");\\n\\n        uint256 currentA = _getAPrecise(self);\\n        self.initialA = currentA;\\n        self.futureA = currentA;\\n        self.initialATime = block.timestamp;\\n        self.futureATime = block.timestamp;\\n\\n        emit StopRampA(currentA, block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"./interfaces/ISwap.sol\\\";\\n\\n/**\\n * @title Liquidity Provider Token\\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\\n * It is used to represent user's shares when providing liquidity to swap contracts.\\n * @dev Only Swap contracts should initialize and own LPToken contracts.\\n */\\ncontract LPToken is ERC20BurnableUpgradeable, OwnableUpgradeable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    /**\\n     * @notice Initializes this LPToken contract with the given name and symbol\\n     * @dev The caller of this function will become the owner. A Swap contract should call this\\n     * in its initializer function.\\n     * @param name name of this token\\n     * @param symbol symbol of this token\\n     */\\n    function initialize(string memory name, string memory symbol)\\n        external\\n        initializer\\n        returns (bool)\\n    {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name, symbol);\\n        __Ownable_init_unchained();\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Mints the given amount of LPToken to the recipient.\\n     * @dev only owner can call this mint function\\n     * @param recipient address of account to receive the tokens\\n     * @param amount amount of tokens to mint\\n     */\\n    function mint(address recipient, uint256 amount) external onlyOwner {\\n        require(amount != 0, \\\"LPToken: cannot mint 0\\\");\\n        _mint(recipient, amount);\\n    }\\n\\n    /**\\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\\n     * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\\n     * This assumes the owner is set to a Swap contract's address.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override(ERC20Upgradeable) {\\n        super._beforeTokenTransfer(from, to, amount);\\n        require(to != address(this), \\\"LPToken: cannot send to itself\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title MathUtils library\\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\\n * differences between two uint256.\\n */\\nlibrary MathUtils {\\n    /**\\n     * @notice Compares a and b and returns true if the difference between a and b\\n     *         is less than 1 or equal to each other.\\n     * @param a uint256 to compare with\\n     * @param b uint256 to compare with\\n     * @return True if the difference between a and b is less than 1 or equal,\\n     *         otherwise return false\\n     */\\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\\n        return (difference(a, b) <= 1);\\n    }\\n\\n    /**\\n     * @notice Calculates absolute difference between a and b\\n     * @param a uint256 to compare with\\n     * @param b uint256 to compare with\\n     * @return Difference between a and b\\n     */\\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a > b) {\\n            return a - b;\\n        }\\n        return b - a;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SwapUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./AmplificationUtils.sol\\\";\\nimport \\\"./LPToken.sol\\\";\\nimport \\\"./MathUtils.sol\\\";\\n\\n/**\\n * @title SwapUtils library\\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\\n * Admin functions should be protected within contracts using this library.\\n */\\nlibrary SwapUtils {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n    using MathUtils for uint256;\\n\\n    /*** EVENTS ***/\\n\\n    event TokenSwap(\\n        address indexed buyer,\\n        uint256 tokensSold,\\n        uint256 tokensBought,\\n        uint128 soldId,\\n        uint128 boughtId\\n    );\\n    event AddLiquidity(\\n        address indexed provider,\\n        uint256[] tokenAmounts,\\n        uint256[] fees,\\n        uint256 invariant,\\n        uint256 lpTokenSupply\\n    );\\n    event RemoveLiquidity(\\n        address indexed provider,\\n        uint256[] tokenAmounts,\\n        uint256 lpTokenSupply\\n    );\\n    event RemoveLiquidityOne(\\n        address indexed provider,\\n        uint256 lpTokenAmount,\\n        uint256 lpTokenSupply,\\n        uint256 boughtId,\\n        uint256 tokensBought\\n    );\\n    event RemoveLiquidityImbalance(\\n        address indexed provider,\\n        uint256[] tokenAmounts,\\n        uint256[] fees,\\n        uint256 invariant,\\n        uint256 lpTokenSupply\\n    );\\n    event NewAdminFee(uint256 newAdminFee);\\n    event NewSwapFee(uint256 newSwapFee);\\n\\n    struct Swap {\\n        // variables around the ramp management of A,\\n        // the amplification coefficient * n * (n - 1)\\n        // see https://www.curve.fi/stableswap-paper.pdf for details\\n        uint256 initialA;\\n        uint256 futureA;\\n        uint256 initialATime;\\n        uint256 futureATime;\\n        // fee calculation\\n        uint256 swapFee;\\n        uint256 adminFee;\\n        LPToken lpToken;\\n        // contract references for all tokens being pooled\\n        IERC20[] pooledTokens;\\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\\n        uint256[] tokenPrecisionMultipliers;\\n        // the pool balance of each token, in the token's precision\\n        // the contract's actual token balance might differ\\n        uint256[] balances;\\n    }\\n\\n    // Struct storing variables used in calculations in the\\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\\n    struct CalculateWithdrawOneTokenDYInfo {\\n        uint256 d0;\\n        uint256 d1;\\n        uint256 newY;\\n        uint256 feePerToken;\\n        uint256 preciseA;\\n    }\\n\\n    // Struct storing variables used in calculations in the\\n    // {add,remove}Liquidity functions to avoid stack too deep errors\\n    struct ManageLiquidityInfo {\\n        uint256 d0;\\n        uint256 d1;\\n        uint256 d2;\\n        uint256 preciseA;\\n        LPToken lpToken;\\n        uint256 totalSupply;\\n        uint256[] balances;\\n        uint256[] multipliers;\\n    }\\n\\n    // the precision all pools tokens will be converted to\\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\\n\\n    // the denominator used to calculate admin and LP fees. For example, an\\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\\n    uint256 private constant FEE_DENOMINATOR = 10**10;\\n\\n    // Max swap fee is 1% or 100bps of each swap\\n    uint256 public constant MAX_SWAP_FEE = 10**8;\\n\\n    // Max adminFee is 100% of the swapFee\\n    // adminFee does not add additional fee on top of swapFee\\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\\n    // users but only on the earnings of LPs\\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\\n\\n    // Constant value used as max loop limit\\n    uint256 private constant MAX_LOOP_LIMIT = 256;\\n\\n    /*** VIEW & PURE FUNCTIONS ***/\\n\\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\\n        return AmplificationUtils._getAPrecise(self);\\n    }\\n\\n    /**\\n     * @notice Calculate the dy, the amount of selected token that user receives and\\n     * the fee of withdrawing in one token\\n     * @param tokenAmount the amount to withdraw in the pool's precision\\n     * @param tokenIndex which token will be withdrawn\\n     * @param self Swap struct to read from\\n     * @return the amount of token user will receive\\n     */\\n    function calculateWithdrawOneToken(\\n        Swap storage self,\\n        uint256 tokenAmount,\\n        uint8 tokenIndex\\n    ) external view returns (uint256) {\\n        (uint256 availableTokenAmount, ) =\\n            _calculateWithdrawOneToken(\\n                self,\\n                tokenAmount,\\n                tokenIndex,\\n                self.lpToken.totalSupply()\\n            );\\n        return availableTokenAmount;\\n    }\\n\\n    function _calculateWithdrawOneToken(\\n        Swap storage self,\\n        uint256 tokenAmount,\\n        uint8 tokenIndex,\\n        uint256 totalSupply\\n    ) internal view returns (uint256, uint256) {\\n        uint256 dy;\\n        uint256 newY;\\n        uint256 currentY;\\n\\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\\n            self,\\n            tokenIndex,\\n            tokenAmount,\\n            totalSupply\\n        );\\n\\n        // dy_0 (without fees)\\n        // dy, dy_0 - dy\\n\\n        uint256 dySwapFee =\\n            currentY\\n                .sub(newY)\\n                .div(self.tokenPrecisionMultipliers[tokenIndex])\\n                .sub(dy);\\n\\n        return (dy, dySwapFee);\\n    }\\n\\n    /**\\n     * @notice Calculate the dy of withdrawing in one token\\n     * @param self Swap struct to read from\\n     * @param tokenIndex which token will be withdrawn\\n     * @param tokenAmount the amount to withdraw in the pools precision\\n     * @return the d and the new y after withdrawing one token\\n     */\\n    function calculateWithdrawOneTokenDY(\\n        Swap storage self,\\n        uint8 tokenIndex,\\n        uint256 tokenAmount,\\n        uint256 totalSupply\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Get the current D, then solve the stableswap invariant\\n        // y_i for D - tokenAmount\\n        uint256[] memory xp = _xp(self);\\n\\n        require(tokenIndex < xp.length, \\\"Token index out of range\\\");\\n\\n        CalculateWithdrawOneTokenDYInfo memory v =\\n            CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\\n        v.preciseA = _getAPrecise(self);\\n        v.d0 = getD(xp, v.preciseA);\\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\\n\\n        require(tokenAmount <= xp[tokenIndex], \\\"Withdraw exceeds available\\\");\\n\\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\\n\\n        uint256[] memory xpReduced = new uint256[](xp.length);\\n\\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\\n        for (uint256 i = 0; i < xp.length; i++) {\\n            uint256 xpi = xp[i];\\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\\n            xpReduced[i] = xpi.sub(\\n                (\\n                    (i == tokenIndex)\\n                        ? xpi.mul(v.d1).div(v.d0).sub(v.newY)\\n                        : xpi.sub(xpi.mul(v.d1).div(v.d0))\\n                )\\n                    .mul(v.feePerToken)\\n                    .div(FEE_DENOMINATOR)\\n            );\\n        }\\n\\n        uint256 dy =\\n            xpReduced[tokenIndex].sub(\\n                getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\\n            );\\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\\n\\n        return (dy, v.newY, xp[tokenIndex]);\\n    }\\n\\n    /**\\n     * @notice Calculate the price of a token in the pool with given\\n     * precision-adjusted balances and a particular D.\\n     *\\n     * @dev This is accomplished via solving the invariant iteratively.\\n     * See the StableSwap paper and Curve.fi implementation for further details.\\n     *\\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\\n     * x_1**2 + b*x_1 = c\\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\\n     *\\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\\n     * @param tokenIndex Index of token we are calculating for.\\n     * @param xp a precision-adjusted set of pool balances. Array should be\\n     * the same cardinality as the pool.\\n     * @param d the stableswap invariant\\n     * @return the price of the token, in the same precision as in xp\\n     */\\n    function getYD(\\n        uint256 a,\\n        uint8 tokenIndex,\\n        uint256[] memory xp,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        uint256 numTokens = xp.length;\\n        require(tokenIndex < numTokens, \\\"Token not found\\\");\\n\\n        uint256 c = d;\\n        uint256 s;\\n        uint256 nA = a.mul(numTokens);\\n\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            if (i != tokenIndex) {\\n                s = s.add(xp[i]);\\n                c = c.mul(d).div(xp[i].mul(numTokens));\\n                // If we were to protect the division loss we would have to keep the denominator separate\\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\\n                // c = c * D * D * D * ... overflow!\\n            }\\n        }\\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\\n\\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\\n        uint256 yPrev;\\n        uint256 y = d;\\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\\n            yPrev = y;\\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\\n            if (y.within1(yPrev)) {\\n                return y;\\n            }\\n        }\\n        revert(\\\"Approximation did not converge\\\");\\n    }\\n\\n    /**\\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\\n     * as the pool.\\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\\n     * See the StableSwap paper for details\\n     * @return the invariant, at the precision of the pool\\n     */\\n    function getD(uint256[] memory xp, uint256 a)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 numTokens = xp.length;\\n        uint256 s;\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            s = s.add(xp[i]);\\n        }\\n        if (s == 0) {\\n            return 0;\\n        }\\n\\n        uint256 prevD;\\n        uint256 d = s;\\n        uint256 nA = a.mul(numTokens);\\n\\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\\n            uint256 dP = d;\\n            for (uint256 j = 0; j < numTokens; j++) {\\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\\n                // If we were to protect the division loss we would have to keep the denominator separate\\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\\n                // dP = dP * D * D * D * ... overflow!\\n            }\\n            prevD = d;\\n            d = nA\\n                .mul(s)\\n                .div(AmplificationUtils.A_PRECISION)\\n                .add(dP.mul(numTokens))\\n                .mul(d)\\n                .div(\\n                nA\\n                    .sub(AmplificationUtils.A_PRECISION)\\n                    .mul(d)\\n                    .div(AmplificationUtils.A_PRECISION)\\n                    .add(numTokens.add(1).mul(dP))\\n            );\\n            if (d.within1(prevD)) {\\n                return d;\\n            }\\n        }\\n\\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\\n        // function which does not rely on D.\\n        revert(\\\"D does not converge\\\");\\n    }\\n\\n    /**\\n     * @notice Given a set of balances and precision multipliers, return the\\n     * precision-adjusted balances.\\n     *\\n     * @param balances an array of token balances, in their native precisions.\\n     * These should generally correspond with pooled tokens.\\n     *\\n     * @param precisionMultipliers an array of multipliers, corresponding to\\n     * the amounts in the balances array. When multiplied together they\\n     * should yield amounts at the pool's precision.\\n     *\\n     * @return an array of amounts \\\"scaled\\\" to the pool's precision\\n     */\\n    function _xp(\\n        uint256[] memory balances,\\n        uint256[] memory precisionMultipliers\\n    ) internal pure returns (uint256[] memory) {\\n        uint256 numTokens = balances.length;\\n        require(\\n            numTokens == precisionMultipliers.length,\\n            \\\"Balances must match multipliers\\\"\\n        );\\n        uint256[] memory xp = new uint256[](numTokens);\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\\n        }\\n        return xp;\\n    }\\n\\n    /**\\n     * @notice Return the precision-adjusted balances of all tokens in the pool\\n     * @param self Swap struct to read from\\n     * @return the pool balances \\\"scaled\\\" to the pool's precision, allowing\\n     * them to be more easily compared.\\n     */\\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\\n    }\\n\\n    /**\\n     * @notice Get the virtual price, to help calculate profit\\n     * @param self Swap struct to read from\\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\\n     */\\n    function getVirtualPrice(Swap storage self)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint256 d = getD(_xp(self), _getAPrecise(self));\\n        LPToken lpToken = self.lpToken;\\n        uint256 supply = lpToken.totalSupply();\\n        if (supply > 0) {\\n            return d.mul(10**uint256(POOL_PRECISION_DECIMALS)).div(supply);\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Calculate the new balances of the tokens given the indexes of the token\\n     * that is swapped from (FROM) and the token that is swapped to (TO).\\n     * This function is used as a helper function to calculate how much TO token\\n     * the user should receive on swap.\\n     *\\n     * @param preciseA precise form of amplification coefficient\\n     * @param tokenIndexFrom index of FROM token\\n     * @param tokenIndexTo index of TO token\\n     * @param x the new total amount of FROM token\\n     * @param xp balances of the tokens in the pool\\n     * @return the amount of TO token that should remain in the pool\\n     */\\n    function getY(\\n        uint256 preciseA,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 x,\\n        uint256[] memory xp\\n    ) internal pure returns (uint256) {\\n        uint256 numTokens = xp.length;\\n        require(\\n            tokenIndexFrom != tokenIndexTo,\\n            \\\"Can't compare token to itself\\\"\\n        );\\n        require(\\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\\n            \\\"Tokens must be in pool\\\"\\n        );\\n\\n        uint256 d = getD(xp, preciseA);\\n        uint256 c = d;\\n        uint256 s;\\n        uint256 nA = numTokens.mul(preciseA);\\n\\n        uint256 _x;\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            if (i == tokenIndexFrom) {\\n                _x = x;\\n            } else if (i != tokenIndexTo) {\\n                _x = xp[i];\\n            } else {\\n                continue;\\n            }\\n            s = s.add(_x);\\n            c = c.mul(d).div(_x.mul(numTokens));\\n            // If we were to protect the division loss we would have to keep the denominator separate\\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\\n            // c = c * D * D * D * ... overflow!\\n        }\\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\\n        uint256 yPrev;\\n        uint256 y = d;\\n\\n        // iterative approximation\\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\\n            yPrev = y;\\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\\n            if (y.within1(yPrev)) {\\n                return y;\\n            }\\n        }\\n        revert(\\\"Approximation did not converge\\\");\\n    }\\n\\n    /**\\n     * @notice Externally calculates a swap between two tokens.\\n     * @param self Swap struct to read from\\n     * @param tokenIndexFrom the token to sell\\n     * @param tokenIndexTo the token to buy\\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n     * use the amount that gets transferred after the fee.\\n     * @return dy the number of tokens the user will get\\n     */\\n    function calculateSwap(\\n        Swap storage self,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256 dy) {\\n        (dy, ) = _calculateSwap(\\n            self,\\n            tokenIndexFrom,\\n            tokenIndexTo,\\n            dx,\\n            self.balances\\n        );\\n    }\\n\\n    /**\\n     * @notice Internally calculates a swap between two tokens.\\n     *\\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\\n     * using the token contracts.\\n     *\\n     * @param self Swap struct to read from\\n     * @param tokenIndexFrom the token to sell\\n     * @param tokenIndexTo the token to buy\\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n     * use the amount that gets transferred after the fee.\\n     * @return dy the number of tokens the user will get\\n     * @return dyFee the associated fee\\n     */\\n    function _calculateSwap(\\n        Swap storage self,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256[] memory balances\\n    ) internal view returns (uint256 dy, uint256 dyFee) {\\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\\n        uint256[] memory xp = _xp(balances, multipliers);\\n        require(\\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\\n            \\\"Token index out of range\\\"\\n        );\\n        uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\\n        uint256 y =\\n            getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\\n        dy = xp[tokenIndexTo].sub(y).sub(1);\\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\\n        dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\\n    }\\n\\n    /**\\n     * @notice A simple method to calculate amount of each underlying\\n     * tokens that is returned upon burning given amount of\\n     * LP tokens\\n     *\\n     * @param amount the amount of LP tokens that would to be burned on\\n     * withdrawal\\n     * @return array of amounts of tokens user will receive\\n     */\\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return\\n            _calculateRemoveLiquidity(\\n                self.balances,\\n                amount,\\n                self.lpToken.totalSupply()\\n            );\\n    }\\n\\n    function _calculateRemoveLiquidity(\\n        uint256[] memory balances,\\n        uint256 amount,\\n        uint256 totalSupply\\n    ) internal pure returns (uint256[] memory) {\\n        require(amount <= totalSupply, \\\"Cannot exceed total supply\\\");\\n\\n        uint256[] memory amounts = new uint256[](balances.length);\\n\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            amounts[i] = balances[i].mul(amount).div(totalSupply);\\n        }\\n        return amounts;\\n    }\\n\\n    /**\\n     * @notice A simple method to calculate prices from deposits or\\n     * withdrawals, excluding fees but including slippage. This is\\n     * helpful as an input into the various \\\"min\\\" parameters on calls\\n     * to fight front-running\\n     *\\n     * @dev This shouldn't be used outside frontends for user estimates.\\n     *\\n     * @param self Swap struct to read from\\n     * @param amounts an array of token amounts to deposit or withdrawal,\\n     * corresponding to pooledTokens. The amount should be in each\\n     * pooled token's native precision. If a token charges a fee on transfers,\\n     * use the amount that gets transferred after the fee.\\n     * @param deposit whether this is a deposit or a withdrawal\\n     * @return if deposit was true, total amount of lp token that will be minted and if\\n     * deposit was false, total amount of lp token that will be burned\\n     */\\n    function calculateTokenAmount(\\n        Swap storage self,\\n        uint256[] calldata amounts,\\n        bool deposit\\n    ) external view returns (uint256) {\\n        uint256 a = _getAPrecise(self);\\n        uint256[] memory balances = self.balances;\\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\\n\\n        uint256 d0 = getD(_xp(balances, multipliers), a);\\n        for (uint256 i = 0; i < balances.length; i++) {\\n            if (deposit) {\\n                balances[i] = balances[i].add(amounts[i]);\\n            } else {\\n                balances[i] = balances[i].sub(\\n                    amounts[i],\\n                    \\\"Cannot withdraw more than available\\\"\\n                );\\n            }\\n        }\\n        uint256 d1 = getD(_xp(balances, multipliers), a);\\n        uint256 totalSupply = self.lpToken.totalSupply();\\n\\n        if (deposit) {\\n            return d1.sub(d0).mul(totalSupply).div(d0);\\n        } else {\\n            return d0.sub(d1).mul(totalSupply).div(d0);\\n        }\\n    }\\n\\n    /**\\n     * @notice return accumulated amount of admin fees of the token with given index\\n     * @param self Swap struct to read from\\n     * @param index Index of the pooled token\\n     * @return admin balance in the token's precision\\n     */\\n    function getAdminBalance(Swap storage self, uint256 index)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(index < self.pooledTokens.length, \\\"Token index out of range\\\");\\n        return\\n            self.pooledTokens[index].balanceOf(address(this)).sub(\\n                self.balances[index]\\n            );\\n    }\\n\\n    /**\\n     * @notice internal helper function to calculate fee per token multiplier used in\\n     * swap fee calculations\\n     * @param swapFee swap fee for the tokens\\n     * @param numTokens number of tokens pooled\\n     */\\n    function _feePerToken(uint256 swapFee, uint256 numTokens)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\\n    }\\n\\n    /*** STATE MODIFYING FUNCTIONS ***/\\n\\n    /**\\n     * @notice swap two tokens in the pool\\n     * @param self Swap struct to read from and write to\\n     * @param tokenIndexFrom the token the user wants to sell\\n     * @param tokenIndexTo the token the user wants to buy\\n     * @param dx the amount of tokens the user wants to sell\\n     * @param minDy the min amount the user would like to receive, or revert.\\n     * @return amount of token user received on swap\\n     */\\n    function swap(\\n        Swap storage self,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy\\n    ) external returns (uint256) {\\n        {\\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\\n            require(\\n                dx <= tokenFrom.balanceOf(msg.sender),\\n                \\\"Cannot swap more than you own\\\"\\n            );\\n            // Transfer tokens first to see if a fee was charged on transfer\\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\\n\\n            // Use the actual transferred amount for AMM math\\n            dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\\n        }\\n\\n        uint256 dy;\\n        uint256 dyFee;\\n        uint256[] memory balances = self.balances;\\n        (dy, dyFee) = _calculateSwap(\\n            self,\\n            tokenIndexFrom,\\n            tokenIndexTo,\\n            dx,\\n            balances\\n        );\\n        require(dy >= minDy, \\\"Swap didn't result in min tokens\\\");\\n\\n        uint256 dyAdminFee =\\n            dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\\n                self.tokenPrecisionMultipliers[tokenIndexTo]\\n            );\\n\\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\\n        self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(\\n            dyAdminFee\\n        );\\n\\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\\n\\n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\\n\\n        return dy;\\n    }\\n\\n    /**\\n     * @notice Add liquidity to the pool\\n     * @param self Swap struct to read from and write to\\n     * @param amounts the amounts of each token to add, in their native precision\\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\\n     * should mint, otherwise revert. Handy for front-running mitigation\\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\\n     * @return amount of LP token user received\\n     */\\n    function addLiquidity(\\n        Swap storage self,\\n        uint256[] memory amounts,\\n        uint256 minToMint\\n    ) external returns (uint256) {\\n        IERC20[] memory pooledTokens = self.pooledTokens;\\n        require(\\n            amounts.length == pooledTokens.length,\\n            \\\"Amounts must match pooled tokens\\\"\\n        );\\n\\n        // current state\\n        ManageLiquidityInfo memory v =\\n            ManageLiquidityInfo(\\n                0,\\n                0,\\n                0,\\n                _getAPrecise(self),\\n                self.lpToken,\\n                0,\\n                self.balances,\\n                self.tokenPrecisionMultipliers\\n            );\\n        v.totalSupply = v.lpToken.totalSupply();\\n\\n        if (v.totalSupply != 0) {\\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\\n        }\\n\\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\\n\\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\\n            require(\\n                v.totalSupply != 0 || amounts[i] > 0,\\n                \\\"Must supply all tokens in pool\\\"\\n            );\\n\\n            // Transfer tokens first to see if a fee was charged on transfer\\n            if (amounts[i] != 0) {\\n                uint256 beforeBalance =\\n                    pooledTokens[i].balanceOf(address(this));\\n                pooledTokens[i].safeTransferFrom(\\n                    msg.sender,\\n                    address(this),\\n                    amounts[i]\\n                );\\n\\n                // Update the amounts[] with actual transfer amount\\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(\\n                    beforeBalance\\n                );\\n            }\\n\\n            newBalances[i] = v.balances[i].add(amounts[i]);\\n        }\\n\\n        // invariant after change\\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\\n        require(v.d1 > v.d0, \\\"D should increase\\\");\\n\\n        // updated to reflect fees and calculate the user's LP tokens\\n        v.d2 = v.d1;\\n        uint256[] memory fees = new uint256[](pooledTokens.length);\\n\\n        if (v.totalSupply != 0) {\\n            uint256 feePerToken =\\n                _feePerToken(self.swapFee, pooledTokens.length);\\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\\n                fees[i] = feePerToken\\n                    .mul(idealBalance.difference(newBalances[i]))\\n                    .div(FEE_DENOMINATOR);\\n                self.balances[i] = newBalances[i].sub(\\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\\n                );\\n                newBalances[i] = newBalances[i].sub(fees[i]);\\n            }\\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\\n        } else {\\n            // the initial depositor doesn't pay fees\\n            self.balances = newBalances;\\n        }\\n\\n        uint256 toMint;\\n        if (v.totalSupply == 0) {\\n            toMint = v.d1;\\n        } else {\\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\\n        }\\n\\n        require(toMint >= minToMint, \\\"Couldn't mint min requested\\\");\\n\\n        // mint the user's LP tokens\\n        v.lpToken.mint(msg.sender, toMint);\\n\\n        emit AddLiquidity(\\n            msg.sender,\\n            amounts,\\n            fees,\\n            v.d1,\\n            v.totalSupply.add(toMint)\\n        );\\n\\n        return toMint;\\n    }\\n\\n    /**\\n     * @notice Burn LP tokens to remove liquidity from the pool.\\n     * @dev Liquidity can always be removed, even when the pool is paused.\\n     * @param self Swap struct to read from and write to\\n     * @param amount the amount of LP tokens to burn\\n     * @param minAmounts the minimum amounts of each token in the pool\\n     * acceptable for this burn. Useful as a front-running mitigation\\n     * @return amounts of tokens the user received\\n     */\\n    function removeLiquidity(\\n        Swap storage self,\\n        uint256 amount,\\n        uint256[] calldata minAmounts\\n    ) external returns (uint256[] memory) {\\n        LPToken lpToken = self.lpToken;\\n        IERC20[] memory pooledTokens = self.pooledTokens;\\n        require(amount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\n        require(\\n            minAmounts.length == pooledTokens.length,\\n            \\\"minAmounts must match poolTokens\\\"\\n        );\\n\\n        uint256[] memory balances = self.balances;\\n        uint256 totalSupply = lpToken.totalSupply();\\n\\n        uint256[] memory amounts =\\n            _calculateRemoveLiquidity(balances, amount, totalSupply);\\n\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            require(amounts[i] >= minAmounts[i], \\\"amounts[i] < minAmounts[i]\\\");\\n            self.balances[i] = balances[i].sub(amounts[i]);\\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\\n        }\\n\\n        lpToken.burnFrom(msg.sender, amount);\\n\\n        emit RemoveLiquidity(msg.sender, amounts, totalSupply.sub(amount));\\n\\n        return amounts;\\n    }\\n\\n    /**\\n     * @notice Remove liquidity from the pool all in one token.\\n     * @param self Swap struct to read from and write to\\n     * @param tokenAmount the amount of the lp tokens to burn\\n     * @param tokenIndex the index of the token you want to receive\\n     * @param minAmount the minimum amount to withdraw, otherwise revert\\n     * @return amount chosen token that user received\\n     */\\n    function removeLiquidityOneToken(\\n        Swap storage self,\\n        uint256 tokenAmount,\\n        uint8 tokenIndex,\\n        uint256 minAmount\\n    ) external returns (uint256) {\\n        LPToken lpToken = self.lpToken;\\n        IERC20[] memory pooledTokens = self.pooledTokens;\\n\\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\n        require(tokenIndex < pooledTokens.length, \\\"Token not found\\\");\\n\\n        uint256 totalSupply = lpToken.totalSupply();\\n\\n        (uint256 dy, uint256 dyFee) =\\n            _calculateWithdrawOneToken(\\n                self,\\n                tokenAmount,\\n                tokenIndex,\\n                totalSupply\\n            );\\n\\n        require(dy >= minAmount, \\\"dy < minAmount\\\");\\n\\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\\n        );\\n        lpToken.burnFrom(msg.sender, tokenAmount);\\n        pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\\n\\n        emit RemoveLiquidityOne(\\n            msg.sender,\\n            tokenAmount,\\n            totalSupply,\\n            tokenIndex,\\n            dy\\n        );\\n\\n        return dy;\\n    }\\n\\n    /**\\n     * @notice Remove liquidity from the pool, weighted differently than the\\n     * pool's current balances.\\n     *\\n     * @param self Swap struct to read from and write to\\n     * @param amounts how much of each token to withdraw\\n     * @param maxBurnAmount the max LP token provider is willing to pay to\\n     * remove liquidity. Useful as a front-running mitigation.\\n     * @return actual amount of LP tokens burned in the withdrawal\\n     */\\n    function removeLiquidityImbalance(\\n        Swap storage self,\\n        uint256[] memory amounts,\\n        uint256 maxBurnAmount\\n    ) public returns (uint256) {\\n        ManageLiquidityInfo memory v =\\n            ManageLiquidityInfo(\\n                0,\\n                0,\\n                0,\\n                _getAPrecise(self),\\n                self.lpToken,\\n                0,\\n                self.balances,\\n                self.tokenPrecisionMultipliers\\n            );\\n        v.totalSupply = v.lpToken.totalSupply();\\n\\n        IERC20[] memory pooledTokens = self.pooledTokens;\\n\\n        require(\\n            amounts.length == pooledTokens.length,\\n            \\\"Amounts should match pool tokens\\\"\\n        );\\n\\n        require(\\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\\n                maxBurnAmount != 0,\\n            \\\">LP.balanceOf\\\"\\n        );\\n\\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\\n        uint256[] memory fees = new uint256[](pooledTokens.length);\\n        {\\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\\n                balances1[i] = v.balances[i].sub(\\n                    amounts[i],\\n                    \\\"Cannot withdraw more than available\\\"\\n                );\\n            }\\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\\n\\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\\n                uint256 difference = idealBalance.difference(balances1[i]);\\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\\n                self.balances[i] = balances1[i].sub(\\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\\n                );\\n                balances1[i] = balances1[i].sub(fees[i]);\\n            }\\n\\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\\n        }\\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\\n        require(tokenAmount != 0, \\\"Burnt amount cannot be zero\\\");\\n        tokenAmount = tokenAmount.add(1);\\n\\n        require(tokenAmount <= maxBurnAmount, \\\"tokenAmount > maxBurnAmount\\\");\\n\\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\\n\\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\\n        }\\n\\n        emit RemoveLiquidityImbalance(\\n            msg.sender,\\n            amounts,\\n            fees,\\n            v.d1,\\n            v.totalSupply.sub(tokenAmount)\\n        );\\n\\n        return tokenAmount;\\n    }\\n\\n    /**\\n     * @notice withdraw all admin fees to a given address\\n     * @param self Swap struct to withdraw fees from\\n     * @param to Address to send the fees to\\n     */\\n    function withdrawAdminFees(Swap storage self, address to) external {\\n        IERC20[] memory pooledTokens = self.pooledTokens;\\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\\n            IERC20 token = pooledTokens[i];\\n            uint256 balance =\\n                token.balanceOf(address(this)).sub(self.balances[i]);\\n            if (balance != 0) {\\n                token.safeTransfer(to, balance);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the admin fee\\n     * @dev adminFee cannot be higher than 100% of the swap fee\\n     * @param self Swap struct to update\\n     * @param newAdminFee new admin fee to be applied on future transactions\\n     */\\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\\n        require(newAdminFee <= MAX_ADMIN_FEE, \\\"Fee is too high\\\");\\n        self.adminFee = newAdminFee;\\n\\n        emit NewAdminFee(newAdminFee);\\n    }\\n\\n    /**\\n     * @notice update the swap fee\\n     * @dev fee cannot be higher than 1% of each swap\\n     * @param self Swap struct to update\\n     * @param newSwapFee new swap fee to be applied on future transactions\\n     */\\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\\n        require(newSwapFee <= MAX_SWAP_FEE, \\\"Fee is too high\\\");\\n        self.swapFee = newSwapFee;\\n\\n        emit NewSwapFee(newSwapFee);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllowlist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IAllowlist {\\n    function getPoolAccountLimit(address poolAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPoolCap(address poolAddress) external view returns (uint256);\\n\\n    function verifyAddress(address account, bytes32[] calldata merkleProof)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./IAllowlist.sol\\\";\\n\\ninterface ISwap {\\n    // pool data view functions\\n    function getA() external view returns (uint256);\\n\\n    function getAllowlist() external view returns (IAllowlist);\\n\\n    function getToken(uint8 index) external view returns (IERC20);\\n\\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\\n\\n    function getTokenBalance(uint8 index) external view returns (uint256);\\n\\n    function getVirtualPrice() external view returns (uint256);\\n\\n    function isGuarded() external view returns (bool);\\n\\n    // min return calculation functions\\n    function calculateSwap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256);\\n\\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function calculateRemoveLiquidity(uint256 amount)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function calculateRemoveLiquidityOneToken(\\n        uint256 tokenAmount,\\n        uint8 tokenIndex\\n    ) external view returns (uint256 availableTokenAmount);\\n\\n    // state modifying functions\\n    function initialize(\\n        IERC20[] memory pooledTokens,\\n        uint8[] memory decimals,\\n        string memory lpTokenName,\\n        string memory lpTokenSymbol,\\n        uint256 a,\\n        uint256 fee,\\n        uint256 adminFee,\\n        address lpTokenTargetAddress\\n    ) external;\\n\\n    function swap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy,\\n        uint256 deadline\\n    ) external returns (uint256);\\n\\n    function addLiquidity(\\n        uint256[] calldata amounts,\\n        uint256 minToMint,\\n        uint256 deadline\\n    ) external returns (uint256);\\n\\n    function removeLiquidity(\\n        uint256 amount,\\n        uint256[] calldata minAmounts,\\n        uint256 deadline\\n    ) external returns (uint256[] memory);\\n\\n    function removeLiquidityOneToken(\\n        uint256 tokenAmount,\\n        uint8 tokenIndex,\\n        uint256 minAmount,\\n        uint256 deadline\\n    ) external returns (uint256);\\n\\n    function removeLiquidityImbalance(\\n        uint256[] calldata amounts,\\n        uint256 maxBurnAmount,\\n        uint256 deadline\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/meta/MetaSwapUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../LPToken.sol\\\";\\nimport \\\"../interfaces/ISwap.sol\\\";\\nimport \\\"../MathUtils.sol\\\";\\nimport \\\"../SwapUtils.sol\\\";\\n\\n/**\\n * @title MetaSwapUtils library\\n * @notice A library to be used within MetaSwap.sol. Contains functions responsible for custody and AMM functionalities.\\n *\\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\\n * As an example, if there is a Swap pool consisting of [DAI, USDC, USDT]. Then a MetaSwap pool can be created\\n * with [sUSD, BaseSwapLPToken] to allow trades between either the LP token or the underlying tokens and sUSD.\\n *\\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\\n * Admin functions should be protected within contracts using this library.\\n */\\nlibrary MetaSwapUtils {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n    using MathUtils for uint256;\\n    using AmplificationUtils for SwapUtils.Swap;\\n\\n    /*** EVENTS ***/\\n\\n    event TokenSwap(\\n        address indexed buyer,\\n        uint256 tokensSold,\\n        uint256 tokensBought,\\n        uint128 soldId,\\n        uint128 boughtId\\n    );\\n    event TokenSwapUnderlying(\\n        address indexed buyer,\\n        uint256 tokensSold,\\n        uint256 tokensBought,\\n        uint128 soldId,\\n        uint128 boughtId\\n    );\\n    event AddLiquidity(\\n        address indexed provider,\\n        uint256[] tokenAmounts,\\n        uint256[] fees,\\n        uint256 invariant,\\n        uint256 lpTokenSupply\\n    );\\n    event RemoveLiquidityOne(\\n        address indexed provider,\\n        uint256 lpTokenAmount,\\n        uint256 lpTokenSupply,\\n        uint256 boughtId,\\n        uint256 tokensBought\\n    );\\n    event RemoveLiquidityImbalance(\\n        address indexed provider,\\n        uint256[] tokenAmounts,\\n        uint256[] fees,\\n        uint256 invariant,\\n        uint256 lpTokenSupply\\n    );\\n    event NewAdminFee(uint256 newAdminFee);\\n    event NewSwapFee(uint256 newSwapFee);\\n    event NewWithdrawFee(uint256 newWithdrawFee);\\n\\n    struct MetaSwap {\\n        // Meta-Swap related parameters\\n        ISwap baseSwap;\\n        uint256 baseVirtualPrice;\\n        uint256 baseCacheLastUpdated;\\n        IERC20[] baseTokens;\\n    }\\n\\n    // Struct storing variables used in calculations in the\\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\\n    struct CalculateWithdrawOneTokenDYInfo {\\n        uint256 d0;\\n        uint256 d1;\\n        uint256 newY;\\n        uint256 feePerToken;\\n        uint256 preciseA;\\n        uint256 xpi;\\n    }\\n\\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\\n    // to avoid stack too deep error\\n    struct ManageLiquidityInfo {\\n        uint256 d0;\\n        uint256 d1;\\n        uint256 d2;\\n        LPToken lpToken;\\n        uint256 totalSupply;\\n        uint256 preciseA;\\n        uint256 baseVirtualPrice;\\n        uint256[] tokenPrecisionMultipliers;\\n        uint256[] newBalances;\\n    }\\n\\n    struct SwapUnderlyingInfo {\\n        uint256 x;\\n        uint256 dx;\\n        uint256 dy;\\n        uint256[] tokenPrecisionMultipliers;\\n        uint256[] oldBalances;\\n        IERC20[] baseTokens;\\n        IERC20 tokenFrom;\\n        uint8 metaIndexFrom;\\n        IERC20 tokenTo;\\n        uint8 metaIndexTo;\\n        uint256 baseVirtualPrice;\\n    }\\n\\n    struct CalculateSwapUnderlyingInfo {\\n        uint256 baseVirtualPrice;\\n        ISwap baseSwap;\\n        uint8 baseLPTokenIndex;\\n        uint8 baseTokensLength;\\n        uint8 metaIndexTo;\\n        uint256 x;\\n        uint256 dy;\\n    }\\n\\n    // the denominator used to calculate admin and LP fees. For example, an\\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\\n    uint256 private constant FEE_DENOMINATOR = 10**10;\\n\\n    // Cache expire time for the stored value of base Swap's virtual price\\n    uint256 public constant BASE_CACHE_EXPIRE_TIME = 10 minutes;\\n    uint256 public constant BASE_VIRTUAL_PRICE_PRECISION = 10**18;\\n\\n    /*** VIEW & PURE FUNCTIONS ***/\\n\\n    /**\\n     * @notice Return the stored value of base Swap's virtual price. If\\n     * value was updated past BASE_CACHE_EXPIRE_TIME, then read it directly\\n     * from the base Swap contract.\\n     * @param metaSwapStorage MetaSwap struct to read from\\n     * @return base Swap's virtual price\\n     */\\n    function _getBaseVirtualPrice(MetaSwap storage metaSwapStorage)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        if (\\n            block.timestamp >\\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\\n        ) {\\n            return metaSwapStorage.baseSwap.getVirtualPrice();\\n        }\\n        return metaSwapStorage.baseVirtualPrice;\\n    }\\n\\n    /**\\n     * @notice Calculate how much the user would receive when withdrawing via single token\\n     * @param self Swap struct to read from\\n     * @param metaSwapStorage MetaSwap struct to read from\\n     * @param tokenAmount the amount to withdraw in the pool's precision\\n     * @param tokenIndex which token will be withdrawn\\n     * @return dy the amount of token user will receive\\n     */\\n    function calculateWithdrawOneToken(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint256 tokenAmount,\\n        uint8 tokenIndex\\n    ) external view returns (uint256 dy) {\\n        (dy, ) = _calculateWithdrawOneToken(\\n            self,\\n            tokenAmount,\\n            tokenIndex,\\n            _getBaseVirtualPrice(metaSwapStorage),\\n            self.lpToken.totalSupply()\\n        );\\n    }\\n\\n    function _calculateWithdrawOneToken(\\n        SwapUtils.Swap storage self,\\n        uint256 tokenAmount,\\n        uint8 tokenIndex,\\n        uint256 baseVirtualPrice,\\n        uint256 totalSupply\\n    ) internal view returns (uint256, uint256) {\\n        uint256 dy;\\n        uint256 dySwapFee;\\n\\n        {\\n            uint256 currentY;\\n            uint256 newY;\\n\\n            // Calculate how much to withdraw\\n            (dy, newY, currentY) = _calculateWithdrawOneTokenDY(\\n                self,\\n                tokenIndex,\\n                tokenAmount,\\n                baseVirtualPrice,\\n                totalSupply\\n            );\\n\\n            // Calculate the associated swap fee\\n            dySwapFee = currentY\\n                .sub(newY)\\n                .div(self.tokenPrecisionMultipliers[tokenIndex])\\n                .sub(dy);\\n        }\\n\\n        return (dy, dySwapFee);\\n    }\\n\\n    /**\\n     * @notice Calculate the dy of withdrawing in one token\\n     * @param self Swap struct to read from\\n     * @param tokenIndex which token will be withdrawn\\n     * @param tokenAmount the amount to withdraw in the pools precision\\n     * @param baseVirtualPrice the virtual price of the base swap's LP token\\n     * @return the dy excluding swap fee, the new y after withdrawing one token, and current y\\n     */\\n    function _calculateWithdrawOneTokenDY(\\n        SwapUtils.Swap storage self,\\n        uint8 tokenIndex,\\n        uint256 tokenAmount,\\n        uint256 baseVirtualPrice,\\n        uint256 totalSupply\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Get the current D, then solve the stableswap invariant\\n        // y_i for D - tokenAmount\\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\\n        require(tokenIndex < xp.length, \\\"Token index out of range\\\");\\n\\n        CalculateWithdrawOneTokenDYInfo memory v =\\n            CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, self._getAPrecise(), 0);\\n        v.d0 = SwapUtils.getD(xp, v.preciseA);\\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\\n\\n        require(tokenAmount <= xp[tokenIndex], \\\"Withdraw exceeds available\\\");\\n\\n        v.newY = SwapUtils.getYD(v.preciseA, tokenIndex, xp, v.d1);\\n\\n        uint256[] memory xpReduced = new uint256[](xp.length);\\n\\n        v.feePerToken = SwapUtils._feePerToken(self.swapFee, xp.length);\\n        for (uint256 i = 0; i < xp.length; i++) {\\n            v.xpi = xp[i];\\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\\n            xpReduced[i] = v.xpi.sub(\\n                (\\n                    (i == tokenIndex)\\n                        ? v.xpi.mul(v.d1).div(v.d0).sub(v.newY)\\n                        : v.xpi.sub(v.xpi.mul(v.d1).div(v.d0))\\n                )\\n                    .mul(v.feePerToken)\\n                    .div(FEE_DENOMINATOR)\\n            );\\n        }\\n\\n        uint256 dy =\\n            xpReduced[tokenIndex].sub(\\n                SwapUtils.getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\\n            );\\n\\n        if (tokenIndex == xp.length.sub(1)) {\\n            dy = dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(baseVirtualPrice);\\n        }\\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\\n\\n        return (dy, v.newY, xp[tokenIndex]);\\n    }\\n\\n    /**\\n     * @notice Given a set of balances and precision multipliers, return the\\n     * precision-adjusted balances. The last element will also get scaled up by\\n     * the given baseVirtualPrice.\\n     *\\n     * @param balances an array of token balances, in their native precisions.\\n     * These should generally correspond with pooled tokens.\\n     *\\n     * @param precisionMultipliers an array of multipliers, corresponding to\\n     * the amounts in the balances array. When multiplied together they\\n     * should yield amounts at the pool's precision.\\n     *\\n     * @param baseVirtualPrice the base virtual price to scale the balance of the\\n     * base Swap's LP token.\\n     *\\n     * @return an array of amounts \\\"scaled\\\" to the pool's precision\\n     */\\n    function _xp(\\n        uint256[] memory balances,\\n        uint256[] memory precisionMultipliers,\\n        uint256 baseVirtualPrice\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory xp = SwapUtils._xp(balances, precisionMultipliers);\\n        uint256 baseLPTokenIndex = balances.length.sub(1);\\n        xp[baseLPTokenIndex] = xp[baseLPTokenIndex].mul(baseVirtualPrice).div(\\n            BASE_VIRTUAL_PRICE_PRECISION\\n        );\\n        return xp;\\n    }\\n\\n    /**\\n     * @notice Return the precision-adjusted balances of all tokens in the pool\\n     * @param self Swap struct to read from\\n     * @return the pool balances \\\"scaled\\\" to the pool's precision, allowing\\n     * them to be more easily compared.\\n     */\\n    function _xp(SwapUtils.Swap storage self, uint256 baseVirtualPrice)\\n        internal\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return\\n            _xp(\\n                self.balances,\\n                self.tokenPrecisionMultipliers,\\n                baseVirtualPrice\\n            );\\n    }\\n\\n    /**\\n     * @notice Get the virtual price, to help calculate profit\\n     * @param self Swap struct to read from\\n     * @param metaSwapStorage MetaSwap struct to read from\\n     * @return the virtual price, scaled to precision of BASE_VIRTUAL_PRICE_PRECISION\\n     */\\n    function getVirtualPrice(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage\\n    ) external view returns (uint256) {\\n        uint256 d =\\n            SwapUtils.getD(\\n                _xp(\\n                    self.balances,\\n                    self.tokenPrecisionMultipliers,\\n                    _getBaseVirtualPrice(metaSwapStorage)\\n                ),\\n                self._getAPrecise()\\n            );\\n        uint256 supply = self.lpToken.totalSupply();\\n        if (supply != 0) {\\n            return d.mul(BASE_VIRTUAL_PRICE_PRECISION).div(supply);\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Externally calculates a swap between two tokens. The SwapUtils.Swap storage and\\n     * MetaSwap storage should be from the same MetaSwap contract.\\n     * @param self Swap struct to read from\\n     * @param metaSwapStorage MetaSwap struct from the same contract\\n     * @param tokenIndexFrom the token to sell\\n     * @param tokenIndexTo the token to buy\\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n     * use the amount that gets transferred after the fee.\\n     * @return dy the number of tokens the user will get\\n     */\\n    function calculateSwap(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256 dy) {\\n        (dy, ) = _calculateSwap(\\n            self,\\n            tokenIndexFrom,\\n            tokenIndexTo,\\n            dx,\\n            _getBaseVirtualPrice(metaSwapStorage)\\n        );\\n    }\\n\\n    /**\\n     * @notice Internally calculates a swap between two tokens.\\n     *\\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\\n     * using the token contracts.\\n     *\\n     * @param self Swap struct to read from\\n     * @param tokenIndexFrom the token to sell\\n     * @param tokenIndexTo the token to buy\\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n     * use the amount that gets transferred after the fee.\\n     * @param baseVirtualPrice the virtual price of the base LP token\\n     * @return dy the number of tokens the user will get and dyFee the associated fee\\n     */\\n    function _calculateSwap(\\n        SwapUtils.Swap storage self,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 baseVirtualPrice\\n    ) internal view returns (uint256 dy, uint256 dyFee) {\\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\\n        require(\\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\\n            \\\"Token index out of range\\\"\\n        );\\n        uint256 x =\\n            dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(\\n                xp[tokenIndexFrom]\\n            );\\n        uint256 y =\\n            SwapUtils.getY(\\n                self._getAPrecise(),\\n                tokenIndexFrom,\\n                tokenIndexTo,\\n                x,\\n                xp\\n            );\\n        dy = xp[tokenIndexTo].sub(y).sub(1);\\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\\n        dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\\n    }\\n\\n    /**\\n     * @notice Calculates the expected return amount from swapping between\\n     * the pooled tokens and the underlying tokens of the base Swap pool.\\n     *\\n     * @param self Swap struct to read from\\n     * @param metaSwapStorage MetaSwap struct from the same contract\\n     * @param tokenIndexFrom the token to sell\\n     * @param tokenIndexTo the token to buy\\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n     * use the amount that gets transferred after the fee.\\n     * @return dy the number of tokens the user will get\\n     */\\n    function calculateSwapUnderlying(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256) {\\n        CalculateSwapUnderlyingInfo memory v =\\n            CalculateSwapUnderlyingInfo(\\n                _getBaseVirtualPrice(metaSwapStorage),\\n                metaSwapStorage.baseSwap,\\n                0,\\n                uint8(metaSwapStorage.baseTokens.length),\\n                0,\\n                0,\\n                0\\n            );\\n\\n        uint256[] memory xp = _xp(self, v.baseVirtualPrice);\\n        v.baseLPTokenIndex = uint8(xp.length.sub(1));\\n        {\\n            uint8 maxRange = v.baseLPTokenIndex + v.baseTokensLength;\\n            require(\\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\\n                \\\"Token index out of range\\\"\\n            );\\n        }\\n\\n        if (tokenIndexFrom < v.baseLPTokenIndex) {\\n            // tokenFrom is from this pool\\n            v.x = xp[tokenIndexFrom].add(\\n                dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom])\\n            );\\n        } else {\\n            // tokenFrom is from the base pool\\n            tokenIndexFrom = tokenIndexFrom - v.baseLPTokenIndex;\\n            if (tokenIndexTo < v.baseLPTokenIndex) {\\n                uint256[] memory baseInputs = new uint256[](v.baseTokensLength);\\n                baseInputs[tokenIndexFrom] = dx;\\n                v.x = v\\n                    .baseSwap\\n                    .calculateTokenAmount(baseInputs, true)\\n                    .mul(v.baseVirtualPrice)\\n                    .div(BASE_VIRTUAL_PRICE_PRECISION)\\n                    .add(xp[v.baseLPTokenIndex]);\\n            } else {\\n                // both from and to are from the base pool\\n                return\\n                    v.baseSwap.calculateSwap(\\n                        tokenIndexFrom,\\n                        tokenIndexTo - v.baseLPTokenIndex,\\n                        dx\\n                    );\\n            }\\n            tokenIndexFrom = v.baseLPTokenIndex;\\n        }\\n\\n        v.metaIndexTo = v.baseLPTokenIndex;\\n        if (tokenIndexTo < v.baseLPTokenIndex) {\\n            v.metaIndexTo = tokenIndexTo;\\n        }\\n\\n        {\\n            uint256 y =\\n                SwapUtils.getY(\\n                    self._getAPrecise(),\\n                    tokenIndexFrom,\\n                    v.metaIndexTo,\\n                    v.x,\\n                    xp\\n                );\\n            v.dy = xp[v.metaIndexTo].sub(y).sub(1);\\n            uint256 dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\\n            v.dy = v.dy.sub(dyFee);\\n        }\\n\\n        if (tokenIndexTo < v.baseLPTokenIndex) {\\n            // tokenTo is from this pool\\n            v.dy = v.dy.div(self.tokenPrecisionMultipliers[v.metaIndexTo]);\\n        } else {\\n            // tokenTo is from the base pool\\n            v.dy = v.baseSwap.calculateRemoveLiquidityOneToken(\\n                v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(v.baseVirtualPrice),\\n                tokenIndexTo - v.baseLPTokenIndex\\n            );\\n        }\\n\\n        return v.dy;\\n    }\\n\\n    /**\\n     * @notice A simple method to calculate prices from deposits or\\n     * withdrawals, excluding fees but including slippage. This is\\n     * helpful as an input into the various \\\"min\\\" parameters on calls\\n     * to fight front-running\\n     *\\n     * @dev This shouldn't be used outside frontends for user estimates.\\n     *\\n     * @param self Swap struct to read from\\n     * @param metaSwapStorage MetaSwap struct to read from\\n     * @param amounts an array of token amounts to deposit or withdrawal,\\n     * corresponding to pooledTokens. The amount should be in each\\n     * pooled token's native precision. If a token charges a fee on transfers,\\n     * use the amount that gets transferred after the fee.\\n     * @param deposit whether this is a deposit or a withdrawal\\n     * @return if deposit was true, total amount of lp token that will be minted and if\\n     * deposit was false, total amount of lp token that will be burned\\n     */\\n    function calculateTokenAmount(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint256[] calldata amounts,\\n        bool deposit\\n    ) external view returns (uint256) {\\n        uint256 a = self._getAPrecise();\\n        uint256 d0;\\n        uint256 d1;\\n        {\\n            uint256 baseVirtualPrice = _getBaseVirtualPrice(metaSwapStorage);\\n            uint256[] memory balances1 = self.balances;\\n            uint256[] memory tokenPrecisionMultipliers =\\n                self.tokenPrecisionMultipliers;\\n            uint256 numTokens = balances1.length;\\n            d0 = SwapUtils.getD(\\n                _xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),\\n                a\\n            );\\n            for (uint256 i = 0; i < numTokens; i++) {\\n                if (deposit) {\\n                    balances1[i] = balances1[i].add(amounts[i]);\\n                } else {\\n                    balances1[i] = balances1[i].sub(\\n                        amounts[i],\\n                        \\\"Cannot withdraw more than available\\\"\\n                    );\\n                }\\n            }\\n            d1 = SwapUtils.getD(\\n                _xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),\\n                a\\n            );\\n        }\\n        uint256 totalSupply = self.lpToken.totalSupply();\\n\\n        if (deposit) {\\n            return d1.sub(d0).mul(totalSupply).div(d0);\\n        } else {\\n            return d0.sub(d1).mul(totalSupply).div(d0);\\n        }\\n    }\\n\\n    /*** STATE MODIFYING FUNCTIONS ***/\\n\\n    /**\\n     * @notice swap two tokens in the pool\\n     * @param self Swap struct to read from and write to\\n     * @param metaSwapStorage MetaSwap struct to read from and write to\\n     * @param tokenIndexFrom the token the user wants to sell\\n     * @param tokenIndexTo the token the user wants to buy\\n     * @param dx the amount of tokens the user wants to sell\\n     * @param minDy the min amount the user would like to receive, or revert.\\n     * @return amount of token user received on swap\\n     */\\n    function swap(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy\\n    ) external returns (uint256) {\\n        {\\n            uint256 pooledTokensLength = self.pooledTokens.length;\\n            require(\\n                tokenIndexFrom < pooledTokensLength &&\\n                    tokenIndexTo < pooledTokensLength,\\n                \\\"Token index is out of range\\\"\\n            );\\n        }\\n\\n        uint256 transferredDx;\\n        {\\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\\n            require(\\n                dx <= tokenFrom.balanceOf(msg.sender),\\n                \\\"Cannot swap more than you own\\\"\\n            );\\n\\n            {\\n                // Transfer tokens first to see if a fee was charged on transfer\\n                uint256 beforeBalance = tokenFrom.balanceOf(address(this));\\n                tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\\n\\n                // Use the actual transferred amount for AMM math\\n                transferredDx = tokenFrom.balanceOf(address(this)).sub(\\n                    beforeBalance\\n                );\\n            }\\n        }\\n\\n        (uint256 dy, uint256 dyFee) =\\n            _calculateSwap(\\n                self,\\n                tokenIndexFrom,\\n                tokenIndexTo,\\n                transferredDx,\\n                _updateBaseVirtualPrice(metaSwapStorage)\\n            );\\n        require(dy >= minDy, \\\"Swap didn't result in min tokens\\\");\\n\\n        uint256 dyAdminFee =\\n            dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\\n                self.tokenPrecisionMultipliers[tokenIndexTo]\\n            );\\n\\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(\\n            transferredDx\\n        );\\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(\\n            dyAdminFee\\n        );\\n\\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\\n\\n        emit TokenSwap(\\n            msg.sender,\\n            transferredDx,\\n            dy,\\n            tokenIndexFrom,\\n            tokenIndexTo\\n        );\\n\\n        return dy;\\n    }\\n\\n    /**\\n     * @notice Swaps with the underlying tokens of the base Swap pool. For this function,\\n     * the token indices are flattened out so that underlying tokens are represented\\n     * in the indices.\\n     * @dev Since this calls multiple external functions during the execution,\\n     * it is recommended to protect any function that depends on this with reentrancy guards.\\n     * @param self Swap struct to read from and write to\\n     * @param metaSwapStorage MetaSwap struct to read from and write to\\n     * @param tokenIndexFrom the token the user wants to sell\\n     * @param tokenIndexTo the token the user wants to buy\\n     * @param dx the amount of tokens the user wants to sell\\n     * @param minDy the min amount the user would like to receive, or revert.\\n     * @return amount of token user received on swap\\n     */\\n    function swapUnderlying(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy\\n    ) external returns (uint256) {\\n        SwapUnderlyingInfo memory v =\\n            SwapUnderlyingInfo(\\n                0,\\n                0,\\n                0,\\n                self.tokenPrecisionMultipliers,\\n                self.balances,\\n                metaSwapStorage.baseTokens,\\n                IERC20(address(0)),\\n                0,\\n                IERC20(address(0)),\\n                0,\\n                _updateBaseVirtualPrice(metaSwapStorage)\\n            );\\n\\n        uint8 baseLPTokenIndex = uint8(v.oldBalances.length.sub(1));\\n\\n        {\\n            uint8 maxRange = uint8(baseLPTokenIndex + v.baseTokens.length);\\n            require(\\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\\n                \\\"Token index out of range\\\"\\n            );\\n        }\\n\\n        ISwap baseSwap = metaSwapStorage.baseSwap;\\n\\n        // Find the address of the token swapping from and the index in MetaSwap's token list\\n        if (tokenIndexFrom < baseLPTokenIndex) {\\n            v.tokenFrom = self.pooledTokens[tokenIndexFrom];\\n            v.metaIndexFrom = tokenIndexFrom;\\n        } else {\\n            v.tokenFrom = v.baseTokens[tokenIndexFrom - baseLPTokenIndex];\\n            v.metaIndexFrom = baseLPTokenIndex;\\n        }\\n\\n        // Find the address of the token swapping to and the index in MetaSwap's token list\\n        if (tokenIndexTo < baseLPTokenIndex) {\\n            v.tokenTo = self.pooledTokens[tokenIndexTo];\\n            v.metaIndexTo = tokenIndexTo;\\n        } else {\\n            v.tokenTo = v.baseTokens[tokenIndexTo - baseLPTokenIndex];\\n            v.metaIndexTo = baseLPTokenIndex;\\n        }\\n\\n        // Check for possible fee on transfer\\n        v.dx = v.tokenFrom.balanceOf(address(this));\\n        v.tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\\n        v.dx = v.tokenFrom.balanceOf(address(this)).sub(v.dx); // update dx in case of fee on transfer\\n\\n        if (\\n            tokenIndexFrom < baseLPTokenIndex || tokenIndexTo < baseLPTokenIndex\\n        ) {\\n            // Either one of the tokens belongs to the MetaSwap tokens list\\n            uint256[] memory xp =\\n                _xp(\\n                    v.oldBalances,\\n                    v.tokenPrecisionMultipliers,\\n                    v.baseVirtualPrice\\n                );\\n\\n            if (tokenIndexFrom < baseLPTokenIndex) {\\n                // Swapping from a MetaSwap token\\n                v.x = xp[tokenIndexFrom].add(\\n                    dx.mul(v.tokenPrecisionMultipliers[tokenIndexFrom])\\n                );\\n            } else {\\n                // Swapping from a base Swap token\\n                // This case requires adding the underlying token to the base Swap, then\\n                // using the base LP token to swap to the desired token\\n                uint256[] memory baseAmounts =\\n                    new uint256[](v.baseTokens.length);\\n                baseAmounts[tokenIndexFrom - baseLPTokenIndex] = v.dx;\\n\\n                // Add liquidity to the underlying Swap contract and receive base LP token\\n                v.dx = baseSwap.addLiquidity(baseAmounts, 0, block.timestamp);\\n\\n                // Calculate the value of total amount of baseLPToken we end up with\\n                v.x = v\\n                    .dx\\n                    .mul(v.baseVirtualPrice)\\n                    .div(BASE_VIRTUAL_PRICE_PRECISION)\\n                    .add(xp[baseLPTokenIndex]);\\n            }\\n\\n            // Calculate how much to withdraw in MetaSwap level and the the associated swap fee\\n            uint256 dyFee;\\n            {\\n                uint256 y =\\n                    SwapUtils.getY(\\n                        self._getAPrecise(),\\n                        v.metaIndexFrom,\\n                        v.metaIndexTo,\\n                        v.x,\\n                        xp\\n                    );\\n                v.dy = xp[v.metaIndexTo].sub(y).sub(1);\\n                dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\\n                v.dy = v.dy.sub(dyFee).div(\\n                    v.tokenPrecisionMultipliers[v.metaIndexTo]\\n                );\\n            }\\n\\n            if (tokenIndexTo >= baseLPTokenIndex) {\\n                // When swapping to a base Swap token, scale down dy by its virtual price\\n                v.dy = v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(\\n                    v.baseVirtualPrice\\n                );\\n            }\\n\\n            // Update the balances array according to the calculated input and output amount\\n            {\\n                uint256 dyAdminFee =\\n                    dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);\\n                dyAdminFee = dyAdminFee.div(\\n                    v.tokenPrecisionMultipliers[v.metaIndexTo]\\n                );\\n                self.balances[v.metaIndexFrom] = v.oldBalances[v.metaIndexFrom]\\n                    .add(v.dx);\\n                self.balances[v.metaIndexTo] = v.oldBalances[v.metaIndexTo]\\n                    .sub(v.dy)\\n                    .sub(dyAdminFee);\\n            }\\n\\n            if (tokenIndexTo >= baseLPTokenIndex) {\\n                // When swapping to a token that belongs to the base Swap, burn the LP token\\n                // and withdraw the desired token from the base pool\\n                uint256 oldBalance = v.tokenTo.balanceOf(address(this));\\n                baseSwap.removeLiquidityOneToken(\\n                    v.dy,\\n                    tokenIndexTo - baseLPTokenIndex,\\n                    0,\\n                    block.timestamp\\n                );\\n                v.dy = v.tokenTo.balanceOf(address(this)) - oldBalance;\\n            }\\n\\n            // Check the amount of token to send meets minDy\\n            require(v.dy >= minDy, \\\"Swap didn't result in min tokens\\\");\\n        } else {\\n            // Both tokens are from the base Swap pool\\n            // Do a swap through the base Swap\\n            v.dy = v.tokenTo.balanceOf(address(this));\\n            baseSwap.swap(\\n                tokenIndexFrom - baseLPTokenIndex,\\n                tokenIndexTo - baseLPTokenIndex,\\n                v.dx,\\n                minDy,\\n                block.timestamp\\n            );\\n            v.dy = v.tokenTo.balanceOf(address(this)).sub(v.dy);\\n        }\\n\\n        // Send the desired token to the caller\\n        v.tokenTo.safeTransfer(msg.sender, v.dy);\\n\\n        emit TokenSwapUnderlying(\\n            msg.sender,\\n            dx,\\n            v.dy,\\n            tokenIndexFrom,\\n            tokenIndexTo\\n        );\\n\\n        return v.dy;\\n    }\\n\\n    /**\\n     * @notice Add liquidity to the pool\\n     * @param self Swap struct to read from and write to\\n     * @param metaSwapStorage MetaSwap struct to read from and write to\\n     * @param amounts the amounts of each token to add, in their native precision\\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\\n     * should mint, otherwise revert. Handy for front-running mitigation\\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\\n     * @return amount of LP token user received\\n     */\\n    function addLiquidity(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint256[] memory amounts,\\n        uint256 minToMint\\n    ) external returns (uint256) {\\n        IERC20[] memory pooledTokens = self.pooledTokens;\\n        require(\\n            amounts.length == pooledTokens.length,\\n            \\\"Amounts must match pooled tokens\\\"\\n        );\\n\\n        uint256[] memory fees = new uint256[](pooledTokens.length);\\n\\n        // current state\\n        ManageLiquidityInfo memory v =\\n            ManageLiquidityInfo(\\n                0,\\n                0,\\n                0,\\n                self.lpToken,\\n                0,\\n                self._getAPrecise(),\\n                _updateBaseVirtualPrice(metaSwapStorage),\\n                self.tokenPrecisionMultipliers,\\n                self.balances\\n            );\\n        v.totalSupply = v.lpToken.totalSupply();\\n\\n        if (v.totalSupply != 0) {\\n            v.d0 = SwapUtils.getD(\\n                _xp(\\n                    v.newBalances,\\n                    v.tokenPrecisionMultipliers,\\n                    v.baseVirtualPrice\\n                ),\\n                v.preciseA\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\\n            require(\\n                v.totalSupply != 0 || amounts[i] > 0,\\n                \\\"Must supply all tokens in pool\\\"\\n            );\\n\\n            // Transfer tokens first to see if a fee was charged on transfer\\n            if (amounts[i] != 0) {\\n                uint256 beforeBalance =\\n                    pooledTokens[i].balanceOf(address(this));\\n                pooledTokens[i].safeTransferFrom(\\n                    msg.sender,\\n                    address(this),\\n                    amounts[i]\\n                );\\n\\n                // Update the amounts[] with actual transfer amount\\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(\\n                    beforeBalance\\n                );\\n            }\\n\\n            v.newBalances[i] = v.newBalances[i].add(amounts[i]);\\n        }\\n\\n        // invariant after change\\n        v.d1 = SwapUtils.getD(\\n            _xp(v.newBalances, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\\n            v.preciseA\\n        );\\n        require(v.d1 > v.d0, \\\"D should increase\\\");\\n\\n        // updated to reflect fees and calculate the user's LP tokens\\n        v.d2 = v.d1;\\n        uint256 toMint;\\n\\n        if (v.totalSupply != 0) {\\n            uint256 feePerToken =\\n                SwapUtils._feePerToken(self.swapFee, pooledTokens.length);\\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\\n                uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\\n                fees[i] = feePerToken\\n                    .mul(idealBalance.difference(v.newBalances[i]))\\n                    .div(FEE_DENOMINATOR);\\n                self.balances[i] = v.newBalances[i].sub(\\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\\n                );\\n                v.newBalances[i] = v.newBalances[i].sub(fees[i]);\\n            }\\n            v.d2 = SwapUtils.getD(\\n                _xp(\\n                    v.newBalances,\\n                    v.tokenPrecisionMultipliers,\\n                    v.baseVirtualPrice\\n                ),\\n                v.preciseA\\n            );\\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\\n        } else {\\n            // the initial depositor doesn't pay fees\\n            self.balances = v.newBalances;\\n            toMint = v.d1;\\n        }\\n\\n        require(toMint >= minToMint, \\\"Couldn't mint min requested\\\");\\n\\n        // mint the user's LP tokens\\n        self.lpToken.mint(msg.sender, toMint);\\n\\n        emit AddLiquidity(\\n            msg.sender,\\n            amounts,\\n            fees,\\n            v.d1,\\n            v.totalSupply.add(toMint)\\n        );\\n\\n        return toMint;\\n    }\\n\\n    /**\\n     * @notice Remove liquidity from the pool all in one token.\\n     * @param self Swap struct to read from and write to\\n     * @param metaSwapStorage MetaSwap struct to read from and write to\\n     * @param tokenAmount the amount of the lp tokens to burn\\n     * @param tokenIndex the index of the token you want to receive\\n     * @param minAmount the minimum amount to withdraw, otherwise revert\\n     * @return amount chosen token that user received\\n     */\\n    function removeLiquidityOneToken(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint256 tokenAmount,\\n        uint8 tokenIndex,\\n        uint256 minAmount\\n    ) external returns (uint256) {\\n        LPToken lpToken = self.lpToken;\\n        uint256 totalSupply = lpToken.totalSupply();\\n        uint256 numTokens = self.pooledTokens.length;\\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\n        require(tokenIndex < numTokens, \\\"Token not found\\\");\\n\\n        uint256 dyFee;\\n        uint256 dy;\\n\\n        (dy, dyFee) = _calculateWithdrawOneToken(\\n            self,\\n            tokenAmount,\\n            tokenIndex,\\n            _updateBaseVirtualPrice(metaSwapStorage),\\n            totalSupply\\n        );\\n\\n        require(dy >= minAmount, \\\"dy < minAmount\\\");\\n\\n        // Update balances array\\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\\n        );\\n\\n        // Burn the associated LP token from the caller and send the desired token\\n        lpToken.burnFrom(msg.sender, tokenAmount);\\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\\n\\n        emit RemoveLiquidityOne(\\n            msg.sender,\\n            tokenAmount,\\n            totalSupply,\\n            tokenIndex,\\n            dy\\n        );\\n\\n        return dy;\\n    }\\n\\n    /**\\n     * @notice Remove liquidity from the pool, weighted differently than the\\n     * pool's current balances.\\n     *\\n     * @param self Swap struct to read from and write to\\n     * @param metaSwapStorage MetaSwap struct to read from and write to\\n     * @param amounts how much of each token to withdraw\\n     * @param maxBurnAmount the max LP token provider is willing to pay to\\n     * remove liquidity. Useful as a front-running mitigation.\\n     * @return actual amount of LP tokens burned in the withdrawal\\n     */\\n    function removeLiquidityImbalance(\\n        SwapUtils.Swap storage self,\\n        MetaSwap storage metaSwapStorage,\\n        uint256[] memory amounts,\\n        uint256 maxBurnAmount\\n    ) public returns (uint256) {\\n        // Using this struct to avoid stack too deep error\\n        ManageLiquidityInfo memory v =\\n            ManageLiquidityInfo(\\n                0,\\n                0,\\n                0,\\n                self.lpToken,\\n                0,\\n                self._getAPrecise(),\\n                _updateBaseVirtualPrice(metaSwapStorage),\\n                self.tokenPrecisionMultipliers,\\n                self.balances\\n            );\\n        v.totalSupply = v.lpToken.totalSupply();\\n\\n        require(\\n            amounts.length == v.newBalances.length,\\n            \\\"Amounts should match pool tokens\\\"\\n        );\\n        require(maxBurnAmount != 0, \\\"Must burn more than 0\\\");\\n\\n        uint256 feePerToken =\\n            SwapUtils._feePerToken(self.swapFee, v.newBalances.length);\\n\\n        // Calculate how much LPToken should be burned\\n        uint256[] memory fees = new uint256[](v.newBalances.length);\\n        {\\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\\n\\n            v.d0 = SwapUtils.getD(\\n                _xp(\\n                    v.newBalances,\\n                    v.tokenPrecisionMultipliers,\\n                    v.baseVirtualPrice\\n                ),\\n                v.preciseA\\n            );\\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\\n                balances1[i] = v.newBalances[i].sub(\\n                    amounts[i],\\n                    \\\"Cannot withdraw more than available\\\"\\n                );\\n            }\\n            v.d1 = SwapUtils.getD(\\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\\n                v.preciseA\\n            );\\n\\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\\n                uint256 difference = idealBalance.difference(balances1[i]);\\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\\n                self.balances[i] = balances1[i].sub(\\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\\n                );\\n                balances1[i] = balances1[i].sub(fees[i]);\\n            }\\n\\n            v.d2 = SwapUtils.getD(\\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\\n                v.preciseA\\n            );\\n        }\\n\\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\\n        require(tokenAmount != 0, \\\"Burnt amount cannot be zero\\\");\\n\\n        // Scale up by withdraw fee\\n        tokenAmount = tokenAmount.add(1);\\n\\n        // Check for max burn amount\\n        require(tokenAmount <= maxBurnAmount, \\\"tokenAmount > maxBurnAmount\\\");\\n\\n        // Burn the calculated amount of LPToken from the caller and send the desired tokens\\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\\n        }\\n\\n        emit RemoveLiquidityImbalance(\\n            msg.sender,\\n            amounts,\\n            fees,\\n            v.d1,\\n            v.totalSupply.sub(tokenAmount)\\n        );\\n\\n        return tokenAmount;\\n    }\\n\\n    /**\\n     * @notice Determines if the stored value of base Swap's virtual price is expired.\\n     * If the last update was past the BASE_CACHE_EXPIRE_TIME, then update the stored value.\\n     *\\n     * @param metaSwapStorage MetaSwap struct to read from and write to\\n     * @return base Swap's virtual price\\n     */\\n    function _updateBaseVirtualPrice(MetaSwap storage metaSwapStorage)\\n        internal\\n        returns (uint256)\\n    {\\n        if (\\n            block.timestamp >\\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\\n        ) {\\n            // When the cache is expired, update it\\n            uint256 baseVirtualPrice =\\n                ISwap(metaSwapStorage.baseSwap).getVirtualPrice();\\n            metaSwapStorage.baseVirtualPrice = baseVirtualPrice;\\n            metaSwapStorage.baseCacheLastUpdated = block.timestamp;\\n            return baseVirtualPrice;\\n        } else {\\n            return metaSwapStorage.baseVirtualPrice;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}"}
{"address": "0xae465fd39b519602ee28f062037f7b9c41fdc8cf", "attacktype": "On-chain oracle manipulation", "sourcecode": "// File: node_modules\\@openzeppelin\\contracts\\GSN\\Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\access\\Ownable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts\\utils\\Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\compound\\CarefulMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author Compound\r\n\r\n/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}\r\n\r\n// File: contracts\\compound\\Exponential.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n     */\r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies three exponentials, returning a new exponential.\r\n     */\r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n\r\n// File: contracts\\compound\\InterestRateModel.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n  * @title Compound's InterestRateModel Interface\r\n  * @author Compound\r\n  */\r\nabstract contract InterestRateModel {\r\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n    bool public constant isInterestRateModel = true;\r\n\r\n    /**\r\n      * @notice Calculates the current borrow interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amount of reserves the market has\r\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external virtual view returns (uint);\r\n\r\n    /**\r\n      * @notice Calculates the current supply interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amount of reserves the market has\r\n      * @param reserveFactorMantissa The current reserve factor the market has\r\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external virtual view returns (uint);\r\n\r\n}\r\n\r\n// File: contracts\\interfaces\\UniswapLPOracleFactoryI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title UniswapLPOracleFactoryI\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nThe UniswapLPOracleFactoryI contract an abstract contract the Warp platform uses to interface\r\n    With the UniswapOracleFactory to retrieve token prices.\r\n**/\r\n\r\nabstract contract UniswapLPOracleFactoryI {\r\n    function createNewOracles(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        address _lpToken\r\n    ) public virtual;\r\n\r\n    function OneUSDC() public virtual view returns (uint256);\r\n\r\n    function getUnderlyingPrice(address _MMI) public virtual returns (uint256);\r\n\r\n    function viewUnderlyingPrice(address _MMI)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPriceOfToken(address _token, uint256 _amount)\r\n        public\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function viewPriceOfToken(address token, uint256 _amount)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferOwnership(address _newOwner) public virtual;\r\n\r\n    function _calculatePriceOfLP(\r\n        uint256 supply,\r\n        uint256 value0,\r\n        uint256 value1,\r\n        uint8 supplyDecimals\r\n    ) public virtual pure returns (uint256);\r\n}\r\n\r\n// File: contracts\\WarpWrapperToken.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpWrapperToken\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n@notice the WarpWrapperToken contract is designed  as a token Wrapper to represent ownership of stablecoins added to a specific\r\n        WarpVault. This contract inherits Ownership and ERC20 functionality from the Open Zeppelin Library.\r\n**/\r\ncontract WarpWrapperToken is Ownable, ERC20 {\r\n    address public stablecoin;\r\n\r\n    ///@notice constructor sets up token names and symbols for the WarpWrapperToken\r\n    constructor(\r\n        address _SC,\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol\r\n    ) public ERC20(_tokenSymbol, _tokenName) {\r\n        stablecoin = _SC;\r\n    }\r\n\r\n    /**\r\n    @notice mint is an only owner function that allows the owner to mint new tokens to an input account\r\n    @param _to is the address that will receive the new tokens\r\n    @param _amount is the amount of token they will receive\r\n    **/\r\n    function mint(address _to, uint256 _amount) public onlyOwner {\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    /**\r\n    @notice burn is an only owner function that allows the owner to burn  tokens from an input account\r\n    @param _from is the address where the tokens will be burnt\r\n    @param _amount is the amount of token to be burnt\r\n    **/\r\n    function burn(address _from, uint256 _amount) public onlyOwner {\r\n        _burn(_from, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\WarpControlI.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpVaultI\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\nThe WarpControlI contract is an abstract contract used by individual WarpVault contracts to call the\r\n  maxWithdrawAllowed function on the WarpControl contract\r\n**/\r\n\r\nabstract contract WarpControlI {\r\n    function getMaxWithdrawAllowed(address account, address lpToken)\r\n        public\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function viewMaxWithdrawAllowed(address account, address lpToken)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function viewPriceOfCollateral(address lpToken)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function addMemberToGroup(address _refferalCode, address _member)\r\n        public\r\n        virtual;\r\n\r\n    function checkIfGroupMember(address _account)\r\n        public\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    function getTotalAvailableCollateralValue(address _account)\r\n        public\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function viewTotalAvailableCollateralValue(address _account)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function viewPriceOfToken(address token)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function viewTotalBorrowedValue(address _account)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTotalBorrowedValue(address _account)\r\n        public\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function calcBorrowLimit(uint256 _collateralValue)\r\n        public\r\n        virtual\r\n        pure\r\n        returns (uint256);\r\n\r\n    function calcCollateralRequired(uint256 _borrowAmount)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBorrowLimit(address _account) public virtual returns (uint256);\r\n\r\n    function viewBorrowLimit(address _account)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256);\r\n\r\n    function liquidateAccount(address _borrower) public virtual;\r\n}\r\n\r\n// File: contracts\\WarpVaultSC.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title WarpVaultSC\r\n/// @author Christopher Dixon\r\n////////////////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n@notice the WarpVaultSC contract is the main point of interface for a specific LP asset class and an end user in the\r\nWarp lending platform. This contract is responsible for distributing WarpWrapper tokens in exchange for stablecoin assets,\r\nholding and accounting of stablecoins and LP tokens and all associates lending/borrowing calculations for a specific Warp LP asset class.\r\nThis contract inherits Ownership and ERC20 functionality from the Open Zeppelin Library as well as Exponential and the InterestRateModel contracts\r\nfrom the coumpound protocol.\r\n**/\r\n\r\ncontract WarpVaultSC is Exponential {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    uint256 internal initialExchangeRateMantissa;\r\n    uint256 public reserveFactorMantissa;\r\n    uint256 public accrualBlockNumber;\r\n    uint256 public borrowIndex;\r\n    uint256 public totalBorrows;\r\n    uint256 public totalReserves;\r\n    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\r\n    uint256 public percent = 1500;\r\n    uint256 public divisor = 10000;\r\n    uint256 public timeWizard;\r\n    address public warpTeam;\r\n\r\n    ERC20 public stablecoin;\r\n    WarpWrapperToken public wStableCoin;\r\n    WarpControlI public warpControl;\r\n    InterestRateModel public InterestRate;\r\n\r\n    mapping(address => BorrowSnapshot) public accountBorrows;\r\n    mapping(address => uint256) public principalBalance;\r\n    mapping(address => uint256) public historicalReward;\r\n\r\n    event InterestAccrued(\r\n        uint256 accrualBlockNumber,\r\n        uint256 borrowIndex,\r\n        uint256 totalBorrows,\r\n        uint256 totalReserves\r\n    );\r\n    event StableCoinLent(\r\n        address _lender,\r\n        uint256 _amountLent,\r\n        uint256 _amountOfWarpMinted\r\n    );\r\n    event StableCoinWithdraw(\r\n        address _lender,\r\n        uint256 _amountWithdrawn,\r\n        uint256 _amountOfWarpBurnt\r\n    );\r\n    event LoanRepayed(\r\n        address _borrower,\r\n        uint256 _repayAmount,\r\n        uint256 remainingPrinciple,\r\n        uint256 remainingInterest\r\n    );\r\n    event ReserveWithdraw(uint256 _amount);\r\n    event InterestShortCircuit(uint256 _blockNumber);\r\n    event WarpControlChanged(address _newControl, address _oldControl);\r\n    event WarpTeamChanged(address _newTeam, address _newControl);\r\n    event InterestRateModelUpdate(address _newIRM);\r\n    event ReserveFactorUpdated(uint _newRF);\r\n\r\n    /**\r\n    @notice struct for borrow balance information\r\n    @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n    @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n    */\r\n    struct BorrowSnapshot {\r\n        uint256 principal;\r\n        uint256 interestIndex;\r\n    }\r\n\r\n    /**\r\n    @dev Throws if called by any account other than a warp control\r\n    **/\r\n    modifier onlyWarpControl() {\r\n        require(msg.sender == address(warpControl));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @dev Throws if a function is called before the time wizard allows it\r\n    **/\r\n    modifier angryWizard() {\r\n        require(now > timeWizard);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @dev Throws if a function is called by anyone but the warp team\r\n    **/\r\n    modifier onlyWarpTeam() {\r\n        require(msg.sender == warpTeam);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @notice constructor sets up token names and symbols for the WarpWrapperToken\r\n    @param _InterestRate is the address of the Interest Rate Model this vault will be using\r\n    @param _StableCoin is the address of the stablecoin this vault will manage\r\n    @param _warpTeam is the address of the Warp Team used for fees\r\n    @param _initialExchangeRate is the initial exchange rate mantissa used to determine how a Warp wrapper token will be distributed when stablecoin is received\r\n    @param _timelock is a variable representing the number of seconds the timeWizard will prevent withdraws and borrows from a contracts(one week is 605800 seconds)\r\n    **/\r\n    constructor(\r\n        address _InterestRate,\r\n        address _StableCoin,\r\n        address _warpControl,\r\n        address _warpTeam,\r\n        uint256 _initialExchangeRate,\r\n        uint256 _timelock,\r\n        uint256 _reserveFactorMantissa\r\n    ) public {\r\n        warpControl = WarpControlI(_warpControl);\r\n        stablecoin = ERC20(_StableCoin);\r\n        InterestRate = InterestRateModel(_InterestRate);\r\n        accrualBlockNumber = getBlockNumber();\r\n        borrowIndex = mantissaOne;\r\n        initialExchangeRateMantissa = _initialExchangeRate; //sets the initialExchangeRateMantissa\r\n        warpTeam = _warpTeam;\r\n        timeWizard = now.add(_timelock);\r\n        reserveFactorMantissa = _reserveFactorMantissa;\r\n\r\n        bytes memory name = abi.encodePacked(\"Warp-\");\r\n        name = abi.encodePacked(name, stablecoin.name());\r\n        //abi encode and concat strings\r\n        bytes memory symbol = abi.encodePacked(\"W-\");\r\n        symbol = abi.encodePacked(symbol, stablecoin.symbol());\r\n        //abi encode and concat strings\r\n        string memory assetName = string(name);\r\n        string memory assetSymbol = string(symbol);\r\n\r\n\r\n        wStableCoin = new WarpWrapperToken(\r\n            address(stablecoin),\r\n            assetName,\r\n            assetSymbol\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice getSCDecimals allows for easy retrieval of the vaults stablecoin decimals\r\n    **/\r\n    function getSCDecimals() public view returns (uint8) {\r\n        return stablecoin.decimals();\r\n    }\r\n\r\n    /**\r\n    @notice getSCAddress allows for the easy retrieval of the vaults stablecoin address\r\n    **/\r\n    function getSCAddress() public view returns (address) {\r\n        return address(stablecoin);\r\n    }\r\n\r\n    /**\r\n    @notice upgrade is used when upgrading to a new version of the WarpControl contracts\r\n    @dev this is a protected function that can only be called by the WarpControl contract\r\n    **/\r\n    function updateWarpControl(address _warpControl) public onlyWarpControl {\r\n        emit WarpControlChanged(_warpControl, address(warpControl));\r\n        warpControl = WarpControlI(_warpControl);\r\n    }\r\n\r\n    function updateTeam(address _team) public onlyWarpControl {\r\n        emit WarpTeamChanged(_team, warpTeam);\r\n        warpTeam = _team;\r\n    }\r\n\r\n    /**\r\n    @notice getCashPrior is a view funcion that returns the USD balance of all held underlying stablecoin assets\r\n    **/\r\n    function getCashPrior() public view returns (uint256) {\r\n        return stablecoin.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n    @notice calculateFee is used to calculate the fee earned by the Warp Platform\r\n    @param _payedAmount is a uint representing the full amount of stablecoin earned as interest\r\n        **/\r\n    function calculateFee(uint256 _payedAmount) public view returns (uint256) {\r\n        uint256 fee = _payedAmount.mul(percent).div(divisor);\r\n        return fee;\r\n    }\r\n\r\n    /**\r\n    @notice withdrawFees allows the warp team to withdraw the reserves earned by fees\r\n    @param _amount is the amount of a stablecoin being withdrawn\r\n    @dev this is a protected function that can only be called by the warpTeam address\r\n    **/\r\n    function withdrawFees(uint256 _amount) public onlyWarpTeam {\r\n        require(\r\n            totalReserves >= _amount,\r\n            \"You are trying to withdraw too much\"\r\n        );\r\n        totalReserves = totalReserves.sub(_amount);\r\n        stablecoin.safeTransfer(warpTeam, _amount);\r\n        emit ReserveWithdraw(_amount);\r\n    }\r\n\r\n    /**\r\n    @notice setNewInterestModel allows for a new interest rate model to be set for this vault\r\n    @param _newModel is the address of the new interest rate model contract\r\n    @dev this is a protected function that can only be called by the WarpControl contract\r\n    **/\r\n    function setNewInterestModel(address _newModel) public onlyWarpControl {\r\n        InterestRate = InterestRateModel(_newModel);\r\n        emit InterestRateModelUpdate(_newModel);\r\n    }\r\n\r\n    /**\r\n    @notice updateReserve allows for a new reserv percentage to be set\r\n    @param _newReserveMantissa is the reserve percentage scaled by 1e18\r\n    **/\r\n    function updateReserve(uint256 _newReserveMantissa) public onlyWarpTeam {\r\n        reserveFactorMantissa = _newReserveMantissa;\r\n        emit ReserveFactorUpdated(_newReserveMantissa);\r\n    }\r\n\r\n    /**\r\n    @notice Applies accrued interest to total borrows and reserves\r\n    @dev This calculates interest accrued from the last checkpointed block\r\n        up to the current block and writes new checkpoint to storage.\r\n    **/\r\n    function accrueInterest() public {\r\n        //Remember the initial block number\r\n        uint256 currentBlockNumber = getBlockNumber();\r\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\r\n\r\n        //Short-circuit accumulating 0 interest\r\n        if (accrualBlockNumberPrior == currentBlockNumber) {\r\n            emit InterestShortCircuit(currentBlockNumber);\r\n            return;\r\n        }\r\n\r\n        //Read the previous values out of storage\r\n        uint256 cashPrior = getCashPrior();\r\n        uint256 borrowsPrior = totalBorrows;\r\n        uint256 reservesPrior = totalReserves;\r\n        uint256 borrowIndexPrior = borrowIndex;\r\n        //Calculate the current borrow interest rate\r\n        uint256 borrowRateMantissa = InterestRate.getBorrowRate(\r\n            cashPrior,\r\n            borrowsPrior,\r\n            reservesPrior\r\n        );\r\n        require(\r\n            borrowRateMantissa <= borrowRateMaxMantissa,\r\n            \"Borrow Rate mantissa error\"\r\n        );\r\n        //Calculate the number of blocks elapsed since the last accrual\r\n        (MathError mathErr, uint256 blockDelta) = subUInt(\r\n            currentBlockNumber,\r\n            accrualBlockNumberPrior\r\n        );\r\n        //Calculate the interest accumulated into borrows and reserves and the new index:\r\n        Exp memory simpleInterestFactor;\r\n        uint256 interestAccumulated;\r\n        uint256 totalBorrowsNew;\r\n        uint256 totalReservesNew;\r\n        uint256 borrowIndexNew;\r\n        //simpleInterestFactor = borrowRate * blockDelta\r\n        (mathErr, simpleInterestFactor) = mulScalar(\r\n            Exp({mantissa: borrowRateMantissa}),\r\n            blockDelta\r\n        );\r\n        //interestAccumulated = simpleInterestFactor * totalBorrows\r\n        (mathErr, interestAccumulated) = mulScalarTruncate(\r\n            simpleInterestFactor,\r\n            borrowsPrior\r\n        );\r\n        //totalBorrowsNew = interestAccumulated + totalBorrows\r\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\r\n        //totalReservesNew = interestAccumulated * reserveFactor + totalReserves\r\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(\r\n            Exp({mantissa: reserveFactorMantissa}),\r\n            interestAccumulated,\r\n            reservesPrior\r\n        );\r\n        //borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\r\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(\r\n            simpleInterestFactor,\r\n            borrowIndexPrior,\r\n            borrowIndexPrior\r\n        );\r\n\r\n        //Write the previously calculated values into storage\r\n        accrualBlockNumber = currentBlockNumber;\r\n        borrowIndex = borrowIndexNew;\r\n        totalBorrows = totalBorrowsNew;\r\n        totalReserves = totalReservesNew;\r\n        emit InterestAccrued(\r\n            accrualBlockNumber,\r\n            borrowIndex,\r\n            totalBorrows,\r\n            totalReserves\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice returns last calculated account's borrow balance using the prior borrowIndex\r\n    @param account The address whose balance should be calculated after updating borrowIndex\r\n    @return The calculated balance\r\n    **/\r\n    function borrowBalancePrior(address account) public view returns (uint256) {\r\n        MathError mathErr;\r\n        uint256 principalTimesIndex;\r\n        uint256 result;\r\n\r\n        //Get borrowBalance and borrowIndex\r\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\r\n        //If borrowBalance = 0 then borrowIndex is likely also 0.\r\n        //Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\r\n        if (borrowSnapshot.principal == 0) {\r\n            return (0);\r\n        }\r\n        //Calculate new borrow balance using the interest index:\r\n        //recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\r\n        (mathErr, principalTimesIndex) = mulUInt(\r\n            borrowSnapshot.principal,\r\n            borrowIndex\r\n        );\r\n        //if theres a math error return zero so as not to fail\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (0);\r\n        }\r\n        (mathErr, result) = divUInt(\r\n            principalTimesIndex,\r\n            borrowSnapshot.interestIndex\r\n        );\r\n        //if theres a math error return zero so as not to fail\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (0);\r\n        }\r\n        return (result);\r\n    }\r\n\r\n    /**\r\n    @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\r\n    @param account The address whose balance should be calculated after updating borrowIndex\r\n    @return The calculated balance\r\n    **/\r\n    function borrowBalanceCurrent(address account) public returns (uint256) {\r\n        accrueInterest();\r\n        return borrowBalancePrior(account);\r\n    }\r\n\r\n    /**\r\n    @notice getBlockNumber allows for easy retrieval of block number\r\n    **/\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    @notice Returns the current per-block borrow interest rate for this cToken\r\n    @return The borrow interest rate per block, scaled by 1e18\r\n    **/\r\n    function borrowRatePerBlock() public view returns (uint256) {\r\n        return\r\n            InterestRate.getBorrowRate(\r\n                getCashPrior(),\r\n                totalBorrows,\r\n                totalReserves\r\n            );\r\n    }\r\n\r\n    /**\r\n    @notice Returns the current per-block supply interest rate for this cToken\r\n    @return The supply interest rate per block, scaled by 1e18\r\n    **/\r\n    function supplyRatePerBlock() public view returns (uint256) {\r\n        return\r\n            InterestRate.getSupplyRate(\r\n                getCashPrior(),\r\n                totalBorrows,\r\n                totalReserves,\r\n                reserveFactorMantissa\r\n            );\r\n    }\r\n\r\n    /**\r\n     @notice Returns the current total borrows plus accrued interest\r\n     @return The total borrows with interest\r\n     **/\r\n    function totalBorrowsCurrent() external returns (uint256) {\r\n        accrueInterest();\r\n        return totalBorrows;\r\n    }\r\n\r\n    /**\r\n    @notice  return the not up-to-date exchange rate\r\n    @return Calculated exchange rate scaled by 1e18\r\n    **/\r\n    function exchangeRatePrior() public view returns (uint256) {\r\n        if (wStableCoin.totalSupply() == 0) {\r\n            //If there are no tokens minted: exchangeRate = initialExchangeRate\r\n            return initialExchangeRateMantissa;\r\n        } else {\r\n            //Otherwise: exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n            uint256 totalCash = getCashPrior(); //get contract asset balance\r\n            uint256 cashPlusBorrowsMinusReserves;\r\n            Exp memory exchangeRate;\r\n            MathError mathErr;\r\n            //calculate total value held by contract plus owed to contract\r\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\r\n                totalCash,\r\n                totalBorrows,\r\n                totalReserves\r\n            );\r\n            //calculate exchange rate\r\n            (mathErr, exchangeRate) = getExp(\r\n                cashPlusBorrowsMinusReserves,\r\n                wStableCoin.totalSupply()\r\n            );\r\n            return (exchangeRate.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     @notice Accrue interest then return the up-to-date exchange rate\r\n     @return Calculated exchange rate scaled by 1e18\r\n     **/\r\n    function exchangeRateCurrent() public returns (uint256) {\r\n        accrueInterest();\r\n\r\n        if (wStableCoin.totalSupply() == 0) {\r\n            //If there are no tokens minted: exchangeRate = initialExchangeRate\r\n            return initialExchangeRateMantissa;\r\n        } else {\r\n            //Otherwise: exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n            uint256 totalCash = getCashPrior(); //get contract asset balance\r\n            uint256 cashPlusBorrowsMinusReserves;\r\n            Exp memory exchangeRate;\r\n            MathError mathErr;\r\n            //calculate total value held by contract plus owed to contract\r\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\r\n                totalCash,\r\n                totalBorrows,\r\n                totalReserves\r\n            );\r\n            //calculate exchange rate\r\n            (mathErr, exchangeRate) = getExp(\r\n                cashPlusBorrowsMinusReserves,\r\n                wStableCoin.totalSupply()\r\n            );\r\n            return (exchangeRate.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Get cash balance of this cToken in the underlying asset in other contracts\r\n    @return The quantity of underlying asset owned by this contract\r\n    **/\r\n    function getCash() external view returns (uint256) {\r\n        return getCashPrior();\r\n    }\r\n\r\n    //struct used by mint to avoid stack too deep errors\r\n    struct MintLocalVars {\r\n        MathError mathErr;\r\n        uint256 exchangeRateMantissa;\r\n        uint256 mintTokens;\r\n        bool isMember;\r\n    }\r\n\r\n    /**\r\n    @notice lendToWarpVault is used to lend stablecoin assets to a WaprVault\r\n    @param _amount is the amount of the asset being lent\r\n    @dev the user will need to first approve the transfer of the underlying asset\r\n    **/\r\n    function lendToWarpVault(uint256 _amount) public {\r\n        //declare struct\r\n        MintLocalVars memory vars;\r\n        //retrieve exchange rate\r\n        vars.exchangeRateMantissa = exchangeRateCurrent();\r\n        //We get the current exchange rate and calculate the number of WarpWrapperToken to be minted:\r\n        //mintTokens = _amount / exchangeRate\r\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\r\n            _amount,\r\n            Exp({mantissa: vars.exchangeRateMantissa})\r\n        );\r\n\r\n        //transfer appropriate amount of DAI from msg.sender to the Vault\r\n        stablecoin.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        principalBalance[msg.sender] = principalBalance[msg.sender] + _amount;\r\n\r\n        //mint appropriate Warp DAI\r\n        wStableCoin.mint(msg.sender, vars.mintTokens);\r\n        emit StableCoinLent(msg.sender, _amount, vars.mintTokens);\r\n    }\r\n\r\n    struct RedeemLocalVars {\r\n        MathError mathErr;\r\n        uint256 exchangeRateMantissa;\r\n        uint256 burnTokens;\r\n        uint256 currentWarpBalance;\r\n        uint256 currentCoinBalance;\r\n        uint256 principalRedeemed;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n    @notice redeem allows a user to redeem their Warp Wrapper Token for the appropriate amount of underlying stablecoin asset\r\n    @param _amount is the amount of StableCoin the user wishes to exchange\r\n    **/\r\n    function redeem(uint256 _amount) public {\r\n        RedeemLocalVars memory vars;\r\n        //retreive the users current Warp Wrapper balance\r\n        vars.currentWarpBalance = wStableCoin.balanceOf(msg.sender);\r\n        //retreive current exchange rate\r\n        vars.exchangeRateMantissa = exchangeRateCurrent();\r\n\r\n        (vars.mathErr, vars.currentCoinBalance) = mulScalarTruncate(\r\n            Exp({mantissa: vars.exchangeRateMantissa}),\r\n            vars.currentWarpBalance\r\n        );\r\n        if (_amount == 0) {\r\n            vars.amount = vars.currentCoinBalance;\r\n        } else {\r\n            vars.amount = _amount;\r\n        }\r\n        //We get the current exchange rate and calculate the number of WarpWrapperToken to be burned:\r\n        //burnTokens = _amount / exchangeRate\r\n        (vars.mathErr, vars.burnTokens) = divScalarByExpTruncate(\r\n            vars.amount,\r\n            Exp({mantissa: vars.exchangeRateMantissa})\r\n        );\r\n        //require the vault has enough stablecoin\r\n        require(\r\n            stablecoin.balanceOf(address(this)) >= vars.amount,\r\n            \"Not enough stablecoin in vault.\"\r\n        );\r\n        //calculate the users current stablecoin balance\r\n\r\n        //calculate and record balances for historical tracking\r\n        uint256 currentStableCoinReward = 0;\r\n        if (vars.currentCoinBalance > principalBalance[msg.sender]) {\r\n            currentStableCoinReward = vars.currentCoinBalance.sub(\r\n                principalBalance[msg.sender]\r\n            );\r\n        }\r\n        vars.principalRedeemed = vars.amount.sub(currentStableCoinReward);\r\n\r\n        if (vars.amount >= currentStableCoinReward) {\r\n            historicalReward[msg.sender] = historicalReward[msg.sender].add(\r\n                currentStableCoinReward\r\n            );\r\n            require(\r\n                vars.principalRedeemed <= principalBalance[msg.sender],\r\n                \"Error calculating reward.\"\r\n            );\r\n            principalBalance[msg.sender] = principalBalance[msg.sender].sub(\r\n                vars.principalRedeemed\r\n            );\r\n        } else {\r\n            historicalReward[msg.sender] = historicalReward[msg.sender].add(\r\n                vars.amount\r\n            );\r\n        }\r\n        wStableCoin.burn(msg.sender, vars.burnTokens);\r\n        stablecoin.safeTransfer(msg.sender, vars.amount);\r\n        emit StableCoinWithdraw(msg.sender, vars.amount, vars.burnTokens);\r\n    }\r\n\r\n    /**\r\n    @notice viewAccountBalance is used to view the current balance of an account\r\n    @param _account is the account whos balance is being viewed\r\n    **/\r\n    function viewAccountBalance(address _account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 exchangeRate = exchangeRatePrior();\r\n        uint256 accountBalance = wStableCoin.balanceOf(_account);\r\n\r\n        MathError mathError;\r\n        uint256 balance;\r\n        (mathError, balance) = mulScalarTruncate(\r\n            Exp({mantissa: exchangeRate}),\r\n            accountBalance\r\n        );\r\n\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n    @notice viewHistoricalReward is used to view the total gains of an account\r\n    @param _account is the account whos gains are being viewed\r\n    **/\r\n    function viewHistoricalReward(address _account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 exchangeRate = exchangeRatePrior();\r\n        uint256 currentWarpBalance = wStableCoin.balanceOf(_account);\r\n        uint256 principal = principalBalance[_account];\r\n\r\n        if (currentWarpBalance == 0) {\r\n            return historicalReward[_account];\r\n        }\r\n\r\n        MathError mathError;\r\n        uint256 currentStableCoinBalance;\r\n        (mathError, currentStableCoinBalance) = mulScalarTruncate(\r\n            Exp({mantissa: exchangeRate}),\r\n            currentWarpBalance\r\n        );\r\n\r\n        uint256 currentGains = currentStableCoinBalance.sub(principal);\r\n        uint256 totalGains = currentGains.add(historicalReward[_account]);\r\n\r\n        return totalGains;\r\n    }\r\n\r\n    //struct used by borrow function to avoid stack too deep errors\r\n    struct BorrowLocalVars {\r\n        MathError mathErr;\r\n        uint256 accountBorrows;\r\n        uint256 accountBorrowsNew;\r\n        uint256 totalBorrowsNew;\r\n    }\r\n\r\n    /**\r\n    @notice Sender borrows stablecoin assets from the protocol to their own address\r\n    @param _borrowAmount The amount of the underlying asset to borrow\r\n    */\r\n    function _borrow(uint256 _borrowAmount, address _borrower)\r\n        external\r\n        onlyWarpControl\r\n        angryWizard\r\n    {\r\n        //create local vars storage\r\n        BorrowLocalVars memory vars;\r\n\r\n        //Fail if protocol has insufficient underlying cash\r\n        require(getCashPrior() > _borrowAmount, \"Not enough tokens to lend\");\r\n        //calculate the new borrower and total borrow balances, failing on overflow:\r\n        vars.accountBorrows = borrowBalancePrior(_borrower);\r\n        //accountBorrowsNew = accountBorrows + borrowAmount\r\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(\r\n            vars.accountBorrows,\r\n            _borrowAmount\r\n        );\r\n        //totalBorrowsNew = totalBorrows + borrowAmount\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(\r\n            totalBorrows,\r\n            _borrowAmount\r\n        );\r\n        //We write the previously calculated values into storage\r\n        accountBorrows[_borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[_borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n        //send them their loaned asset\r\n        stablecoin.safeTransfer(_borrower, _borrowAmount);\r\n    }\r\n\r\n    struct RepayBorrowLocalVars {\r\n        MathError mathErr;\r\n        uint256 repayAmount;\r\n        uint256 borrowerIndex;\r\n        uint256 accountBorrows;\r\n        uint256 accountBorrowsNew;\r\n        uint256 totalBorrowsNew;\r\n        uint256 totalOwed;\r\n        uint256 borrowPrinciple;\r\n        uint256 interestPayed;\r\n    }\r\n\r\n    /**\r\n    @notice Sender repays their own borrow\r\n    @param _repayAmount The amount to repay\r\n    */\r\n    function repayBorrow(uint256 _repayAmount) public angryWizard {\r\n        //create local vars storage\r\n        RepayBorrowLocalVars memory vars;\r\n\r\n        //We fetch the amount the borrower owes, with accumulated interest\r\n        vars.accountBorrows = borrowBalanceCurrent(msg.sender);\r\n        //require the borrower cant pay more than they owe\r\n        require(\r\n            _repayAmount <= vars.accountBorrows,\r\n            \"You are trying to pay back more than you owe\"\r\n        );\r\n\r\n        //If repayAmount == 0, repayAmount = accountBorrows\r\n        if (_repayAmount == 0) {\r\n            vars.repayAmount = vars.accountBorrows;\r\n        } else {\r\n            vars.repayAmount = _repayAmount;\r\n        }\r\n\r\n        require(\r\n            stablecoin.balanceOf(msg.sender) >= vars.repayAmount,\r\n            \"Not enough stablecoin to repay\"\r\n        );\r\n        //transfer the stablecoin from the borrower\r\n        stablecoin.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            vars.repayAmount\r\n        );\r\n\r\n        //We calculate the new borrower and total borrow balances\r\n        //accountBorrowsNew = accountBorrows - actualRepayAmount\r\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(\r\n            vars.accountBorrows,\r\n            vars.repayAmount\r\n        );\r\n        require(\r\n            vars.mathErr == MathError.NO_ERROR,\r\n            \"Repay borrow new account balance calculation failed\"\r\n        );\r\n\r\n        //totalBorrowsNew = totalBorrows - actualRepayAmount\r\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(\r\n            totalBorrows,\r\n            vars.repayAmount\r\n        );\r\n        require(\r\n            vars.mathErr == MathError.NO_ERROR,\r\n            \"Repay borrow new total balance calculation failed\"\r\n        );\r\n\r\n        /* We write the previously calculated values into storage */\r\n        totalBorrows = vars.totalBorrowsNew;\r\n        accountBorrows[msg.sender].principal = vars.accountBorrowsNew;\r\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\r\n\r\n        emit LoanRepayed(\r\n            msg.sender,\r\n            _repayAmount,\r\n            accountBorrows[msg.sender].principal,\r\n            accountBorrows[msg.sender].interestIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice repayLiquidatedLoan is a function used by the Warp Control contract to repay a loan on behalf of a liquidator\r\n    @param _borrower is the address of the borrower who took out the loan\r\n    @param _liquidator is the address of the account who is liquidating the loan\r\n    @param _amount is the amount of StableCoin being repayed\r\n    @dev this function uses the onlyWarpControl modifier which means it can only be called by the Warp Control contract\r\n    **/\r\n    function _repayLiquidatedLoan(\r\n        address _borrower,\r\n        address _liquidator,\r\n        uint256 _amount\r\n    ) public onlyWarpControl angryWizard {\r\n        stablecoin.safeTransferFrom(_liquidator, address(this), _amount);\r\n        //calculate the fee on the principle received\r\n        uint256 fee = calculateFee(_amount);\r\n        //transfer fee amount to Warp team\r\n        totalReserves = totalReserves.add(fee);\r\n        // Clear the borrowers loan\r\n        accountBorrows[_borrower].principal = 0;\r\n        accountBorrows[_borrower].interestIndex = 0;\r\n        totalBorrows = totalBorrows.sub(_amount);\r\n\r\n        //transfer the owed amount of stablecoin from the borrower to this contract\r\n    }\r\n}"}
{"address": "0x818e6fecd516ecc3849daf6845e3ec868087b755", "attacktype": "On-chain oracle manipulation", "sourcecode": "pragma solidity 0.4.18;\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/KyberNetworkInterface.sol\r\n\r\n/// @title Kyber Network interface\r\ninterface KyberNetworkInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(address trader, ERC20 src, uint srcAmount, ERC20 dest, address destAddress,\r\n        uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\n// File: contracts/KyberNetworkProxyInterface.sol\r\n\r\n/// @title Kyber Network interface\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\n// File: contracts/SimpleNetworkInterface.sol\r\n\r\n/// @title simple interface for Kyber Network \r\ninterface SimpleNetworkInterface {\r\n    function swapTokenToToken(ERC20 src, uint srcAmount, ERC20 dest, uint minConversionRate) public returns(uint);\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) public payable returns(uint);\r\n    function swapTokenToEther(ERC20 token, uint srcAmount, uint minConversionRate) public returns(uint);\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/Utils2.sol\r\n\r\ncontract Utils2 is Utils {\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\r\n\r\n        if (decimals[token] == 0) {\r\n            setDecimals(token);\r\n        }\r\n\r\n        return decimals[token];\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/PermissionGroups.sol\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Withdrawable.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @author Ilan Doron\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/KyberNetworkProxy.sol\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title Kyber Network proxy for main contract\r\ncontract KyberNetworkProxy is KyberNetworkProxyInterface, SimpleNetworkInterface, Withdrawable, Utils2 {\r\n\r\n    KyberNetworkInterface public kyberNetworkContract;\r\n\r\n    function KyberNetworkProxy(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            destAddress,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade between src and dest token and send dest tokens to msg sender\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest Destination token\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapTokenToToken(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        uint minConversionRate\r\n    )\r\n        public\r\n        returns(uint)\r\n    {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade from Ether to token. Sends token to msg sender\r\n    /// @param token Destination token\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) public payable returns(uint) {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            ETH_TOKEN_ADDRESS,\r\n            msg.value,\r\n            token,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade from token to Ether, sends Ether to msg sender\r\n    /// @param token Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapTokenToEther(ERC20 token, uint srcAmount, uint minConversionRate) public returns(uint) {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            token,\r\n            srcAmount,\r\n            ETH_TOKEN_ADDRESS,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    struct UserBalance {\r\n        uint srcBalance;\r\n        uint destBalance;\r\n    }\r\n\r\n    event ExecuteTrade(address indexed trader, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @param hint will give hints for the trade.\r\n    /// @return amount of actual dest tokens\r\n    function tradeWithHint(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId,\r\n        bytes hint\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(src == ETH_TOKEN_ADDRESS || msg.value == 0);\r\n        \r\n        UserBalance memory userBalanceBefore;\r\n\r\n        userBalanceBefore.srcBalance = getBalance(src, msg.sender);\r\n        userBalanceBefore.destBalance = getBalance(dest, destAddress);\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            userBalanceBefore.srcBalance += msg.value;\r\n        } else {\r\n            require(src.transferFrom(msg.sender, kyberNetworkContract, srcAmount));\r\n        }\r\n\r\n        uint reportedDestAmount = kyberNetworkContract.tradeWithHint.value(msg.value)(\r\n            msg.sender,\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            destAddress,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId,\r\n            hint\r\n        );\r\n\r\n        TradeOutcome memory tradeOutcome = calculateTradeOutcome(\r\n            userBalanceBefore.srcBalance,\r\n            userBalanceBefore.destBalance,\r\n            src,\r\n            dest,\r\n            destAddress\r\n        );\r\n\r\n        require(reportedDestAmount == tradeOutcome.userDeltaDestAmount);\r\n        require(tradeOutcome.userDeltaDestAmount <= maxDestAmount);\r\n        require(tradeOutcome.actualRate >= minConversionRate);\r\n\r\n        ExecuteTrade(msg.sender, src, dest, tradeOutcome.userDeltaSrcAmount, tradeOutcome.userDeltaDestAmount);\r\n        return tradeOutcome.userDeltaDestAmount;\r\n    }\r\n\r\n    event KyberNetworkSet(address newNetworkContract, address oldNetworkContract);\r\n\r\n    function setKyberNetworkContract(KyberNetworkInterface _kyberNetworkContract) public onlyAdmin {\r\n\r\n        require(_kyberNetworkContract != address(0));\r\n\r\n        KyberNetworkSet(_kyberNetworkContract, kyberNetworkContract);\r\n\r\n        kyberNetworkContract = _kyberNetworkContract;\r\n    }\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns(uint expectedRate, uint slippageRate)\r\n    {\r\n        return kyberNetworkContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return kyberNetworkContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) {\r\n        return kyberNetworkContract.getUserCapInTokenWei(user, token);\r\n    }\r\n\r\n    function maxGasPrice() public view returns(uint) {\r\n        return kyberNetworkContract.maxGasPrice();\r\n    }\r\n\r\n    function enabled() public view returns(bool) {\r\n        return kyberNetworkContract.enabled();\r\n    }\r\n\r\n    function info(bytes32 field) public view returns(uint) {\r\n        return kyberNetworkContract.info(field);\r\n    }\r\n\r\n    struct TradeOutcome {\r\n        uint userDeltaSrcAmount;\r\n        uint userDeltaDestAmount;\r\n        uint actualRate;\r\n    }\r\n\r\n    function calculateTradeOutcome (uint srcBalanceBefore, uint destBalanceBefore, ERC20 src, ERC20 dest,\r\n        address destAddress)\r\n        internal returns(TradeOutcome outcome)\r\n    {\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        //protect from underflow\r\n        require(userDestBalanceAfter > destBalanceBefore);\r\n        require(srcBalanceBefore > userSrcBalanceAfter);\r\n\r\n        outcome.userDeltaDestAmount = userDestBalanceAfter - destBalanceBefore;\r\n        outcome.userDeltaSrcAmount = srcBalanceBefore - userSrcBalanceAfter;\r\n\r\n        outcome.actualRate = calcRateFromQty(\r\n                outcome.userDeltaSrcAmount,\r\n                outcome.userDeltaDestAmount,\r\n                getDecimalsSafe(src),\r\n                getDecimalsSafe(dest)\r\n            );\r\n    }\r\n}"}
{"address": "0xacbdb82f07b2653137d3a08a22637121422ae747", "attacktype": "Flash liquidity borrow, purchase, mint or deposit", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LiquidBoardroom.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\nimport \\\"./interfaces/IVotingEscrow.sol\\\";\\nimport \\\"./Boardroom.sol\\\";\\n\\n/// Boardroom distributes token emission among shareholders that stake Klon and lock Klon in veToken\\ncontract LiquidBoardroom is Boardroom {\\n    /// Address of veToken\\n    IVotingEscrow public veToken;\\n\\n    /// Creates new Boardroom\\n    /// @param _stakingToken address of the base token\\n    /// @param _tokenManager address of the TokenManager\\n    /// @param _emissionManager address of the EmissionManager\\n    /// @param _start start of the boardroom date\\n    constructor(\\n        address _stakingToken,\\n        address _tokenManager,\\n        address _emissionManager,\\n        uint256 _start\\n    )\\n        public\\n        Boardroom(_stakingToken, _tokenManager, _emissionManager, _start)\\n    {}\\n\\n    /// Update veToken\\n    /// @param _veToken new token address\\n    function setVeToken(address _veToken) public onlyOwner {\\n        veToken = IVotingEscrow(_veToken);\\n        emit VeTokenChanged(msg.sender, _veToken);\\n    }\\n\\n    /// Shows the balance of the virtual token that participates in reward calculation\\n    /// @param owner the owner of the share tokens\\n    function shareTokenBalance(address owner)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return stakingTokenBalances[owner].add(veToken.locked__balance(owner));\\n    }\\n\\n    /// Shows the supply of the virtual token that participates in reward calculation\\n    function shareTokenSupply() public view override returns (uint256) {\\n        return stakingTokenSupply.add(veToken.supply());\\n    }\\n\\n    event VeTokenChanged(address indexed operator, address newVeToken);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// Voting escrow interface\\ninterface IVotingEscrow is IERC20 {\\n    function locked__balance(address _addr) external view returns (uint256);\\n\\n    function supply() external view returns (uint256);\\n\\n    function withdraw() external;\\n\\n    function deposit_for(address _addr, uint256 _value) external;\\n\\n    function create_lock(uint256 _value, uint256 _unlock_time) external;\\n\\n    function increase_amount(uint256 _value) external;\\n\\n    function increase_unlock_time(uint256 _unlock_time) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Boardroom.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./time/Timeboundable.sol\\\";\\nimport \\\"./SyntheticToken.sol\\\";\\nimport \\\"./interfaces/ITokenManager.sol\\\";\\nimport \\\"./interfaces/IBoardroom.sol\\\";\\n\\n/// Boardroom distributes token emission among shareholders\\ncontract Boardroom is IBoardroom, ReentrancyGuard, Timeboundable, Operatable {\\n    using SafeMath for uint256;\\n\\n    /// Added each time reward to the Boardroom is added\\n    struct PoolRewardSnapshot {\\n        /// when snapshost was made\\n        uint256 timestamp;\\n        /// how much reward was added at this snapshot\\n        uint256 addedSyntheticReward;\\n        /// accumulated reward per share unit (10^18 of reward token)\\n        uint256 accruedRewardPerShareUnit;\\n    }\\n\\n    /// Accumulated personal rewards available for claiming\\n    struct PersonRewardAccrual {\\n        /// Last accrual time represented by snapshotId\\n        uint256 lastAccrualSnaphotId;\\n        /// Accrued and ready for distribution reward\\n        uint256 accruedReward;\\n    }\\n\\n    /// A set of PoolRewardSnapshots for every synthetic token\\n    mapping(address => PoolRewardSnapshot[]) public poolRewardSnapshots;\\n    /// A set of records of personal accumulated income.\\n    /// The first key is token, the second is holder address.\\n    mapping(address => mapping(address => PersonRewardAccrual))\\n        public personRewardAccruals;\\n\\n    /// Pause\\n    bool public pause;\\n\\n    /// one unit of staking token (e.g. # of wei in eth)\\n    uint256 public immutable stakingUnit;\\n\\n    /// Staking token. Both base and boost token yield reward token which ultimately participates in rewards distribution.\\n    SyntheticToken public stakingToken;\\n    /// TokenManager ref\\n    ITokenManager public tokenManager;\\n    /// EmissionManager ref\\n    address public emissionManager;\\n\\n    /// Staking token supply in the Boardroom\\n    uint256 public stakingTokenSupply;\\n    /// Staking token balances in the Boardroom\\n    mapping(address => uint256) public stakingTokenBalances;\\n\\n    /// Creates new Boardroom\\n    /// @param _stakingToken address of the base token. Should have 18 decimals.\\n    /// @param _tokenManager address of the TokenManager\\n    /// @param _emissionManager address of the EmissionManager\\n    /// @param _start start of the boardroom date\\n    constructor(\\n        address _stakingToken,\\n        address _tokenManager,\\n        address _emissionManager,\\n        uint256 _start\\n    ) public Timeboundable(_start, 0) {\\n        stakingToken = SyntheticToken(_stakingToken);\\n        stakingUnit = uint256(10)**18;\\n        tokenManager = ITokenManager(_tokenManager);\\n        emissionManager = _emissionManager;\\n    }\\n\\n    // ------- Modifiers ----------\\n\\n    /// Checks if pause is set\\n    modifier unpaused() {\\n        require(!pause, \\\"Boardroom operations are paused\\\");\\n        _;\\n    }\\n\\n    // ------- Public ----------\\n\\n    /// Funds available for user to withdraw\\n    /// @param syntheticTokenAddress the token we're looking up balance for\\n    /// @param owner the owner of the token\\n    function availableForWithdraw(address syntheticTokenAddress, address owner)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        PersonRewardAccrual storage accrual =\\n            personRewardAccruals[syntheticTokenAddress][owner];\\n        PoolRewardSnapshot[] storage tokenSnapshots =\\n            poolRewardSnapshots[syntheticTokenAddress];\\n        if (tokenSnapshots.length == 0) {\\n            return 0;\\n        }\\n        PoolRewardSnapshot storage lastSnapshot =\\n            tokenSnapshots[tokenSnapshots.length.sub(1)];\\n        uint256 lastOverallRPSU = lastSnapshot.accruedRewardPerShareUnit;\\n        PoolRewardSnapshot storage lastAccrualSnapshot =\\n            tokenSnapshots[accrual.lastAccrualSnaphotId];\\n        uint256 lastUserAccrualRPSU =\\n            lastAccrualSnapshot.accruedRewardPerShareUnit;\\n        uint256 deltaRPSU = lastOverallRPSU.sub(lastUserAccrualRPSU);\\n        uint256 addedUserReward =\\n            shareTokenBalance(owner).mul(deltaRPSU).div(stakingUnit);\\n        return accrual.accruedReward.add(addedUserReward);\\n    }\\n\\n    /// Stake tokens into Boardroom\\n    /// @param to the receiver of the token\\n    /// @param amount amount of staking token\\n    function stake(address to, uint256 amount)\\n        public\\n        nonReentrant\\n        inTimeBounds\\n        unpaused\\n    {\\n        require((amount > 0), \\\"Boardroom: amount should be > 0\\\");\\n        updateAccruals(msg.sender);\\n        stakingTokenBalances[to] = stakingTokenBalances[to].add(amount);\\n        stakingTokenSupply = stakingTokenSupply.add(amount);\\n        _doStakeTransfer(msg.sender, to, amount);\\n        emit Staked(msg.sender, to, amount);\\n    }\\n\\n    /// Withdraw tokens from Boardroom\\n    /// @param to the receiver of the token\\n    /// @param amount amount of base token\\n    function withdraw(address to, uint256 amount) public nonReentrant {\\n        require((amount > 0), \\\"Boardroom: amount should be > 0\\\");\\n        updateAccruals(msg.sender);\\n        stakingTokenBalances[msg.sender] = stakingTokenBalances[msg.sender].sub(\\n            amount\\n        );\\n        stakingTokenSupply = stakingTokenSupply.sub(amount);\\n        _doWithdrawTransfer(msg.sender, to, amount);\\n        emit Withdrawn(msg.sender, to, amount);\\n    }\\n\\n    /// Called inside `stake` method after updating internal balances\\n    /// @param from the owner of the staking tokens\\n    /// @param amount amount to stake\\n    function _doStakeTransfer(\\n        address from,\\n        address,\\n        uint256 amount\\n    ) internal virtual {\\n        stakingToken.transferFrom(from, address(this), amount);\\n    }\\n\\n    /// Called inside `withdraw` method after updating internal balances\\n    /// @param to the receiver of the staking tokens\\n    /// @param amount amount to unstake\\n    function _doWithdrawTransfer(\\n        address,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        stakingToken.transfer(to, amount);\\n    }\\n\\n    /// Shows the balance of the virtual token that participates in reward calculation\\n    /// @param owner the owner of the share tokens\\n    function shareTokenBalance(address owner)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return stakingTokenBalances[owner];\\n    }\\n\\n    /// Shows the supply of the virtual token that participates in reward calculation\\n    function shareTokenSupply() public view virtual returns (uint256) {\\n        return stakingTokenSupply;\\n    }\\n\\n    /// Update accrued rewards for all tokens of sender\\n    /// @param owner address to update accruals\\n    function updateAccruals(address owner) public unpaused {\\n        address[] memory tokens = tokenManager.allTokens();\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            _updateAccrual(tokens[i], owner);\\n        }\\n    }\\n\\n    /// Transfer all rewards to sender\\n    /// @param to reward receiver\\n    function claimRewards(address to) public nonReentrant unpaused {\\n        updateAccruals(msg.sender);\\n        address[] memory tokens = tokenManager.allTokens();\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            _claimReward(to, tokens[i]);\\n        }\\n    }\\n\\n    // ------- Public, EmissionManager ----------\\n\\n    /// Notify Boardroom about new incoming reward for token\\n    /// @param token Rewards denominated in this token\\n    /// @param amount The amount of rewards\\n    function notifyTransfer(address token, uint256 amount) external override {\\n        require(\\n            msg.sender == address(emissionManager),\\n            \\\"Boardroom: can only be called by EmissionManager\\\"\\n        );\\n        uint256 shareSupply = shareTokenSupply();\\n        require(\\n            shareSupply > 0,\\n            \\\"Boardroom: Cannot receive incoming reward when token balance is 0\\\"\\n        );\\n        PoolRewardSnapshot[] storage tokenSnapshots =\\n            poolRewardSnapshots[token];\\n        PoolRewardSnapshot storage lastSnapshot =\\n            tokenSnapshots[tokenSnapshots.length - 1];\\n        uint256 deltaRPSU = amount.mul(stakingUnit).div(shareSupply);\\n        tokenSnapshots.push(\\n            PoolRewardSnapshot({\\n                timestamp: block.timestamp,\\n                addedSyntheticReward: amount,\\n                accruedRewardPerShareUnit: lastSnapshot\\n                    .accruedRewardPerShareUnit\\n                    .add(deltaRPSU)\\n            })\\n        );\\n        emit IncomingBoardroomReward(token, msg.sender, amount);\\n    }\\n\\n    // ------- Public, Owner (timelock) ----------\\n\\n    /// Updates TokenManager\\n    /// @param _tokenManager new TokenManager\\n    function setTokenManager(address _tokenManager) public onlyOwner {\\n        tokenManager = ITokenManager(_tokenManager);\\n        emit UpdatedTokenManager(msg.sender, _tokenManager);\\n    }\\n\\n    /// Updates EmissionManager\\n    /// @param _emissionManager new EmissionManager\\n    function setEmissionManager(address _emissionManager) public onlyOwner {\\n        emissionManager = _emissionManager;\\n        emit UpdatedEmissionManager(msg.sender, _emissionManager);\\n    }\\n\\n    // ------- Public, Operator (multisig) ----------\\n\\n    /// Set pause\\n    /// @param _pause pause value\\n    function setPause(bool _pause) public onlyOperator {\\n        pause = _pause;\\n        emit UpdatedPause(msg.sender, _pause);\\n    }\\n\\n    // ------- Internal ----------\\n\\n    function _claimReward(address to, address syntheticTokenAddress) internal {\\n        uint256 reward =\\n            personRewardAccruals[syntheticTokenAddress][msg.sender]\\n                .accruedReward;\\n        if (reward > 0) {\\n            personRewardAccruals[syntheticTokenAddress][msg.sender]\\n                .accruedReward = 0;\\n            SyntheticToken token = SyntheticToken(syntheticTokenAddress);\\n            token.transfer(to, reward);\\n            emit RewardPaid(syntheticTokenAddress, msg.sender, to, reward);\\n        }\\n    }\\n\\n    function _updateAccrual(address syntheticTokenAddress, address owner)\\n        internal\\n    {\\n        PersonRewardAccrual storage accrual =\\n            personRewardAccruals[syntheticTokenAddress][owner];\\n        PoolRewardSnapshot[] storage tokenSnapshots =\\n            poolRewardSnapshots[syntheticTokenAddress];\\n        if (tokenSnapshots.length == 0) {\\n            tokenSnapshots.push(\\n                PoolRewardSnapshot({\\n                    timestamp: block.timestamp,\\n                    addedSyntheticReward: 0,\\n                    accruedRewardPerShareUnit: 0\\n                })\\n            );\\n        }\\n        if (accrual.lastAccrualSnaphotId == tokenSnapshots.length - 1) {\\n            return;\\n        }\\n        PoolRewardSnapshot storage lastSnapshot =\\n            tokenSnapshots[tokenSnapshots.length - 1];\\n        uint256 lastOverallRPSU = lastSnapshot.accruedRewardPerShareUnit;\\n        PoolRewardSnapshot storage lastAccrualSnapshot =\\n            tokenSnapshots[accrual.lastAccrualSnaphotId];\\n        uint256 lastUserAccrualRPSU =\\n            lastAccrualSnapshot.accruedRewardPerShareUnit;\\n        uint256 deltaRPSU = lastOverallRPSU.sub(lastUserAccrualRPSU);\\n        uint256 addedUserReward =\\n            shareTokenBalance(owner).mul(deltaRPSU).div(stakingUnit);\\n        accrual.lastAccrualSnaphotId = tokenSnapshots.length - 1;\\n        accrual.accruedReward = accrual.accruedReward.add(addedUserReward);\\n        emit RewardAccrued(\\n            syntheticTokenAddress,\\n            owner,\\n            addedUserReward,\\n            accrual.accruedReward\\n        );\\n    }\\n\\n    // ------- Events ----------\\n\\n    event RewardAccrued(\\n        address syntheticTokenAddress,\\n        address to,\\n        uint256 incrementalReward,\\n        uint256 totalReward\\n    );\\n    event RewardPaid(\\n        address indexed syntheticTokenAddress,\\n        address indexed from,\\n        address indexed to,\\n        uint256 reward\\n    );\\n    event IncomingBoardroomReward(\\n        address indexed token,\\n        address indexed from,\\n        uint256 amount\\n    );\\n    event Staked(address indexed from, address indexed to, uint256 amount);\\n    event Withdrawn(address indexed from, address indexed to, uint256 amount);\\n    event UpdatedPause(address indexed operator, bool pause);\\n    event UpdatedTokenManager(\\n        address indexed operator,\\n        address newTokenManager\\n    );\\n    event UpdatedEmissionManager(\\n        address indexed operator,\\n        address newEmissionManager\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/time/Timeboundable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\n/// Checks time bounds for contract\\nabstract contract Timeboundable {\\n    uint256 public immutable start;\\n    uint256 public immutable finish;\\n\\n    /// @param _start The block timestamp to start from (in secs). Use 0 for unbounded start.\\n    /// @param _finish The block timestamp to finish in (in secs). Use 0 for unbounded finish.\\n    constructor(uint256 _start, uint256 _finish) internal {\\n        require(\\n            (_start != 0) || (_finish != 0),\\n            \\\"Timebound: either start or finish must be nonzero\\\"\\n        );\\n        require(\\n            (_finish == 0) || (_finish > _start),\\n            \\\"Timebound: finish must be zero or greater than start\\\"\\n        );\\n        uint256 s = _start;\\n        if (s == 0) {\\n            s = block.timestamp;\\n        }\\n        uint256 f = _finish;\\n        if (f == 0) {\\n            f = uint256(-1);\\n        }\\n        start = s;\\n        finish = f;\\n    }\\n\\n    /// Checks if timebounds are satisfied\\n    modifier inTimeBounds() {\\n        require(block.timestamp >= start, \\\"Timeboundable: Not started yet\\\");\\n        require(block.timestamp <= finish, \\\"Timeboundable: Already finished\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SyntheticToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"./access/Operatable.sol\\\";\\n\\n/// @title Synthetic token for the Klondike platform\\ncontract SyntheticToken is ERC20Burnable, Operatable {\\n    /// Creates a new synthetic token\\n    /// @param _name Name of the token\\n    /// @param _symbol Ticker for the token\\n    /// @param _decimals Number of decimals\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) public ERC20(_name, _symbol) {\\n        _setupDecimals(_decimals);\\n    }\\n\\n    ///  Mints tokens to the recepient\\n    ///  @param recipient The address of recipient\\n    ///  @param amount The amount of tokens to mint\\n    function mint(address recipient, uint256 amount)\\n        public\\n        onlyOperator\\n        returns (bool)\\n    {\\n        _mint(recipient, amount);\\n    }\\n\\n    ///  Burns token from the caller\\n    ///  @param amount The amount of tokens to burn\\n    function burn(uint256 amount) public override onlyOperator {\\n        super.burn(amount);\\n    }\\n\\n    ///  Burns token from address\\n    ///  @param account The account to burn from\\n    ///  @param amount The amount of tokens to burn\\n    ///  @dev The allowance for sender in address account must be\\n    ///  strictly >= amount. Otherwise the function call will fail.\\n    function burnFrom(address account, uint256 amount)\\n        public\\n        override\\n        onlyOperator\\n    {\\n        super.burnFrom(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\nimport \\\"./ISmelter.sol\\\";\\n\\n/// Token manager as seen by other managers\\ninterface ITokenManager is ISmelter {\\n    /// A set of synthetic tokens under management\\n    /// @dev Deleted tokens are still present in the array but with address(0)\\n    function allTokens() external view returns (address[] memory);\\n\\n    /// Checks if the token is managed by Token Manager\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    /// @return True if token is managed\\n    function isManagedToken(address syntheticTokenAddress)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// Address of the underlying token\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    function underlyingToken(address syntheticTokenAddress)\\n        external\\n        view\\n        returns (address);\\n\\n    /// Average price of the synthetic token according to price oracle\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    /// @param syntheticTokenAmount The amount to be priced\\n    /// @return The equivalent amount of the underlying token required to buy syntheticTokenAmount (average)\\n    /// @dev Fails if the token is not managed\\n    function averagePrice(\\n        address syntheticTokenAddress,\\n        uint256 syntheticTokenAmount\\n    ) external view returns (uint256);\\n\\n    /// Current price of the synthetic token according to Uniswap\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    /// @param syntheticTokenAmount The amount to be priced\\n    /// @return The equivalent amount of the underlying token required to buy syntheticTokenAmount\\n    /// @dev Fails if the token is not managed\\n    function currentPrice(\\n        address syntheticTokenAddress,\\n        uint256 syntheticTokenAmount\\n    ) external view returns (uint256);\\n\\n    /// Updates Oracle for the synthetic asset\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    function updateOracle(address syntheticTokenAddress) external;\\n\\n    /// Get one synthetic unit\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    /// @return one unit of the synthetic asset\\n    function oneSyntheticUnit(address syntheticTokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// Get one underlying unit\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    /// @return one unit of the underlying asset\\n    function oneUnderlyingUnit(address syntheticTokenAddress)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBoardroom.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\n/// Boardroom as seen by others\\ninterface IBoardroom {\\n    /// Notify Boardroom about new incoming reward for token\\n    /// @param token Rewards denominated in this token\\n    /// @param amount The amount of rewards\\n    function notifyTransfer(address token, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/Operatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// Introduces `Operator` role that can be changed only by Owner.\\nabstract contract Operatable is Ownable {\\n    address public operator;\\n\\n    constructor() internal {\\n        operator = msg.sender;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(msg.sender == operator, \\\"Only operator can call this method\\\");\\n        _;\\n    }\\n\\n    /// Set new operator\\n    /// @param newOperator New operator to be set\\n    /// @dev Only owner is allowed to call this method.\\n    function transferOperator(address newOperator) public onlyOwner {\\n        emit OperatorTransferred(operator, newOperator);\\n        operator = newOperator;\\n    }\\n\\n    event OperatorTransferred(\\n        address indexed previousOperator,\\n        address indexed newOperator\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISmelter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.6.6;\\n\\n/// Smelter can mint and burn tokens\\ninterface ISmelter {\\n    /// Burn SyntheticToken\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    /// @param owner Owner of the tokens to burn\\n    /// @param amount Amount to burn\\n    function burnSyntheticFrom(\\n        address syntheticTokenAddress,\\n        address owner,\\n        uint256 amount\\n    ) external;\\n\\n    /// Mints synthetic token\\n    /// @param syntheticTokenAddress The address of the synthetic token\\n    /// @param receiver Address to receive minted token\\n    /// @param amount Amount to mint\\n    function mintSynthetic(\\n        address syntheticTokenAddress,\\n        address receiver,\\n        uint256 amount\\n    ) external;\\n\\n    /// Check if address is token admin\\n    /// @param admin - address to check\\n    function isTokenAdmin(address admin) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0x6b7a87899490ece95443e979ca9485cbe7e71522", "attacktype": "Unsafe call to phantom function, Absence of code logic or sanity check", "sourcecode": "/**\r\n *Submitted for verification at FtmScan.com on 2021-05-31\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2021-04-15\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2021-04-08\r\n*/\r\n\r\n/**\r\n *Submitted for verification at hecoinfo.com on 2021-04-08\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.0;\r\n\r\ninterface ISushiswapV2Pair {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMathSushiswap {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\nlibrary SushiswapV2Library {\r\n    using SafeMathSushiswap for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\r\n            )))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferNative(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IwNATIVE {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface AnyswapV1ERC20 {\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n    function burn(address from, uint256 amount) external returns (bool);\r\n    function changeVault(address newVault) external returns (bool);\r\n    function depositVault(uint amount, address to) external returns (uint);\r\n    function withdrawVault(address from, uint amount, address to) external returns (uint);\r\n    function underlying() external view returns (address);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AnyswapV4Router {\r\n    using SafeMathSushiswap for uint;\r\n\r\n    address public immutable factory;\r\n    address public immutable wNATIVE;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _wNATIVE, address _mpc) {\r\n        _newMPC = _mpc;\r\n        _newMPCEffectiveTime = block.timestamp;\r\n        factory = _factory;\r\n        wNATIVE = _wNATIVE;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\r\n    }\r\n\r\n    address private _oldMPC;\r\n    address private _newMPC;\r\n    uint256 private _newMPCEffectiveTime;\r\n\r\n\r\n    event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\r\n    event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\r\n    event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\r\n    event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\r\n    event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\r\n    event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\r\n\r\n    modifier onlyMPC() {\r\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\r\n        _;\r\n    }\r\n\r\n    function mpc() public view returns (address) {\r\n        if (block.timestamp >= _newMPCEffectiveTime) {\r\n            return _newMPC;\r\n        }\r\n        return _oldMPC;\r\n    }\r\n\r\n    function cID() public view returns (uint id) {\r\n        assembly {id := chainid()}\r\n    }\r\n\r\n    function changeMPC(address newMPC) public onlyMPC returns (bool) {\r\n        require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\r\n        _oldMPC = mpc();\r\n        _newMPC = newMPC;\r\n        _newMPCEffectiveTime = block.timestamp + 2*24*3600;\r\n        emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\r\n        return true;\r\n    }\r\n\r\n    function changeVault(address token, address newVault) public onlyMPC returns (bool) {\r\n        require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\r\n        return AnyswapV1ERC20(token).changeVault(newVault);\r\n    }\r\n\r\n    function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\r\n        AnyswapV1ERC20(token).burn(from, amount);\r\n        emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\r\n    }\r\n\r\n    // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\r\n    function anySwapOut(address token, address to, uint amount, uint toChainID) external {\r\n        _anySwapOut(msg.sender, token, to, amount, toChainID);\r\n    }\r\n\r\n    // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\r\n    function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\r\n        TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\r\n        AnyswapV1ERC20(token).depositVault(amount, msg.sender);\r\n        _anySwapOut(msg.sender, token, to, amount, toChainID);\r\n    }\r\n\r\n    function anySwapOutUnderlyingWithPermit(\r\n        address from,\r\n        address token,\r\n        address to,\r\n        uint amount,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external {\r\n        address _underlying = AnyswapV1ERC20(token).underlying();\r\n        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\r\n        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\r\n        AnyswapV1ERC20(token).depositVault(amount, from);\r\n        _anySwapOut(from, token, to, amount, toChainID);\r\n    }\r\n\r\n    function anySwapOutUnderlyingWithTransferPermit(\r\n        address from,\r\n        address token,\r\n        address to,\r\n        uint amount,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external {\r\n        IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\r\n        AnyswapV1ERC20(token).depositVault(amount, from);\r\n        _anySwapOut(from, token, to, amount, toChainID);\r\n    }\r\n\r\n    function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\r\n        }\r\n    }\r\n\r\n    // swaps `amount` `token` in `fromChainID` to `to` on this chainID\r\n    function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\r\n        AnyswapV1ERC20(token).mint(to, amount);\r\n        emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\r\n    }\r\n\r\n    // swaps `amount` `token` in `fromChainID` to `to` on this chainID\r\n    // triggered by `anySwapOut`\r\n    function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\r\n        _anySwapIn(txs, token, to, amount, fromChainID);\r\n    }\r\n\r\n    // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\r\n    function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\r\n        _anySwapIn(txs, token, to, amount, fromChainID);\r\n        AnyswapV1ERC20(token).withdrawVault(to, amount, to);\r\n    }\r\n\r\n    // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\r\n    function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\r\n        _anySwapIn(txs, token, to, amount, fromChainID);\r\n        AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\r\n        address _underlying = _anyToken.underlying();\r\n        if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\r\n            _anyToken.withdrawVault(to, amount, to);\r\n        }\r\n    }\r\n\r\n    // extracts mpc fee from bridge fees\r\n    function anySwapFeeTo(address token, uint amount) external onlyMPC {\r\n        address _mpc = mpc();\r\n        AnyswapV1ERC20(token).mint(_mpc, amount);\r\n        AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\r\n    }\r\n\r\n    function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\r\n        }\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = SushiswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\r\n        emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForTokensUnderlying(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\r\n        AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\r\n        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\r\n        emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForTokensUnderlyingWithPermit(\r\n        address from,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        address _underlying = AnyswapV1ERC20(path[0]).underlying();\r\n        IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\r\n        TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\r\n        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\r\n        AnyswapV1ERC20(path[0]).burn(from, amountIn);\r\n        {\r\n        address[] memory _path = path;\r\n        address _from = from;\r\n        address _to = to;\r\n        uint _amountIn = amountIn;\r\n        uint _amountOutMin = amountOutMin;\r\n        uint _cID = cID();\r\n        uint _toChainID = toChainID;\r\n        emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\r\n        }\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\r\n        address from,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\r\n        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\r\n        AnyswapV1ERC20(path[0]).burn(from, amountIn);\r\n        emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\r\n    }\r\n\r\n    // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\r\n    // Triggered by `anySwapOutExactTokensForTokens`\r\n    function anySwapInExactTokensForTokens(\r\n        bytes32 txs,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint fromChainID\r\n    ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForNative(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\r\n        emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForNativeUnderlying(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\r\n        AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\r\n        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\r\n        emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForNativeUnderlyingWithPermit(\r\n        address from,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        address _underlying = AnyswapV1ERC20(path[0]).underlying();\r\n        IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\r\n        TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\r\n        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\r\n        AnyswapV1ERC20(path[0]).burn(from, amountIn);\r\n        {\r\n        address[] memory _path = path;\r\n        address _from = from;\r\n        address _to = to;\r\n        uint _amountIn = amountIn;\r\n        uint _amountOutMin = amountOutMin;\r\n        uint _cID = cID();\r\n        uint _toChainID = toChainID;\r\n        emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\r\n        }\r\n    }\r\n\r\n    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\r\n    function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\r\n        address from,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external virtual ensure(deadline) {\r\n        IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\r\n        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\r\n        AnyswapV1ERC20(path[0]).burn(from, amountIn);\r\n        emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\r\n    }\r\n\r\n    // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\r\n    // Triggered by `anySwapOutExactTokensForNative`\r\n    function anySwapInExactTokensForNative(\r\n        bytes32 txs,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        uint fromChainID\r\n    ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\r\n        require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\r\n        amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\r\n        _swap(amounts, path, address(this));\r\n        IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\r\n        return SushiswapV2Library.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        returns (uint amountOut)\r\n    {\r\n        return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        returns (uint amountIn)\r\n    {\r\n        return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint amountIn, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint amountOut, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\r\n    }\r\n}"}
{"address": "0xa23179be88887804f319c047e88fdd4dd4867ef5", "attacktype": "Direct call to untrusted contract, Insider trade or other activities", "sourcecode": "// Sharedstake.org SmartTimeLock forked from badger.finance\r\n// Used to lock up 40% of SGT supply for 2 years. \r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/contracts/badger-timelock/Executor.sol\r\n\r\npragma solidity >=0.5.0 <0.7.0;\r\n\r\n/*\r\n    Gnosis Safe Executor - library wrapping low level calls\r\n    https://github.com/gnosis/safe-contracts/blob/development/contracts/base/Executor.sol\r\n\r\n    Ability to execute delegateCall has been removed for security\r\n*/\r\n\r\n/// @title Executor - A contract that can execute transactions\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\n\r\ncontract Executor {\r\n    function execute(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        success = executeCall(to, value, data, txGas);\r\n    }\r\n\r\n    function executeCall(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(\r\n                txGas,\r\n                to,\r\n                value,\r\n                add(data, 0x20),\r\n                mload(data),\r\n                0,\r\n                0\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/deps/%40openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/deps/%40openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/deps/%40openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/deps/%40openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/deps/%40openzeppelin/contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/deps/%40openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: https://raw.githubusercontent.com/sharedStake-dev/badger-system/master/deps/%40openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: browser/smartTimelock.sol\r\n\r\npragma solidity 0.6.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// SmartTimeLock forked from badger.finance\r\n\r\n/**\r\n * @dev A token holder contract that will allow a beneficiary to extract the\r\n * tokens after a given release time.\r\n *\r\n * Useful for simple vesting schedules like \"advisors get all of their tokens\r\n * after 1 year\".\r\n */\r\nabstract contract TokenTimelock is Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ERC20 basic token contract being held\r\n    IERC20 private _token;\r\n\r\n    // beneficiary of tokens after they are released\r\n    address private _beneficiary;\r\n\r\n    // timestamp when token release is enabled\r\n    uint256 private _releaseTime;\r\n\r\n    constructor (IERC20 token, address beneficiary, uint256 releaseTime) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(releaseTime > block.timestamp, \"TokenTimelock: release time is before current time\");\r\n        _token = token;\r\n        _beneficiary = beneficiary;\r\n        _releaseTime = releaseTime;\r\n    }\r\n\r\n    /**\r\n     * @return the token being held.\r\n     */\r\n    function token() public view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the tokens.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @return the time when the tokens are released.\r\n     */\r\n    function releaseTime() public view returns (uint256) {\r\n        return _releaseTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the beneficiary to be changed for future multi sig deploys or team structure changes\r\n     */\r\n    function changeBeneficiary(address newBeneficiary) external onlyOwner() {\r\n        _beneficiary = newBeneficiary;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by timelock to beneficiary.\r\n     */\r\n    function release() public virtual {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp >= _releaseTime, \"TokenTimelock: current time is before release time\");\r\n\r\n        uint256 amount = _token.balanceOf(address(this));\r\n        require(amount > 0, \"TokenTimelock: no tokens to release\");\r\n\r\n        _token.safeTransfer(_beneficiary, amount);\r\n    }\r\n}\r\n\r\n/* \r\n  A token timelock that is capable of interacting with other smart contracts.\r\n  This allows the beneficiary to participate in on-chain goverance processes, despite having locked tokens.\r\n  Features safety functions to allow beneficiary to claim ETH & ERC20-compliant tokens sent to the timelock contract, accidentially or otherwise.\r\n  An optional 'governor' address has the ability to allow the timelock to send it's tokens to approved destinations. \r\n  This is intended to allow the token holder to stake their tokens in approved mechanisms.\r\n*/\r\n\r\ncontract SmartTimelock is TokenTimelock, Executor, ReentrancyGuard {\r\n    address internal _governor;\r\n    mapping(address => bool) internal _transferAllowed;\r\n\r\n    constructor(\r\n        IERC20 token,\r\n        address beneficiary,\r\n        address governor,\r\n        uint256 releaseTime\r\n    ) TokenTimelock(token, beneficiary, releaseTime) public {\r\n        _governor = governor;\r\n    }\r\n\r\n    event Call(address to, uint256 value, bytes data, bool transfersAllowed);\r\n    event ApproveTransfer(address to);\r\n    event RevokeTransfer(address to);\r\n    event ClaimToken(IERC20 token, uint256 amount);\r\n    event ClaimEther(uint256 amount);\r\n\r\n    modifier onlyGovernor() {\r\n        require(msg.sender == _governor, \"smart-timelock/only-governor\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the timelock to call arbitrary contracts, as long as it does not reduce it's locked token balance\r\n     * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\r\n     *      created via `newVote(),` which requires initialization\r\n     * @param to Contract address to call\r\n     * @param value ETH value to send, if any\r\n     * @param data Encoded data to send\r\n     */\r\n    function call(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external payable onlyOwner() nonReentrant() returns (bool success) {\r\n        uint256 preAmount = token().balanceOf(address(this));\r\n\r\n        success = execute(to, value, data, gasleft());\r\n\r\n        if (!_transferAllowed[to]) {\r\n            uint256 postAmount = token().balanceOf(address(this));\r\n            require(\r\n                postAmount >= preAmount,\r\n                \"smart-timelock/locked-balance-check\"\r\n            );\r\n        }\r\n\r\n        emit Call(to, value, data, _transferAllowed[to]);\r\n    }\r\n\r\n    function approveTransfer(address to) external onlyGovernor() {\r\n        _transferAllowed[to] = true;\r\n        emit ApproveTransfer(to);\r\n    }\r\n\r\n    function revokeTransfer(address to) external onlyGovernor() {\r\n        _transferAllowed[to] = false;\r\n        emit RevokeTransfer(to);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim ERC20-compliant tokens other than locked token.\r\n     * @param tokenToClaim Token to claim balance of.\r\n     */\r\n    function claimToken(IERC20 tokenToClaim)\r\n        external\r\n        onlyOwner()\r\n        nonReentrant()\r\n    {\r\n        require(\r\n            address(tokenToClaim) != address(token()),\r\n            \"smart-timelock/no-locked-token-claim\"\r\n        );\r\n        uint256 preAmount = token().balanceOf(address(this));\r\n\r\n        uint256 claimableTokenAmount = tokenToClaim.balanceOf(address(this));\r\n        require(\r\n            claimableTokenAmount > 0,\r\n            \"smart-timelock/no-token-balance-to-claim\"\r\n        );\r\n\r\n        tokenToClaim.transfer(beneficiary(), claimableTokenAmount);\r\n\r\n        uint256 postAmount = token().balanceOf(address(this));\r\n        require(postAmount >= preAmount, \"smart-timelock/locked-balance-check\");\r\n\r\n        emit ClaimToken(tokenToClaim, claimableTokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim Ether in contract.\r\n     */\r\n    function claimEther() external onlyOwner() nonReentrant() {\r\n        uint256 preAmount = token().balanceOf(address(this));\r\n\r\n        uint256 etherToTransfer = address(this).balance;\r\n        require(\r\n            etherToTransfer > 0,\r\n            \"smart-timelock/no-ether-balance-to-claim\"\r\n        );\r\n\r\n        payable(beneficiary()).transfer(etherToTransfer);\r\n\r\n        uint256 postAmount = token().balanceOf(address(this));\r\n        require(postAmount >= preAmount, \"smart-timelock/locked-balance-check\");\r\n\r\n        emit ClaimEther(etherToTransfer);\r\n    }\r\n\r\n    /**\r\n     * @notice Governor address\r\n     */\r\n    function governor() external view returns (address) {\r\n        return _governor;\r\n    }\r\n\r\n    /**\r\n     * @notice Allow timelock to receive Ether\r\n     */\r\n    receive() external payable {}\r\n}"}
{"address": "0x929cb86046e421abf7e1e02de7836742654d49d6", "attacktype": "Delegatecall injection, Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/3rdDeFiInterfaces/CTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\ninterface CTokenInterface {\\n    \\n    function mint() external payable;\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function claimComp(address holder) external;\\n}\\n\"\r\n    },\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/3rdDeFiInterfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;\\n}\\n\"\r\n    },\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/ModelStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\ncontract ModelStorage{\\n    \\n    address [] private _tokens;\\n    address private _forge;\\n\\n    /**\\n     * @dev This modifier allows only \\\"Forge\\\" to be executed.\\n     */\\n    modifier OnlyForge(){\\n        require(_forge == msg.sender, \\\"MODEL : Only Forge\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Add a 'token' ERC20 to be used in the model.\\n     */\\n    function addToken( address token_ ) internal returns( bool ){\\n        for( uint i = 0 ; i < tokens().length ; i++ ){\\n            if( token( i ) == token_ ){ return false; }\\n        }\\n        _tokens.push( token_ );\\n        return true;\\n    }\\n    \\n    /**\\n     * @dev A model must have only one Forge.\\n     * \\n     * IMPORTANT: 'Forge' should be non-replaceable by default.\\n     */\\n    function setForge( address forge_ ) internal returns( bool ){\\n        _forge = forge_;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the token as 'index'.\\n     */ \\n    function token( uint index ) public view returns( address ){\\n        return _tokens[index];\\n    }\\n\\n    /**\\n     * @dev Returns a list of addresses of tokens.\\n     */ \\n    function tokens() public view returns( address [] memory ){\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @dev Returns the address of Forge.\\n     */ \\n    function forge() public view returns( address ){\\n        return _forge;\\n    }\\n}\"\r\n    },\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/interfaces/ModelInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\ninterface ModelInterface{\\n\\n    event Invest( uint amount, uint timestamp );\\n    event Withdraw( uint amount, address to, uint timestamp  );\\n\\n    /**\\n     * @dev Returns the balance held by the model without investing.\\n     */\\n    function underlyingBalanceInModel() external view returns ( uint256 );\\n\\n    /**\\n     * @dev Returns the sum of the invested amount and the amount held by the model without investing.\\n     */\\n    function underlyingBalanceWithInvestment() external view returns ( uint256 );\\n\\n    /**\\n     * @dev Invest uninvested amounts according to your strategy.\\n     *\\n     * Emits a {Invest} event.\\n     */\\n    function invest() external;\\n\\n    /**\\n     * @dev After withdrawing all the invested amount, all the balance is transferred to 'Forge'.\\n     *\\n     * IMPORTANT: Must use the \\\"OnlyForge\\\" Modifier from \\\"ModelStorage.sol\\\". \\n     * \\n     * Emits a {Withdraw} event.\\n     */\\n    function withdrawAllToForge() external;\\n\\n    /**\\n     * @dev After withdrawing 'amount', send it to 'Forge'.\\n     *\\n     * IMPORTANT: Must use the \\\"OnlyForge\\\" Modifier from \\\"ModelStorage.sol\\\". \\n     * \\n     * Emits a {Withdraw} event.\\n     */\\n    function withdrawToForge( uint256 amount ) external;\\n\\n    /**\\n     * @dev After withdrawing 'amount', send it to 'to'.\\n     *\\n     * IMPORTANT: Must use the \\\"OnlyForge\\\" Modifier from \\\"ModelStorage.sol\\\". \\n     * \\n     * Emits a {Withdraw} event.\\n     */\\n    function withdrawTo( uint256 amount, address to )  external;\\n    \\n}\\n\"\r\n    },\r\n    \"/Users/jacob/Developer/DeFiWorkspace/punk.protocol/contracts/models/CompoundModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/ModelInterface.sol\\\";\\nimport \\\"../ModelStorage.sol\\\";\\nimport \\\"../3rdDeFiInterfaces/CTokenInterface.sol\\\";\\nimport \\\"../3rdDeFiInterfaces/IUniswapV2Router.sol\\\";\\n\\ncontract CompoundModel is ModelInterface, ModelStorage{\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n    event Swap( uint compAmount, uint underlying );\\n\\n    address _cToken;\\n    address _comp;\\n    address _comptroller;\\n    address _uRouterV2;\\n\\n    function initialize( \\n        address forge_, \\n        address token_,\\n        address cToken_, \\n        address comp_, \\n        address comptroller_,\\n        address uRouterV2_ ) public {\\n\\n            addToken( token_ );\\n            setForge( forge_ );\\n            _cToken         = cToken_;\\n            _comp           = comp_;\\n            _comptroller    = comptroller_;\\n            _uRouterV2      = uRouterV2_;\\n\\n    }\\n\\n    function underlyingBalanceInModel() public override view returns ( uint256 ){\\n        return IERC20( token( 0 ) ).balanceOf( address( this ) );\\n    }\\n\\n    function underlyingBalanceWithInvestment() public override view returns ( uint256 ){\\n        // Hard Work Now! For Punkers by 0xViktor\\n        return underlyingBalanceInModel().add( CTokenInterface( _cToken ).exchangeRateStored().mul( _cTokenBalanceOf() ).div( 1e18 ) );\\n    }\\n\\n    function invest() public override {\\n        // Hard Work Now! For Punkers by 0xViktor\\n        IERC20( token( 0 ) ).safeApprove( _cToken, underlyingBalanceInModel() );\\n        emit Invest( underlyingBalanceInModel(), block.timestamp );\\n        CTokenInterface( _cToken ).mint( underlyingBalanceInModel() );\\n    }\\n    \\n    function reInvest() public{\\n        // Hard Work Now! For Punkers by 0xViktor\\n        _claimComp();\\n        _swapCompToUnderlying();\\n        invest();\\n    }\\n\\n    function withdrawAllToForge() public OnlyForge override{\\n        // Hard Work Now! For Punkers by 0xViktor\\n        _claimComp();\\n        _swapCompToUnderlying();\\n\\n        emit Withdraw(  underlyingBalanceWithInvestment(), forge(), block.timestamp);\\n        CTokenInterface( _cToken ).redeem( _cTokenBalanceOf() );\\n    }\\n\\n    function withdrawToForge( uint256 amount ) public OnlyForge override{\\n        withdrawTo( amount, forge() );\\n    }\\n\\n    function withdrawTo( uint256 amount, address to ) public OnlyForge override{\\n        // Hard Work Now! For Punkers by 0xViktor\\n        uint oldBalance = IERC20( token(0) ).balanceOf( address( this ) );\\n        CTokenInterface( _cToken ).redeemUnderlying( amount );\\n        uint newBalance = IERC20( token(0) ).balanceOf( address( this ) );\\n        require(newBalance.sub( oldBalance ) > 0, \\\"MODEL : REDEEM BALANCE IS ZERO\\\");\\n        IERC20( token( 0 ) ).safeTransfer( to, newBalance.sub( oldBalance ) );\\n        \\n        emit Withdraw( amount, forge(), block.timestamp);\\n    }\\n\\n    function _cTokenBalanceOf() internal view returns( uint ){\\n        return CTokenInterface( _cToken ).balanceOf( address( this ) );\\n    }\\n\\n    function _claimComp() internal {\\n        // Hard Work Now! For Punkers by 0xViktor\\n        CTokenInterface( _comptroller ).claimComp( address( this ) );\\n    }\\n\\n    function _swapCompToUnderlying() internal {\\n        // Hard Work Now! For Punkers by 0xViktor\\n        uint balance = IERC20(_comp).balanceOf(address(this));\\n        if (balance > 0) {\\n\\n            IERC20(_comp).safeApprove(_uRouterV2, balance);\\n            \\n            address[] memory path = new address[](3);\\n            path[0] = address(_comp);\\n            path[1] = IUniswapV2Router02( _uRouterV2 ).WETH();\\n            path[2] = address( token( 0 ) );\\n\\n            IUniswapV2Router02(_uRouterV2).swapExactTokensForTokens(\\n                balance,\\n                1,\\n                path,\\n                address(this),\\n                block.timestamp + ( 15 * 60 )\\n            );\\n\\n            emit Swap(balance, underlyingBalanceInModel());\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"}
{"address": "0x3157439c84260541003001129c42fb6aba57e758", "attacktype": "Governance attack", "sourcecode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Governance {\r\n\r\n  // The duration of voting on a proposal\r\n  uint public constant votingPeriod = 86000;\r\n\r\n  // Time since submission before the proposal can be executed\r\n  uint public constant executionPeriod = 86000 * 2;\r\n\r\n  // The required minimum number of votes in support of a proposal for it to succeed\r\n  uint public constant quorumVotes = 5000e18;\r\n\r\n  // The minimum number of votes required for an account to create a proposal\r\n  uint public constant proposalThreshold = 100e18;\r\n\r\n  IERC20 public votingToken;\r\n\r\n  // The total number of proposals\r\n  uint public proposalCount;\r\n\r\n  // The record of all proposals ever proposed\r\n  mapping (uint => Proposal) public proposals;\r\n\r\n  // receipts[ProposalId][voter]\r\n  mapping (uint => mapping (address => Receipt)) public receipts;\r\n\r\n  // The time until which tokens used for voting will be locked\r\n  mapping (address => uint) public voteLock;\r\n\r\n  // Keeps track of locked tokens per address\r\n  mapping(address => uint) public balanceOf;\r\n\r\n  struct Proposal {\r\n    // Unique id for looking up a proposal\r\n    uint id;\r\n\r\n    // Creator of the proposal\r\n    address proposer;\r\n\r\n    // The time at which voting starts\r\n    uint startTime;\r\n\r\n    // Current number of votes in favor of this proposal\r\n    uint forVotes;\r\n\r\n    // Current number of votes in opposition to this proposal\r\n    uint againstVotes;\r\n\r\n    // Queued transaction hash\r\n    bytes32 txHash;\r\n\r\n    bool executed;\r\n  }\r\n\r\n  // Ballot receipt record for a voter\r\n  struct Receipt {\r\n    // Whether or not a vote has been cast\r\n    bool hasVoted;\r\n\r\n    // Whether or not the voter supports the proposal\r\n    bool support;\r\n\r\n    // The number of votes the voter had, which were cast\r\n    uint votes;\r\n  }\r\n\r\n  // Possible states that a proposal may be in\r\n  enum ProposalState {\r\n    Active,            // 0\r\n    Defeated,          // 1\r\n    PendingExecution,  // 2\r\n    ReadyForExecution, // 3\r\n    Executed           // 4\r\n  }\r\n\r\n  // If the votingPeriod is changed and the user votes again, the lock period will be reset.\r\n  modifier lockVotes() {\r\n    uint tokenBalance = votingToken.balanceOf(msg.sender);\r\n    votingToken.transferFrom(msg.sender, address(this), tokenBalance);\r\n    _mint(msg.sender, tokenBalance);\r\n    voteLock[msg.sender] = block.timestamp + votingPeriod;\r\n    _;\r\n  }\r\n\r\n  constructor(IERC20 _votingToken) {\r\n      votingToken = _votingToken;\r\n  }\r\n\r\n  function state(uint proposalId) public view returns (ProposalState) {\r\n    require(proposalCount >= proposalId && proposalId > 0, \"Governance::state: invalid proposal id\");\r\n    Proposal storage proposal = proposals[proposalId];\r\n\r\n    if (block.timestamp <= proposal.startTime + votingPeriod) {\r\n      return ProposalState.Active;\r\n\r\n    } else if (proposal.executed == true) {\r\n      return ProposalState.Executed;\r\n\r\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\r\n      return ProposalState.Defeated;\r\n\r\n    } else if (block.timestamp < proposal.startTime + executionPeriod) {\r\n      return ProposalState.PendingExecution;\r\n\r\n    } else {\r\n      return ProposalState.ReadyForExecution;\r\n    }\r\n  }\r\n\r\n  function execute(uint _proposalId, address _target, bytes memory _data)\r\n    public\r\n    payable\r\n    returns (bytes memory)\r\n  {\r\n    bytes32 txHash = keccak256(abi.encode(_target, _data));\r\n    Proposal storage proposal = proposals[_proposalId];\r\n    require(proposal.txHash == txHash, \"Governance::execute: Invalid proposal\");\r\n    require(state(_proposalId) == ProposalState.ReadyForExecution, \"Governance::execute: Cannot be executed\");\r\n\r\n    (bool success, bytes memory returnData) = _target.delegatecall(_data);\r\n    require(success, \"Governance::execute: Transaction execution reverted.\");\r\n    proposal.executed = true;\r\n\r\n    return returnData;\r\n  }\r\n\r\n  function propose(address _target, bytes memory _data) public lockVotes returns (uint) {\r\n\r\n    require(balanceOf[msg.sender] >= proposalThreshold, \"Governance::propose: proposer votes below proposal threshold\");\r\n\r\n    bytes32 txHash = keccak256(abi.encode(_target, _data));\r\n\r\n    proposalCount++;\r\n    Proposal memory newProposal = Proposal({\r\n      id:           proposalCount,\r\n      proposer:     msg.sender,\r\n      startTime:    block.timestamp,\r\n      forVotes:     0,\r\n      againstVotes: 0,\r\n      txHash:       txHash,\r\n      executed:     false\r\n    });\r\n\r\n    proposals[newProposal.id] = newProposal;\r\n\r\n    return proposalCount;\r\n  }\r\n\r\n  function vote(uint _proposalId, bool _support) public lockVotes {\r\n\r\n    require(state(_proposalId) == ProposalState.Active, \"Governance::vote: voting is closed\");\r\n    Proposal storage proposal = proposals[_proposalId];\r\n    Receipt storage receipt = receipts[_proposalId][msg.sender];\r\n    require(receipt.hasVoted == false, \"Governance::vote: voter already voted\");\r\n\r\n    uint votes = balanceOf[msg.sender];\r\n\r\n    if (_support) {\r\n      proposal.forVotes += votes;\r\n    } else {\r\n      proposal.againstVotes += votes;\r\n    }\r\n\r\n    receipt.hasVoted = true;\r\n    receipt.support = _support;\r\n    receipt.votes = votes;\r\n  }\r\n\r\n  function withdraw() public {\r\n    require(block.timestamp > voteLock[msg.sender], \"Governance::withdraw: wait until voteLock expiration\");\r\n    votingToken.transfer(msg.sender, balanceOf[msg.sender]);\r\n    _burn(msg.sender, balanceOf[msg.sender]);\r\n  }\r\n\r\n  function _mint(address _account, uint _amount) internal {\r\n    balanceOf[_account] += _amount;\r\n  }\r\n\r\n  function _burn(address _account, uint _amount) internal {\r\n    balanceOf[_account] -= _amount;\r\n  }\r\n}"}
{"address": "0x0e6ffd4daeca13a8158146516f847d2f44ad4a30", "attacktype": "Locked or frozen tokens", "sourcecode": "/*\r\n   ____            __   __        __   _\r\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\r\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\r\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\r\n     /___/\r\n\r\n* Synthetix: YFIRewards.sol\r\n*\r\n* Docs: https://docs.synthetix.io/\r\n*\r\n*\r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2020 Synthetix\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal {}\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function mint(address account, uint amount) external;\r\n\r\n    function burn(uint amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {codehash := extcodehash(account)}\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success,) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {// Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/IRewardDistributionRecipient.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract IRewardDistributionRecipient is Ownable {\r\n    address public rewardReferral;\r\n    address public rewardVote;\r\n\r\n    function notifyRewardAmount(uint256 reward) external;\r\n\r\n    function setRewardReferral(address _rewardReferral) external onlyOwner {\r\n        rewardReferral = _rewardReferral;\r\n    }\r\n\r\n    function setRewardVote(address _rewardVote) external onlyOwner {\r\n        rewardVote = _rewardVote;\r\n    }\r\n}\r\n\r\n// File: contracts/CurveRewards.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract LPTokenWrapper {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    IERC20 public yfv = IERC20(0x45f24BaEef268BB6d63AEe5129015d69702BCDfa);\r\n\r\n    uint256 private _totalSupply;\r\n    mapping(address => uint256) private _balances;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function tokenStake(uint256 amount) internal {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\r\n        yfv.safeTransferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function tokenStakeOnBehalf(address stakeFor, uint256 amount) internal {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[stakeFor] = _balances[stakeFor].add(amount);\r\n        yfv.safeTransferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function tokenWithdraw(uint256 amount) internal {\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n        yfv.safeTransfer(msg.sender, amount);\r\n    }\r\n}\r\n\r\ninterface IYFVReferral {\r\n    function setReferrer(address farmer, address referrer) external;\r\n    function getReferrer(address farmer) external view returns (address);\r\n}\r\n\r\ninterface IYFVVote {\r\n    function averageVotingValue(address poolAddress, uint256 votingItem) external view returns (uint16);\r\n}\r\n\r\ncontract YFVStake is LPTokenWrapper, IRewardDistributionRecipient {\r\n    IERC20 public vUSD = IERC20(0x1B8E12F839BD4e73A47adDF76cF7F0097d74c14C);\r\n    IERC20 public vETH = IERC20(0x76A034e76Aa835363056dd418611E4f81870f16e);\r\n\r\n    uint256 public vUSD_REWARD_FRACTION_RATE = 21000000000; // 21 * 1e9 (vUSD decimals = 9)\r\n    uint256 public vETH_REWARD_FRACTION_RATE = 21000000000000; // 21000 * 1e9 (vETH decimals = 9)\r\n\r\n    uint256 public constant DURATION = 7 days;\r\n    uint8 public constant NUMBER_EPOCHS = 50;\r\n\r\n    uint256 public constant FROZEN_STAKING_TIME = 72 hours;\r\n    uint256 public constant REFERRAL_COMMISSION_PERCENT = 1;\r\n\r\n    uint256 public constant EPOCH_REWARD = 63000 ether;\r\n    uint256 public constant TOTAL_REWARD = EPOCH_REWARD * NUMBER_EPOCHS;\r\n\r\n    uint256 public currentEpochReward = EPOCH_REWARD;\r\n    uint256 public totalAccumulatedReward = 0;\r\n    uint8 public currentEpoch = 0;\r\n    uint256 public starttime = 1598018400; // Friday, August 21, 2020 2:00:00 PM (GMT+0)\r\n    uint256 public periodFinish = 0;\r\n    uint256 public rewardRate = 0;\r\n    uint256 public lastUpdateTime;\r\n    uint256 public rewardPerTokenStored;\r\n    mapping(address => uint256) public userRewardPerTokenPaid;\r\n    mapping(address => uint256) public rewards;\r\n    mapping(address => uint256) public lastStakeTimes;\r\n    mapping(address => bool) public claimedVETHRewards; // account -> has claimed vETH?\r\n\r\n    mapping(address => uint256) public accumulatedStakingPower; // will accumulate every time staker does getReward()\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event Burned(uint256 reward);\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 reward);\r\n    event CommissionPaid(address indexed user, uint256 reward);\r\n\r\n    modifier updateReward(address account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        lastUpdateTime = lastTimeRewardApplicable();\r\n        if (account != address(0)) {\r\n            rewards[account] = earned(account);\r\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\r\n        }\r\n        _;\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return Math.min(block.timestamp, periodFinish);\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (totalSupply() == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n        return\r\n        rewardPerTokenStored.add(\r\n            lastTimeRewardApplicable()\r\n            .sub(lastUpdateTime)\r\n            .mul(rewardRate)\r\n            .mul(1e18)\r\n            .div(totalSupply())\r\n        );\r\n    }\r\n\r\n    function earned(address account) public view returns (uint256) {\r\n        uint256 calculatedEarned = balanceOf(account)\r\n            .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\r\n            .div(1e18)\r\n            .add(rewards[account]);\r\n        uint256 poolBalance = yfv.balanceOf(address(this));\r\n        if (poolBalance < totalSupply()) return 0; // double-check for sure. It should never happen\r\n        // some rare case the reward can be slightly bigger than real number, we need to check against how much we have left in pool\r\n        if (calculatedEarned.add(totalSupply()) > poolBalance) return poolBalance.sub(totalSupply());\r\n        return calculatedEarned;\r\n    }\r\n\r\n    function stakingPower(address account) public view returns (uint256) {\r\n        return accumulatedStakingPower[account].add(earned(account));\r\n    }\r\n\r\n    function vUSDBalance(address account) public view returns (uint256) {\r\n        return earned(account).div(vUSD_REWARD_FRACTION_RATE);\r\n    }\r\n\r\n    function vETHBalance(address account) public view returns (uint256) {\r\n        return stakingPower(account).div(vETH_REWARD_FRACTION_RATE);\r\n    }\r\n\r\n    function claimVETHReward() public {\r\n        require(rewardRate == 0, \"vETH could be claimed only after the pool ends.\");\r\n        uint256 claimAmount = vETHBalance(msg.sender);\r\n        require(claimAmount > 0, \"You have no vETH to claim\");\r\n        require(!claimedVETHRewards[msg.sender], \"You have claimed all pending vETH.\");\r\n        claimedVETHRewards[msg.sender] = true;\r\n        vETH.safeTransfer(msg.sender, claimAmount);\r\n    }\r\n\r\n    function stake(uint256 amount, address referrer) public updateReward(msg.sender) checkNextEpoch {\r\n        require(amount > 0, \"Cannot stake 0\");\r\n        require(referrer != msg.sender, \"You cannot refer yourself.\");\r\n        super.tokenStake(amount);\r\n        lastStakeTimes[msg.sender] = block.timestamp;\r\n        emit Staked(msg.sender, amount);\r\n        if (rewardReferral != address(0) && referrer != address(0)) {\r\n            IYFVReferral(rewardReferral).setReferrer(msg.sender, referrer);\r\n        }\r\n    }\r\n\r\n    function stakeOnBehalf(address stakeFor, uint256 amount) public updateReward(stakeFor) checkNextEpoch {\r\n        require(amount > 0, \"Cannot stake 0\");\r\n        super.tokenStakeOnBehalf(stakeFor, amount);\r\n        lastStakeTimes[stakeFor] = block.timestamp;\r\n        emit Staked(stakeFor, amount);\r\n    }\r\n\r\n    function stakeReward() public updateReward(msg.sender) checkNextEpoch {\r\n        uint256 reward = getReward();\r\n        require(reward > 0, \"Earned too little\");\r\n        super.tokenStake(reward);\r\n        lastStakeTimes[msg.sender] = block.timestamp;\r\n        emit Staked(msg.sender, reward);\r\n    }\r\n\r\n    function unfrozenStakeTime(address account) public view returns (uint256) {\r\n        return lastStakeTimes[account] + FROZEN_STAKING_TIME;\r\n    }\r\n\r\n    function withdraw(uint256 amount) public updateReward(msg.sender) checkNextEpoch {\r\n        require(amount > 0, \"Cannot withdraw 0\");\r\n        require(block.timestamp >= unfrozenStakeTime(msg.sender), \"Coin is still frozen\");\r\n        super.tokenWithdraw(amount);\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    function exit() external {\r\n        withdraw(balanceOf(msg.sender));\r\n        getReward();\r\n    }\r\n\r\n    function getReward() public updateReward(msg.sender) checkNextEpoch returns (uint256) {\r\n        uint256 reward = earned(msg.sender);\r\n        if (reward > 1) {\r\n            accumulatedStakingPower[msg.sender] = accumulatedStakingPower[msg.sender].add(rewards[msg.sender]);\r\n            rewards[msg.sender] = 0;\r\n\r\n            uint256 actualPaid = reward.mul(100 - REFERRAL_COMMISSION_PERCENT).div(100); // 99%\r\n            uint256 commission = reward - actualPaid; // 1%\r\n\r\n            yfv.safeTransfer(msg.sender, actualPaid);\r\n            emit RewardPaid(msg.sender, actualPaid);\r\n\r\n            address referrer = address(0);\r\n            if (rewardReferral != address(0)) {\r\n                referrer = IYFVReferral(rewardReferral).getReferrer(msg.sender);\r\n            }\r\n            if (referrer != address(0)) { // send commission to referrer\r\n                yfv.safeTransfer(referrer, commission);\r\n                emit RewardPaid(msg.sender, commission);\r\n            } else {// or burn\r\n                yfv.burn(commission);\r\n                emit Burned(commission);\r\n            }\r\n\r\n            vUSD.safeTransfer(msg.sender, reward.div(vUSD_REWARD_FRACTION_RATE));\r\n            return actualPaid;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    modifier checkNextEpoch() {\r\n        require(periodFinish > 0, \"Pool has not started\");\r\n        if (block.timestamp >= periodFinish) {\r\n            currentEpochReward = EPOCH_REWARD;\r\n\r\n            if (totalAccumulatedReward.add(currentEpochReward) > TOTAL_REWARD) {\r\n                currentEpochReward = TOTAL_REWARD.sub(totalAccumulatedReward); // limit total reward\r\n            }\r\n\r\n            if (currentEpochReward > 0) {\r\n                yfv.mint(address(this), currentEpochReward);\r\n                vUSD.mint(address(this), currentEpochReward.div(vUSD_REWARD_FRACTION_RATE));\r\n                vETH.mint(address(this), currentEpochReward.div(vETH_REWARD_FRACTION_RATE));\r\n                totalAccumulatedReward = totalAccumulatedReward.add(currentEpochReward);\r\n                currentEpoch++;\r\n            }\r\n\r\n            rewardRate = currentEpochReward.div(DURATION);\r\n            lastUpdateTime = block.timestamp;\r\n            periodFinish = block.timestamp.add(DURATION);\r\n            emit RewardAdded(currentEpochReward);\r\n        }\r\n        _;\r\n    }\r\n\r\n    function notifyRewardAmount(uint256 reward) external onlyOwner updateReward(address(0)) {\r\n        require(periodFinish == 0, \"Only can call once to start staking\");\r\n        currentEpochReward = reward;\r\n        if (totalAccumulatedReward.add(currentEpochReward) > TOTAL_REWARD) {\r\n            currentEpochReward = TOTAL_REWARD.sub(totalAccumulatedReward); // limit total reward\r\n        }\r\n        lastUpdateTime = block.timestamp;\r\n        if (block.timestamp < starttime) {// epoch zero\r\n            periodFinish = starttime;\r\n            rewardRate = reward.div(periodFinish.sub(block.timestamp));\r\n        } else { // 1st epoch\r\n            periodFinish = lastUpdateTime.add(DURATION);\r\n            rewardRate = reward.div(DURATION);\r\n            currentEpoch++;\r\n        }\r\n        yfv.mint(address(this), reward);\r\n        vUSD.mint(address(this), reward.div(vUSD_REWARD_FRACTION_RATE));\r\n        vETH.mint(address(this), reward.div(vETH_REWARD_FRACTION_RATE));\r\n        totalAccumulatedReward = totalAccumulatedReward.add(reward);\r\n        emit RewardAdded(reward);\r\n    }\r\n}"}
{"address": "0x606e9758a39d2d7fa7e70bc68e6e7d9b02948962", "attacktype": "Absence of code logic or sanity check", "sourcecode": "pragma solidity ^0.5.0;\n\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint supply);\n    function balanceOf(address _owner) external view returns (uint balance);\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ninterface ExchangeInterface {\n    function swapEtherToToken (uint _ethAmount, address _tokenAddress, uint _maxAmount) payable external returns(uint, uint);\n    function swapTokenToEther (address _tokenAddress, uint _amount, uint _maxAmount) external returns(uint);\n    function swapTokenToToken(address _src, address _dest, uint _amount) external payable returns(uint);\n\n    function getExpectedRate(address src, address dest, uint srcQty) external view\n        returns (uint expectedRate);\n}\n\ncontract TokenInterface {\n    function allowance(address, address) public returns (uint);\n    function balanceOf(address) public returns (uint);\n    function approve(address, uint) public;\n    function transfer(address, uint) public returns (bool);\n    function transferFrom(address, address, uint) public returns (bool);\n    function deposit() public payable;\n    function withdraw(uint) public;\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function div(uint x, uint y) internal pure returns (uint z) {\n        return x / y;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\ncontract SaverExchangeConstantAddresses {\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    address public constant KYBER_WRAPPER = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;\n    address public constant UNISWAP_WRAPPER = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;\n    address public constant OASIS_WRAPPER = 0x891f5A171f865031b0f3Eb9723bb8f68C901c9FE;\n\n    // Our contracts\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n}\n\ncontract Discount {\n\n    address public owner;\n    mapping (address => CustomServiceFee) public serviceFees;\n\n    uint constant MAX_SERVICE_FEE = 400;\n\n    struct CustomServiceFee {\n        bool active;\n        uint amount;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({\n            active: true,\n            amount: _fee\n        });\n    }\n\n    function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({\n            active: false,\n            amount: 0\n        });\n    }\n}\n\ncontract SaverExchange is DSMath, SaverExchangeConstantAddresses {\n\n    uint public constant SERVICE_FEE = 800; // 0.125% Fee\n\n    event Swap(address src, address dest, uint amountSold, uint amountBought, address wrapper);\n\n    function swapTokenToToken(address _src, address _dest, uint _amount, uint _minPrice, uint _exchangeType, address _exchangeAddress, bytes memory _callData, uint _0xPrice) public payable {\n        // use this to avoid stack too deep error\n        address[3] memory orderAddresses = [_exchangeAddress, _src, _dest];\n\n        if (orderAddresses[1] == KYBER_ETH_ADDRESS) {\n            require(msg.value >= _amount, \"msg.value smaller than amount\");\n        } else {\n            require(ERC20(orderAddresses[1]).transferFrom(msg.sender, address(this), _amount), \"Not able to withdraw wanted amount\");\n        }\n\n        uint fee = takeFee(_amount, orderAddresses[1]);\n        _amount = sub(_amount, fee);\n        // [tokensReturned, tokensLeft]\n        uint[2] memory tokens;\n        address wrapper;\n        uint price;\n        bool success;\n\n        // at the beggining tokensLeft equals _amount\n        tokens[1] = _amount;\n\n        if (_exchangeType == 4) {\n            if (orderAddresses[1] != KYBER_ETH_ADDRESS) {\n                ERC20(orderAddresses[1]).approve(address(ERC20_PROXY_0X), _amount);\n            }\n\n            (success, tokens[0], ) = takeOrder(orderAddresses, _callData, address(this).balance, _amount);\n            // either it reverts or order doesn't exist anymore, we reverts as it was explicitely asked for this exchange\n            require(success && tokens[0] > 0, \"0x transaction failed\");\n            wrapper = address(_exchangeAddress);\n        }\n\n        if (tokens[0] == 0) {\n            (wrapper, price) = getBestPrice(_amount, orderAddresses[1], orderAddresses[2], _exchangeType);\n\n            require(price > _minPrice || _0xPrice > _minPrice, \"Slippage hit\");\n\n            // handle 0x exchange, if equal price, try 0x to use less gas\n            if (_0xPrice >= price) {\n                if (orderAddresses[1] != KYBER_ETH_ADDRESS) {\n                    ERC20(orderAddresses[1]).approve(address(ERC20_PROXY_0X), _amount);\n                }\n                (success, tokens[0], tokens[1]) = takeOrder(orderAddresses, _callData, address(this).balance, _amount);\n                // either it reverts or order doesn't exist anymore\n                if (success && tokens[0] > 0) {\n                    wrapper = address(_exchangeAddress);\n                    emit Swap(orderAddresses[1], orderAddresses[2], _amount, tokens[0], wrapper);\n                }\n            }\n\n            if (tokens[1] > 0) {\n                // in case 0x swapped just some amount of tokens and returned everything else\n                if (tokens[1] != _amount) {\n                    (wrapper, price) = getBestPrice(tokens[1], orderAddresses[1], orderAddresses[2], _exchangeType);\n                }\n\n                // in case 0x failed, price on other exchanges still needs to be higher than minPrice\n                require(price > _minPrice, \"Slippage hit onchain price\");\n                if (orderAddresses[1] == KYBER_ETH_ADDRESS) {\n                    (tokens[0],) = ExchangeInterface(wrapper).swapEtherToToken.value(tokens[1])(tokens[1], orderAddresses[2], uint(-1));\n                } else {\n                    ERC20(orderAddresses[1]).transfer(wrapper, tokens[1]);\n\n                    if (orderAddresses[2] == KYBER_ETH_ADDRESS) {\n                        tokens[0] = ExchangeInterface(wrapper).swapTokenToEther(orderAddresses[1], tokens[1], uint(-1));\n                    } else {\n                        tokens[0] = ExchangeInterface(wrapper).swapTokenToToken(orderAddresses[1], orderAddresses[2], tokens[1]);\n                    }\n                }\n\n                emit Swap(orderAddresses[1], orderAddresses[2], _amount, tokens[0], wrapper);\n            }\n        }\n\n        // return whatever is left in contract\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n\n        // return if there is any tokens left\n        if (orderAddresses[2] != KYBER_ETH_ADDRESS) {\n            if (ERC20(orderAddresses[2]).balanceOf(address(this)) > 0) {\n                ERC20(orderAddresses[2]).transfer(msg.sender, ERC20(orderAddresses[2]).balanceOf(address(this)));\n            }\n        }\n\n        if (orderAddresses[1] != KYBER_ETH_ADDRESS) {\n            if (ERC20(orderAddresses[1]).balanceOf(address(this)) > 0) {\n                ERC20(orderAddresses[1]).transfer(msg.sender, ERC20(orderAddresses[1]).balanceOf(address(this)));\n            }\n        }\n    }\n\n    // @notice Takes order from 0x and returns bool indicating if it is successful\n    // @param _addresses [exchange, src, dst]\n    // @param _data Data to send with call\n    // @param _value Value to send with call\n    // @param _amount Amount being sold\n    function takeOrder(address[3] memory _addresses, bytes memory _data, uint _value, uint _amount) private returns(bool, uint, uint) {\n        bool success;\n\n        (success, ) = _addresses[0].call.value(_value)(_data);\n\n        uint tokensLeft = _amount;\n        uint tokensReturned = 0;\n        if (success){\n            // check how many tokens left from _src\n            if (_addresses[1] == KYBER_ETH_ADDRESS) {\n                tokensLeft = address(this).balance;\n            } else {\n                tokensLeft = ERC20(_addresses[1]).balanceOf(address(this));\n            }\n\n            // check how many tokens are returned\n            if (_addresses[2] == KYBER_ETH_ADDRESS) {\n                TokenInterface(WETH_ADDRESS).withdraw(TokenInterface(WETH_ADDRESS).balanceOf(address(this)));\n                tokensReturned = address(this).balance;\n            } else {\n                tokensReturned = ERC20(_addresses[2]).balanceOf(address(this));\n            }\n        }\n\n        return (success, tokensReturned, tokensLeft);\n    }\n\n    /// @notice Returns the best estimated price from 2 exchanges\n    /// @param _amount Amount of source tokens you want to exchange\n    /// @param _srcToken Address of the source token\n    /// @param _destToken Address of the destination token\n    /// @return (address, uint) The address of the best exchange and the exchange price\n    function getBestPrice(uint _amount, address _srcToken, address _destToken, uint _exchangeType) public returns (address, uint) {\n        uint expectedRateKyber;\n        uint expectedRateUniswap;\n        uint expectedRateOasis;\n\n\n        if (_exchangeType == 1) {\n            return (OASIS_WRAPPER, getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount));\n        }\n\n        if (_exchangeType == 2) {\n            return (KYBER_WRAPPER, getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount));\n        }\n\n        if (_exchangeType == 3) {\n            expectedRateUniswap = getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount);\n            expectedRateUniswap = expectedRateUniswap * (10 ** (18 - getDecimals(_destToken)));\n            return (UNISWAP_WRAPPER, expectedRateUniswap);\n        }\n\n        expectedRateKyber = getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount);\n        expectedRateUniswap = getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount);\n        expectedRateUniswap = expectedRateUniswap * (10 ** (18 - getDecimals(_destToken)));\n        expectedRateOasis = getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount);\n\n        if ((expectedRateKyber >= expectedRateUniswap) && (expectedRateKyber >= expectedRateOasis)) {\n            return (KYBER_WRAPPER, expectedRateKyber);\n        }\n\n        if ((expectedRateOasis >= expectedRateKyber) && (expectedRateOasis >= expectedRateUniswap)) {\n            return (OASIS_WRAPPER, expectedRateOasis);\n        }\n\n        if ((expectedRateUniswap >= expectedRateKyber) && (expectedRateUniswap >= expectedRateOasis)) {\n            return (UNISWAP_WRAPPER, expectedRateUniswap);\n        }\n    }\n\n    function getExpectedRate(address _wrapper, address _srcToken, address _destToken, uint _amount) public returns(uint) {\n        bool success;\n        bytes memory result;\n\n        (success, result) = _wrapper.call(abi.encodeWithSignature(\"getExpectedRate(address,address,uint256)\", _srcToken, _destToken, _amount));\n\n        if (success) {\n            return sliceUint(result, 0);\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Takes a feePercentage and sends it to wallet\n    /// @param _amount Dai amount of the whole trade\n    /// @return feeAmount Amount in Dai owner earned on the fee\n    function takeFee(uint _amount, address _token) internal returns (uint feeAmount) {\n        uint fee = SERVICE_FEE;\n\n        if (Discount(DISCOUNT_ADDRESS).isCustomFeeSet(msg.sender)) {\n            fee = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(msg.sender);\n        }\n\n        if (fee == 0) {\n            feeAmount = 0;\n        } else {\n            feeAmount = _amount / SERVICE_FEE;\n            if (_token == KYBER_ETH_ADDRESS) {\n                WALLET_ID.transfer(feeAmount);\n            } else {\n                ERC20(_token).transfer(WALLET_ID, feeAmount);\n            }\n        }\n    }\n\n\n    function getDecimals(address _token) internal view returns(uint) {\n        // DGD\n        if (_token == address(0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A)) {\n            return 9;\n        }\n        // USDC\n        if (_token == address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)) {\n            return 6;\n        }\n        // WBTC\n        if (_token == address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599)) {\n            return 8;\n        }\n\n        return 18;\n    }\n\n    function sliceUint(bytes memory bs, uint start) internal pure returns (uint) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n\n    // receive eth from wrappers\n    function() external payable {}\n}"}
{"address": "0x1cec0e358f882733c5ecc028d8a0c24baee02004", "attacktype": "Reentrancy", "sourcecode": "// File: @openzeppelin\\contracts-ethereum-package\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin\\upgrades\\contracts\\Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is Initializable, IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\utils\\Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\GSN\\Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\access\\Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\access\\roles\\CapperRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract CapperRole is Initializable, Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event CapperAdded(address indexed account);\r\n    event CapperRemoved(address indexed account);\r\n\r\n    Roles.Role private _cappers;\r\n\r\n    function initialize(address sender) public initializer {\r\n        if (!isCapper(sender)) {\r\n            _addCapper(sender);\r\n        }\r\n    }\r\n\r\n    modifier onlyCapper() {\r\n        require(isCapper(_msgSender()), \"CapperRole: caller does not have the Capper role\");\r\n        _;\r\n    }\r\n\r\n    function isCapper(address account) public view returns (bool) {\r\n        return _cappers.has(account);\r\n    }\r\n\r\n    function addCapper(address account) public onlyCapper {\r\n        _addCapper(account);\r\n    }\r\n\r\n    function renounceCapper() public {\r\n        _removeCapper(_msgSender());\r\n    }\r\n\r\n    function _addCapper(address account) internal {\r\n        _cappers.add(account);\r\n        emit CapperAdded(account);\r\n    }\r\n\r\n    function _removeCapper(address account) internal {\r\n        _cappers.remove(account);\r\n        emit CapperRemoved(account);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\interfaces\\defi\\IDefiProtocol.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\ninterface IDefiProtocol {\r\n    /**\r\n     * @notice Transfer tokens from sender to DeFi protocol\r\n     * @param token Address of token\r\n     * @param amount Value of token to deposit\r\n     * @return new balances of each token\r\n     */\r\n    function handleDeposit(address token, uint256 amount) external;\r\n\r\n    function handleDeposit(address[] calldata tokens, uint256[] calldata amounts) external;\r\n\r\n    /**\r\n     * @notice Transfer tokens from DeFi protocol to beneficiary\r\n     * @param token Address of token\r\n     * @param amount Denormalized value of token to withdraw\r\n     * @return new balances of each token\r\n     */\r\n    function withdraw(address beneficiary, address token, uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Transfer tokens from DeFi protocol to beneficiary\r\n     * @param amounts Array of amounts to withdraw, in order of supportedTokens()\r\n     * @return new balances of each token\r\n     */\r\n    function withdraw(address beneficiary, uint256[] calldata amounts) external;\r\n\r\n    /**\r\n     * @notice Claim rewards. Reward tokens will be stored on protocol balance.\r\n     * @return tokens and their amounts received\r\n     */\r\n    function claimRewards() external returns(address[] memory tokens, uint256[] memory amounts);\r\n\r\n    /**\r\n     * @notice Withdraw reward tokens to user\r\n     * @dev called by SavingsModule\r\n     * @param token Reward token to withdraw\r\n     * @param user Who should receive tokens\r\n     * @param amount How many tokens to send\r\n     */\r\n    function withdrawReward(address token, address user, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev This function is not view because on some protocols \r\n     * (Compound, RAY with Compound oportunity) it may cause storage writes\r\n     */\r\n    function balanceOf(address token) external returns(uint256);\r\n\r\n    /**\r\n     * @notice Balance of all tokens supported by protocol \r\n     * @dev This function is not view because on some protocols \r\n     * (Compound, RAY with Compound oportunity) it may cause storage writes\r\n     */\r\n    function balanceOfAll() external returns(uint256[] memory); \r\n\r\n    /**\r\n     * @notice Returns optimal proportions of underlying tokens \r\n     * to prevent fees on deposit/withdrawl if supplying multiple tokens\r\n     * @dev This function is not view because on some protocols \r\n     * (Compound, RAY with Compound oportunity) it may cause storage writes\r\n     * same as balanceOfAll()\r\n     */\r\n    function optimalProportions() external returns(uint256[] memory);\r\n\r\n    /**\r\n    * @notice Returns normalized (to USD with 18 decimals) summary balance \r\n    * of pool using all tokens in this protocol\r\n    */\r\n    function normalizedBalance() external returns(uint256);\r\n\r\n    function supportedTokens() external view returns(address[] memory);\r\n\r\n    function supportedTokensCount() external view returns(uint256);\r\n\r\n    function supportedRewardTokens() external view returns(address[] memory);\r\n\r\n    function isSupportedRewardToken(address token) external view returns(bool);\r\n\r\n    /**\r\n     * @notice Returns if this protocol can swap all it's normalizedBalance() to specified token\r\n     */\r\n    function canSwapToToken(address token) external view returns(bool);\r\n\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\ownership\\Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Initializable, Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\common\\Base.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n/**\r\n * Base contract for all modules\r\n */\r\ncontract Base is Initializable, Context, Ownable {\r\n    address constant  ZERO_ADDRESS = address(0);\r\n\r\n    function initialize() public initializer {\r\n        Ownable.initialize(_msgSender());\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\core\\ModuleNames.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @dev List of module names\r\n */\r\ncontract ModuleNames {\r\n    // Pool Modules\r\n    string internal constant MODULE_ACCESS            = \"access\";\r\n    string internal constant MODULE_SAVINGS           = \"savings\";\r\n    string internal constant MODULE_INVESTING         = \"investing\";\r\n    string internal constant MODULE_STAKING_AKRO      = \"staking\";\r\n    string internal constant MODULE_STAKING_ADEL      = \"stakingAdel\";\r\n    string internal constant MODULE_DCA               = \"dca\";\r\n    string internal constant MODULE_REWARD            = \"reward\";\r\n    string internal constant MODULE_REWARD_DISTR      = \"rewardDistributions\";\r\n\r\n    // Pool tokens\r\n    string internal constant TOKEN_AKRO               = \"akro\";    \r\n    string internal constant TOKEN_ADEL               = \"adel\";    \r\n\r\n    // External Modules (used to store addresses of external contracts)\r\n    string internal constant CONTRACT_RAY             = \"ray\";\r\n}\r\n\r\n// File: contracts\\common\\Module.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n/**\r\n * Base contract for all modules\r\n */\r\ncontract Module is Base, ModuleNames {\r\n    event PoolAddressChanged(address newPool);\r\n    address public pool;\r\n\r\n    function initialize(address _pool) public initializer {\r\n        Base.initialize();\r\n        setPool(_pool);\r\n    }\r\n\r\n    function setPool(address _pool) public onlyOwner {\r\n        require(_pool != ZERO_ADDRESS, \"Module: pool address can't be zero\");\r\n        pool = _pool;\r\n        emit PoolAddressChanged(_pool);        \r\n    }\r\n\r\n    function getModuleAddress(string memory module) public view returns(address){\r\n        require(pool != ZERO_ADDRESS, \"Module: no pool\");\r\n        (bool success, bytes memory result) = pool.staticcall(abi.encodeWithSignature(\"get(string)\", module));\r\n        \r\n        //Forward error from Pool contract\r\n        if (!success) assembly {\r\n            revert(add(result, 32), result)\r\n        }\r\n\r\n        address moduleAddress = abi.decode(result, (address));\r\n        // string memory error = string(abi.encodePacked(\"Module: requested module not found - \", module));\r\n        // require(moduleAddress != ZERO_ADDRESS, error);\r\n        require(moduleAddress != ZERO_ADDRESS, \"Module: requested module not found\");\r\n        return moduleAddress;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\interfaces\\access\\IAccessModule.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\ninterface IAccessModule {\r\n    enum Operation {\r\n        Deposit,\r\n        Withdraw\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if operation is allowed\r\n     * @param operation Requested operation\r\n     * @param sender Sender of transaction\r\n     */\r\n    function isOperationAllowed(Operation operation, address sender) external view returns(bool);\r\n}\r\n\r\n// File: contracts\\modules\\access\\AccessChecker.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\ncontract AccessChecker is Module {\r\n    modifier operationAllowed(IAccessModule.Operation operation) {\r\n        IAccessModule am = IAccessModule(getModuleAddress(MODULE_ACCESS));\r\n        require(am.isOperationAllowed(operation, _msgSender()), \"AccessChecker: operation not allowed\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Initializable, Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\access\\roles\\MinterRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract MinterRole is Initializable, Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    function initialize(address sender) public initializer {\r\n        if (!isMinter(sender)) {\r\n            _addMinter(sender);\r\n        }\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(_msgSender());\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20Mintable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\r\n * which have permission to mint (create) new tokens as they see fit.\r\n *\r\n * At construction, the deployer of the contract is the only minter.\r\n */\r\ncontract ERC20Mintable is Initializable, ERC20, MinterRole {\r\n    function initialize(address sender) public initializer {\r\n        MinterRole.initialize(sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the {MinterRole}.\r\n     */\r\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\r\n        _mint(account, amount);\r\n        return true;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20Burnable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\ncontract ERC20Burnable is Initializable, Context, ERC20 {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_burnFrom}.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public {\r\n        _burnFrom(account, amount);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts\\interfaces\\token\\IPoolTokenBalanceChangeRecipient.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\ninterface IPoolTokenBalanceChangeRecipient {\r\n    function poolTokenBalanceChanged(address user) external; \r\n}\r\n\r\n// File: contracts\\modules\\token\\DistributionToken.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n//solhint-disable func-order\r\ncontract DistributionToken is ERC20, ERC20Mintable {\r\n    using SafeMath for uint256;\r\n    uint256 public constant DISTRIBUTION_AGGREGATION_PERIOD = 24*60*60;\r\n\r\n    event DistributionCreated(uint256 amount, uint256 totalSupply);\r\n    event DistributionsClaimed(address account, uint256 amount, uint256 fromDistribution, uint256 toDistribution);\r\n    event DistributionAccumulatorIncreased(uint256 amount);\r\n\r\n    struct Distribution {\r\n        uint256 amount;         // Amount of tokens being distributed during the event\r\n        uint256 totalSupply;    // Total supply before distribution\r\n    }\r\n\r\n    Distribution[] public distributions;                   // Array of all distributions\r\n    mapping(address => uint256) public nextDistributions;  // Map account to first distribution not yet processed\r\n\r\n    uint256 public nextDistributionTimestamp;      //Timestamp when next distribuition should be fired regardles of accumulated tokens\r\n    uint256 public distributionAccumulator;        //Tokens accumulated for next distribution\r\n\r\n    function distribute(uint256 amount) external onlyMinter {\r\n        distributionAccumulator = distributionAccumulator.add(amount);\r\n        emit DistributionAccumulatorIncreased(amount);\r\n        _createDistributionIfReady();\r\n    }\r\n\r\n    function createDistribution() external onlyMinter {\r\n        require(distributionAccumulator > 0, \"DistributionToken: nothing to distribute\");\r\n        _createDistribution();\r\n    }\r\n\r\n    function claimDistributions(address account) external returns(uint256) {\r\n        _createDistributionIfReady();\r\n        uint256 amount = _updateUserBalance(account, distributions.length);\r\n        if (amount > 0) userBalanceChanged(account);\r\n        return amount;\r\n    }\r\n    \r\n    /**\r\n     * @notice Claims distributions and allows to specify how many distributions to process.\r\n     * This allows limit gas usage.\r\n     * One can do this for others\r\n     */\r\n    function claimDistributions(address account, uint256 toDistribution) external returns(uint256) {\r\n        require(toDistribution <= distributions.length, \"DistributionToken: lastDistribution too hight\");\r\n        require(nextDistributions[account] < toDistribution, \"DistributionToken: no distributions to claim\");\r\n        uint256 amount = _updateUserBalance(account, toDistribution);\r\n        if (amount > 0) userBalanceChanged(account);\r\n        return amount;\r\n    }\r\n\r\n    function claimDistributions(address[] calldata accounts) external {\r\n        _createDistributionIfReady();\r\n        for (uint256 i=0; i < accounts.length; i++){\r\n            uint256 amount = _updateUserBalance(accounts[i], distributions.length);\r\n            if (amount > 0) userBalanceChanged(accounts[i]);\r\n        }\r\n    }\r\n\r\n    function claimDistributions(address[] calldata accounts, uint256 toDistribution) external {\r\n        require(toDistribution <= distributions.length, \"DistributionToken: lastDistribution too hight\");\r\n        for (uint256 i=0; i < accounts.length; i++){\r\n            uint256 amount = _updateUserBalance(accounts[i], toDistribution);\r\n            if (amount > 0) userBalanceChanged(accounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Full balance of account includes:\r\n     * - balance of tokens account holds himself (0 for addresses of locking contracts)\r\n     * - balance of tokens locked in contracts\r\n     * - tokens not yet claimed from distributions\r\n     */\r\n    function fullBalanceOf(address account) public view returns(uint256){\r\n        if (account == address(this)) return 0;  //Token itself only holds tokens for others\r\n        uint256 distributionBalance = distributionBalanceOf(account);\r\n        uint256 unclaimed = calculateClaimAmount(account);\r\n        return distributionBalance.add(unclaimed);\r\n    }\r\n\r\n    /**\r\n     * @notice How many tokens are not yet claimed from distributions\r\n     * @param account Account to check\r\n     * @return Amount of tokens available to claim\r\n     */\r\n    function calculateUnclaimedDistributions(address account) public view returns(uint256) {\r\n        return calculateClaimAmount(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates amount of tokens distributed to inital amount between startDistribution and nextDistribution\r\n     * @param fromDistribution index of first Distribution to start calculations\r\n     * @param toDistribution index of distribuition next to the last processed\r\n     * @param initialBalance amount of tokens before startDistribution\r\n     * @return amount of tokens distributed\r\n     */\r\n    function calculateDistributedAmount(uint256 fromDistribution, uint256 toDistribution, uint256 initialBalance) public view returns(uint256) {\r\n        require(fromDistribution < toDistribution, \"DistributionToken: startDistribution is too high\");\r\n        require(toDistribution <= distributions.length, \"DistributionToken: nextDistribution is too high\");\r\n        return _calculateDistributedAmount(fromDistribution, toDistribution, initialBalance);\r\n    }\r\n\r\n    function nextDistribution() public view returns(uint256){\r\n        return distributions.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Balance of account, which is counted for distributions\r\n     * It only represents already distributed balance.\r\n     * @dev This function should be overloaded to include balance of tokens stored in proposals\r\n     */\r\n    function distributionBalanceOf(address account) public view returns(uint256) {\r\n        return balanceOf(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Total supply which is counted for distributions\r\n     * It only represents already distributed tokens\r\n     * @dev This function should be overloaded to exclude tokens locked in loans\r\n     */\r\n    function distributionTotalSupply() public view returns(uint256){\r\n        return totalSupply();\r\n    }\r\n\r\n    // Override functions that change user balance\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        _createDistributionIfReady();\r\n        _updateUserBalance(sender);\r\n        _updateUserBalance(recipient);\r\n        super._transfer(sender, recipient, amount);\r\n        userBalanceChanged(sender);\r\n        userBalanceChanged(recipient);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        _createDistributionIfReady();\r\n        _updateUserBalance(account);\r\n        super._mint(account, amount);\r\n        userBalanceChanged(account);\r\n    }\r\n    \r\n    function _burn(address account, uint256 amount) internal {\r\n        _createDistributionIfReady();\r\n        _updateUserBalance(account);\r\n        super._burn(account, amount);\r\n        userBalanceChanged(account);\r\n    }\r\n\r\n    function _updateUserBalance(address account) internal returns(uint256) {\r\n        return _updateUserBalance(account, distributions.length);\r\n    }\r\n\r\n    function _updateUserBalance(address account, uint256 toDistribution) internal returns(uint256) {\r\n        uint256 fromDistribution = nextDistributions[account];\r\n        if (fromDistribution >= toDistribution) return 0;\r\n        uint256 distributionAmount = calculateClaimAmount(account, toDistribution);\r\n        nextDistributions[account] = toDistribution;\r\n        if (distributionAmount == 0) return 0;\r\n        super._transfer(address(this), account, distributionAmount);\r\n        emit DistributionsClaimed(account, distributionAmount, fromDistribution, toDistribution);\r\n        return distributionAmount;\r\n    }\r\n\r\n    function _createDistributionIfReady() internal {\r\n        if (!isReadyForDistribution()) return;\r\n        _createDistribution();\r\n    }\r\n    \r\n    function _createDistribution() internal {\r\n        uint256 currentTotalSupply = distributionTotalSupply();\r\n        distributions.push(Distribution({\r\n            amount:distributionAccumulator,\r\n            totalSupply: currentTotalSupply\r\n        }));\r\n        super._mint(address(this), distributionAccumulator); //Use super because we overloaded _mint in this contract and need old behaviour\r\n        emit DistributionCreated(distributionAccumulator, currentTotalSupply);\r\n\r\n        // Clear data for next distribution\r\n        distributionAccumulator = 0;\r\n        nextDistributionTimestamp = now.sub(now % DISTRIBUTION_AGGREGATION_PERIOD).add(DISTRIBUTION_AGGREGATION_PERIOD);\r\n    }\r\n\r\n    /**\r\n     * @dev This is a placeholder, which may be overrided to notify other contracts of PTK balance change\r\n     */\r\n    function userBalanceChanged(address /*account*/) internal {\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates amount of account's tokens to be claimed from distributions\r\n     */\r\n    function calculateClaimAmount(address account) internal view returns(uint256) {\r\n        if (nextDistributions[account] >= distributions.length) return 0;\r\n        return calculateClaimAmount(account, distributions.length);\r\n    }\r\n\r\n    function calculateClaimAmount(address account, uint256 toDistribution) internal view returns(uint256) {\r\n        assert(toDistribution <= distributions.length);\r\n        return _calculateDistributedAmount(nextDistributions[account], toDistribution, distributionBalanceOf(account));\r\n    }\r\n\r\n    function _calculateDistributedAmount(uint256 fromDistribution, uint256 toDistribution, uint256 initialBalance) internal view returns(uint256) {\r\n        uint256 next = fromDistribution;\r\n        uint256 balance = initialBalance;\r\n        if (initialBalance == 0) return 0;\r\n        while (next < toDistribution) {\r\n            uint256 da = balance.mul(distributions[next].amount).div(distributions[next].totalSupply);\r\n            balance = balance.add(da);\r\n            next++;\r\n        }\r\n        return balance.sub(initialBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates if conditions for creating new distribution are met\r\n     */\r\n    function isReadyForDistribution() internal view returns(bool) {\r\n        return (distributionAccumulator > 0) && (now >= nextDistributionTimestamp);\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\token\\PoolToken.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PoolToken is Module, ERC20, ERC20Detailed, ERC20Mintable, ERC20Burnable, DistributionToken {\r\n\r\n    bool allowTransfers;\r\n\r\n    function initialize(address _pool, string memory poolName, string memory poolSymbol) public initializer {\r\n        Module.initialize(_pool);\r\n        ERC20Detailed.initialize(poolName, poolSymbol, 18);\r\n        ERC20Mintable.initialize(_msgSender());\r\n    }\r\n\r\n    function setAllowTransfers(bool _allowTransfers) public onlyOwner {\r\n        allowTransfers = _allowTransfers;\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides ERC20Burnable burnFrom to allow unlimited transfers by SavingsModule\r\n     */\r\n    function burnFrom(address from, uint256 value) public {\r\n        if (isMinter(_msgSender())) {\r\n            //Skip decrease allowance\r\n            _burn(from, value);\r\n        }else{\r\n            super.burnFrom(from, value);\r\n        }\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        if( !allowTransfers && \r\n            (sender != address(this)) //transfers from *this* used for distributions\r\n        ){\r\n            revert(\"PoolToken: transfers between users disabled\");\r\n        }\r\n        super._transfer(sender, recipient, amount);\r\n    } \r\n\r\n    function userBalanceChanged(address account) internal {\r\n        IPoolTokenBalanceChangeRecipient rewardDistrModule = IPoolTokenBalanceChangeRecipient(getModuleAddress(MODULE_REWARD_DISTR));\r\n        rewardDistrModule.poolTokenBalanceChanged(account);\r\n    }\r\n\r\n    function distributionBalanceOf(address account) public view returns(uint256) {\r\n        return (account == address(this))?0:super.distributionBalanceOf(account);\r\n    }\r\n\r\n    function distributionTotalSupply() public view returns(uint256) {\r\n        return super.distributionTotalSupply().sub(balanceOf(address(this))); \r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\modules\\savings\\RewardDistributions.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract RewardDistributions is Base, AccessChecker {\r\n    using SafeMath for uint256;\r\n\r\n    struct RewardTokenDistribution {\r\n        address poolToken;                  // PoolToken which holders will receive reward\r\n        uint256 totalShares;                // Total shares of PoolToken participating in this distribution\r\n        address[] rewardTokens;             // List of reward tokens being distributed \r\n        mapping(address=>uint256) amounts; \r\n    }\r\n\r\n    struct UserProtocolRewards {\r\n        mapping(address=>uint256) amounts;  // Maps address of reward token to amount beeing distributed\r\n    }\r\n    struct RewardBalance {\r\n        uint256 nextDistribution;\r\n        mapping(address => uint256) shares;     // Maps PoolToken to amount of user shares participating in distributions\r\n        mapping(address => UserProtocolRewards) rewardsByProtocol; //Maps PoolToken to ProtocolRewards struct (map of reward tokens to their balances);\r\n    }\r\n\r\n    RewardTokenDistribution[] rewardDistributions;\r\n    mapping(address=>RewardBalance) rewardBalances; //Mapping users to their RewardBalance\r\n\r\n    // function registeredPoolTokens() public view returns(address[] memory);\r\n\r\n    // function userRewards(address user, address protocol, address[] calldata rewardTokens) external view returns(uint256[] memory){\r\n    //     uint256[] memory amounts = new uint256[](rewardTokens.length);\r\n    //     RewardBalance storage rb = rewardBalances[user];\r\n    //     require(rb.nextDistribution == rewardDistributions.length, \"RewardDistributions: rewards not calculated\");\r\n    //     for(uint256 i=0; i<amounts.length; i++) {\r\n    //         address rt = rewardTokens[i];\r\n    //         amounts[i] = rb.rewardsByProtocol[protocol].amounts[rt];\r\n    //     }\r\n    //     return amounts;\r\n    // }\r\n\r\n    // function rewardBalanceOf(address user, address poolToken, address rewardToken) public view returns(uint256) {\r\n    //     RewardBalance storage rb = rewardBalances[user];\r\n    //     UserProtocolRewards storage upr = rb.rewardsByProtocol[poolToken];\r\n    //     uint256 balance = upr.amounts[rewardToken];\r\n    //     uint256 next = rb.nextDistribution;\r\n    //     while (next < rewardDistributions.length) {\r\n    //         RewardTokenDistribution storage d = rewardDistributions[next];\r\n    //         next++;\r\n\r\n    //         uint256 sh = rb.shares[d.poolToken];\r\n    //         if (sh == 0 || poolToken != d.poolToken) continue;\r\n    //         uint256 distrAmount = d.amounts[rewardToken];\r\n    //         balance = balance.add(distrAmount.mul(sh).div(d.totalShares));\r\n    //     }\r\n    //     return balance;\r\n    // }\r\n\r\n    function rewardBalanceOf(address user, address poolToken, address[] memory rewardTokens) public view returns(uint256[] memory) {\r\n        RewardBalance storage rb = rewardBalances[user];\r\n        UserProtocolRewards storage upr = rb.rewardsByProtocol[poolToken];\r\n        uint256[] memory balances = new uint256[](rewardTokens.length);\r\n        uint256 i;\r\n        for(i=0; i < rewardTokens.length; i++){\r\n            balances[i] = upr.amounts[rewardTokens[i]];\r\n        }\r\n        uint256 next = rb.nextDistribution;\r\n        while (next < rewardDistributions.length) {\r\n            RewardTokenDistribution storage d = rewardDistributions[next];\r\n            next++;\r\n\r\n            uint256 sh = rb.shares[d.poolToken];\r\n            if (sh == 0 || poolToken != d.poolToken) continue;\r\n            for(i=0; i < rewardTokens.length; i++){\r\n                uint256 distrAmount = d.amounts[rewardTokens[i]];\r\n                balances[i] = balances[i].add(distrAmount.mul(sh).div(d.totalShares));\r\n            }\r\n        }\r\n        return balances;\r\n    }\r\n\r\n\r\n    // /**\r\n    // * @notice Updates user balance\r\n    // * @param user User address \r\n    // */\r\n    // function updateRewardBalance(address user) public {\r\n    //     _updateRewardBalance(user, rewardDistributions.length);\r\n    // }\r\n\r\n    // /**\r\n    // * @notice Updates user balance\r\n    // * @param user User address \r\n    // * @param toDistribution Index of distribution next to the last one, which should be processed\r\n    // */\r\n    // function updateRewardBalance(address user, uint256 toDistribution) public {\r\n    //     _updateRewardBalance(user, toDistribution);\r\n    // }\r\n\r\n    // function _updateRewardBalance(address user, uint256 toDistribution) internal {\r\n    //     require(toDistribution <= rewardDistributions.length, \"RewardDistributions: toDistribution index is too high\");\r\n    //     RewardBalance storage rb = rewardBalances[user];\r\n    //     uint256 next = rb.nextDistribution;\r\n    //     if(next >= toDistribution) return;\r\n\r\n    //     if(next == 0 && rewardDistributions.length > 0){\r\n    //         //This might be a new user, if so we can skip previous distributions\r\n    //         address[] memory poolTokens = registeredPoolTokens();\r\n    //         bool hasDeposit;\r\n    //         for(uint256 i=0; i< poolTokens.length; i++){\r\n    //             address poolToken = poolTokens[i];\r\n    //             if(rb.shares[poolToken] != 0) {\r\n    //                 hasDeposit = true;\r\n    //                 break;\r\n    //             }\r\n    //         }\r\n    //         if(!hasDeposit){\r\n    //             rb.nextDistribution = rewardDistributions.length;\r\n    //             return;\r\n    //         }\r\n    //     }\r\n\r\n    //     while (next < toDistribution) {\r\n    //         RewardTokenDistribution storage d = rewardDistributions[next];\r\n    //         next++;\r\n    //         uint256 sh = rb.shares[d.poolToken];\r\n    //         if (sh == 0) continue;\r\n    //         UserProtocolRewards storage upr = rb.rewardsByProtocol[d.poolToken]; \r\n    //         for (uint256 i=0; i < d.rewardTokens.length; i++) {\r\n    //             address rToken = d.rewardTokens[i];\r\n    //             uint256 distrAmount = d.amounts[rToken];\r\n    //             upr.amounts[rToken] = upr.amounts[rToken].add(distrAmount.mul(sh).div(d.totalShares));\r\n\r\n    //         }\r\n    //     }\r\n    //     rb.nextDistribution = next;\r\n    // }\r\n\r\n}\r\n\r\n// File: contracts\\modules\\savings\\SavingsModule.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SavingsModule is Module, AccessChecker, RewardDistributions, CapperRole {\r\n    uint256 constant MAX_UINT256 = uint256(-1);\r\n\r\n    event ProtocolRegistered(address protocol, address poolToken);\r\n    event YieldDistribution(address indexed poolToken, uint256 amount);\r\n    event DepositToken(address indexed protocol, address indexed token, uint256 dnAmount);\r\n    event Deposit(address indexed protocol, address indexed user, uint256 nAmount, uint256 nFee);\r\n    event WithdrawToken(address indexed protocol, address indexed token, uint256 dnAmount);\r\n    event Withdraw(address indexed protocol, address indexed user, uint256 nAmount, uint256 nFee);\r\n    event UserCapEnabledChange(bool enabled);\r\n    event UserCapChanged(address indexed protocol, address indexed user, uint256 newCap);\r\n    event DefaultUserCapChanged(address indexed protocol, uint256 newCap);\r\n    event ProtocolCapEnabledChange(bool enabled);\r\n    event ProtocolCapChanged(address indexed protocol, uint256 newCap);\r\n    event VipUserEnabledChange(bool enabled);\r\n    event VipUserChanged(address indexed protocol, address indexed user, bool isVip);\r\n\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    struct ProtocolInfo {\r\n        PoolToken poolToken;\r\n        uint256 previousBalance;\r\n        uint256 lastRewardDistribution;\r\n        address[] supportedRewardTokens;\r\n        mapping(address => uint256) userCap; //Limit of pool tokens which can be minted for a user during deposit\r\n        uint256 withdrawAllSlippage;         //Allowed slippage for withdrawAll function in wei\r\n        mapping(address=>bool) isVipUser;       \r\n    }\r\n\r\n    struct TokenData {\r\n        uint8 decimals;\r\n    }\r\n\r\n    address[] registeredTokens;\r\n    IDefiProtocol[] registeredProtocols;\r\n    address[] registeredRewardTokens;\r\n    mapping(address => TokenData) tokens;\r\n    mapping(address => ProtocolInfo) protocols; //Mapping of protocol to data we need to calculate APY and do distributions\r\n    mapping(address => address) poolTokenToProtocol;    //Mapping of pool tokens to protocols\r\n    mapping(address => bool) private rewardTokenRegistered;     //marks registered reward tokens\r\n    bool public userCapEnabled;\r\n    bool public protocolCapEnabled;\r\n    mapping(address=>uint256) public defaultUserCap;\r\n    mapping(address=>uint256) public protocolCap;\r\n    bool public vipUserEnabled;                         // Enable VIP user (overrides protocol cap)\r\n\r\n\r\n    function initialize(address _pool) public initializer {\r\n        Module.initialize(_pool);\r\n        CapperRole.initialize(_msgSender());\r\n    }\r\n\r\n    function setUserCapEnabled(bool _userCapEnabled) public onlyCapper {\r\n        userCapEnabled = _userCapEnabled;\r\n        emit UserCapEnabledChange(userCapEnabled);\r\n    }\r\n\r\n    // function setUserCap(address _protocol, address user, uint256 cap) public onlyCapper {\r\n    //     protocols[_protocol].userCap[user] = cap;\r\n    //     emit UserCapChanged(_protocol, user, cap);\r\n    // }\r\n\r\n    // function setUserCap(address _protocol, address[] calldata users, uint256[] calldata caps) external onlyCapper {\r\n    //     require(users.length == caps.length, \"SavingsModule: arrays length not match\");\r\n    //     for(uint256 i=0;  i < users.length; i++) {\r\n    //         protocols[_protocol].userCap[users[i]] = caps[i];\r\n    //         emit UserCapChanged(_protocol, users[i], caps[i]);\r\n    //     }\r\n    // }\r\n\r\n    function setVipUserEnabled(bool _vipUserEnabled) public onlyCapper {\r\n        vipUserEnabled = _vipUserEnabled;\r\n        emit VipUserEnabledChange(_vipUserEnabled);\r\n    }\r\n\r\n    function setVipUser(address _protocol, address user, bool isVip) public onlyCapper {\r\n        protocols[_protocol].isVipUser[user] = isVip;\r\n        emit VipUserChanged(_protocol, user, isVip);\r\n    }\r\n    \r\n    function setDefaultUserCap(address _protocol, uint256 cap) public onlyCapper {\r\n        defaultUserCap[_protocol] = cap;\r\n        emit DefaultUserCapChanged(_protocol, cap);\r\n    }\r\n\r\n    function setProtocolCapEnabled(bool _protocolCapEnabled) public onlyCapper {\r\n        protocolCapEnabled = _protocolCapEnabled;\r\n        emit ProtocolCapEnabledChange(protocolCapEnabled);\r\n    }\r\n\r\n    function setProtocolCap(address _protocol, uint256 cap) public onlyCapper {\r\n        protocolCap[_protocol] = cap;\r\n        emit ProtocolCapChanged(_protocol, cap);\r\n    }\r\n\r\n    function setWithdrawAllSlippage(address _protocol, uint256 slippageWei) public onlyOwner {\r\n        protocols[_protocol].withdrawAllSlippage = slippageWei;\r\n    }\r\n\r\n    function registerProtocol(IDefiProtocol protocol, PoolToken poolToken) public onlyOwner {\r\n        uint256 i;\r\n        for (i = 0; i < registeredProtocols.length; i++){\r\n            if (address(registeredProtocols[i]) == address(protocol)) revert(\"SavingsModule: protocol already registered\");\r\n        }\r\n        registeredProtocols.push(protocol);\r\n        protocols[address(protocol)] = ProtocolInfo({\r\n            poolToken: poolToken,\r\n            previousBalance: protocol.normalizedBalance(),\r\n            lastRewardDistribution: 0,\r\n            supportedRewardTokens: protocol.supportedRewardTokens(),\r\n            withdrawAllSlippage:0\r\n        });\r\n        for(i=0; i < protocols[address(protocol)].supportedRewardTokens.length; i++) {\r\n            address rtkn = protocols[address(protocol)].supportedRewardTokens[i];\r\n            if(!rewardTokenRegistered[rtkn]){\r\n                rewardTokenRegistered[rtkn] = true;\r\n                registeredRewardTokens.push(rtkn);\r\n            }\r\n        }\r\n        poolTokenToProtocol[address(poolToken)] = address(protocol);\r\n        address[] memory supportedTokens = protocol.supportedTokens();\r\n        for (i = 0; i < supportedTokens.length; i++) {\r\n            address tkn = supportedTokens[i];\r\n            if (!isTokenRegistered(tkn)){\r\n                registeredTokens.push(tkn);\r\n                tokens[tkn].decimals = ERC20Detailed(tkn).decimals();\r\n            }\r\n        }\r\n        uint256 normalizedBalance= protocols[address(protocol)].previousBalance;\r\n        if(normalizedBalance > 0) {\r\n            uint256 ts = poolToken.totalSupply();\r\n            if(ts < normalizedBalance) {\r\n                poolToken.mint(_msgSender(), normalizedBalance.sub(ts));\r\n            }\r\n        }\r\n        emit ProtocolRegistered(address(protocol), address(poolToken));\r\n    }\r\n\r\n    /**\r\n     * @notice Only adding reward tokens is correctly supported now (!!!)\r\n     */\r\n    function updateProtocolRewardTokens(IDefiProtocol protocol) public onlyOwner {\r\n        ProtocolInfo storage pi = protocols[address(protocol)];\r\n        pi.supportedRewardTokens = protocol.supportedRewardTokens();\r\n        for(uint256 i=0; i < pi.supportedRewardTokens.length; i++) {\r\n            address rtkn = pi.supportedRewardTokens[i];\r\n            if(!rewardTokenRegistered[rtkn]){\r\n                rewardTokenRegistered[rtkn] = true;\r\n                registeredRewardTokens.push(rtkn);\r\n            }\r\n        }\r\n        emit ProtocolRegistered(address(protocol), poolTokenByProtocol(address(protocol)));\r\n        //TODO: cleanup registeredRewardTokens if reward tokens removed\r\n    }\r\n\r\n    // function unregisterProtocol(address _protocol) public onlyOwner {\r\n    //     address poolToken = address(protocols[_protocol].poolToken);\r\n    //     delete protocols[_protocol];\r\n    //     delete poolTokenToProtocol[poolToken];\r\n\r\n    //     address[] memory supportedRewardTokens = IDefiProtocol(_protocol).supportedRewardTokens();\r\n    //     for(uint256 i=0; i < supportedRewardTokens.length; i++) {\r\n    //         address rtkn = supportedRewardTokens[i];\r\n    //         //TODO check if this token used by other protocols\r\n\r\n    //         rewardTokenRegistered[rtkn] = false;\r\n    //         // Remove reward token from registered array\r\n    //         for(uint256 j=0; j< registeredRewardTokens.length; j++){\r\n    //             if(registeredRewardTokens[j] == rtkn) {\r\n    //                 if(j != registeredRewardTokens.length-1){\r\n    //                     registeredRewardTokens[j] = registeredRewardTokens[registeredRewardTokens.length-1];\r\n    //                 }\r\n    //                 registeredRewardTokens.pop();\r\n    //             }\r\n    //         }\r\n            \r\n    //     }\r\n    // }\r\n\r\n\r\n    /**\r\n     * @notice Deposit tokens to several protocols\r\n     * @param _protocols Array of protocols to deposit tokens (each protocol only once)\r\n     * @param _tokens Array of tokens to deposit\r\n     * @param _dnAmounts Array of amounts (denormalized to token decimals)\r\n     */\r\n    function deposit(address[] memory _protocols, address[] memory _tokens, uint256[] memory _dnAmounts) \r\n    public operationAllowed(IAccessModule.Operation.Deposit) \r\n    returns(uint256[] memory) \r\n    {\r\n        require(_protocols.length == _tokens.length && _tokens.length == _dnAmounts.length, \"SavingsModule: size of arrays does not match\");\r\n        uint256[] memory ptAmounts = new uint256[](_protocols.length);\r\n        for (uint256 i=0; i < _protocols.length; i++) {\r\n            address[] memory tkns = new address[](1);\r\n            tkns[0] = _tokens[i];\r\n            uint256[] memory amnts = new uint256[](1);\r\n            amnts[0] = _dnAmounts[i];\r\n            ptAmounts[i] = deposit(_protocols[i], tkns, amnts);\r\n        }\r\n        return ptAmounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit tokens to a protocol\r\n     * @param _protocol Protocol to deposit tokens\r\n     * @param _tokens Array of tokens to deposit\r\n     * @param _dnAmounts Array of amounts (denormalized to token decimals)\r\n     */\r\n    function deposit(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts)\r\n    public operationAllowed(IAccessModule.Operation.Deposit)\r\n    returns(uint256) \r\n    {\r\n        //distributeRewardIfRequired(_protocol);\r\n\r\n        uint256 nAmount;\r\n        for (uint256 i=0; i < _tokens.length; i++) {\r\n            nAmount = nAmount.add(normalizeTokenAmount(_tokens[i], _dnAmounts[i]));\r\n        }\r\n\r\n        uint256 nBalanceBefore = distributeYieldInternal(_protocol);\r\n        depositToProtocol(_protocol, _tokens, _dnAmounts);\r\n        uint256 nBalanceAfter = updateProtocolBalance(_protocol);\r\n\r\n        PoolToken poolToken = PoolToken(protocols[_protocol].poolToken);\r\n        uint256 nDeposit = nBalanceAfter.sub(nBalanceBefore);\r\n\r\n        uint256 cap;\r\n        if(userCapEnabled) {\r\n            cap = userCap(_protocol, _msgSender());\r\n        }\r\n\r\n        uint256 fee;\r\n        if(nAmount > nDeposit) {\r\n            fee = nAmount - nDeposit;\r\n            poolToken.mint(_msgSender(), nDeposit);\r\n        } else {\r\n            fee = 0;\r\n            poolToken.mint(_msgSender(), nAmount);\r\n            uint256 yield = nDeposit - nAmount;\r\n            if (yield > 0) {\r\n                //Additional Yield received from protocol (because of lottery, or something)\r\n                createYieldDistribution(poolToken, yield);\r\n            }\r\n        }\r\n\r\n        if(protocolCapEnabled) {\r\n            if( !(vipUserEnabled && protocols[_protocol].isVipUser[_msgSender()]) ) {\r\n                uint256 ptTS = poolToken.totalSupply();\r\n                require(ptTS <= protocolCap[_protocol], \"SavingsModule: deposit exeeds protocols cap\");\r\n            }\r\n        }\r\n\r\n        if(userCapEnabled) {\r\n            //uint256 actualAmount = nAmount.sub(fee); //Had to remove this because of stack too deep err\r\n            require(cap >= nAmount.sub(fee), \"SavingsModule: deposit exeeds user cap\");\r\n            // cap = cap - nAmount.sub(fee);\r\n            //protocols[_protocol].userCap[_msgSender()] = cap;\r\n            // emit UserCapChanged(_protocol, _msgSender(), cap);\r\n        }\r\n\r\n        emit Deposit(_protocol, _msgSender(), nAmount, fee);\r\n        return nDeposit;\r\n    }\r\n\r\n    function depositToProtocol(address _protocol, address[] memory _tokens, uint256[] memory _dnAmounts) internal {\r\n        require(_tokens.length == _dnAmounts.length, \"SavingsModule: count of tokens does not match count of amounts\");\r\n        for (uint256 i=0; i < _tokens.length; i++) {\r\n            address tkn = _tokens[i];\r\n            IERC20(tkn).safeTransferFrom(_msgSender(), _protocol, _dnAmounts[i]);\r\n            IDefiProtocol(_protocol).handleDeposit(tkn, _dnAmounts[i]);\r\n            emit DepositToken(_protocol, tkn, _dnAmounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Withdraw tokens from protocol (all underlying tokens proportiaonally)\r\n     * @param _protocol Protocol to withdraw from\r\n     * @param nAmount Normalized (to 18 decimals) amount to withdraw\r\n     * @return Amount of PoolToken burned from user\r\n     */\r\n    function withdrawAll(address _protocol, uint256 nAmount)\r\n    public operationAllowed(IAccessModule.Operation.Withdraw)\r\n    returns(uint256) \r\n    {\r\n        //distributeRewardIfRequired(_protocol);\r\n\r\n        PoolToken poolToken = PoolToken(protocols[_protocol].poolToken);\r\n\r\n        uint256 nBalanceBefore = distributeYieldInternal(_protocol);\r\n        withdrawFromProtocolProportionally(_msgSender(), IDefiProtocol(_protocol), nAmount, nBalanceBefore);\r\n        uint256 nBalanceAfter = updateProtocolBalance(_protocol);\r\n\r\n        uint256 yield;\r\n        uint256 actualAmount;\r\n        if(nBalanceAfter.add(nAmount) > nBalanceBefore) {\r\n            yield = nBalanceAfter.add(nAmount).sub(nBalanceBefore);\r\n            actualAmount = nAmount;\r\n        }else{\r\n            actualAmount = nBalanceBefore.sub(nBalanceAfter);\r\n            require(actualAmount.sub(nAmount) <= protocols[_protocol].withdrawAllSlippage, \"SavingsModule: withdrawal fee exeeds slippage\");\r\n        }\r\n\r\n        // if(userCapEnabled){\r\n        //     uint256 cap = userCap(_protocol, _msgSender());\r\n        //     cap = cap.add(actualAmount);\r\n        //     protocols[_protocol].userCap[_msgSender()] = cap;\r\n        //     emit UserCapChanged(_protocol, _msgSender(), cap);\r\n        // }\r\n\r\n        poolToken.burnFrom(_msgSender(), actualAmount);\r\n        emit Withdraw(_protocol, _msgSender(), actualAmount, 0);\r\n\r\n        if (yield > 0) {\r\n            //Additional Yield received from protocol (because of lottery, or something)\r\n            createYieldDistribution(poolToken, yield);\r\n        }\r\n\r\n        return actualAmount;\r\n    }\r\n\r\n    /**\r\n     * Withdraw token from protocol\r\n     * @param _protocol Protocol to withdraw from\r\n     * @param token Token to withdraw\r\n     * @param dnAmount Amount to withdraw (denormalized)\r\n     * @param maxNAmount Max amount of PoolToken to burn\r\n     * @return Amount of PoolToken burned from user\r\n     */\r\n    function withdraw(address _protocol, address token, uint256 dnAmount, uint256 maxNAmount)\r\n    public operationAllowed(IAccessModule.Operation.Withdraw)\r\n    returns(uint256){\r\n        //distributeRewardIfRequired(_protocol);\r\n\r\n        uint256 nAmount = normalizeTokenAmount(token, dnAmount);\r\n\r\n        uint256 nBalanceBefore = distributeYieldInternal(_protocol);\r\n        withdrawFromProtocolOne(_msgSender(), IDefiProtocol(_protocol), token, dnAmount);\r\n        uint256 nBalanceAfter = updateProtocolBalance(_protocol);\r\n\r\n        uint256 yield;\r\n        uint256 actualAmount;\r\n        uint256 fee;\r\n        if(nBalanceAfter.add(nAmount) > nBalanceBefore) {\r\n            yield = nBalanceAfter.add(nAmount).sub(nBalanceBefore);\r\n            actualAmount = nAmount;\r\n        }else{\r\n            actualAmount = nBalanceBefore.sub(nBalanceAfter);\r\n            if (actualAmount > nAmount) fee = actualAmount-nAmount;\r\n        }\r\n\r\n        require(maxNAmount == 0 || actualAmount <= maxNAmount, \"SavingsModule: provided maxNAmount is too low\");\r\n\r\n        // if(userCapEnabled){\r\n        //     uint256 cap = userCap(_protocol, _msgSender());\r\n        //     cap = cap.add(actualAmount);\r\n        //     protocols[_protocol].userCap[_msgSender()] = cap;\r\n        //     emit UserCapChanged(_protocol, _msgSender(), cap);\r\n        // }\r\n\r\n        PoolToken poolToken = PoolToken(protocols[_protocol].poolToken);\r\n        poolToken.burnFrom(_msgSender(), actualAmount);\r\n        emit WithdrawToken(_protocol, token, dnAmount);\r\n        emit Withdraw(_protocol, _msgSender(), actualAmount, fee);\r\n\r\n\r\n        if (yield > 0) {\r\n            //Additional Yield received from protocol (because of lottery, or something)\r\n            createYieldDistribution(poolToken, yield);\r\n        }\r\n\r\n        return actualAmount;\r\n    }\r\n\r\n    /** \r\n     * @notice Distributes yield. May be called by bot, if there was no deposits/withdrawals\r\n     */\r\n    function distributeYield() public {\r\n        for(uint256 i=0; i<registeredProtocols.length; i++) {\r\n            distributeYieldInternal(address(registeredProtocols[i]));\r\n        }\r\n    }\r\n\r\n    function userCap(address _protocol, address user) public view returns(uint256) {\r\n        // uint256 cap = protocols[_protocol].userCap[user];\r\n        // if(cap == 0){\r\n        //     uint256 balance = protocols[_protocol].poolToken.balanceOf(user);\r\n        //     if(balance == 0) cap = defaultUserCap[_protocol];\r\n        // }\r\n        uint256 balance = protocols[_protocol].poolToken.balanceOf(user);\r\n        uint256 cap;\r\n        if(balance < defaultUserCap[_protocol]) {\r\n            cap = defaultUserCap[_protocol] - balance;\r\n        }\r\n        return cap;\r\n    }\r\n\r\n    function isVipUser(address _protocol, address user) view public returns(bool){\r\n        return protocols[_protocol].isVipUser[user];\r\n    }\r\n\r\n    function poolTokenByProtocol(address _protocol) public view returns(address) {\r\n        return address(protocols[_protocol].poolToken);\r\n    }\r\n\r\n    function protocolByPoolToken(address _poolToken) public view returns(address) {\r\n        return poolTokenToProtocol[_poolToken];\r\n    }\r\n\r\n    function rewardTokensByProtocol(address _protocol) public view returns(address[] memory) {\r\n        return protocols[_protocol].supportedRewardTokens;\r\n    }\r\n\r\n    function registeredPoolTokens() public view returns(address[] memory poolTokens) {\r\n        poolTokens = new address[](registeredProtocols.length);\r\n        for(uint256 i=0; i<poolTokens.length; i++){\r\n            poolTokens[i] = address(protocols[address(registeredProtocols[i])].poolToken);\r\n        }\r\n    }\r\n\r\n    function supportedProtocols() public view returns(IDefiProtocol[] memory) {\r\n        return registeredProtocols;\r\n    }\r\n\r\n    function supportedRewardTokens() public view returns(address[] memory) {\r\n        return registeredRewardTokens;\r\n    }\r\n\r\n    function withdrawFromProtocolProportionally(address beneficiary, IDefiProtocol protocol, uint256 nAmount, uint256 currentProtocolBalance) internal {\r\n        uint256[] memory balances = protocol.balanceOfAll();\r\n        uint256[] memory amounts = new uint256[](balances.length);\r\n        address[] memory _tokens = protocol.supportedTokens();\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            amounts[i] = balances[i].mul(nAmount).div(currentProtocolBalance);\r\n            emit WithdrawToken(address(protocol), _tokens[i], amounts[i]);\r\n        }\r\n        protocol.withdraw(beneficiary, amounts);\r\n    }\r\n\r\n    function withdrawFromProtocolOne(address beneficiary, IDefiProtocol protocol, address token, uint256 dnAmount) internal {\r\n        protocol.withdraw(beneficiary, token, dnAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates difference from previous action with a protocol and distributes yield\r\n     * @dev MUST call this BEFORE deposit/withdraw from protocol\r\n     * @param _protocol to check\r\n     * @return Current balance of the protocol\r\n     */\r\n    function distributeYieldInternal(address _protocol) internal returns(uint256){\r\n        uint256 currentBalance = IDefiProtocol(_protocol).normalizedBalance();\r\n        ProtocolInfo storage pi = protocols[_protocol];\r\n        PoolToken poolToken = PoolToken(pi.poolToken);\r\n        if(currentBalance > pi.previousBalance) {\r\n            uint256 yield = currentBalance.sub(pi.previousBalance);\r\n            pi.previousBalance = currentBalance;\r\n            createYieldDistribution(poolToken, yield);\r\n        }\r\n        return currentBalance;\r\n    }\r\n\r\n    function createYieldDistribution(PoolToken poolToken, uint256 yield) internal {\r\n        poolToken.distribute(yield);\r\n        emit YieldDistribution(address(poolToken), yield);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates balance with result of deposit/withdraw\r\n     * @dev MUST call this AFTER deposit/withdraw from protocol\r\n     * @param _protocol to update\r\n     * @return Current balance of the protocol\r\n     */\r\n    function updateProtocolBalance(address _protocol) internal returns(uint256){\r\n        uint256 currentBalance = IDefiProtocol(_protocol).normalizedBalance();\r\n        protocols[_protocol].previousBalance = currentBalance;\r\n        return currentBalance;\r\n    }\r\n\r\n    function isTokenRegistered(address token) private view returns(bool) {\r\n        for (uint256 i = 0; i < registeredTokens.length; i++){\r\n            if (registeredTokens[i] == token) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isPoolToken(address token) internal view returns(bool) {\r\n        for (uint256 i = 0; i < registeredProtocols.length; i++){\r\n            IDefiProtocol protocol = registeredProtocols[i];\r\n            if (address(protocols[address(protocol)].poolToken) == token) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function normalizeTokenAmount(address token, uint256 amount) private view returns(uint256) {\r\n        uint256 decimals = tokens[token].decimals;\r\n        if (decimals == 18) {\r\n            return amount;\r\n        } else if (decimals > 18) {\r\n            return amount.div(10**(decimals-18));\r\n        } else if (decimals < 18) {\r\n            return amount.mul(10**(18 - decimals));\r\n        }\r\n    }\r\n\r\n    function denormalizeTokenAmount(address token, uint256 amount) private view returns(uint256) {\r\n        uint256 decimals = tokens[token].decimals;\r\n        if (decimals == 18) {\r\n            return amount;\r\n        } else if (decimals > 18) {\r\n            return amount.mul(10**(decimals-18));\r\n        } else if (decimals < 18) {\r\n            return amount.div(10**(18 - decimals));\r\n        }\r\n    }\r\n\r\n}"}
{"address": "0x876b9ebd725d1fa0b879fcee12560a6453b51dc8", "attacktype": "Visibility errors, including unrestricted action", "sourcecode": "/*\r\n\r\n Copyright 2017-2018 RigoBlock, Rigo Investment Sagl.\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.25;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface Authority {\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n    event AuthoritySet(address indexed authority);\r\n    event WhitelisterSet(address indexed whitelister);\r\n    event WhitelistedUser(address indexed target, bool approved);\r\n    event WhitelistedRegistry(address indexed registry, bool approved);\r\n    event WhitelistedFactory(address indexed factory, bool approved);\r\n    event WhitelistedVault(address indexed vault, bool approved);\r\n    event WhitelistedDrago(address indexed drago, bool isWhitelisted);\r\n    event NewDragoEventful(address indexed dragoEventful);\r\n    event NewVaultEventful(address indexed vaultEventful);\r\n    event NewNavVerifier(address indexed navVerifier);\r\n    event NewExchangesAuthority(address indexed exchangesAuthority);\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    function setAuthority(address _authority, bool _isWhitelisted) external;\r\n    function setWhitelister(address _whitelister, bool _isWhitelisted) external;\r\n    function whitelistUser(address _target, bool _isWhitelisted) external;\r\n    function whitelistDrago(address _drago, bool _isWhitelisted) external;\r\n    function whitelistVault(address _vault, bool _isWhitelisted) external;\r\n    function whitelistRegistry(address _registry, bool _isWhitelisted) external;\r\n    function whitelistFactory(address _factory, bool _isWhitelisted) external;\r\n    function setDragoEventful(address _dragoEventful) external;\r\n    function setVaultEventful(address _vaultEventful) external;\r\n    function setNavVerifier(address _navVerifier) external;\r\n    function setExchangesAuthority(address _exchangesAuthority) external;\r\n\r\n    /*\r\n     * CONSTANT PUBLIC FUNCTIONS\r\n     */\r\n    function isWhitelistedUser(address _target) external view returns (bool);\r\n    function isAuthority(address _authority) external view returns (bool);\r\n    function isWhitelistedRegistry(address _registry) external view returns (bool);\r\n    function isWhitelistedDrago(address _drago) external view returns (bool);\r\n    function isWhitelistedVault(address _vault) external view returns (bool);\r\n    function isWhitelistedFactory(address _factory) external view returns (bool);\r\n    function getDragoEventful() external view returns (address);\r\n    function getVaultEventful() external view returns (address);\r\n    function getNavVerifier() external view returns (address);\r\n    function getExchangesAuthority() external view returns (address);\r\n}\r\n\r\ninterface ExchangesAuthority {\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n    event AuthoritySet(address indexed authority);\r\n    event WhitelisterSet(address indexed whitelister);\r\n    event WhitelistedAsset(address indexed asset, bool approved);\r\n    event WhitelistedExchange(address indexed exchange, bool approved);\r\n    event WhitelistedWrapper(address indexed wrapper, bool approved);\r\n    event WhitelistedProxy(address indexed proxy, bool approved);\r\n    event WhitelistedMethod(bytes4 indexed method, address indexed exchange, bool approved);\r\n    event NewSigVerifier(address indexed sigVerifier);\r\n    event NewExchangeEventful(address indexed exchangeEventful);\r\n    event NewCasper(address indexed casper);\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    /// @dev Allows the owner to whitelist an authority\r\n    /// @param _authority Address of the authority\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function setAuthority(address _authority, bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows the owner to whitelist a whitelister\r\n    /// @param _whitelister Address of the whitelister\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function setWhitelister(address _whitelister, bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows a whitelister to whitelist an asset\r\n    /// @param _asset Address of the token\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function whitelistAsset(address _asset, bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows a whitelister to whitelist an exchange\r\n    /// @param _exchange Address of the target exchange\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function whitelistExchange(address _exchange, bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows a whitelister to whitelist an token wrapper\r\n    /// @param _wrapper Address of the target token wrapper\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function whitelistWrapper(address _wrapper, bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows a whitelister to whitelist a tokenTransferProxy\r\n    /// @param _tokenTransferProxy Address of the proxy\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function whitelistTokenTransferProxy(\r\n        address _tokenTransferProxy, bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows a whitelister to enable trading on a particular exchange\r\n    /// @param _asset Address of the token\r\n    /// @param _exchange Address of the exchange\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function whitelistAssetOnExchange(\r\n        address _asset,\r\n        address _exchange,\r\n        bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows a whitelister to enable assiciate wrappers to a token\r\n    /// @param _token Address of the token\r\n    /// @param _wrapper Address of the exchange\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function whitelistTokenOnWrapper(\r\n        address _token,\r\n        address _wrapper,\r\n        bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows an admin to whitelist a factory\r\n    /// @param _method Hex of the function ABI\r\n    /// @param _isWhitelisted Bool whitelisted\r\n    function whitelistMethod(\r\n        bytes4 _method,\r\n        address _adapter,\r\n        bool _isWhitelisted)\r\n        external;\r\n\r\n    /// @dev Allows the owner to set the signature verifier\r\n    /// @param _sigVerifier Address of the logs contract\r\n    function setSignatureVerifier(address _sigVerifier)\r\n        external;\r\n\r\n    /// @dev Allows the owner to set the exchange eventful\r\n    /// @param _exchangeEventful Address of the exchange logs contract\r\n    function setExchangeEventful(address _exchangeEventful)\r\n        external;\r\n\r\n    /// @dev Allows the owner to associate an exchange to its adapter\r\n    /// @param _exchange Address of the exchange\r\n    /// @param _adapter Address of the adapter\r\n    function setExchangeAdapter(address _exchange, address _adapter)\r\n        external;\r\n\r\n    /// @dev Allows the owner to set the casper contract\r\n    /// @param _casper Address of the casper contract\r\n    function setCasper(address _casper)\r\n        external;\r\n\r\n    /*\r\n     * CONSTANT PUBLIC FUNCTIONS\r\n     */\r\n    /// @dev Provides whether an address is an authority\r\n    /// @param _authority Address of the target authority\r\n    /// @return Bool is whitelisted\r\n    function isAuthority(address _authority)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Provides whether an asset is whitelisted\r\n    /// @param _asset Address of the target asset\r\n    /// @return Bool is whitelisted\r\n    function isWhitelistedAsset(address _asset)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Provides whether an exchange is whitelisted\r\n    /// @param _exchange Address of the target exchange\r\n    /// @return Bool is whitelisted\r\n    function isWhitelistedExchange(address _exchange)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Provides whether a token wrapper is whitelisted\r\n    /// @param _wrapper Address of the target exchange\r\n    /// @return Bool is whitelisted\r\n    function isWhitelistedWrapper(address _wrapper)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Provides whether a proxy is whitelisted\r\n    /// @param _tokenTransferProxy Address of the proxy\r\n    /// @return Bool is whitelisted\r\n    function isWhitelistedProxy(address _tokenTransferProxy)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Provides the address of the exchange adapter\r\n    /// @param _exchange Address of the exchange\r\n    /// @return Address of the adapter\r\n    function getExchangeAdapter(address _exchange)\r\n        external view\r\n        returns (address);\r\n\r\n    /// @dev Provides the address of the signature verifier\r\n    /// @return Address of the verifier\r\n    function getSigVerifier()\r\n        external view\r\n        returns (address);\r\n\r\n    /// @dev Checkes whether a token is allowed on an exchange\r\n    /// @param _token Address of the token\r\n    /// @param _exchange Address of the exchange\r\n    /// @return Bool the token is whitelisted on the exchange\r\n    function canTradeTokenOnExchange(address _token, address _exchange)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Checkes whether a token is allowed on a wrapper\r\n    /// @param _token Address of the token\r\n    /// @return Bool the token is whitelisted on the exchange\r\n    function canWrapTokenOnWrapper(address _token, address _wrapper)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Checkes whether a method is allowed on an exchange\r\n    function isMethodAllowed(bytes4 _method, address _exchange)\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Checkes whether casper has been inizialized\r\n    /// @return Bool the casper contract has been initialized\r\n    function isCasperInitialized()\r\n        external view\r\n        returns (bool);\r\n\r\n    /// @dev Provides the address of the casper contract\r\n    /// @return Address of the casper contract\r\n    function getCasper()\r\n        external view\r\n        returns (address);\r\n}\r\n\r\ninterface SigVerifier {\r\n\r\n    /// @dev Verifies that a signature is valid.\r\n    /// @param hash Message hash that is signed.\r\n    /// @param signature Proof of signing.\r\n    /// @return Validity of order signature.\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        bytes signature\r\n    )\r\n        external\r\n        view\r\n        returns (bool isValid);\r\n}\r\n\r\ninterface NavVerifier {\r\n\r\n    /// @dev Verifies that a signature is valid.\r\n    /// @param sellPrice Price in wei\r\n    /// @param buyPrice Price in wei\r\n    /// @param signaturevaliduntilBlock Number of blocks till price expiry\r\n    /// @param hash Message hash that is signed.\r\n    /// @param signedData Proof of nav validity.\r\n    /// @notice mock function which returns true\r\n    function isValidNav(\r\n        uint256 sellPrice,\r\n        uint256 buyPrice,\r\n        uint256 signaturevaliduntilBlock,\r\n        bytes32 hash,\r\n        bytes signedData)\r\n        external\r\n        view\r\n        returns (bool isValid);\r\n}\r\n\r\ninterface Kyc\r\n\r\n{\r\n    function isWhitelistedUser(address hodler) external view returns (bool);\r\n}\r\n\r\ninterface DragoEventful {\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n    event BuyDrago(address indexed drago, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\r\n    event SellDrago(address indexed drago, address indexed from, address indexed to, uint256 amount, uint256 revenue, bytes name, bytes symbol);\r\n    event NewRatio(address indexed drago, address indexed from, uint256 newRatio);\r\n    event NewNAV(address indexed drago, address indexed from, address indexed to, uint256 sellPrice, uint256 buyPrice);\r\n    event NewFee(address indexed drago, address indexed group, address indexed who, uint256 transactionFee);\r\n    event NewCollector( address indexed drago, address indexed group, address indexed who, address feeCollector);\r\n    event DragoDao(address indexed drago, address indexed from, address indexed to, address dragoDao);\r\n    event DepositExchange(address indexed drago, address indexed exchange, address indexed token, uint256 value, uint256 amount);\r\n    event WithdrawExchange(address indexed drago, address indexed exchange, address indexed token, uint256 value, uint256 amount);\r\n    event OrderExchange(address indexed drago, address indexed exchange, address indexed cfd, uint256 value, uint256 revenue);\r\n    event TradeExchange(address indexed drago, address indexed exchange, address tokenGet, address tokenGive, uint256 amountGet, uint256 amountGive, address get);\r\n    event CancelOrder(address indexed drago, address indexed exchange, address indexed cfd, uint256 value, uint256 id);\r\n    event DealFinalized(address indexed drago, address indexed exchange, address indexed cfd, uint256 value, uint256 id);\r\n    event CustomDragoLog(bytes4 indexed methodHash, bytes encodedParams);\r\n    event CustomDragoLog2(bytes4 indexed methodHash,  bytes32 topic2, bytes32 topic3, bytes encodedParams);\r\n    event DragoCreated(address indexed drago, address indexed group, address indexed owner, uint256 dragoId, string name, string symbol);\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    function buyDrago(address _who, address _targetDrago, uint256 _value, uint256 _amount, bytes _name, bytes _symbol) external returns (bool success);\r\n    function sellDrago(address _who, address _targetDrago, uint256 _amount, uint256 _revenue, bytes _name, bytes _symbol) external returns(bool success);\r\n    function changeRatio(address _who, address _targetDrago, uint256 _ratio) external returns(bool success);\r\n    function changeFeeCollector(address _who, address _targetDrago, address _feeCollector) external returns(bool success);\r\n    function changeDragoDao(address _who, address _targetDrago, address _dragoDao) external returns(bool success);\r\n    function setDragoPrice(address _who, address _targetDrago, uint256 _sellPrice, uint256 _buyPrice) external returns(bool success);\r\n    function setTransactionFee(address _who, address _targetDrago, uint256 _transactionFee) external returns(bool success);\r\n    function depositToExchange(address _who, address _targetDrago, address _exchange, address _token, uint256 _value) external returns(bool success);\r\n    function withdrawFromExchange(address _who, address _targetDrago, address _exchange, address _token, uint256 _value) external returns(bool success);\r\n    function customDragoLog(bytes4 _methodHash, bytes _encodedParams) external returns (bool success);\r\n    function customDragoLog2(bytes4 _methodHash, bytes32 topic2, bytes32 topic3, bytes _encodedParams) external returns (bool success);\r\n    function customExchangeLog(bytes4 _methodHash, bytes _encodedParams) external returns (bool success);\r\n    function customExchangeLog2(bytes4 _methodHash, bytes32 topic2, bytes32 topic3,bytes _encodedParams) external returns (bool success);\r\n    function createDrago(address _who, address _newDrago, string _name, string _symbol, uint256 _dragoId) external returns(bool success);\r\n}\r\n\r\ninterface Token {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n\r\n    // Locked state of mutex\r\n    bool private locked = false;\r\n\r\n    /// @dev Functions with this modifer cannot be reentered. The mutex will be locked\r\n    ///      before function execution and unlocked after.\r\n    modifier nonReentrant() {\r\n        // Ensure mutex is unlocked\r\n        require(\r\n            !locked,\r\n            \"REENTRANCY_ILLEGAL\"\r\n        );\r\n\r\n        // Lock mutex before function call\r\n        locked = true;\r\n\r\n        // Perform function call\r\n        _;\r\n\r\n        // Unlock mutex after function call\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    event NewOwner(address indexed old, address indexed current);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _new) public onlyOwner {\r\n        require(_new != address(0));\r\n        owner = _new;\r\n        emit  NewOwner(owner, _new);\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary LibFindMethod {\r\n\r\n    /// @dev Returns the method of an ABIencoded call\r\n    /// @param assembledData Bytes of the call data\r\n    /// @return Bytes4 of the function signature\r\n    function findMethod(bytes assembledData)\r\n        internal\r\n        pure\r\n        returns (bytes4 method)\r\n    {\r\n        // find the bytes4(keccak256('functionABI')) of the function\r\n        assembly {\r\n            // Load free memory pointer\r\n            method := mload(0x00)\r\n            let transaction := assembledData\r\n            method := mload(add(transaction, 0x20))\r\n        }\r\n        return method;\r\n    }\r\n}\r\n\r\n/// @title Drago - A set of rules for a drago.\r\n/// @author Gabriele Rigo - <gab@rigoblock.com>\r\n// solhint-disable-next-line\r\ncontract Drago is Owned, SafeMath, ReentrancyGuard {\r\n\r\n    using LibFindMethod for *;\r\n\r\n    string constant VERSION = 'HF 0.5.2';\r\n    uint256 constant BASE = 1000000; // tokens are divisible by 1 million\r\n\r\n    mapping (address => Account) accounts;\r\n\r\n    DragoData data;\r\n    Admin admin;\r\n\r\n    struct Receipt {\r\n        uint256 units;\r\n        uint32 activation;\r\n    }\r\n\r\n    struct Account {\r\n        uint256 balance;\r\n        Receipt receipt;\r\n        mapping(address => address[]) approvedAccount;\r\n    }\r\n\r\n    struct Transaction {\r\n        bytes assembledData;\r\n    }\r\n\r\n    struct DragoData {\r\n        string name;\r\n        string symbol;\r\n        uint256 dragoId;\r\n        uint256 totalSupply;\r\n        uint256 sellPrice;\r\n        uint256 buyPrice;\r\n        uint256 transactionFee; // in basis points 1 = 0.01%\r\n        uint32 minPeriod;\r\n    }\r\n\r\n    struct Admin {\r\n        address authority;\r\n        address dragoDao;\r\n        address feeCollector;\r\n        address kycProvider;\r\n        bool kycEnforced;\r\n        uint256 minOrder; // minimum stake to avoid dust clogging things up\r\n        uint256 ratio; // ratio is 80%\r\n    }\r\n\r\n    modifier onlyDragoDao() {\r\n        require(msg.sender == admin.dragoDao);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrAuthority() {\r\n        Authority auth = Authority(admin.authority);\r\n        require(auth.isAuthority(msg.sender) || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier whenApprovedExchangeOrWrapper(address _target) {\r\n        bool approvedExchange = ExchangesAuthority(getExchangesAuthority())\r\n            .isWhitelistedExchange(_target);\r\n        bool approvedWrapper = ExchangesAuthority(getExchangesAuthority())\r\n            .isWhitelistedWrapper(_target);\r\n        require(approvedWrapper || approvedExchange);\r\n        _;\r\n    }\r\n\r\n    modifier whenApprovedProxy(address _proxy) {\r\n        bool approved = ExchangesAuthority(getExchangesAuthority())\r\n            .isWhitelistedProxy(_proxy);\r\n        require(approved);\r\n        _;\r\n    }\r\n\r\n    modifier minimumStake(uint256 amount) {\r\n        require (amount >= admin.minOrder);\r\n        _;\r\n    }\r\n\r\n    modifier hasEnough(uint256 _amount) {\r\n        require(accounts[msg.sender].balance >= _amount);\r\n        _;\r\n    }\r\n\r\n    modifier positiveAmount(uint256 _amount) {\r\n        require(accounts[msg.sender].balance + _amount > accounts[msg.sender].balance);\r\n        _;\r\n    }\r\n\r\n    modifier minimumPeriodPast() {\r\n        require(block.timestamp >= accounts[msg.sender].receipt.activation);\r\n        _;\r\n    }\r\n\r\n    modifier buyPriceHigherOrEqual(uint256 _sellPrice, uint256 _buyPrice) {\r\n        require(_sellPrice <= _buyPrice);\r\n        _;\r\n    }\r\n\r\n    modifier notPriceError(uint256 _sellPrice, uint256 _buyPrice) {\r\n        if (_sellPrice <= data.sellPrice / 10 || _buyPrice >= data.buyPrice * 10) return;\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string _dragoName,\r\n        string _dragoSymbol,\r\n        uint256 _dragoId,\r\n        address _owner,\r\n        address _authority)\r\n        public\r\n    {\r\n        data.name = _dragoName;\r\n        data.symbol = _dragoSymbol;\r\n        data.dragoId = _dragoId;\r\n        data.sellPrice = 1 ether;\r\n        data.buyPrice = 1 ether;\r\n        owner = _owner;\r\n        admin.authority = _authority;\r\n        admin.dragoDao = msg.sender;\r\n        admin.minOrder = 1 finney;\r\n        admin.feeCollector = _owner;\r\n        admin.ratio = 80;\r\n    }\r\n\r\n    /*\r\n     * CORE FUNCTIONS\r\n     */\r\n    /// @dev Allows Ether to be received.\r\n    /// @notice Used for settlements and withdrawals.\r\n    function()\r\n        external\r\n        payable\r\n    {\r\n        require(msg.value != 0);\r\n    }\r\n\r\n    /// @dev Allows a user to buy into a drago.\r\n    /// @return Bool the function executed correctly.\r\n    function buyDrago()\r\n        external\r\n        payable\r\n        minimumStake(msg.value)\r\n        returns (bool success)\r\n    {\r\n        require(buyDragoInternal(msg.sender));\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows a user to buy into a drago on behalf of an address.\r\n    /// @param _hodler Address of the target user.\r\n    /// @return Bool the function executed correctly.\r\n    function buyDragoOnBehalf(address _hodler)\r\n        external\r\n        payable\r\n        minimumStake(msg.value)\r\n        returns (bool success)\r\n    {\r\n        require(buyDragoInternal(_hodler));\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows a user to sell from a drago.\r\n    /// @param _amount Number of shares to sell.\r\n    /// @return Bool the function executed correctly.\r\n    function sellDrago(uint256 _amount)\r\n        external\r\n        nonReentrant\r\n        hasEnough(_amount)\r\n        positiveAmount(_amount)\r\n        minimumPeriodPast\r\n        returns (bool success)\r\n    {\r\n        uint256 feeDrago;\r\n        uint256 feeDragoDao;\r\n        uint256 netAmount;\r\n        uint256 netRevenue;\r\n        (feeDrago, feeDragoDao, netAmount, netRevenue) = getSaleAmounts(_amount);\r\n        addSaleLog(_amount, netRevenue);\r\n        allocateSaleTokens(msg.sender, _amount, feeDrago, feeDragoDao);\r\n        data.totalSupply = safeSub(data.totalSupply, netAmount);\r\n        msg.sender.transfer(netRevenue);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows drago owner or authority to set the price for a drago.\r\n    /// @param _newSellPrice Price in wei.\r\n    /// @param _newBuyPrice Price in wei.\r\n    /// @param _signaturevaliduntilBlock Number of blocks till expiry of new data.\r\n    /// @param _hash Bytes32 of the transaction hash.\r\n    /// @param _signedData Bytes of extradata and signature.\r\n    function setPrices(\r\n        uint256 _newSellPrice,\r\n        uint256 _newBuyPrice,\r\n        uint256 _signaturevaliduntilBlock,\r\n        bytes32 _hash,\r\n        bytes _signedData)\r\n        external\r\n        nonReentrant\r\n        onlyOwnerOrAuthority\r\n        buyPriceHigherOrEqual(_newSellPrice, _newBuyPrice)\r\n        notPriceError(_newSellPrice, _newBuyPrice)\r\n    {\r\n        require(\r\n            isValidNav(\r\n                _newSellPrice,\r\n                _newBuyPrice,\r\n                _signaturevaliduntilBlock,\r\n                _hash,\r\n                _signedData\r\n            )\r\n        );\r\n        DragoEventful events = DragoEventful(getDragoEventful());\r\n        require(events.setDragoPrice(msg.sender, this, _newSellPrice, _newBuyPrice));\r\n        data.sellPrice = _newSellPrice;\r\n        data.buyPrice = _newBuyPrice;\r\n    }\r\n\r\n    /// @dev Allows drago dao/factory to change fee split ratio.\r\n    /// @param _ratio Number of ratio for wizard, from 0 to 100.\r\n    function changeRatio(uint256 _ratio)\r\n        external\r\n        onlyDragoDao\r\n    {\r\n        DragoEventful events = DragoEventful(getDragoEventful());\r\n        require(events.changeRatio(msg.sender, this, _ratio));\r\n        admin.ratio = _ratio;\r\n    }\r\n\r\n    /// @dev Allows drago owner to set the transaction fee.\r\n    /// @param _transactionFee Value of the transaction fee in basis points.\r\n    function setTransactionFee(uint256 _transactionFee)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_transactionFee <= 100); //fee cannot be higher than 1%\r\n        DragoEventful events = DragoEventful(getDragoEventful());\r\n        require(events.setTransactionFee(msg.sender, this, _transactionFee));\r\n        data.transactionFee = _transactionFee;\r\n    }\r\n\r\n    /// @dev Allows owner to decide where to receive the fee.\r\n    /// @param _feeCollector Address of the fee receiver.\r\n    function changeFeeCollector(address _feeCollector)\r\n        external\r\n        onlyOwner\r\n    {\r\n        DragoEventful events = DragoEventful(getDragoEventful());\r\n        events.changeFeeCollector(msg.sender, this, _feeCollector);\r\n        admin.feeCollector = _feeCollector;\r\n    }\r\n\r\n    /// @dev Allows drago dao/factory to upgrade its address.\r\n    /// @param _dragoDao Address of the new drago dao.\r\n    function changeDragoDao(address _dragoDao)\r\n        external\r\n        onlyDragoDao\r\n    {\r\n        DragoEventful events = DragoEventful(getDragoEventful());\r\n        require(events.changeDragoDao(msg.sender, this, _dragoDao));\r\n        admin.dragoDao = _dragoDao;\r\n    }\r\n\r\n    /// @dev Allows drago dao/factory to change the minimum holding period.\r\n    /// @param _minPeriod Time in seconds.\r\n    function changeMinPeriod(uint32 _minPeriod)\r\n        external\r\n        onlyDragoDao\r\n    {\r\n        data.minPeriod = _minPeriod;\r\n    }\r\n\r\n    function enforceKyc(\r\n        bool _enforced,\r\n        address _kycProvider)\r\n        external\r\n        onlyOwner\r\n    {\r\n        admin.kycEnforced = _enforced;\r\n        admin.kycProvider = _kycProvider;\r\n    }\r\n\r\n    /// @dev Allows owner to set an allowance to an approved token transfer proxy.\r\n    /// @param _tokenTransferProxy Address of the proxy to be approved.\r\n    /// @param _token Address of the token to receive allowance for.\r\n    /// @param _amount Number of tokens approved for spending.\r\n    function setAllowance(\r\n        address _tokenTransferProxy,\r\n        address _token,\r\n        uint256 _amount)\r\n        external\r\n        onlyOwner\r\n        whenApprovedProxy(_tokenTransferProxy)\r\n    {\r\n        require(setAllowancesInternal(_tokenTransferProxy, _token, _amount));\r\n    }\r\n\r\n    /// @dev Allows owner to set allowances to multiple approved tokens with one call.\r\n    /// @param _tokenTransferProxy Address of the proxy to be approved.\r\n    /// @param _tokens Address of the token to receive allowance for.\r\n    /// @param _amounts Array of number of tokens to be approved.\r\n    function setMultipleAllowances(\r\n        address _tokenTransferProxy,\r\n        address[] _tokens,\r\n        uint256[] _amounts)\r\n        external\r\n    {\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            if (!setAllowancesInternal(_tokenTransferProxy, _tokens[i], _amounts[i])) continue;\r\n        }\r\n    }\r\n\r\n    /// @dev Allows owner to operate on exchange through extension.\r\n    /// @param _exchange Address of the target exchange.\r\n    /// @param transaction ABIencoded transaction.\r\n    function operateOnExchange(\r\n        address _exchange,\r\n        Transaction memory transaction)\r\n        public\r\n        onlyOwner\r\n        nonReentrant\r\n        whenApprovedExchangeOrWrapper(_exchange)\r\n        returns (bool success)\r\n    {\r\n        address adapter = getExchangeAdapter(_exchange);\r\n        bytes memory transactionData = transaction.assembledData;\r\n        require(\r\n            methodAllowedOnExchange(\r\n                findMethod(transactionData),\r\n                adapter\r\n            )\r\n        );\r\n\r\n        bytes memory response;\r\n        bool failed = true;\r\n\r\n        assembly {\r\n\r\n            let succeeded := delegatecall(\r\n                sub(gas, 5000),\r\n                adapter,\r\n                add(transactionData, 0x20),\r\n                mload(transactionData),\r\n                0,\r\n                32) // 0x0\r\n\r\n            // load delegatecall output\r\n            response := mload(0)\r\n            failed := iszero(succeeded)\r\n\r\n            switch failed\r\n            case 1 {\r\n                // throw if delegatecall failed\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        return (success = true);\r\n    }\r\n\r\n    /// @dev Allows owner or approved exchange to send a transaction to exchange\r\n    /// @dev With data of signed/unsigned transaction\r\n    /// @param _exchange Address of the exchange\r\n    /// @param transactions Array of ABI encoded transactions\r\n    function batchOperateOnExchange(\r\n        address _exchange,\r\n        Transaction[] memory transactions)\r\n        public\r\n        onlyOwner\r\n        nonReentrant\r\n        whenApprovedExchangeOrWrapper(_exchange)\r\n    {\r\n        for (uint256 i = 0; i < transactions.length; i++) {\r\n            if (!operateOnExchange(_exchange, transactions[i])) continue;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * CONSTANT PUBLIC FUNCTIONS\r\n     */\r\n    /// @dev Calculates how many shares a user holds.\r\n    /// @param _who Address of the target account.\r\n    /// @return Number of shares.\r\n    function balanceOf(address _who)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return accounts[_who].balance;\r\n    }\r\n\r\n    /// @dev Gets the address of the logger contract.\r\n    /// @return Address of the logger contrac.\r\n    function getEventful()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        Authority auth = Authority(admin.authority);\r\n        return auth.getDragoEventful();\r\n    }\r\n\r\n    /// @dev Finds details of a drago pool.\r\n    /// @return String name of a drago.\r\n    /// @return String symbol of a drago.\r\n    /// @return Value of the share price in wei.\r\n    /// @return Value of the share price in wei.\r\n    function getData()\r\n        external\r\n        view\r\n        returns (\r\n            string name,\r\n            string symbol,\r\n            uint256 sellPrice,\r\n            uint256 buyPrice\r\n        )\r\n    {\r\n        name = data.name;\r\n        symbol = data.symbol;\r\n        sellPrice = data.sellPrice;\r\n        buyPrice = data.buyPrice;\r\n    }\r\n\r\n    /// @dev Returns the price of a pool.\r\n    /// @return Value of the share price in wei.\r\n    function calcSharePrice()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return data.sellPrice;\r\n    }\r\n\r\n    /// @dev Finds the administrative data of the pool.\r\n    /// @return Address of the account where a user collects fees.\r\n    /// @return Address of the drago dao/factory.\r\n    /// @return Number of the fee split ratio.\r\n    /// @return Value of the transaction fee in basis points.\r\n    /// @return Number of the minimum holding period for shares.\r\n    function getAdminData()\r\n        external\r\n        view\r\n        returns (\r\n            address, //owner\r\n            address feeCollector,\r\n            address dragoDao,\r\n            uint256 ratio,\r\n            uint256 transactionFee,\r\n            uint32 minPeriod\r\n        )\r\n    {\r\n        return (\r\n            owner,\r\n            admin.feeCollector,\r\n            admin.dragoDao,\r\n            admin.ratio,\r\n            data.transactionFee,\r\n            data.minPeriod\r\n        );\r\n    }\r\n\r\n    function getKycProvider()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        if(admin.kycEnforced) {\r\n            return admin.kycProvider;\r\n        }\r\n    }\r\n\r\n    /// @dev Verifies that a signature is valid.\r\n    /// @param hash Message hash that is signed.\r\n    /// @param signature Proof of signing.\r\n    /// @return Validity of order signature.\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        bytes signature\r\n    )\r\n        external\r\n        view\r\n        returns (bool isValid)\r\n    {\r\n        isValid = SigVerifier(getSigVerifier())\r\n            .isValidSignature(hash, signature);\r\n        return isValid;\r\n    }\r\n\r\n    /// @dev Finds the exchanges authority.\r\n    /// @return Address of the exchanges authority.\r\n    function getExchangesAuth()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return getExchangesAuthority();\r\n    }\r\n\r\n    /// @dev Returns the total amount of issued tokens for this drago.\r\n    /// @return Number of shares.\r\n    function totalSupply()\r\n        external view\r\n        returns (uint256)\r\n    {\r\n        return data.totalSupply;\r\n    }\r\n\r\n    /*\r\n     * INTERNAL FUNCTIONS\r\n     */\r\n\r\n    /// @dev Executes the pool purchase.\r\n    /// @param _hodler Address of the target user.\r\n    /// @return Bool the function executed correctly.\r\n    function buyDragoInternal(address _hodler)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (admin.kycProvider != 0x0) {\r\n            require(Kyc(admin.kycProvider).isWhitelistedUser(_hodler));\r\n        }\r\n        uint256 grossAmount;\r\n        uint256 feeDrago;\r\n        uint256 feeDragoDao;\r\n        uint256 amount;\r\n        (grossAmount, feeDrago, feeDragoDao, amount) = getPurchaseAmounts();\r\n        addPurchaseLog(amount);\r\n        allocatePurchaseTokens(_hodler, amount, feeDrago, feeDragoDao);\r\n        data.totalSupply = safeAdd(data.totalSupply, grossAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allocates tokens to buyer, splits fee in tokens to wizard and dao.\r\n    /// @param _hodler Address of the buyer.\r\n    /// @param _amount Value of issued tokens.\r\n    /// @param _feeDrago Number of shares as fee.\r\n    /// @param _feeDragoDao Number of shares as fee to dao.\r\n    function allocatePurchaseTokens(\r\n        address _hodler,\r\n        uint256 _amount,\r\n        uint256 _feeDrago,\r\n        uint256 _feeDragoDao)\r\n        internal\r\n    {\r\n        accounts[_hodler].balance = safeAdd(accounts[_hodler].balance, _amount);\r\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeDrago);\r\n        accounts[admin.dragoDao].balance = safeAdd(accounts[admin.dragoDao].balance, _feeDragoDao);\r\n        accounts[_hodler].receipt.activation = uint32(now) + data.minPeriod;\r\n    }\r\n\r\n    /// @dev Destroys tokens of seller, splits fee in tokens to wizard and dao.\r\n    /// @param _hodler Address of the seller.\r\n    /// @param _amount Value of burnt tokens.\r\n    /// @param _feeDrago Number of shares as fee.\r\n    /// @param _feeDragoDao Number of shares as fee to dao.\r\n    function allocateSaleTokens(\r\n        address _hodler,\r\n        uint256 _amount,\r\n        uint256 _feeDrago,\r\n        uint256 _feeDragoDao)\r\n        internal\r\n    {\r\n        accounts[_hodler].balance = safeSub(accounts[_hodler].balance, _amount);\r\n        accounts[admin.feeCollector].balance = safeAdd(accounts[admin.feeCollector].balance, _feeDrago);\r\n        accounts[admin.dragoDao].balance = safeAdd(accounts[admin.dragoDao].balance, _feeDragoDao);\r\n    }\r\n\r\n    /// @dev Sends a buy log to the eventful contract.\r\n    /// @param _amount Number of purchased shares.\r\n    function addPurchaseLog(uint256 _amount)\r\n        internal\r\n    {\r\n        bytes memory name = bytes(data.name);\r\n        bytes memory symbol = bytes(data.symbol);\r\n        Authority auth = Authority(admin.authority);\r\n        DragoEventful events = DragoEventful(auth.getDragoEventful());\r\n        require(events.buyDrago(msg.sender, this, msg.value, _amount, name, symbol));\r\n    }\r\n\r\n    /// @dev Sends a sell log to the eventful contract.\r\n    /// @param _amount Number of sold shares.\r\n    /// @param _netRevenue Value of sale for hodler.\r\n    function addSaleLog(uint256 _amount, uint256 _netRevenue)\r\n        internal\r\n    {\r\n        bytes memory name = bytes(data.name);\r\n        bytes memory symbol = bytes(data.symbol);\r\n        Authority auth = Authority(admin.authority);\r\n        DragoEventful events = DragoEventful(auth.getDragoEventful());\r\n        require(events.sellDrago(msg.sender, this, _amount, _netRevenue, name, symbol));\r\n    }\r\n\r\n    /// @dev Allows owner to set an infinite allowance to an approved exchange.\r\n    /// @param _tokenTransferProxy Address of the proxy to be approved.\r\n    /// @param _token Address of the token to receive allowance for.\r\n    function setAllowancesInternal(\r\n        address _tokenTransferProxy,\r\n        address _token,\r\n        uint256 _amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(Token(_token)\r\n            .approve(_tokenTransferProxy, _amount));\r\n        return true;\r\n    }\r\n\r\n    /// @dev Calculates the correct purchase amounts.\r\n    /// @return Number of new shares.\r\n    /// @return Value of fee in shares.\r\n    /// @return Value of fee in shares to dao.\r\n    /// @return Value of net purchased shares.\r\n    function getPurchaseAmounts()\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 grossAmount,\r\n            uint256 feeDrago,\r\n            uint256 feeDragoDao,\r\n            uint256 amount\r\n        )\r\n    {\r\n        grossAmount = safeDiv(msg.value * BASE, data.buyPrice);\r\n        uint256 fee = safeMul(grossAmount, data.transactionFee) / 10000; //fee is in basis points\r\n        return (\r\n            grossAmount,\r\n            feeDrago = safeMul(fee , admin.ratio) / 100,\r\n            feeDragoDao = safeSub(fee, feeDrago),\r\n            amount = safeSub(grossAmount, fee)\r\n        );\r\n    }\r\n\r\n    /// @dev Calculates the correct sale amounts.\r\n    /// @return Value of fee in shares.\r\n    /// @return Value of fee in shares to dao.\r\n    /// @return Value of net sold shares.\r\n    /// @return Value of sale amount for hodler.\r\n    function getSaleAmounts(uint256 _amount)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 feeDrago,\r\n            uint256 feeDragoDao,\r\n            uint256 netAmount,\r\n            uint256 netRevenue\r\n        )\r\n    {\r\n        uint256 fee = safeMul(_amount, data.transactionFee) / 10000; //fee is in basis points\r\n        return (\r\n            feeDrago = safeMul(fee, admin.ratio) / 100,\r\n            feeDragoDao = safeSub(fee, feeDragoDao),\r\n            netAmount = safeSub(_amount, fee),\r\n            netRevenue = (safeMul(netAmount, data.sellPrice) / BASE)\r\n        );\r\n    }\r\n\r\n    /// @dev Gets the address of the logger contract.\r\n    /// @return Address of the logger contrac.\r\n    function getDragoEventful()\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        Authority auth = Authority(admin.authority);\r\n        return auth.getDragoEventful();\r\n    }\r\n\r\n    /// @dev Returns the address of the signature verifier.\r\n    /// @return Address of the verifier contract.\r\n    function getSigVerifier()\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return ExchangesAuthority(\r\n            Authority(admin.authority)\r\n            .getExchangesAuthority())\r\n            .getSigVerifier();\r\n    }\r\n\r\n    /// @dev Returns the address of the price verifier.\r\n    /// @return Address of the verifier contract.\r\n    function getNavVerifier()\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return Authority(admin.authority)\r\n            .getNavVerifier();\r\n    }\r\n\r\n    /// @dev Verifies that a signature is valid.\r\n    /// @param sellPrice Price in wei.\r\n    /// @param buyPrice Price in wei.\r\n    /// @param signaturevaliduntilBlock Number of blocks till price expiry.\r\n    /// @param hash Message hash that is signed.\r\n    /// @param signedData Proof of nav validity.\r\n    /// @return Bool validity of signed price update.\r\n    function isValidNav(\r\n        uint256 sellPrice,\r\n        uint256 buyPrice,\r\n        uint256 signaturevaliduntilBlock,\r\n        bytes32 hash,\r\n        bytes signedData)\r\n        internal\r\n        view\r\n        returns (bool isValid)\r\n    {\r\n        isValid = NavVerifier(getNavVerifier()).isValidNav(\r\n            sellPrice,\r\n            buyPrice,\r\n            signaturevaliduntilBlock,\r\n            hash,\r\n            signedData\r\n        );\r\n        return isValid;\r\n    }\r\n\r\n    /// @dev Finds the exchanges authority.\r\n    /// @return Address of the exchanges authority.\r\n    function getExchangesAuthority()\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return Authority(admin.authority).getExchangesAuthority();\r\n    }\r\n\r\n    /// @dev Returns the address of the exchange adapter.\r\n    /// @param _exchange Address of the target exchange.\r\n    /// @return Address of the exchange adapter.\r\n    function getExchangeAdapter(address _exchange)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return ExchangesAuthority(\r\n            Authority(admin.authority)\r\n            .getExchangesAuthority())\r\n            .getExchangeAdapter(_exchange);\r\n    }\r\n\r\n    /// @dev Returns the method of a call.\r\n    /// @param assembledData Bytes of the encoded transaction.\r\n    /// @return Bytes4 function signature.\r\n    function findMethod(bytes assembledData)\r\n        internal\r\n        pure\r\n        returns (bytes4 method)\r\n    {\r\n        return method = LibFindMethod.findMethod(assembledData);\r\n    }\r\n\r\n    /// @dev Finds if a method is allowed on an exchange.\r\n    /// @param _adapter Address of the target exchange.\r\n    /// @return Bool the method is allowed.\r\n    function methodAllowedOnExchange(\r\n        bytes4 _method,\r\n        address _adapter)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return ExchangesAuthority(\r\n            Authority(admin.authority)\r\n            .getExchangesAuthority())\r\n            .isMethodAllowed(_method, _adapter);\r\n    }\r\n}"}
{"address": "0x328d15f6b5eba1c30cde1a5f1f5a9e35b07f5424", "attacktype": "Reentrancy, Flash liquidity borrow, purchase, mint or deposit", "sourcecode": "/*\r\n * Origin Protocol\r\n * https://originprotocol.com\r\n *\r\n * Released under the MIT license\r\n * https://github.com/OriginProtocol/origin-dollar\r\n *\r\n * Copyright 2020 Origin Protocol, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/interfaces/IStrategy.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n/**\r\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\r\n */\r\ninterface IStrategy {\r\n    /**\r\n     * @dev Deposit the given asset to Lending platform.\r\n     * @param _asset asset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(address _asset, uint256 _amount)\r\n        external\r\n        returns (uint256 amountDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw given asset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _recipient,\r\n        address _asset,\r\n        uint256 _amount\r\n    ) external returns (uint256 amountWithdrawn);\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given asset.\r\n     */\r\n    function checkBalance(address _asset)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns bool indicating whether strategy supports asset.\r\n     */\r\n    function supportsAsset(address _asset) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Liquidate all assets in strategy and return them to Vault.\r\n     */\r\n    function liquidate() external;\r\n\r\n    /**\r\n     * @dev Collect reward tokens from the Strategy.\r\n     */\r\n    function collectRewardToken() external;\r\n\r\n    /**\r\n     * @dev The address of the reward token for the Strategy.\r\n     */\r\n    function rewardTokenAddress() external pure returns (address);\r\n\r\n    /**\r\n     * @dev The threshold (denominated in the reward token) over which the\r\n     * vault will auto harvest on allocate calls.\r\n     */\r\n    function rewardLiquidationThreshold() external pure returns (uint256);\r\n}\r\n\r\n// File: contracts/governance/Governable.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n/**\r\n * @title OUSD Governable Contract\r\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\r\n *      from owner to governor and renounce methods removed. Does not use\r\n *      Context.sol like Ownable.sol does for simplification.\r\n * @author Origin Protocol Inc\r\n */\r\ncontract Governable {\r\n    // Storage position of the owner and pendingOwner of the contract\r\n    bytes32\r\n        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\r\n    //keccak256(\"OUSD.governor\");\r\n\r\n    bytes32\r\n        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\r\n    //keccak256(\"OUSD.pending.governor\");\r\n\r\n    event PendingGovernorshipTransfer(\r\n        address indexed previousGovernor,\r\n        address indexed newGovernor\r\n    );\r\n\r\n    event GovernorshipTransferred(\r\n        address indexed previousGovernor,\r\n        address indexed newGovernor\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial Governor.\r\n     */\r\n    constructor() internal {\r\n        _setGovernor(msg.sender);\r\n        emit GovernorshipTransferred(address(0), _governor());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current Governor.\r\n     */\r\n    function governor() public view returns (address) {\r\n        return _governor();\r\n    }\r\n\r\n    function _governor() internal view returns (address governorOut) {\r\n        bytes32 position = governorPosition;\r\n        assembly {\r\n            governorOut := sload(position)\r\n        }\r\n    }\r\n\r\n    function _pendingGovernor()\r\n        internal\r\n        view\r\n        returns (address pendingGovernor)\r\n    {\r\n        bytes32 position = pendingGovernorPosition;\r\n        assembly {\r\n            pendingGovernor := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        require(isGovernor(), \"Caller is not the Governor\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current Governor.\r\n     */\r\n    function isGovernor() public view returns (bool) {\r\n        return msg.sender == _governor();\r\n    }\r\n\r\n    function _setGovernor(address newGovernor) internal {\r\n        bytes32 position = governorPosition;\r\n        assembly {\r\n            sstore(position, newGovernor)\r\n        }\r\n    }\r\n\r\n    function _setPendingGovernor(address newGovernor) internal {\r\n        bytes32 position = pendingGovernorPosition;\r\n        assembly {\r\n            sstore(position, newGovernor)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers Governance of the contract to a new account (`newGovernor`).\r\n     * Can only be called by the current Governor. Must be claimed for this to complete\r\n     * @param _newGovernor Address of the new Governor\r\n     */\r\n    function transferGovernance(address _newGovernor) external onlyGovernor {\r\n        _setPendingGovernor(_newGovernor);\r\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim Governance of the contract to a new account (`newGovernor`).\r\n     * Can only be called by the new Governor.\r\n     */\r\n    function claimGovernance() external {\r\n        require(\r\n            msg.sender == _pendingGovernor(),\r\n            \"Only the pending Governor can complete the claim\"\r\n        );\r\n        _changeGovernor(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\r\n     * @param _newGovernor Address of the new Governor\r\n     */\r\n    function _changeGovernor(address _newGovernor) internal {\r\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\r\n        emit GovernorshipTransferred(_governor(), _newGovernor);\r\n        _setGovernor(_newGovernor);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\n// File: contracts/utils/InitializableERC20Detailed.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\r\n */\r\ncontract InitializableERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(\r\n        string memory nameArg,\r\n        string memory symbolArg,\r\n        uint8 decimalsArg\r\n    ) internal {\r\n        _name = nameArg;\r\n        _symbol = symbolArg;\r\n        _decimals = decimalsArg;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/InitializableToken.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n\r\ncontract InitializableToken is ERC20, InitializableERC20Detailed {\r\n    /**\r\n     * @dev Initialization function for implementing contract\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(string memory _nameArg, string memory _symbolArg)\r\n        internal\r\n    {\r\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/StableMath.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n// Based on StableMath from Stability Labs Pty. Ltd.\r\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\r\n\r\nlibrary StableMath {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /***************************************\r\n                    Helpers\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Adjust the scale of an integer\r\n     * @param adjustment Amount to adjust by e.g. scaleBy(1e18, -1) == 1e17\r\n     */\r\n    function scaleBy(uint256 x, int8 adjustment)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (adjustment > 0) {\r\n            x = x.mul(10**uint256(adjustment));\r\n        } else if (adjustment < 0) {\r\n            x = x.div(10**uint256(adjustment * -1));\r\n        }\r\n        return x;\r\n    }\r\n\r\n    /***************************************\r\n               Precise Arithmetic\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x Left hand input to multiplication\r\n     * @param y Right hand input to multiplication\r\n     * @return Result after multiplying the two inputs and then dividing by the shared\r\n     *         scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x Left hand input to multiplication\r\n     * @param y Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return Result after multiplying the two inputs and then dividing by the shared\r\n     *         scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        uint256 z = x.mul(y);\r\n        // return 9e38 / 1e18 = 9e18\r\n        return z.div(scale);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x Left hand input to multiplication\r\n     * @param y Right hand input to multiplication\r\n     * @return Result after multiplying the two inputs and then dividing by the shared\r\n     *          scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x.mul(y);\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil.div(FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x Left hand input to division\r\n     * @param y Right hand input to division\r\n     * @return Result after multiplying the left operand by the scale, and\r\n     *         executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        uint256 z = x.mul(FULL_SCALE);\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return z.div(y);\r\n    }\r\n}\r\n\r\n// File: contracts/token/OUSD.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n/**\r\n * @title OUSD Token Contract\r\n * @dev ERC20 compatible contract for OUSD\r\n * @dev Implements an elastic supply\r\n * @author Origin Protocol Inc\r\n */\r\n\r\n\r\n\r\n\r\n\r\ncontract OUSD is Initializable, InitializableToken, Governable {\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n\r\n    event TotalSupplyUpdated(\r\n        uint256 totalSupply,\r\n        uint256 rebasingCredits,\r\n        uint256 rebasingCreditsPerToken\r\n    );\r\n\r\n    uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 public rebasingCredits;\r\n    // Exchange rate between internal credits and OUSD\r\n    uint256 public rebasingCreditsPerToken;\r\n\r\n    mapping(address => uint256) private _creditBalances;\r\n\r\n    // Allowances denominated in OUSD\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    address public vaultAddress = address(0);\r\n\r\n    // Frozen address/credits are non rebasing (value is held in contracts which\r\n    // do not receive yield unless they explicitly opt in)\r\n    uint256 public nonRebasingCredits;\r\n    uint256 public nonRebasingSupply;\r\n    mapping(address => uint256) public nonRebasingCreditsPerToken;\r\n    enum RebaseOptions { NotSet, OptOut, OptIn }\r\n    mapping(address => RebaseOptions) public rebaseState;\r\n\r\n    function initialize(\r\n        string calldata _nameArg,\r\n        string calldata _symbolArg,\r\n        address _vaultAddress\r\n    ) external onlyGovernor initializer {\r\n        InitializableToken._initialize(_nameArg, _symbolArg);\r\n\r\n        _totalSupply = 0;\r\n        rebasingCredits = 0;\r\n        rebasingCreditsPerToken = 1e18;\r\n\r\n        vaultAddress = _vaultAddress;\r\n\r\n        nonRebasingCredits = 0;\r\n        nonRebasingSupply = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the caller is the Savings Manager contract\r\n     */\r\n    modifier onlyVault() {\r\n        require(vaultAddress == msg.sender, \"Caller is not the Vault\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return The total supply of OUSD.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _account Address to query the balance of.\r\n     * @return A uint256 representing the _amount of base units owned by the\r\n     *         specified address.\r\n     */\r\n    function balanceOf(address _account) public view returns (uint256) {\r\n        return\r\n            _creditBalances[_account].divPrecisely(_creditsPerToken(_account));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the credits balance of the specified address.\r\n     * @param _account The address to query the balance of.\r\n     * @return (uint256, uint256) Credit balance and credits per token of the\r\n     *         address\r\n     */\r\n    function creditsBalanceOf(address _account)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return (_creditBalances[_account], _creditsPerToken(_account));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified address.\r\n     * @param _to the address to transfer to.\r\n     * @param _value the _amount to be transferred.\r\n     * @return true on success.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0), \"Transfer to zero address\");\r\n\r\n        _executeTransfer(msg.sender, _to, _value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * @param _from The address you want to send tokens from.\r\n     * @param _to The address you want to transfer to.\r\n     * @param _value The _amount of tokens to be transferred.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool) {\r\n        require(_to != address(0), \"Transfer to zero address\");\r\n\r\n        _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(\r\n            _value\r\n        );\r\n\r\n        _executeTransfer(_from, _to, _value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the count of non rebasing credits in response to a transfer\r\n     * @param _from The address you want to send tokens from.\r\n     * @param _to The address you want to transfer to.\r\n     * @param _value Amount of OUSD to transfer\r\n     */\r\n    function _executeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        bool isNonRebasingTo = _isNonRebasingAccount(_to);\r\n        bool isNonRebasingFrom = _isNonRebasingAccount(_from);\r\n\r\n        // Credits deducted and credited might be different due to the\r\n        // differing creditsPerToken used by each account\r\n        uint256 creditsCredited = _value.mulTruncate(_creditsPerToken(_to));\r\n        uint256 creditsDeducted = _value.mulTruncate(_creditsPerToken(_from));\r\n\r\n        _creditBalances[_from] = _creditBalances[_from].sub(\r\n            creditsDeducted,\r\n            \"Transfer amount exceeds balance\"\r\n        );\r\n        _creditBalances[_to] = _creditBalances[_to].add(creditsCredited);\r\n\r\n        if (isNonRebasingTo && !isNonRebasingFrom) {\r\n            // Transfer to non-rebasing account from rebasing account, credits\r\n            // are removed from the non rebasing tally\r\n            nonRebasingCredits = nonRebasingCredits.add(creditsCredited);\r\n            nonRebasingSupply = nonRebasingSupply.add(_value);\r\n            // Update rebasingCredits by subtracting the deducted amount\r\n            rebasingCredits = rebasingCredits.sub(creditsDeducted);\r\n        } else if (!isNonRebasingTo && isNonRebasingFrom) {\r\n            // Transfer to rebasing account from non-rebasing account\r\n            // Decreasing non-rebasing credits by the amount that was sent\r\n            nonRebasingCredits = nonRebasingCredits.sub(creditsDeducted);\r\n            nonRebasingSupply = nonRebasingSupply.sub(_value);\r\n            // Update rebasingCredits by adding the credited amount\r\n            rebasingCredits = rebasingCredits.add(creditsCredited);\r\n        } else if (isNonRebasingTo && isNonRebasingFrom) {\r\n            // Transfer between two non rebasing accounts. They may have\r\n            // different exchange rates so update the count of non rebasing\r\n            // credits with the difference\r\n            nonRebasingCredits =\r\n                nonRebasingCredits +\r\n                creditsCredited -\r\n                creditsDeducted;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the _amount of tokens that an owner has allowed to a _spender.\r\n     * @param _owner The address which owns the funds.\r\n     * @param _spender The address which will spend the funds.\r\n     * @return The number of tokens still available for the _spender.\r\n     */\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowances[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified _amount of tokens on behalf of\r\n     * msg.sender. This method is included for ERC20 compatibility.\r\n     * increaseAllowance and decreaseAllowance should be used instead.\r\n     * Changing an allowance with this method brings the risk that someone may transfer both\r\n     * the old and the new allowance - if they are both greater than zero - if a transfer\r\n     * transaction is mined before the later approve() call is mined.\r\n     *\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The _amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the _amount of tokens that an owner has allowed to a _spender.\r\n     * This method should be used instead of approve() to avoid the double approval vulnerability\r\n     * described above.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The _amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address _spender, uint256 _addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        _allowances[msg.sender][_spender] = _allowances[msg.sender][_spender]\r\n            .add(_addedValue);\r\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the _amount of tokens that an owner has allowed to a _spender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The _amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = _allowances[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            _allowances[msg.sender][_spender] = 0;\r\n        } else {\r\n            _allowances[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints new tokens, increasing totalSupply.\r\n     */\r\n    function mint(address _account, uint256 _amount) external onlyVault {\r\n        return _mint(_account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `_amount` tokens and assigns them to `_account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address _account, uint256 _amount) internal {\r\n        require(_account != address(0), \"Mint to the zero address\");\r\n\r\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\r\n\r\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\r\n        _creditBalances[_account] = _creditBalances[_account].add(creditAmount);\r\n\r\n        // If the account is non rebasing and doesn't have a set creditsPerToken\r\n        // then set it i.e. this is a mint from a fresh contract\r\n        if (isNonRebasingAccount) {\r\n            nonRebasingCredits = nonRebasingCredits.add(creditAmount);\r\n            nonRebasingSupply = nonRebasingSupply.add(_amount);\r\n        } else {\r\n            rebasingCredits = rebasingCredits.add(creditAmount);\r\n        }\r\n\r\n        _totalSupply = _totalSupply.add(_amount);\r\n\r\n        emit Transfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens, decreasing totalSupply.\r\n     */\r\n    function burn(address account, uint256 amount) external onlyVault {\r\n        return _burn(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `_amount` tokens from `_account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `_account` cannot be the zero address.\r\n     * - `_account` must have at least `_amount` tokens.\r\n     */\r\n    function _burn(address _account, uint256 _amount) internal {\r\n        require(_account != address(0), \"Burn from the zero address\");\r\n\r\n        bool isNonRebasingAccount = _isNonRebasingAccount(_account);\r\n        uint256 creditAmount = _amount.mulTruncate(_creditsPerToken(_account));\r\n        uint256 currentCredits = _creditBalances[_account];\r\n\r\n        // Remove the credits, burning rounding errors\r\n        if (\r\n            currentCredits == creditAmount || currentCredits - 1 == creditAmount\r\n        ) {\r\n            // Handle dust from rounding\r\n            _creditBalances[_account] = 0;\r\n        } else if (currentCredits > creditAmount) {\r\n            _creditBalances[_account] = _creditBalances[_account].sub(\r\n                creditAmount\r\n            );\r\n        } else {\r\n            revert(\"Remove exceeds balance\");\r\n        }\r\n\r\n        // Remove from the credit tallies and non-rebasing supply\r\n        if (isNonRebasingAccount) {\r\n            nonRebasingCredits = nonRebasingCredits.sub(creditAmount);\r\n            nonRebasingSupply = nonRebasingSupply.sub(_amount);\r\n        } else {\r\n            rebasingCredits = rebasingCredits.sub(creditAmount);\r\n        }\r\n\r\n        _totalSupply = _totalSupply.sub(_amount);\r\n\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the credits per token for an account. Returns a fixed amount\r\n     *      if the account is non-rebasing.\r\n     * @param _account Address of the account.\r\n     */\r\n    function _creditsPerToken(address _account)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (nonRebasingCreditsPerToken[_account] != 0) {\r\n            return nonRebasingCreditsPerToken[_account];\r\n        } else {\r\n            return rebasingCreditsPerToken;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Is an accounts balance non rebasing, i.e. does not alter with rebases\r\n     * @param _account Address of the account.\r\n     */\r\n    function _isNonRebasingAccount(address _account) internal returns (bool) {\r\n        if (Address.isContract(_account)) {\r\n            // Contracts by default opt out\r\n            if (rebaseState[_account] == RebaseOptions.OptIn) {\r\n                // If they've opted in explicitly it is not a non rebasing\r\n                // address\r\n                return false;\r\n            }\r\n            // Is a non rebasing account because no explicit opt in\r\n            // Make sure the rebasing/non-rebasing supply is updated and\r\n            // fixed credits per token is set for this account\r\n            _ensureRebasingMigration(_account);\r\n            return true;\r\n        } else {\r\n            // EOAs by default opt in\r\n            // Check for explicit opt out\r\n            return rebaseState[_account] == RebaseOptions.OptOut;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Ensures internal account for rebasing and non-rebasing credits and\r\n     *      supply is updated following deployment of frozen yield change.\r\n     */\r\n    function _ensureRebasingMigration(address _account) internal {\r\n        if (nonRebasingCreditsPerToken[_account] == 0) {\r\n            // Set fixed credits per token for this account\r\n            nonRebasingCreditsPerToken[_account] = rebasingCreditsPerToken;\r\n            // Update non rebasing supply\r\n            nonRebasingSupply = nonRebasingSupply.add(balanceOf(_account));\r\n            // Update credit tallies\r\n            rebasingCredits = rebasingCredits.sub(_creditBalances[_account]);\r\n            nonRebasingCredits = nonRebasingCredits.add(\r\n                _creditBalances[_account]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add a contract address to the non rebasing exception list. I.e. the\r\n     * address's balance will be part of rebases so the account will be exposed\r\n     * to upside and downside.\r\n     */\r\n    function rebaseOptIn() public {\r\n        require(_isNonRebasingAccount(msg.sender), \"Account has not opted out\");\r\n\r\n        // Convert balance into the same amount at the current exchange rate\r\n        uint256 newCreditBalance = _creditBalances[msg.sender]\r\n            .mul(rebasingCreditsPerToken)\r\n            .div(_creditsPerToken(msg.sender));\r\n\r\n        // Decreasing non rebasing supply\r\n        nonRebasingSupply = nonRebasingSupply.sub(balanceOf(msg.sender));\r\n        // Decrease non rebasing credits\r\n        nonRebasingCredits = nonRebasingCredits.sub(\r\n            _creditBalances[msg.sender]\r\n        );\r\n\r\n        _creditBalances[msg.sender] = newCreditBalance;\r\n\r\n        // Increase rebasing credits, totalSupply remains unchanged so no\r\n        // adjustment necessary\r\n        rebasingCredits = rebasingCredits.add(_creditBalances[msg.sender]);\r\n\r\n        rebaseState[msg.sender] = RebaseOptions.OptIn;\r\n\r\n        // Delete any fixed credits per token\r\n        delete nonRebasingCreditsPerToken[msg.sender];\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a contract address to the non rebasing exception list.\r\n     */\r\n    function rebaseOptOut() public {\r\n        require(!_isNonRebasingAccount(msg.sender), \"Account has not opted in\");\r\n\r\n        // Increase non rebasing supply\r\n        nonRebasingSupply = nonRebasingSupply.add(balanceOf(msg.sender));\r\n        // Increase non rebasing credits\r\n        nonRebasingCredits = nonRebasingCredits.add(\r\n            _creditBalances[msg.sender]\r\n        );\r\n\r\n        // Set fixed credits per token\r\n        nonRebasingCreditsPerToken[msg.sender] = rebasingCreditsPerToken;\r\n\r\n        // Decrease rebasing credits, total supply remains unchanged so no\r\n        // adjustment necessary\r\n        rebasingCredits = rebasingCredits.sub(_creditBalances[msg.sender]);\r\n\r\n        // Mark explicitly opted out of rebasing\r\n        rebaseState[msg.sender] = RebaseOptions.OptOut;\r\n    }\r\n\r\n    /**\r\n     * @dev Modify the supply without minting new tokens. This uses a change in\r\n     *      the exchange rate between \"credits\" and OUSD tokens to change balances.\r\n     * @param _newTotalSupply New total supply of OUSD.\r\n     * @return uint256 representing the new total supply.\r\n     */\r\n    function changeSupply(uint256 _newTotalSupply)\r\n        external\r\n        onlyVault\r\n        returns (uint256)\r\n    {\r\n        require(_totalSupply > 0, \"Cannot increase 0 supply\");\r\n\r\n        if (_totalSupply == _newTotalSupply) {\r\n            emit TotalSupplyUpdated(\r\n                _totalSupply,\r\n                rebasingCredits,\r\n                rebasingCreditsPerToken\r\n            );\r\n            return _totalSupply;\r\n        }\r\n\r\n        _totalSupply = _newTotalSupply;\r\n\r\n        if (_totalSupply > MAX_SUPPLY) _totalSupply = MAX_SUPPLY;\r\n\r\n        rebasingCreditsPerToken = rebasingCredits.divPrecisely(\r\n            _totalSupply.sub(nonRebasingSupply)\r\n        );\r\n\r\n        emit TotalSupplyUpdated(\r\n            _totalSupply,\r\n            rebasingCredits,\r\n            rebasingCreditsPerToken\r\n        );\r\n\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IBasicToken.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\ninterface IBasicToken {\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: contracts/utils/Helpers.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\nlibrary Helpers {\r\n    /**\r\n     * @notice Fetch the `symbol()` from an ERC20 token\r\n     * @dev Grabs the `symbol()` from a contract\r\n     * @param _token Address of the ERC20 token\r\n     * @return string Symbol of the ERC20 token\r\n     */\r\n    function getSymbol(address _token) internal view returns (string memory) {\r\n        string memory symbol = IBasicToken(_token).symbol();\r\n        return symbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Fetch the `decimals()` from an ERC20 token\r\n     * @dev Grabs the `decimals()` from a contract and fails if\r\n     *      the decimal value does not live within a certain range\r\n     * @param _token Address of the ERC20 token\r\n     * @return uint256 Decimals of the ERC20 token\r\n     */\r\n    function getDecimals(address _token) internal view returns (uint256) {\r\n        uint256 decimals = IBasicToken(_token).decimals();\r\n        require(\r\n            decimals >= 4 && decimals <= 18,\r\n            \"Token must have sufficient decimal places\"\r\n        );\r\n\r\n        return decimals;\r\n    }\r\n}\r\n\r\n// File: contracts/vault/VaultStorage.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n/**\r\n * @title OUSD VaultStorage Contract\r\n * @notice The VaultStorage contract defines the storage for the Vault contracts\r\n * @author Origin Protocol Inc\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract VaultStorage is Initializable, Governable {\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n    using SafeMath for int256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event AssetSupported(address _asset);\r\n    event StrategyAdded(address _addr);\r\n    event StrategyRemoved(address _addr);\r\n    event Mint(address _addr, uint256 _value);\r\n    event Redeem(address _addr, uint256 _value);\r\n    event StrategyWeightsUpdated(\r\n        address[] _strategyAddresses,\r\n        uint256[] weights\r\n    );\r\n    event DepositsPaused();\r\n    event DepositsUnpaused();\r\n\r\n    // Assets supported by the Vault, i.e. Stablecoins\r\n    struct Asset {\r\n        bool isSupported;\r\n    }\r\n    mapping(address => Asset) assets;\r\n    address[] allAssets;\r\n\r\n    // Strategies supported by the Vault\r\n    struct Strategy {\r\n        bool isSupported;\r\n        uint256 targetWeight; // 18 decimals. 100% = 1e18\r\n    }\r\n    mapping(address => Strategy) strategies;\r\n    address[] allStrategies;\r\n\r\n    // Address of the Oracle price provider contract\r\n    address public priceProvider;\r\n    // Pausing bools\r\n    bool public rebasePaused = false;\r\n    bool public depositPaused = true;\r\n    // Redemption fee in basis points\r\n    uint256 public redeemFeeBps;\r\n    // Buffer of assets to keep in Vault to handle (most) withdrawals\r\n    uint256 public vaultBuffer;\r\n    // Mints over this amount automatically allocate funds. 18 decimals.\r\n    uint256 public autoAllocateThreshold;\r\n    // Mints over this amount automatically rebase. 18 decimals.\r\n    uint256 public rebaseThreshold;\r\n\r\n    OUSD oUSD;\r\n\r\n    //keccak256(\"OUSD.vault.governor.admin.impl\");\r\n    bytes32 constant adminImplPosition = 0xa2bd3d3cf188a41358c8b401076eb59066b09dec5775650c0de4c55187d17bd9;\r\n\r\n    // Address of the contract responsible for post rebase syncs with AMMs\r\n    address public rebaseHooksAddr = address(0);\r\n\r\n    // Address of Uniswap\r\n    address public uniswapAddr = address(0);\r\n\r\n    address public strategistAddr = address(0);\r\n\r\n    /**\r\n     * @dev set the implementation for the admin, this needs to be in a base class else we cannot set it\r\n     * @param newImpl address pf the implementation\r\n     */\r\n    function setAdminImpl(address newImpl) external onlyGovernor {\r\n        bytes32 position = adminImplPosition;\r\n        assembly {\r\n            sstore(position, newImpl)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IMinMaxOracle.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\ninterface IMinMaxOracle {\r\n    //Assuming 8 decimals\r\n    function priceMin(string calldata symbol) external returns (uint256);\r\n\r\n    function priceMax(string calldata symbol) external returns (uint256);\r\n}\r\n\r\ninterface IViewMinMaxOracle {\r\n    function priceMin(string calldata symbol) external view returns (uint256);\r\n\r\n    function priceMax(string calldata symbol) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IRebaseHooks.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\ninterface IRebaseHooks {\r\n    function postRebase(bool sync) external;\r\n}\r\n\r\n// File: contracts/interfaces/IVault.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\ninterface IVault {\r\n    event AssetSupported(address _asset);\r\n    event StrategyAdded(address _addr);\r\n    event StrategyRemoved(address _addr);\r\n    event Mint(address _addr, uint256 _value);\r\n    event Redeem(address _addr, uint256 _value);\r\n    event StrategyWeightsUpdated(\r\n        address[] _strategyAddresses,\r\n        uint256[] weights\r\n    );\r\n    event DepositsPaused();\r\n    event DepositsUnpaused();\r\n\r\n    // Governable.sol\r\n    function transferGovernance(address _newGovernor) external;\r\n\r\n    function claimGovernance() external;\r\n\r\n    function governor() external view returns (address);\r\n\r\n    // VaultAdmin.sol\r\n    function setPriceProvider(address _priceProvider) external;\r\n\r\n    function priceProvider() external view returns (address);\r\n\r\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external;\r\n\r\n    function redeemFeeBps() external view returns (uint256);\r\n\r\n    function setVaultBuffer(uint256 _vaultBuffer) external;\r\n\r\n    function vaultBuffer() external view returns (uint256);\r\n\r\n    function setAutoAllocateThreshold(uint256 _threshold) external;\r\n\r\n    function autoAllocateThreshold() external view returns (uint256);\r\n\r\n    function setRebaseThreshold(uint256 _threshold) external;\r\n\r\n    function rebaseThreshold() external view returns (uint256);\r\n\r\n    function setRebaseHooksAddr(address _address) external;\r\n\r\n    function rebaseHooksAddr() external view returns (address);\r\n\r\n    function setStrategistAddr(address _address) external;\r\n\r\n    function strategistAddr() external view returns (address);\r\n\r\n    function setUniswapAddr(address _address) external;\r\n\r\n    function uniswapAddr() external view returns (address);\r\n\r\n    function supportAsset(address _asset) external;\r\n\r\n    function addStrategy(address _addr, uint256 _targetWeight) external;\r\n\r\n    function removeStrategy(address _addr) external;\r\n\r\n    function setStrategyWeights(\r\n        address[] calldata _strategyAddresses,\r\n        uint256[] calldata _weights\r\n    ) external;\r\n\r\n    function pauseRebase() external;\r\n\r\n    function unpauseRebase() external;\r\n\r\n    function rebasePaused() external view returns (bool);\r\n\r\n    function pauseDeposits() external;\r\n\r\n    function unpauseDeposits() external;\r\n\r\n    function depositPaused() external view returns (bool);\r\n\r\n    function transferToken(address _asset, uint256 _amount) external;\r\n\r\n    function harvest() external;\r\n\r\n    function harvest(address _strategyAddr) external;\r\n\r\n    function priceUSDMint(string calldata symbol) external returns (uint256);\r\n\r\n    function priceUSDRedeem(string calldata symbol) external returns (uint256);\r\n\r\n    // VaultCore.sol\r\n    function mint(address _asset, uint256 _amount) external;\r\n\r\n    function mintMultiple(\r\n        address[] calldata _assets,\r\n        uint256[] calldata _amount\r\n    ) external;\r\n\r\n    function redeem(uint256 _amount) external;\r\n\r\n    function redeemAll() external;\r\n\r\n    function allocate() external;\r\n\r\n    function reallocate(\r\n        address _strategyFromAddress,\r\n        address _strategyToAddress,\r\n        address[] calldata _assets,\r\n        uint256[] calldata _amounts\r\n    ) external;\r\n\r\n    function rebase() external returns (uint256);\r\n\r\n    function totalValue() external view returns (uint256 value);\r\n\r\n    function checkBalance() external view returns (uint256);\r\n\r\n    function checkBalance(address _asset) external view returns (uint256);\r\n\r\n    function calculateRedeemOutputs(uint256 _amount)\r\n        external\r\n        returns (uint256[] memory);\r\n\r\n    function getAssetCount() external view returns (uint256);\r\n\r\n    function getAllAssets() external view returns (address[] memory);\r\n\r\n    function getStrategyCount() external view returns (uint256);\r\n\r\n    function isSupportedAsset(address _asset) external view returns (bool);\r\n}\r\n\r\n// File: contracts/vault/VaultCore.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n/**\r\n * @title OUSD Vault Contract\r\n * @notice The Vault contract stores assets. On a deposit, OUSD will be minted\r\n           and sent to the depositor. On a withdrawal, OUSD will be burned and\r\n           assets will be sent to the withdrawer. The Vault accepts deposits of\r\n           interest form yield bearing strategies which will modify the supply\r\n           of OUSD.\r\n * @author Origin Protocol Inc\r\n */\r\n\r\n\r\n\r\n\r\ncontract VaultCore is VaultStorage {\r\n    uint256 constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Verifies that the rebasing is not paused.\r\n     */\r\n    modifier whenNotRebasePaused() {\r\n        require(!rebasePaused, \"Rebasing paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies that the deposits are not paused.\r\n     */\r\n    modifier whenNotDepositPaused() {\r\n        require(!depositPaused, \"Deposits paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit a supported asset and mint OUSD.\r\n     * @param _asset Address of the asset being deposited\r\n     * @param _amount Amount of the asset being deposited\r\n     */\r\n    function mint(address _asset, uint256 _amount)\r\n        external\r\n        whenNotDepositPaused\r\n    {\r\n        require(assets[_asset].isSupported, \"Asset is not supported\");\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n\r\n        uint256 price = IMinMaxOracle(priceProvider).priceMin(\r\n            Helpers.getSymbol(_asset)\r\n        );\r\n        if (price > 1e8) {\r\n            price = 1e8;\r\n        }\r\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\r\n        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));\r\n        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(\r\n            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision\r\n            10**assetDecimals\r\n        );\r\n\r\n        // Rebase must happen before any transfers occur.\r\n        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\r\n            rebase(true);\r\n        }\r\n\r\n        // Transfer the deposited coins to the vault\r\n        IERC20 asset = IERC20(_asset);\r\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Mint matching OUSD\r\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\r\n        emit Mint(msg.sender, priceAdjustedDeposit);\r\n\r\n        if (unitAdjustedDeposit >= autoAllocateThreshold) {\r\n            allocate();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Mint for multiple assets in the same call.\r\n     * @param _assets Addresses of assets being deposited\r\n     * @param _amounts Amount of each asset at the same index in the _assets\r\n     *                 to deposit.\r\n     */\r\n    function mintMultiple(\r\n        address[] calldata _assets,\r\n        uint256[] calldata _amounts\r\n    ) external whenNotDepositPaused {\r\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\r\n\r\n        uint256 unitAdjustedTotal = 0;\r\n        uint256 priceAdjustedTotal = 0;\r\n        uint256[] memory assetPrices = _getAssetPrices(false);\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            for (uint256 j = 0; j < _assets.length; j++) {\r\n                if (_assets[j] == allAssets[i]) {\r\n                    if (_amounts[j] > 0) {\r\n                        uint256 assetDecimals = Helpers.getDecimals(\r\n                            allAssets[i]\r\n                        );\r\n                        uint256 price = assetPrices[i];\r\n                        if (price > 1e18) {\r\n                            price = 1e18;\r\n                        }\r\n                        unitAdjustedTotal += _amounts[j].scaleBy(\r\n                            int8(18 - assetDecimals)\r\n                        );\r\n                        priceAdjustedTotal += _amounts[j].mulTruncateScale(\r\n                            price,\r\n                            10**assetDecimals\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Rebase must happen before any transfers occur.\r\n        if (unitAdjustedTotal >= rebaseThreshold && !rebasePaused) {\r\n            rebase(true);\r\n        }\r\n\r\n        for (uint256 i = 0; i < _assets.length; i++) {\r\n            IERC20 asset = IERC20(_assets[i]);\r\n            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);\r\n        }\r\n\r\n        oUSD.mint(msg.sender, priceAdjustedTotal);\r\n        emit Mint(msg.sender, priceAdjustedTotal);\r\n\r\n        if (unitAdjustedTotal >= autoAllocateThreshold) {\r\n            allocate();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw a supported asset and burn OUSD.\r\n     * @param _amount Amount of OUSD to burn\r\n     */\r\n    function redeem(uint256 _amount) public {\r\n        if (_amount > rebaseThreshold && !rebasePaused) {\r\n            rebase(false);\r\n        }\r\n        _redeem(_amount);\r\n    }\r\n\r\n    function _redeem(uint256 _amount) internal {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n\r\n        // Calculate redemption outputs\r\n        uint256[] memory outputs = _calculateRedeemOutputs(_amount);\r\n        // Send outputs\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            if (outputs[i] == 0) continue;\r\n\r\n            IERC20 asset = IERC20(allAssets[i]);\r\n\r\n            if (asset.balanceOf(address(this)) >= outputs[i]) {\r\n                // Use Vault funds first if sufficient\r\n                asset.safeTransfer(msg.sender, outputs[i]);\r\n            } else {\r\n                address strategyAddr = _selectWithdrawStrategyAddr(\r\n                    allAssets[i],\r\n                    outputs[i]\r\n                );\r\n\r\n                if (strategyAddr != address(0)) {\r\n                    // Nothing in Vault, but something in Strategy, send from there\r\n                    IStrategy strategy = IStrategy(strategyAddr);\r\n                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);\r\n                } else {\r\n                    // Cant find funds anywhere\r\n                    revert(\"Liquidity error\");\r\n                }\r\n            }\r\n        }\r\n\r\n        oUSD.burn(msg.sender, _amount);\r\n\r\n        // Until we can prove that we won't affect the prices of our assets\r\n        // by withdrawing them, this should be here.\r\n        // It's possible that a strategy was off on its asset total, perhaps\r\n        // a reward token sold for more or for less than anticipated.\r\n        if (_amount > rebaseThreshold && !rebasePaused) {\r\n            rebase(true);\r\n        }\r\n\r\n        emit Redeem(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw a supported asset and burn all OUSD.\r\n     */\r\n    function redeemAll() external {\r\n        //unfortunately we have to do balanceOf twice\r\n        if (oUSD.balanceOf(msg.sender) > rebaseThreshold && !rebasePaused) {\r\n            rebase(false);\r\n        }\r\n        _redeem(oUSD.balanceOf(msg.sender));\r\n    }\r\n\r\n    /**\r\n     * @notice Allocate unallocated funds on Vault to strategies.\r\n     * @dev Allocate unallocated funds on Vault to strategies.\r\n     **/\r\n    function allocate() public {\r\n        _allocate();\r\n    }\r\n\r\n    /**\r\n     * @notice Allocate unallocated funds on Vault to strategies.\r\n     * @dev Allocate unallocated funds on Vault to strategies.\r\n     **/\r\n    function _allocate() internal {\r\n        uint256 vaultValue = _totalValueInVault();\r\n        // Nothing in vault to allocate\r\n        if (vaultValue == 0) return;\r\n        uint256 strategiesValue = _totalValueInStrategies();\r\n        // We have a method that does the same as this, gas optimisation\r\n        uint256 totalValue = vaultValue + strategiesValue;\r\n\r\n        // We want to maintain a buffer on the Vault so calculate a percentage\r\n        // modifier to multiply each amount being allocated by to enforce the\r\n        // vault buffer\r\n        uint256 vaultBufferModifier;\r\n        if (strategiesValue == 0) {\r\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\r\n            // strategies\r\n            vaultBufferModifier = uint256(1e18).sub(vaultBuffer);\r\n        } else {\r\n            vaultBufferModifier = vaultBuffer.mul(totalValue).div(vaultValue);\r\n            if (1e18 > vaultBufferModifier) {\r\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\r\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\r\n                vaultBufferModifier = uint256(1e18).sub(vaultBufferModifier);\r\n            } else {\r\n                // We need to let the buffer fill\r\n                return;\r\n            }\r\n        }\r\n        if (vaultBufferModifier == 0) return;\r\n\r\n        // Iterate over all assets in the Vault and allocate the the appropriate\r\n        // strategy\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            IERC20 asset = IERC20(allAssets[i]);\r\n            uint256 assetBalance = asset.balanceOf(address(this));\r\n            // No balance, nothing to do here\r\n            if (assetBalance == 0) continue;\r\n\r\n            // Multiply the balance by the vault buffer modifier and truncate\r\n            // to the scale of the asset decimals\r\n            uint256 allocateAmount = assetBalance.mulTruncate(\r\n                vaultBufferModifier\r\n            );\r\n\r\n            // Get the target Strategy to maintain weightings\r\n            address depositStrategyAddr = _selectDepositStrategyAddr(\r\n                address(asset),\r\n                allocateAmount\r\n            );\r\n\r\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\r\n                IStrategy strategy = IStrategy(depositStrategyAddr);\r\n                // Transfer asset to Strategy and call deposit method to\r\n                // mint or take required action\r\n                asset.safeTransfer(address(strategy), allocateAmount);\r\n                strategy.deposit(address(asset), allocateAmount);\r\n            }\r\n        }\r\n\r\n        // Harvest for all reward tokens above reward liquidation threshold\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            IStrategy strategy = IStrategy(allStrategies[i]);\r\n            address rewardTokenAddress = strategy.rewardTokenAddress();\r\n            if (rewardTokenAddress != address(0)) {\r\n                uint256 liquidationThreshold = strategy\r\n                    .rewardLiquidationThreshold();\r\n                if (liquidationThreshold == 0) {\r\n                    // No threshold set, always harvest from strategy\r\n                    IVault(address(this)).harvest(allStrategies[i]);\r\n                } else {\r\n                    // Check balance against liquidation threshold\r\n                    // Note some strategies don't hold the reward token balance\r\n                    // on their contract so the liquidation threshold should be\r\n                    // set to 0\r\n                    IERC20 rewardToken = IERC20(rewardTokenAddress);\r\n                    uint256 rewardTokenAmount = rewardToken.balanceOf(\r\n                        allStrategies[i]\r\n                    );\r\n                    if (rewardTokenAmount >= liquidationThreshold) {\r\n                        IVault(address(this)).harvest(allStrategies[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the total value of assets held by the Vault and all\r\n     *         strategies and update the supply of oUSD\r\n     */\r\n    function rebase() public whenNotRebasePaused returns (uint256) {\r\n        rebase(true);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the total value of assets held by the Vault and all\r\n     *         strategies and update the supply of oUSD\r\n     */\r\n    function rebase(bool sync) internal whenNotRebasePaused returns (uint256) {\r\n        if (oUSD.totalSupply() == 0) return 0;\r\n        uint256 oldTotalSupply = oUSD.totalSupply();\r\n        uint256 newTotalSupply = _totalValue();\r\n        // Only rachet upwards\r\n        if (newTotalSupply > oldTotalSupply) {\r\n            oUSD.changeSupply(newTotalSupply);\r\n            if (rebaseHooksAddr != address(0)) {\r\n                IRebaseHooks(rebaseHooksAddr).postRebase(sync);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Determine the total value of assets held by the vault and its\r\n     *         strategies.\r\n     * @return uint256 value Total value in USD (1e18)\r\n     */\r\n    function totalValue() external view returns (uint256 value) {\r\n        value = _totalValue();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal Calculate the total value of the assets held by the\r\n     *         vault and its strategies.\r\n     * @return uint256 value Total value in USD (1e18)\r\n     */\r\n    function _totalValue() internal view returns (uint256 value) {\r\n        return _totalValueInVault() + _totalValueInStrategies();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal to calculate total value of all assets held in Vault.\r\n     * @return uint256 Total value in ETH (1e18)\r\n     */\r\n    function _totalValueInVault() internal view returns (uint256 value) {\r\n        value = 0;\r\n        for (uint256 y = 0; y < allAssets.length; y++) {\r\n            IERC20 asset = IERC20(allAssets[y]);\r\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\r\n            uint256 balance = asset.balanceOf(address(this));\r\n            if (balance > 0) {\r\n                value += balance.scaleBy(int8(18 - assetDecimals));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal to calculate total value of all assets held in Strategies.\r\n     * @return uint256 Total value in ETH (1e18)\r\n     */\r\n    function _totalValueInStrategies() internal view returns (uint256 value) {\r\n        value = 0;\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            value += _totalValueInStrategy(allStrategies[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal to calculate total value of all assets held by strategy.\r\n     * @param _strategyAddr Address of the strategy\r\n     * @return uint256 Total value in ETH (1e18)\r\n     */\r\n    function _totalValueInStrategy(address _strategyAddr)\r\n        internal\r\n        view\r\n        returns (uint256 value)\r\n    {\r\n        value = 0;\r\n        IStrategy strategy = IStrategy(_strategyAddr);\r\n        for (uint256 y = 0; y < allAssets.length; y++) {\r\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\r\n            if (strategy.supportsAsset(allAssets[y])) {\r\n                uint256 balance = strategy.checkBalance(allAssets[y]);\r\n                if (balance > 0) {\r\n                    value += balance.scaleBy(int8(18 - assetDecimals));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate difference in percent of asset allocation for a\r\n               strategy.\r\n     * @param _strategyAddr Address of the strategy\r\n     * @return unt256 Difference between current and target. 18 decimals.\r\n     *  NOTE: This is relative value! not the actual percentage\r\n     */\r\n    function _strategyWeightDifference(\r\n        address _strategyAddr,\r\n        address _asset,\r\n        uint256 _modAmount,\r\n        bool deposit\r\n    ) internal view returns (uint256 difference) {\r\n        // Since we are comparing relative weights, we should scale by weight so\r\n        // that even small weights will be triggered, ie 1% versus 20%\r\n        uint256 weight = strategies[_strategyAddr].targetWeight;\r\n        if (weight == 0) return 0;\r\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\r\n        difference =\r\n            MAX_UINT -\r\n            (\r\n                deposit\r\n                    ? _totalValueInStrategy(_strategyAddr).add(\r\n                        _modAmount.scaleBy(int8(18 - assetDecimals))\r\n                    )\r\n                    : _totalValueInStrategy(_strategyAddr).sub(\r\n                        _modAmount.scaleBy(int8(18 - assetDecimals))\r\n                    )\r\n            )\r\n                .divPrecisely(weight);\r\n    }\r\n\r\n    /**\r\n     * @dev Select a strategy for allocating an asset to.\r\n     * @param _asset Address of asset\r\n     * @return address Address of the target strategy\r\n     */\r\n    function _selectDepositStrategyAddr(address _asset, uint256 depositAmount)\r\n        internal\r\n        view\r\n        returns (address depositStrategyAddr)\r\n    {\r\n        depositStrategyAddr = address(0);\r\n        uint256 maxDifference = 0;\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            IStrategy strategy = IStrategy(allStrategies[i]);\r\n            if (strategy.supportsAsset(_asset)) {\r\n                uint256 diff = _strategyWeightDifference(\r\n                    allStrategies[i],\r\n                    _asset,\r\n                    depositAmount,\r\n                    true\r\n                );\r\n                if (diff >= maxDifference) {\r\n                    maxDifference = diff;\r\n                    depositStrategyAddr = allStrategies[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Select a strategy for withdrawing an asset from.\r\n     * @param _asset Address of asset\r\n     * @return address Address of the target strategy for withdrawal\r\n     */\r\n    function _selectWithdrawStrategyAddr(address _asset, uint256 _amount)\r\n        internal\r\n        view\r\n        returns (address withdrawStrategyAddr)\r\n    {\r\n        withdrawStrategyAddr = address(0);\r\n        uint256 minDifference = MAX_UINT;\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            IStrategy strategy = IStrategy(allStrategies[i]);\r\n            if (\r\n                strategy.supportsAsset(_asset) &&\r\n                strategy.checkBalance(_asset) > _amount\r\n            ) {\r\n                uint256 diff = _strategyWeightDifference(\r\n                    allStrategies[i],\r\n                    _asset,\r\n                    _amount,\r\n                    false\r\n                );\r\n                if (diff <= minDifference) {\r\n                    minDifference = diff;\r\n                    withdrawStrategyAddr = allStrategies[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of an asset held in Vault and all strategies.\r\n     * @param _asset Address of asset\r\n     * @return uint256 Balance of asset in decimals of asset\r\n     */\r\n    function checkBalance(address _asset) external view returns (uint256) {\r\n        return _checkBalance(_asset);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of an asset held in Vault and all strategies.\r\n     * @param _asset Address of asset\r\n     * @return uint256 Balance of asset in decimals of asset\r\n     */\r\n    function _checkBalance(address _asset)\r\n        internal\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        IERC20 asset = IERC20(_asset);\r\n        balance = asset.balanceOf(address(this));\r\n        for (uint256 i = 0; i < allStrategies.length; i++) {\r\n            IStrategy strategy = IStrategy(allStrategies[i]);\r\n            if (strategy.supportsAsset(_asset)) {\r\n                balance += strategy.checkBalance(_asset);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of all assets held in Vault and all strategies.\r\n     * @return uint256 Balance of all assets (1e18)\r\n     */\r\n    function _checkBalance() internal view returns (uint256 balance) {\r\n        balance = 0;\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\r\n            balance += _checkBalance(allAssets[i]).scaleBy(\r\n                int8(18 - assetDecimals)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\r\n     * coins that will be returned\r\n     */\r\n    function calculateRedeemOutputs(uint256 _amount)\r\n        external\r\n        returns (uint256[] memory)\r\n    {\r\n        return _calculateRedeemOutputs(_amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\r\n     * coins that will be returned.\r\n     * @return Array of amounts respective to the supported assets\r\n     */\r\n    function _calculateRedeemOutputs(uint256 _amount)\r\n        internal\r\n        returns (uint256[] memory outputs)\r\n    {\r\n        // We always give out coins in proportion to how many we have,\r\n        // Now if all coins were the same value, this math would easy,\r\n        // just take the percentage of each coin, and multiply by the\r\n        // value to be given out. But if coins are worth more than $1,\r\n        // then we would end up handing out too many coins. We need to\r\n        // adjust by the total value of coins.\r\n        //\r\n        // To do this, we total up the value of our coins, by their\r\n        // percentages. Then divide what we would otherwise give out by\r\n        // this number.\r\n        //\r\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\r\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\r\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\r\n        //\r\n        // So when calculating the output, we take the percentage of\r\n        // each coin, times the desired output value, divided by the\r\n        // totalOutputRatio.\r\n        //\r\n        // For example, withdrawing: 30 OUSD:\r\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\r\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\r\n        //\r\n        // Checking these numbers:\r\n        // 9.80 DAI * 1.06 = $10.40\r\n        // 19.60 USDT * 1.00 = $19.60\r\n        //\r\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\r\n\r\n        uint256 assetCount = getAssetCount();\r\n        uint256[] memory assetPrices = _getAssetPrices(true);\r\n        uint256[] memory assetBalances = new uint256[](assetCount);\r\n        uint256[] memory assetDecimals = new uint256[](assetCount);\r\n        uint256 totalBalance = 0;\r\n        uint256 totalOutputRatio = 0;\r\n        outputs = new uint256[](assetCount);\r\n\r\n        // Calculate redeem fee\r\n        if (redeemFeeBps > 0) {\r\n            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);\r\n            _amount = _amount.sub(redeemFee);\r\n        }\r\n\r\n        // Calculate assets balances and decimals once,\r\n        // for a large gas savings.\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            uint256 balance = _checkBalance(allAssets[i]);\r\n            uint256 decimals = Helpers.getDecimals(allAssets[i]);\r\n            assetBalances[i] = balance;\r\n            assetDecimals[i] = decimals;\r\n            totalBalance += balance.scaleBy(int8(18 - decimals));\r\n        }\r\n        // Calculate totalOutputRatio\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            uint256 price = assetPrices[i];\r\n            // Never give out more than one\r\n            // stablecoin per dollar of OUSD\r\n            if (price < 1e18) {\r\n                price = 1e18;\r\n            }\r\n            uint256 ratio = assetBalances[i]\r\n                .scaleBy(int8(18 - assetDecimals[i]))\r\n                .mul(price)\r\n                .div(totalBalance);\r\n            totalOutputRatio += ratio;\r\n        }\r\n        // Calculate final outputs\r\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            outputs[i] = assetBalances[i].mul(factor).div(totalBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get an array of the supported asset prices in USD.\r\n     * @return uint256[] Array of asset prices in USD (1e18)\r\n     */\r\n    function _getAssetPrices(bool useMax)\r\n        internal\r\n        returns (uint256[] memory assetPrices)\r\n    {\r\n        assetPrices = new uint256[](getAssetCount());\r\n\r\n        IMinMaxOracle oracle = IMinMaxOracle(priceProvider);\r\n        // Price from Oracle is returned with 8 decimals\r\n        // _amount is in assetDecimals\r\n\r\n        for (uint256 i = 0; i < allAssets.length; i++) {\r\n            string memory symbol = Helpers.getSymbol(allAssets[i]);\r\n            // Get all the USD prices of the asset in 1e18\r\n            if (useMax) {\r\n                assetPrices[i] = oracle.priceMax(symbol).scaleBy(int8(18 - 8));\r\n            } else {\r\n                assetPrices[i] = oracle.priceMin(symbol).scaleBy(int8(18 - 8));\r\n            }\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    Utils\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Return the number of assets suppported by the Vault.\r\n     */\r\n    function getAssetCount() public view returns (uint256) {\r\n        return allAssets.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Return all asset addresses in order\r\n     */\r\n    function getAllAssets() external view returns (address[] memory) {\r\n        return allAssets;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the number of strategies active on the Vault.\r\n     */\r\n    function getStrategyCount() public view returns (uint256) {\r\n        return allStrategies.length;\r\n    }\r\n\r\n    function isSupportedAsset(address _asset) external view returns (bool) {\r\n        return assets[_asset].isSupported;\r\n    }\r\n\r\n    /**\r\n     * @dev Falldown to the admin implementation\r\n     * @notice This is a catch all for all functions not declared in core\r\n     */\r\n    function() external payable {\r\n        bytes32 slot = adminImplPosition;\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, sload(slot), 0, calldatasize, 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n                // delegatecall returns 0 on error.\r\n                case 0 {\r\n                    revert(0, returndatasize)\r\n                }\r\n                default {\r\n                    return(0, returndatasize)\r\n                }\r\n        }\r\n    }\r\n}"}
{"address": "0x77f973fcaf871459aa58cd81881ce453759281bc", "attacktype": "Other unfair or unsafe DeFi protocol interaction, Absence of code logic or sanity check", "sourcecode": "/**\r\n * Copyright 2017-2019, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n \r\npragma solidity 0.5.8;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract WETHInterface is ERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n  */\r\n  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return ((_a - 1) / _b) + 1;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n  /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n  uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n  /// @dev Constant for locked guard state\r\n  uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one `nonReentrant` function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and an `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n    reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n    _;\r\n    reentrancyLock = REENTRANCY_GUARD_FREE;\r\n  }\r\n\r\n}\r\n\r\ncontract LoanTokenization is ReentrancyGuard, Ownable {\r\n\r\n    uint256 internal constant MAX_UINT = 2**256 - 1;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public bZxContract;\r\n    address public bZxVault;\r\n    address public bZxOracle;\r\n    address public wethContract;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    // price of token at last user checkpoint\r\n    mapping (address => uint256) internal checkpointPrices_;\r\n}\r\n\r\ncontract LoanTokenStorage is LoanTokenization {\r\n\r\n    struct ListIndex {\r\n        uint256 index;\r\n        bool isSet;\r\n    }\r\n\r\n    struct LoanData {\r\n        bytes32 loanOrderHash;\r\n        uint256 leverageAmount;\r\n        uint256 initialMarginAmount;\r\n        uint256 maintenanceMarginAmount;\r\n        uint256 maxDurationUnixTimestampSec;\r\n        uint256 index;\r\n    }\r\n\r\n    struct TokenReserves {\r\n        address lender;\r\n        uint256 amount;\r\n    }\r\n\r\n    event Borrow(\r\n        address indexed borrower,\r\n        uint256 borrowAmount,\r\n        uint256 interestRate,\r\n        address collateralTokenAddress,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen\r\n    );\r\n\r\n    event Claim(\r\n        address indexed claimant,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 remainingTokenAmount,\r\n        uint256 price\r\n    );\r\n\r\n    bool internal isInitialized_ = false;\r\n\r\n    address public tokenizedRegistry;\r\n\r\n    uint256 public baseRate = 1000000000000000000; // 1.0%\r\n    uint256 public rateMultiplier = 39000000000000000000; // 39%\r\n\r\n    // \"fee percentage retained by the oracle\" = SafeMath.sub(10**20, spreadMultiplier);\r\n    uint256 public spreadMultiplier;\r\n\r\n    mapping (uint256 => bytes32) public loanOrderHashes; // mapping of levergeAmount to loanOrderHash\r\n    mapping (bytes32 => LoanData) public loanOrderData; // mapping of loanOrderHash to LoanOrder\r\n    uint256[] public leverageList;\r\n\r\n    TokenReserves[] public burntTokenReserveList; // array of TokenReserves\r\n    mapping (address => ListIndex) public burntTokenReserveListIndex; // mapping of lender address to ListIndex objects\r\n    uint256 public burntTokenReserved; // total outstanding burnt token amount\r\n    address internal nextOwedLender_;\r\n\r\n    uint256 public totalAssetBorrow = 0; // current amount of loan token amount tied up in loans\r\n\r\n    uint256 internal checkpointSupply_;\r\n\r\n    uint256 internal lastSettleTime_;\r\n\r\n    uint256 public initialPrice;\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract LoanToken is AdvancedTokenStorage {\r\n\r\n    address internal target_;\r\n\r\n    constructor(\r\n        address _newTarget)\r\n        public\r\n    {\r\n        _setTarget(_newTarget);\r\n    }\r\n\r\n    function()\r\n        external\r\n        payable\r\n    {\r\n        address target = target_;\r\n        bytes memory data = msg.data;\r\n        assembly {\r\n            let result := delegatecall(gas, target, add(data, 0x20), mload(data), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n\r\n    function setTarget(\r\n        address _newTarget)\r\n        public\r\n        onlyOwner\r\n    {\r\n        _setTarget(_newTarget);\r\n    }\r\n\r\n    function _setTarget(\r\n        address _newTarget)\r\n        internal\r\n    {\r\n        require(_isContract(_newTarget), \"target not a contract\");\r\n        target_ = _newTarget;\r\n    }\r\n\r\n    function _isContract(\r\n        address addr)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}"}
{"address": "0xde744d544a9d768e96c21b5f087fc54b776e9b25", "attacktype": "Absence of code logic or sanity check", "sourcecode": "/**\r\n * Copyright 2017-2020, bZeroX, LLC <https://bzx.network/>. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IWeth {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\ncontract IERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract IWethERC20 is IWeth, IERC20 {}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n    */\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divCeil(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n    */\r\n    function divCeil(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = ((a - 1) / b) + 1;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n        /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n    /// @dev Constant for locked guard state\r\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n    /**\r\n    * @dev We use a single lock for the whole contract.\r\n    */\r\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n    /**\r\n    * @dev Prevents a contract from calling itself, directly or indirectly.\r\n    * If you mark a function `nonReentrant`, you should also\r\n    * mark it `external`. Calling one `nonReentrant` function from\r\n    * another is not supported. Instead, you can implement a\r\n    * `private` function doing the actual work, and an `external`\r\n    * wrapper marked as `nonReentrant`.\r\n    */\r\n    modifier nonReentrant() {\r\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n        _;\r\n        reentrancyLock = REENTRANCY_GUARD_FREE;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ProtocolLike {\r\n    function borrowOrTradeFromPool(\r\n        bytes32 loanParamsId,\r\n        bytes32 loanId, // if 0, start a new loan\r\n        bool isTorqueLoan,\r\n        uint256 initialMargin,\r\n        address[4] calldata sentAddresses,\r\n            // lender: must match loan if loanId provided\r\n            // borrower: must match loan if loanId provided\r\n            // receiver: receiver of funds (address(0) assumes borrower address)\r\n            // manager: delegated manager of loan unless address(0)\r\n        uint256[5] calldata sentValues,\r\n            // newRate: new loan interest rate\r\n            // newPrincipal: new loan size (borrowAmount + any borrowed interest)\r\n            // torqueInterest: new amount of interest to escrow for Torque loan (determines initial loan length)\r\n            // loanTokenReceived: total loanToken deposit (amount not sent to borrower in the case of Torque loans)\r\n            // collateralTokenReceived: total collateralToken deposit\r\n        bytes calldata loanDataBytes)\r\n        external\r\n        payable\r\n        returns (uint256 newPrincipal, uint256 newCollateral);\r\n\r\n    function getTotalPrincipal(\r\n        address lender,\r\n        address loanToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function withdrawAccruedInterest(\r\n        address loanToken)\r\n        external;\r\n\r\n    function getLenderInterestData(\r\n        address lender,\r\n        address loanToken)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 interestPaid,\r\n            uint256 interestPaidDate,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid,\r\n            uint256 interestFeePercent,\r\n            uint256 principalTotal);\r\n\r\n    function priceFeeds()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getEstimatedMarginExposure(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        uint256 interestRate,\r\n        uint256 newPrincipal)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRequiredCollateralByParams(\r\n        bytes32 loanParamsId,\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 newPrincipal,\r\n        bool isTorqueLoan)\r\n        external\r\n        view\r\n        returns (uint256 collateralAmountRequired);\r\n\r\n    function getBorrowAmountByParams(\r\n        bytes32 loanParamsId,\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 collateralTokenAmount,\r\n        bool isTorqueLoan)\r\n        external\r\n        view\r\n        returns (uint256 borrowAmount);\r\n\r\n    function isLoanPool(\r\n        address loanPool)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function lendingFeePercent()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface FeedsLike {\r\n    function queryRate(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress)\r\n        external\r\n        view\r\n        returns (uint256 rate, uint256 precision);\r\n}\r\n\r\ncontract ITokenHolderLike {\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function freeUpTo(uint256 value) public returns (uint256);\r\n    function freeFromUpTo(address from, uint256 value) public returns (uint256);\r\n}\r\n\r\ncontract GasTokenUser {\r\n\r\n    ITokenHolderLike constant public gasToken = ITokenHolderLike(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    ITokenHolderLike constant public tokenHolder = ITokenHolderLike(0x55Eb3DD3f738cfdda986B8Eff3fa784477552C61);\r\n\r\n    modifier usesGasToken(address holder) {\r\n        if (holder == address(0)) {\r\n            holder = address(tokenHolder);\r\n        }\r\n\r\n        if (gasToken.balanceOf(holder) != 0) {\r\n            uint256 gasCalcValue = gasleft();\r\n\r\n            _;\r\n\r\n            gasCalcValue = (_gasUsed(gasCalcValue) + 14154) / 41947;\r\n\r\n            if (holder == address(tokenHolder)) {\r\n                tokenHolder.freeUpTo(\r\n                    gasCalcValue\r\n                );\r\n            } else {\r\n                tokenHolder.freeFromUpTo(\r\n                    holder,\r\n                    gasCalcValue\r\n                );\r\n            }\r\n\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function _gasUsed(\r\n        uint256 startingGas)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return 21000 +\r\n            startingGas -\r\n            gasleft() +\r\n            16 *\r\n            msg.data.length;\r\n\r\n    }\r\n}\r\n\r\ncontract Pausable {\r\n\r\n    // keccak256(\"Pausable_FunctionPause\")\r\n    bytes32 internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047;\r\n\r\n    modifier pausable(bytes4 sig) {\r\n        require(!_isPaused(sig), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function _isPaused(\r\n        bytes4 sig)\r\n        internal\r\n        view\r\n        returns (bool isPaused)\r\n    {\r\n        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanTokenBase is ReentrancyGuard, Ownable, Pausable {\r\n\r\n    uint256 internal constant WEI_PRECISION = 10**18;\r\n    uint256 internal constant WEI_PERCENT_PRECISION = 10**20;\r\n\r\n    int256 internal constant sWEI_PRECISION = 10**18;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    // uint88 for tight packing -> 8 + 88 + 160 = 256\r\n    uint88 internal lastSettleTime_;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    uint256 public baseRate;\r\n    uint256 public rateMultiplier;\r\n    uint256 public lowUtilBaseRate;\r\n    uint256 public lowUtilRateMultiplier;\r\n\r\n    uint256 public targetLevel;\r\n    uint256 public kinkLevel;\r\n    uint256 public maxScaleRate;\r\n\r\n    uint256 internal _flTotalAssetSupply;\r\n    uint256 public checkpointSupply;\r\n    uint256 public initialPrice;\r\n\r\n    mapping (uint256 => bytes32) public loanParamsIds; // mapping of keccak256(collateralToken, isTorqueLoan) to loanParamsId\r\n    mapping (address => uint256) internal checkpointPrices_; // price of token at last user checkpoint\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenBase {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 _allowed = allowed[msg.sender][_spender]\r\n            .add(_addedValue);\r\n        allowed[msg.sender][_spender] = _allowed;\r\n\r\n        emit Approval(msg.sender, _spender, _allowed);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 _allowed = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= _allowed) {\r\n            _allowed = 0;\r\n        } else {\r\n            _allowed -= _subtractedValue;\r\n        }\r\n        allowed[msg.sender][_spender] = _allowed;\r\n\r\n        emit Approval(msg.sender, _spender, _allowed);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        require(_to != address(0), \"15\");\r\n\r\n        uint256 _balance = balances[_to]\r\n            .add(_tokenAmount);\r\n        balances[_to] = _balance;\r\n\r\n        totalSupply_ = totalSupply_\r\n            .add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 _balance = balances[_who].sub(_tokenAmount, \"16\");\r\n        \r\n        // a rounding error may leave dust behind, so we clear this out\r\n        if (_balance <= 10) {\r\n            _tokenAmount = _tokenAmount.add(_balance);\r\n            _balance = 0;\r\n        }\r\n        balances[_who] = _balance;\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n}\r\n\r\ncontract LoanTokenLogicStandard is AdvancedToken, GasTokenUser {\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    modifier settlesInterest() {\r\n        _settleInterest();\r\n        _;\r\n    }\r\n\r\n    address internal target_;\r\n\r\n    uint256 public constant VERSION = 6;\r\n    address internal constant arbitraryCaller = 0x000F400e6818158D541C3EBE45FE3AA0d47372FF;\r\n\r\n    address public constant bZxContract = 0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f;\r\n    address public constant wethToken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    bytes32 internal constant iToken_ProfitSoFar = 0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6;          // keccak256(\"iToken_ProfitSoFar\")\r\n    bytes32 internal constant iToken_LowerAdminAddress = 0x7ad06df6a0af6bd602d90db766e0d5f253b45187c3717a0f9026ea8b10ff0d4b;    // keccak256(\"iToken_LowerAdminAddress\")\r\n    bytes32 internal constant iToken_LowerAdminContract = 0x34b31cff1dbd8374124bd4505521fc29cab0f9554a5386ba7d784a4e611c7e31;   // keccak256(\"iToken_LowerAdminContract\")\r\n\r\n\r\n    constructor(\r\n        address _newOwner)\r\n        public\r\n    {\r\n        transferOwnership(_newOwner);\r\n    }\r\n\r\n    function()\r\n        external\r\n    {\r\n        revert(\"fallback not allowed\");\r\n    }\r\n\r\n    /* Public functions */\r\n\r\n    function mint(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256) // mintAmount\r\n    {\r\n        return _mintToken(\r\n            receiver,\r\n            depositAmount\r\n        );\r\n    }\r\n\r\n    function burn(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid != 0) {\r\n            _safeTransfer(loanTokenAddress, receiver, loanAmountPaid, \"5\");\r\n        }\r\n    }\r\n\r\n    function flashBorrow(\r\n        uint256 borrowAmount,\r\n        address borrower,\r\n        address target,\r\n        string calldata signature,\r\n        bytes calldata data)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        pausable(msg.sig)\r\n        settlesInterest\r\n        returns (bytes memory)\r\n    {\r\n        require(borrowAmount != 0, \"38\");\r\n\r\n        // save before balances\r\n        uint256 beforeEtherBalance = address(this).balance.sub(msg.value);\r\n        uint256 beforeAssetsBalance = _underlyingBalance()\r\n            .add(totalAssetBorrow());\r\n\r\n        // lock totalAssetSupply for duration of flash loan\r\n        _flTotalAssetSupply = beforeAssetsBalance;\r\n\r\n        // transfer assets to calling contract\r\n        _safeTransfer(loanTokenAddress, borrower, borrowAmount, \"39\");\r\n\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // arbitrary call\r\n        (bool success, bytes memory returnData) = arbitraryCaller.call.value(msg.value)(\r\n            abi.encodeWithSelector(\r\n                0xde064e0d, // sendCall(address,bytes)\r\n                target,\r\n                callData\r\n            )\r\n        );\r\n        require(success, \"call failed\");\r\n\r\n        // unlock totalAssetSupply\r\n        _flTotalAssetSupply = 0;\r\n\r\n        // verifies return of flash loan\r\n        require(\r\n            address(this).balance >= beforeEtherBalance &&\r\n            _underlyingBalance()\r\n                .add(totalAssetBorrow()) >= beforeAssetsBalance,\r\n            \"40\"\r\n        );\r\n\r\n        return returnData;\r\n    }\r\n\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function borrow(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\r\n        public\r\n        payable\r\n        returns (uint256, uint256) // returns new principal and new collateral added to loan\r\n    {\r\n        return _borrow(\r\n            loanId,\r\n            withdrawAmount,\r\n            initialLoanDuration,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            borrower,\r\n            receiver,\r\n            \"\"\r\n        );\r\n    }\r\n\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function borrowWithGasToken(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        address gasTokenUser,           // specifies an address that has given spend approval for gas/chi token\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\r\n        public\r\n        payable\r\n        usesGasToken(gasTokenUser)\r\n        returns (uint256, uint256) // returns new principal and new collateral added to loan\r\n    {\r\n        return _borrow(\r\n            loanId,\r\n            withdrawAmount,\r\n            initialLoanDuration,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            borrower,\r\n            receiver,\r\n            \"\"\r\n        );\r\n    }\r\n\r\n    // Called to borrow and immediately get into a position\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function marginTrade(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        bytes memory loanDataBytes)     // arbitrary order data\r\n        public\r\n        payable\r\n        returns (uint256, uint256) // returns new principal and new collateral added to trade\r\n    {\r\n        return _marginTrade(\r\n            loanId,\r\n            leverageAmount,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            trader,\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    // Called to borrow and immediately get into a position\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function marginTradeWithGasToken(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        address gasTokenUser,           // specifies an address that has given spend approval for gas/chi token\r\n        bytes memory loanDataBytes)     // arbitrary order data\r\n        public\r\n        payable\r\n        usesGasToken(gasTokenUser)\r\n        returns (uint256, uint256) // returns new principal and new collateral added to trade\r\n    {\r\n        return _marginTrade(\r\n            loanId,\r\n            leverageAmount,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            trader,\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return _internalTransferFrom(\r\n            msg.sender,\r\n            _to,\r\n            _value,\r\n            uint256(-1)\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return _internalTransferFrom(\r\n            _from,\r\n            _to,\r\n            _value,\r\n            allowed[_from][msg.sender]\r\n            /*ProtocolLike(bZxContract).isLoanPool(msg.sender) ?\r\n                uint256(-1) :\r\n                allowed[_from][msg.sender]*/\r\n        );\r\n    }\r\n\r\n    function _internalTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _allowanceAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (_allowanceAmount != uint256(-1)) {\r\n            allowed[_from][msg.sender] = _allowanceAmount.sub(_value, \"14\");\r\n        }\r\n\r\n        uint256 _balancesFrom = balances[_from];\r\n        uint256 _balancesTo = balances[_to];\r\n\r\n        require(_to != address(0), \"15\");\r\n\r\n        uint256 _balancesFromNew = _balancesFrom\r\n            .sub(_value, \"16\");\r\n        balances[_from] = _balancesFromNew;\r\n\r\n        uint256 _balancesToNew = _balancesTo\r\n            .add(_value);\r\n        balances[_to] = _balancesToNew;\r\n\r\n        // handle checkpoint update\r\n        uint256 _currentPrice = tokenPrice();\r\n\r\n        _updateCheckpoints(\r\n            _from,\r\n            _balancesFrom,\r\n            _balancesFromNew,\r\n            _currentPrice\r\n        );\r\n        _updateCheckpoints(\r\n            _to,\r\n            _balancesTo,\r\n            _balancesToNew,\r\n            _currentPrice\r\n        );\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function _updateCheckpoints(\r\n        address _user,\r\n        uint256 _oldBalance,\r\n        uint256 _newBalance,\r\n        uint256 _currentPrice)\r\n        internal\r\n    {\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(_user, iToken_ProfitSoFar)\r\n        );\r\n\r\n        int256 _currentProfit;\r\n        if (_newBalance == 0) {\r\n            _currentPrice = 0;\r\n        } else if (_oldBalance != 0) {\r\n            _currentProfit = _profitOf(\r\n                slot,\r\n                _oldBalance,\r\n                _currentPrice,\r\n                checkpointPrices_[_user]\r\n            );\r\n        }\r\n\r\n        assembly {\r\n            sstore(slot, _currentProfit)\r\n        }\r\n\r\n        checkpointPrices_[_user] = _currentPrice;\r\n    }\r\n\r\n    /* Public View functions */\r\n\r\n    function profitOf(\r\n        address user)\r\n        public\r\n        view\r\n        returns (int256)\r\n    {\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(user, iToken_ProfitSoFar)\r\n        );\r\n\r\n        return _profitOf(\r\n            slot,\r\n            balances[user],\r\n            tokenPrice(),\r\n            checkpointPrices_[user]\r\n        );\r\n    }\r\n\r\n    function _profitOf(\r\n        bytes32 slot,\r\n        uint256 _balance,\r\n        uint256 _currentPrice,\r\n        uint256 _checkpointPrice)\r\n        internal\r\n        view\r\n        returns (int256 profitSoFar)\r\n    {\r\n        if (_checkpointPrice == 0) {\r\n            return 0;\r\n        }\r\n\r\n        assembly {\r\n            profitSoFar := sload(slot)\r\n        }\r\n\r\n        profitSoFar = int256(_currentPrice)\r\n            .sub(int256(_checkpointPrice))\r\n            .mul(int256(_balance))\r\n            .div(sWEI_PRECISION)\r\n            .add(profitSoFar);\r\n    }\r\n\r\n    function tokenPrice()\r\n        public\r\n        view\r\n        returns (uint256) // price\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _tokenPrice(_totalAssetSupply(interestUnPaid));\r\n    }\r\n\r\n    function checkpointPrice(\r\n        address _user)\r\n        public\r\n        view\r\n        returns (uint256) // price\r\n    {\r\n        return checkpointPrices_[_user];\r\n    }\r\n\r\n    function marketLiquidity()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalSupply = _totalAssetSupply(0);\r\n        uint256 totalBorrow = totalAssetBorrow();\r\n        if (totalSupply > totalBorrow) {\r\n            return totalSupply - totalBorrow;\r\n        }\r\n    }\r\n\r\n    function avgBorrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _avgBorrowInterestRate(totalAssetBorrow());\r\n    }\r\n\r\n    // the minimum rate the next base protocol borrower will receive for variable-rate loans\r\n    function borrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(0);\r\n    }\r\n\r\n    function nextBorrowInterestRate(\r\n        uint256 borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(borrowAmount);\r\n    }\r\n\r\n    // interest that lenders are currently receiving when supplying to the pool\r\n    function supplyInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0));\r\n    }\r\n\r\n    function nextSupplyInterestRate(\r\n        uint256 supplyAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0).add(supplyAmount));\r\n    }\r\n\r\n    function totalSupplyInterestRate(\r\n        uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetBorrow = totalAssetBorrow();\r\n        if (assetBorrow != 0) {\r\n            return _supplyInterestRate(\r\n                assetBorrow,\r\n                assetSupply\r\n            );\r\n        }\r\n    }\r\n\r\n    function totalAssetBorrow()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ProtocolLike(bZxContract).getTotalPrincipal(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n    }\r\n\r\n    function totalAssetSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _totalAssetSupply(interestUnPaid);\r\n    }\r\n\r\n    function getMaxEscrowAmount(\r\n        uint256 leverageAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 initialMargin = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\r\n        return marketLiquidity()\r\n            .mul(initialMargin)\r\n            .div(_adjustValue(\r\n                WEI_PERCENT_PRECISION, // maximum possible interest (100%)\r\n                2419200, // 28 day duration for margin trades\r\n                initialMargin));\r\n    }\r\n\r\n    // returns the user's balance of underlying token\r\n    function assetBalanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOf(_owner)\r\n            .mul(tokenPrice())\r\n            .div(WEI_PRECISION);\r\n    }\r\n\r\n    function getEstimatedMarginDetails(\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 principal, uint256 collateral, uint256 interestRate)\r\n    {\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wethToken;\r\n        }\r\n\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n\r\n        (principal, interestRate) = _getMarginBorrowAmountAndRate(\r\n            leverageAmount,\r\n            totalDeposit\r\n        );\r\n        if (principal > _underlyingBalance()) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        loanTokenSent = loanTokenSent\r\n            .add(principal);\r\n\r\n        collateral = ProtocolLike(bZxContract).getEstimatedMarginExposure(\r\n            loanTokenAddress,\r\n            collateralTokenAddress,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            interestRate,\r\n            principal\r\n        );\r\n    }\r\n\r\n    function getDepositAmountForBorrow(\r\n        uint256 borrowAmount,\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256) // depositAmount\r\n    {\r\n        if (borrowAmount != 0) {\r\n            (,,uint256 newBorrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (newBorrowAmount <= _underlyingBalance()) {\r\n                return ProtocolLike(bZxContract).getRequiredCollateralByParams(\r\n                    loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n                        collateralTokenAddress,\r\n                        true\r\n                    )))],\r\n                    loanTokenAddress,\r\n                    collateralTokenAddress != address(0) ? collateralTokenAddress : wethToken,\r\n                    newBorrowAmount,\r\n                    true // isTorqueLoan\r\n                ).add(10); // some dust to compensate for rounding errors\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBorrowAmountForDeposit(\r\n        uint256 depositAmount,\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 borrowAmount)\r\n    {\r\n        if (depositAmount != 0) {\r\n            borrowAmount = ProtocolLike(bZxContract).getBorrowAmountByParams(\r\n                loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n                    collateralTokenAddress,\r\n                    true\r\n                )))],\r\n                loanTokenAddress,\r\n                collateralTokenAddress != address(0) ? collateralTokenAddress : wethToken,\r\n                depositAmount,\r\n                true // isTorqueLoan\r\n            );\r\n\r\n            (,,borrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (borrowAmount > _underlyingBalance()) {\r\n                borrowAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /* Internal functions */\r\n\r\n    function _mintToken(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        internal\r\n        settlesInterest\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require (depositAmount != 0, \"17\");\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n        mintAmount = depositAmount\r\n            .mul(WEI_PRECISION)\r\n            .div(currentPrice);\r\n\r\n        if (msg.value == 0) {\r\n            _safeTransferFrom(loanTokenAddress, msg.sender, address(this), depositAmount, \"18\");\r\n        } else {\r\n            require(msg.value == depositAmount, \"18\");\r\n            IWeth(wethToken).deposit.value(depositAmount)();\r\n        }\r\n\r\n        _updateCheckpoints(\r\n            receiver,\r\n            balances[receiver],\r\n            _mint(receiver, mintAmount, depositAmount, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _burnToken(\r\n        uint256 burnAmount)\r\n        internal\r\n        settlesInterest\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(burnAmount != 0, \"19\");\r\n\r\n        if (burnAmount > balanceOf(msg.sender)) {\r\n            require(burnAmount == uint256(-1), \"32\");\r\n            burnAmount = balanceOf(msg.sender);\r\n        }\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 loanAmountOwed = burnAmount\r\n            .mul(currentPrice)\r\n            .div(WEI_PRECISION);\r\n        uint256 loanAmountAvailableInContract = _underlyingBalance();\r\n\r\n        loanAmountPaid = loanAmountOwed;\r\n        require(loanAmountPaid <= loanAmountAvailableInContract, \"37\");\r\n\r\n        _updateCheckpoints(\r\n            msg.sender,\r\n            balances[msg.sender],\r\n            _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _borrow(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\r\n        internal\r\n        pausable(msg.sig)\r\n        settlesInterest\r\n        returns (uint256, uint256) // returns new principal and new collateral added to loan\r\n    {\r\n        require(withdrawAmount != 0, \"6\");\r\n\r\n        require(msg.value == 0 || msg.value == collateralTokenSent, \"7\");\r\n        require(collateralTokenSent != 0 || loanId != 0, \"8\");\r\n        require(collateralTokenAddress != address(0) || msg.value != 0 || loanId != 0, \"9\");\r\n\r\n        // ensures authorized use of existing loan\r\n        require(loanId == 0 || msg.sender == borrower, \"13\");\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wethToken;\r\n        }\r\n        require(collateralTokenAddress != loanTokenAddress, \"10\");\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = borrower;\r\n        sentAddresses[2] = receiver;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        //sentAmounts[0] = 0; // interestRate (found later)\r\n        //sentAmounts[1] = 0; // borrowAmount (found later)\r\n        //sentAmounts[2] = 0; // interestInitialAmount (found later)\r\n        //sentAmounts[3] = 0; // loanTokenSent\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        // interestRate, interestInitialAmount, borrowAmount (newBorrowAmount)\r\n        (sentAmounts[0], sentAmounts[2], sentAmounts[1]) = _getInterestRateAndBorrowAmount(\r\n            withdrawAmount,\r\n            _totalAssetSupply(0), // interest is settled above\r\n            initialLoanDuration\r\n        );\r\n\r\n        return _borrowOrTrade(\r\n            loanId,\r\n            withdrawAmount,\r\n            0, // leverageAmount (calculated later)\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            \"\" // loanDataBytes\r\n        );\r\n    }\r\n\r\n    function _marginTrade(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        pausable(msg.sig)\r\n        settlesInterest\r\n        returns (uint256, uint256) // returns new principal and new collateral added to trade\r\n    {\r\n        // ensures authorized use of existing loan\r\n        require(loanId == 0 || msg.sender == trader, \"13\");\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wethToken;\r\n        }\r\n        require(collateralTokenAddress != loanTokenAddress, \"11\");\r\n\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n        require(totalDeposit != 0, \"12\");\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = trader;\r\n        sentAddresses[2] = trader;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        //sentAmounts[0] = 0; // interestRate (found later)\r\n        //sentAmounts[1] = 0; // borrowAmount (found later)\r\n        //sentAmounts[2] = 0; // interestInitialAmount (interest is calculated based on fixed-term loan)\r\n        sentAmounts[3] = loanTokenSent;\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        (sentAmounts[1], sentAmounts[0]) = _getMarginBorrowAmountAndRate( // borrowAmount, interestRate\r\n            leverageAmount,\r\n            totalDeposit\r\n        );\r\n\r\n        return _borrowOrTrade(\r\n            loanId,\r\n            0, // withdrawAmount\r\n            leverageAmount,\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    function _settleInterest()\r\n        internal\r\n    {\r\n        uint88 ts = uint88(block.timestamp);\r\n        if (lastSettleTime_ != ts) {\r\n            ProtocolLike(bZxContract).withdrawAccruedInterest(\r\n                loanTokenAddress\r\n            );\r\n\r\n            lastSettleTime_ = ts;\r\n        }\r\n    }\r\n\r\n    function _totalDeposit(\r\n        address collateralTokenAddress,\r\n        uint256 collateralTokenSent,\r\n        uint256 loanTokenSent)\r\n        internal\r\n        view\r\n        returns (uint256 totalDeposit)\r\n    {\r\n        totalDeposit = loanTokenSent;\r\n        if (collateralTokenSent != 0) {\r\n            (uint256 sourceToDestRate, uint256 sourceToDestPrecision) = FeedsLike(ProtocolLike(bZxContract).priceFeeds()).queryRate(\r\n                collateralTokenAddress,\r\n                loanTokenAddress\r\n            );\r\n            if (sourceToDestRate != 0) {\r\n                totalDeposit = collateralTokenSent\r\n                    .mul(sourceToDestRate)\r\n                    .div(sourceToDestPrecision)\r\n                    .add(totalDeposit);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getInterestRateAndBorrowAmount(\r\n        uint256 borrowAmount,\r\n        uint256 assetSupply,\r\n        uint256 initialLoanDuration) // duration in seconds\r\n        internal\r\n        view\r\n        returns (uint256 interestRate, uint256 interestInitialAmount, uint256 newBorrowAmount)\r\n    {\r\n        interestRate = _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            assetSupply\r\n        );\r\n\r\n        // newBorrowAmount = borrowAmount * 10^18 / (10^18 - (interestRate * initialLoanDuration * 10^18 / (31536000 * 10^20)))\r\n        newBorrowAmount = borrowAmount\r\n            .mul(WEI_PRECISION)\r\n            .div(\r\n                SafeMath.sub(WEI_PRECISION,\r\n                    interestRate\r\n                        .mul(initialLoanDuration)\r\n                        .mul(WEI_PRECISION)\r\n                        .div(31536000 * WEI_PERCENT_PRECISION) // 365 * 86400 * WEI_PERCENT_PRECISION\r\n                )\r\n            );\r\n\r\n        interestInitialAmount = newBorrowAmount\r\n            .sub(borrowAmount);\r\n    }\r\n\r\n    // returns newPrincipal\r\n    function _borrowOrTrade(\r\n        bytes32 loanId,\r\n        uint256 withdrawAmount,\r\n        uint256 leverageAmount,\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        require (sentAmounts[1] <= _underlyingBalance() && // newPrincipal\r\n            sentAddresses[1] != address(0), // borrower\r\n            \"24\"\r\n        );\r\n\r\n\t    if (sentAddresses[2] == address(0)) {\r\n            sentAddresses[2] = sentAddresses[1]; // receiver = borrower\r\n        }\r\n\r\n        // handle transfers prior to adding newPrincipal to loanTokenSent\r\n        uint256 msgValue = _verifyTransfers(\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            withdrawAmount\r\n        );\r\n\r\n        // adding the loan token portion from the lender to loanTokenSent\r\n        sentAmounts[3] = sentAmounts[3]\r\n            .add(sentAmounts[1]); // newPrincipal\r\n\r\n        if (withdrawAmount != 0) {\r\n            // withdrawAmount already sent to the borrower, so we aren't sending it to the protocol\r\n            sentAmounts[3] = sentAmounts[3]\r\n                .sub(withdrawAmount);\r\n        }\r\n\r\n        bool isTorqueLoan = withdrawAmount != 0 ?\r\n            true :\r\n            false;\r\n\r\n        bytes32 loanParamsId = loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n            collateralTokenAddress,\r\n            isTorqueLoan\r\n        )))];\r\n\r\n        // converting to initialMargin\r\n        if (leverageAmount != 0) {\r\n            leverageAmount = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\r\n        }\r\n\r\n        (sentAmounts[1], sentAmounts[4]) = ProtocolLike(bZxContract).borrowOrTradeFromPool.value(msgValue)( // newPrincipal, newCollateral\r\n            loanParamsId,\r\n            loanId,\r\n            isTorqueLoan,\r\n            leverageAmount, // initialMargin\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n        require (sentAmounts[1] != 0, \"25\");\r\n\r\n        return (sentAmounts[1], sentAmounts[4]); // newPrincipal, newCollateral\r\n    }\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount)\r\n        internal\r\n        returns (uint256 msgValue)\r\n    {\r\n        address _wethToken = wethToken;\r\n        address _loanTokenAddress = loanTokenAddress;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) { // withdrawOnOpen == true\r\n            _safeTransfer(_loanTokenAddress, receiver, withdrawalAmount, \"27\");\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal - withdrawalAmount, \"27\");\r\n            }\r\n        } else {\r\n            _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal, \"27\");\r\n        }\r\n\r\n        if (collateralTokenSent != 0) {\r\n            if (collateralTokenAddress == _wethToken && msgValue != 0 && msgValue >= collateralTokenSent) {\r\n                IWeth(_wethToken).deposit.value(collateralTokenSent)();\r\n                _safeTransfer(collateralTokenAddress, bZxContract, collateralTokenSent, \"28\");\r\n                msgValue -= collateralTokenSent;\r\n            } else {\r\n                _safeTransferFrom(collateralTokenAddress, msg.sender, bZxContract, collateralTokenSent, \"28\");\r\n            }\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            _safeTransferFrom(_loanTokenAddress, msg.sender, bZxContract, loanTokenSent, \"29\");\r\n        }\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(IERC20(token).transfer.selector, to, amount),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, amount),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(\r\n        address token,\r\n        bytes memory data,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        (bool success, bytes memory returndata) = token.call(data);\r\n        require(success, errorMsg);\r\n\r\n        if (returndata.length != 0) {\r\n            require(abi.decode(returndata, (bool)), errorMsg);\r\n        }\r\n    }\r\n\r\n    function _underlyingBalance()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return IERC20(loanTokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    /* Internal View functions */\r\n\r\n    function _tokenPrice(\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalTokenSupply = totalSupply_;\r\n\r\n        return totalTokenSupply != 0 ?\r\n            assetSupply\r\n                .mul(WEI_PRECISION)\r\n                .div(totalTokenSupply) : initialPrice;\r\n    }\r\n\r\n    function _avgBorrowInterestRate(\r\n        uint256 assetBorrow)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0) {\r\n            (uint256 interestOwedPerDay,) = _getAllInterest();\r\n            return interestOwedPerDay\r\n                .mul(365 * WEI_PERCENT_PRECISION)\r\n                .div(assetBorrow);\r\n        }\r\n    }\r\n\r\n    // next supply interest adjustment\r\n    function _supplyInterestRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply >= assetBorrow) {\r\n            return _avgBorrowInterestRate(assetBorrow)\r\n                .mul(_utilizationRate(assetBorrow, assetSupply))\r\n                .mul(SafeMath.sub(WEI_PERCENT_PRECISION, ProtocolLike(bZxContract).lendingFeePercent()))\r\n                .div(WEI_PERCENT_PRECISION * WEI_PERCENT_PRECISION);\r\n        }\r\n    }\r\n\r\n    function _nextBorrowInterestRate(\r\n        uint256 borrowAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (borrowAmount != 0) {\r\n            if (lastSettleTime_ != uint88(block.timestamp)) {\r\n                (,interestUnPaid) = _getAllInterest();\r\n            }\r\n\r\n            uint256 balance = _underlyingBalance()\r\n                .add(interestUnPaid);\r\n            if (borrowAmount > balance) {\r\n                borrowAmount = balance;\r\n            }\r\n        }\r\n\r\n        return _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            _totalAssetSupply(interestUnPaid)\r\n        );\r\n    }\r\n\r\n    function _nextBorrowInterestRate2(\r\n        uint256 newBorrowAmount,\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256 nextRate)\r\n    {\r\n        uint256 utilRate = _utilizationRate(\r\n            totalAssetBorrow().add(newBorrowAmount),\r\n            assetSupply\r\n        );\r\n\r\n        uint256 thisMinRate;\r\n        uint256 thisMaxRate;\r\n        uint256 thisBaseRate = baseRate;\r\n        uint256 thisRateMultiplier = rateMultiplier;\r\n        uint256 thisTargetLevel = targetLevel;\r\n        uint256 thisKinkLevel = kinkLevel;\r\n        uint256 thisMaxScaleRate = maxScaleRate;\r\n\r\n        if (utilRate < thisTargetLevel) {\r\n            // target targetLevel utilization when utilization is under targetLevel\r\n            utilRate = thisTargetLevel;\r\n        }\r\n\r\n        if (utilRate > thisKinkLevel) {\r\n            // scale rate proportionally up to 100%\r\n            uint256 thisMaxRange = WEI_PERCENT_PRECISION - thisKinkLevel; // will not overflow\r\n\r\n            utilRate -= thisKinkLevel;\r\n            if (utilRate > thisMaxRange)\r\n                utilRate = thisMaxRange;\r\n\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate)\r\n                .mul(thisKinkLevel)\r\n                .div(WEI_PERCENT_PRECISION);\r\n\r\n            nextRate = utilRate\r\n                .mul(SafeMath.sub(thisMaxScaleRate, thisMaxRate))\r\n                .div(thisMaxRange)\r\n                .add(thisMaxRate);\r\n        } else {\r\n            nextRate = utilRate\r\n                .mul(thisRateMultiplier)\r\n                .div(WEI_PERCENT_PRECISION)\r\n                .add(thisBaseRate);\r\n\r\n            thisMinRate = thisBaseRate;\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate);\r\n\r\n            if (nextRate < thisMinRate)\r\n                nextRate = thisMinRate;\r\n            else if (nextRate > thisMaxRate)\r\n                nextRate = thisMaxRate;\r\n        }\r\n    }\r\n\r\n    function _getAllInterest()\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid)\r\n    {\r\n        // interestPaid, interestPaidDate, interestOwedPerDay, interestUnPaid, interestFeePercent, principalTotal\r\n        uint256 interestFeePercent;\r\n        (,,interestOwedPerDay,interestUnPaid,interestFeePercent,) = ProtocolLike(bZxContract).getLenderInterestData(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n\r\n        interestUnPaid = interestUnPaid\r\n            .mul(SafeMath.sub(WEI_PERCENT_PRECISION, interestFeePercent))\r\n            .div(WEI_PERCENT_PRECISION);\r\n    }\r\n\r\n    function _getMarginBorrowAmountAndRate(\r\n        uint256 leverageAmount,\r\n        uint256 depositAmount)\r\n        internal\r\n        view\r\n        returns (uint256 borrowAmount, uint256 interestRate)\r\n    {\r\n        uint256 initialMargin = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\r\n\r\n        interestRate = _nextBorrowInterestRate2(\r\n            depositAmount\r\n                .mul(WEI_PERCENT_PRECISION)\r\n                .div(initialMargin),\r\n            _totalAssetSupply(0)\r\n        );\r\n\r\n        // assumes that loan, collateral, and interest token are the same\r\n        borrowAmount = depositAmount\r\n            .mul(WEI_PERCENT_PRECISION * WEI_PERCENT_PRECISION)\r\n            .div(_adjustValue(\r\n                interestRate,\r\n                2419200, // 28 day duration for margin trades\r\n                initialMargin))\r\n            .div(initialMargin);\r\n    }\r\n\r\n    function _totalAssetSupply(\r\n        uint256 interestUnPaid)\r\n        internal\r\n        view\r\n        returns (uint256) // assetSupply\r\n    {\r\n        if (totalSupply_ != 0) {\r\n            uint256 assetsBalance = _flTotalAssetSupply; // temporary locked totalAssetSupply during a flash loan transaction\r\n            if (assetsBalance == 0) {\r\n                assetsBalance = _underlyingBalance()\r\n                    .add(totalAssetBorrow());\r\n            }\r\n\r\n            return assetsBalance\r\n                .add(interestUnPaid);\r\n        }\r\n    }\r\n\r\n    function _adjustValue(\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        uint256 marginAmount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return maxDuration != 0 ?\r\n            interestRate\r\n                .mul(WEI_PERCENT_PRECISION)\r\n                .mul(maxDuration)\r\n                .div(31536000) // 86400 * 365\r\n                .div(marginAmount)\r\n                .add(WEI_PERCENT_PRECISION) :\r\n            WEI_PERCENT_PRECISION;\r\n    }\r\n\r\n    function _utilizationRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply != 0) {\r\n            // U = total_borrow / total_supply\r\n            return assetBorrow\r\n                .mul(WEI_PERCENT_PRECISION)\r\n                .div(assetSupply);\r\n        }\r\n    }\r\n\r\n\r\n    /* Owner-Only functions */\r\n\r\n    function updateSettings(\r\n        address settingsTarget,\r\n        bytes memory callData)\r\n        public\r\n    {\r\n        if (msg.sender != owner()) {\r\n            address _lowerAdmin;\r\n            address _lowerAdminContract;\r\n            assembly {\r\n                _lowerAdmin := sload(iToken_LowerAdminAddress)\r\n                _lowerAdminContract := sload(iToken_LowerAdminContract)\r\n            }\r\n            require(msg.sender == _lowerAdmin && settingsTarget == _lowerAdminContract);\r\n        }\r\n\r\n        address currentTarget = target_;\r\n        target_ = settingsTarget;\r\n\r\n        (bool result,) = address(this).call(callData);\r\n\r\n        uint256 size;\r\n        uint256 ptr;\r\n        assembly {\r\n            size := returndatasize\r\n            ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            if eq(result, 0) { revert(ptr, size) }\r\n        }\r\n\r\n        target_ = currentTarget;\r\n\r\n        assembly {\r\n            return(ptr, size)\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanTokenLogicWeth is LoanTokenLogicStandard {\r\n\r\n    constructor(\r\n        address _newOwner)\r\n        public\r\n        LoanTokenLogicStandard(_newOwner)\r\n    {}\r\n\r\n    function mintWithEther(\r\n        address receiver)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        return _mintToken(\r\n            receiver,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    function burnToEther(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid != 0) {\r\n            IWethERC20(wethToken).withdraw(loanAmountPaid);\r\n            Address.sendValue(\r\n                receiver,\r\n                loanAmountPaid\r\n            );\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount)\r\n        internal\r\n        returns (uint256 msgValue)\r\n    {\r\n        address _wethToken = wethToken;\r\n        address _loanTokenAddress = _wethToken;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) { // withdrawOnOpen == true\r\n            IWethERC20(_wethToken).withdraw(withdrawalAmount);\r\n            Address.sendValue(\r\n                receiver,\r\n                withdrawalAmount\r\n            );\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal - withdrawalAmount, \"27\");\r\n            }\r\n        } else {\r\n            _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal, \"27\");\r\n        }\r\n\r\n        if (collateralTokenSent != 0) {\r\n            _safeTransferFrom(collateralTokenAddress, msg.sender, bZxContract, collateralTokenSent, \"28\");\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            if (msgValue != 0 && msgValue >= loanTokenSent) {\r\n                IWeth(_wethToken).deposit.value(loanTokenSent)();\r\n                _safeTransfer(_loanTokenAddress, bZxContract, loanTokenSent, \"29\");\r\n                msgValue -= loanTokenSent;\r\n            } else {\r\n                _safeTransferFrom(_loanTokenAddress, msg.sender, bZxContract, loanTokenSent, \"29\");\r\n            }\r\n        }\r\n    }\r\n}"}
{"address": "0xdac17f958d2ee523a2206206994597c13d831ec7", "attacktype": "Absence of code logic or sanity check", "sourcecode": "pragma solidity ^0.4.17;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n      * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n      * account.\r\n      */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n      * @dev Throws if called by any account other than the owner.\r\n      */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n    uint public _totalSupply;\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address who) public constant returns (uint);\r\n    function transfer(address to, uint value) public;\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n    function transferFrom(address from, address to, uint value) public;\r\n    function approve(address spender, uint value) public;\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is Ownable, ERC20Basic {\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) public balances;\r\n\r\n    // additional variables for use if transaction fees ever became necessary\r\n    uint public basisPointsRate = 0;\r\n    uint public maximumFee = 0;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\r\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n        if (fee > maximumFee) {\r\n            fee = maximumFee;\r\n        }\r\n        uint sendAmount = _value.sub(fee);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(sendAmount);\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n            Transfer(msg.sender, owner, fee);\r\n        }\r\n        Transfer(msg.sender, _to, sendAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n\r\n    uint public constant MAX_UINT = 2**256 - 1;\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // if (_value > _allowance) throw;\r\n\r\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n        if (fee > maximumFee) {\r\n            fee = maximumFee;\r\n        }\r\n        if (_allowance < MAX_UINT) {\r\n            allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        }\r\n        uint sendAmount = _value.sub(fee);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(sendAmount);\r\n        if (fee > 0) {\r\n            balances[owner] = balances[owner].add(fee);\r\n            Transfer(_from, owner, fee);\r\n        }\r\n        Transfer(_from, _to, sendAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\ncontract BlackList is Ownable, BasicToken {\r\n\r\n    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////\r\n    function getBlackListStatus(address _maker) external constant returns (bool) {\r\n        return isBlackListed[_maker];\r\n    }\r\n\r\n    function getOwner() external constant returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    mapping (address => bool) public isBlackListed;\r\n    \r\n    function addBlackList (address _evilUser) public onlyOwner {\r\n        isBlackListed[_evilUser] = true;\r\n        AddedBlackList(_evilUser);\r\n    }\r\n\r\n    function removeBlackList (address _clearedUser) public onlyOwner {\r\n        isBlackListed[_clearedUser] = false;\r\n        RemovedBlackList(_clearedUser);\r\n    }\r\n\r\n    function destroyBlackFunds (address _blackListedUser) public onlyOwner {\r\n        require(isBlackListed[_blackListedUser]);\r\n        uint dirtyFunds = balanceOf(_blackListedUser);\r\n        balances[_blackListedUser] = 0;\r\n        _totalSupply -= dirtyFunds;\r\n        DestroyedBlackFunds(_blackListedUser, dirtyFunds);\r\n    }\r\n\r\n    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\r\n\r\n    event AddedBlackList(address _user);\r\n\r\n    event RemovedBlackList(address _user);\r\n\r\n}\r\n\r\ncontract UpgradedStandardToken is StandardToken{\r\n    // those methods are called by the legacy contract\r\n    // and they must ensure msg.sender to be the contract address\r\n    function transferByLegacy(address from, address to, uint value) public;\r\n    function transferFromByLegacy(address sender, address from, address spender, uint value) public;\r\n    function approveByLegacy(address from, address spender, uint value) public;\r\n}\r\n\r\ncontract TetherToken is Pausable, StandardToken, BlackList {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals;\r\n    address public upgradedAddress;\r\n    bool public deprecated;\r\n\r\n    //  The contract can be initialized with a number of tokens\r\n    //  All the tokens are deposited to the owner address\r\n    //\r\n    // @param _balance Initial supply of the contract\r\n    // @param _name Token Name\r\n    // @param _symbol Token symbol\r\n    // @param _decimals Token decimals\r\n    function TetherToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\r\n        _totalSupply = _initialSupply;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        balances[owner] = _initialSupply;\r\n        deprecated = false;\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function transfer(address _to, uint _value) public whenNotPaused {\r\n        require(!isBlackListed[msg.sender]);\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);\r\n        } else {\r\n            return super.transfer(_to, _value);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\r\n        require(!isBlackListed[_from]);\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);\r\n        } else {\r\n            return super.transferFrom(_from, _to, _value);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function balanceOf(address who) public constant returns (uint) {\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).balanceOf(who);\r\n        } else {\r\n            return super.balanceOf(who);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n        if (deprecated) {\r\n            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);\r\n        } else {\r\n            return super.approve(_spender, _value);\r\n        }\r\n    }\r\n\r\n    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        if (deprecated) {\r\n            return StandardToken(upgradedAddress).allowance(_owner, _spender);\r\n        } else {\r\n            return super.allowance(_owner, _spender);\r\n        }\r\n    }\r\n\r\n    // deprecate current contract in favour of a new one\r\n    function deprecate(address _upgradedAddress) public onlyOwner {\r\n        deprecated = true;\r\n        upgradedAddress = _upgradedAddress;\r\n        Deprecate(_upgradedAddress);\r\n    }\r\n\r\n    // deprecate current contract if favour of a new one\r\n    function totalSupply() public constant returns (uint) {\r\n        if (deprecated) {\r\n            return StandardToken(upgradedAddress).totalSupply();\r\n        } else {\r\n            return _totalSupply;\r\n        }\r\n    }\r\n\r\n    // Issue a new amount of tokens\r\n    // these tokens are deposited into the owner address\r\n    //\r\n    // @param _amount Number of tokens to be issued\r\n    function issue(uint amount) public onlyOwner {\r\n        require(_totalSupply + amount > _totalSupply);\r\n        require(balances[owner] + amount > balances[owner]);\r\n\r\n        balances[owner] += amount;\r\n        _totalSupply += amount;\r\n        Issue(amount);\r\n    }\r\n\r\n    // Redeem tokens.\r\n    // These tokens are withdrawn from the owner address\r\n    // if the balance must be enough to cover the redeem\r\n    // or the call will fail.\r\n    // @param _amount Number of tokens to be issued\r\n    function redeem(uint amount) public onlyOwner {\r\n        require(_totalSupply >= amount);\r\n        require(balances[owner] >= amount);\r\n\r\n        _totalSupply -= amount;\r\n        balances[owner] -= amount;\r\n        Redeem(amount);\r\n    }\r\n\r\n    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {\r\n        // Ensure transparency by hardcoding limit beyond which fees can never be added\r\n        require(newBasisPoints < 20);\r\n        require(newMaxFee < 50);\r\n\r\n        basisPointsRate = newBasisPoints;\r\n        maximumFee = newMaxFee.mul(10**decimals);\r\n\r\n        Params(basisPointsRate, maximumFee);\r\n    }\r\n\r\n    // Called when new token are issued\r\n    event Issue(uint amount);\r\n\r\n    // Called when tokens are redeemed\r\n    event Redeem(uint amount);\r\n\r\n    // Called when contract is deprecated\r\n    event Deprecate(address newAddress);\r\n\r\n    // Called if contract ever adds fees\r\n    event Params(uint feeBasisPoints, uint maxFee);\r\n}"}
{"address": "0xe7f445b93eb9cdabfe76541cc43ff8de930a58e6", "attacktype": "Absence of code logic or sanity check", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/E/Defi/force/contracts/contracts/ForceProfitSharing.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\\\";\\r\\n\\r\\ncontract ForceProfitSharing is ERC20, ERC20Detailed, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    IERC20 public force;\\r\\n\\r\\n    event Withdraw(address indexed beneficiary, uint256 amount);\\r\\n    event Deposit(address indexed beneficiary, uint256 amount);\\r\\n\\r\\n    // Define the Force token contract\\r\\n    constructor(address _underlying) public {\\r\\n        force = IERC20(_underlying);\\r\\n        ERC20Detailed.initialize(\\r\\n            \\\"xFORCE\\\",\\r\\n            \\\"xFORCE\\\",\\r\\n            ERC20Detailed(_underlying).decimals()\\r\\n        );\\r\\n        ReentrancyGuard.initialize();\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 amount) external nonReentrant {\\r\\n        // Gets the amount of Force locked in the contract\\r\\n        uint256 totalForce = force.balanceOf(address(this));\\r\\n        // Gets the amount of xForce in existence\\r\\n        uint256 totalShares = totalSupply();\\r\\n        // If no xForce exists, mint it 1:1 to the amount put in\\r\\n        if (totalShares == 0 || totalForce == 0) {\\r\\n            _mint(msg.sender, amount);\\r\\n        }\\r\\n        // Calculate and mint the amount of xForce the Force is worth. The ratio will change overtime, as xForce is burned/minted and Force deposited + gained from fees / withdrawn.\\r\\n        else {\\r\\n            uint256 what = amount.mul(totalShares).div(totalForce);\\r\\n            _mint(msg.sender, what);\\r\\n        }\\r\\n        // Lock the Force in the contract\\r\\n        force.transferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        emit Deposit(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 numberOfShares) external nonReentrant {\\r\\n        // Gets the amount of xForce in existence\\r\\n        uint256 totalShares = totalSupply();\\r\\n        // Calculates the amount of Force the xForce is worth\\r\\n        uint256 what =\\r\\n            numberOfShares.mul(force.balanceOf(address(this))).div(totalShares);\\r\\n        _burn(msg.sender, numberOfShares);\\r\\n        force.transfer(msg.sender, what);\\r\\n\\r\\n        emit Withdraw(msg.sender, what);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Initializable, Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is Initializable, IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n */\\ncontract ReentrancyGuard is Initializable {\\n    // counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    function initialize() public initializer {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"}
{"address": "0x0efb384d843a191c02f5c4470d0f9ec0122a1c0b", "attacktype": "Absence of code logic or sanity check, Fake tokens", "sourcecode": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/ElasticERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This contract is based on the OpenZeppelin ERC20 implementation,\r\n * basically adding the elastic extensions.\r\n */\r\ncontract ElasticERC20 is Context, IERC20\r\n{\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint8 constant UNSCALED_DECIMALS = 24;\r\n\tuint256 constant UNSCALED_FACTOR = 10 ** uint256(UNSCALED_DECIMALS);\r\n\r\n\tmapping (address => mapping (address => uint256)) private allowances_;\r\n\r\n\tmapping (address => uint256) private unscaledBalances_;\r\n\tuint256 private unscaledTotalSupply_;\r\n\r\n\tstring private name_;\r\n\tstring private symbol_;\r\n\tuint8 private decimals_;\r\n\r\n\tuint256 private scalingFactor_;\r\n\r\n\tconstructor (string memory _name, string memory _symbol) public\r\n\t{\r\n\t\tname_ = _name;\r\n\t\tsymbol_ = _symbol;\r\n\t\t_setupDecimals(18);\r\n\t}\r\n\r\n\tfunction name() public view returns (string memory _name)\r\n\t{\r\n\t\treturn name_;\r\n\t}\r\n\r\n\tfunction symbol() public view returns (string memory _symbol)\r\n\t{\r\n\t\treturn symbol_;\r\n\t}\r\n\r\n\tfunction decimals() public view returns (uint8 _decimals)\r\n\t{\r\n\t\treturn decimals_;\r\n\t}\r\n\r\n\tfunction totalSupply() public view override returns (uint256 _supply)\r\n\t{\r\n\t\treturn _scale(unscaledTotalSupply_, scalingFactor_);\r\n\t}\r\n\r\n\tfunction balanceOf(address _account) public view override returns (uint256 _balance)\r\n\t{\r\n\t\treturn _scale(unscaledBalances_[_account], scalingFactor_);\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _spender) public view virtual override returns (uint256 _allowance)\r\n\t{\r\n\t\treturn allowances_[_owner][_spender];\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _amount) public virtual override returns (bool _success)\r\n\t{\r\n\t\t_approve(_msgSender(), _spender, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool _success)\r\n\t{\r\n\t\t_approve(_msgSender(), _spender, allowances_[_msgSender()][_spender].add(_addedValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool _success)\r\n\t{\r\n\t\t_approve(_msgSender(), _spender, allowances_[_msgSender()][_spender].sub(_subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transfer(address _recipient, uint256 _amount) public virtual override returns (bool _success)\r\n\t{\r\n\t\t_transfer(_msgSender(), _recipient, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _sender, address _recipient, uint256 _amount) public virtual override returns (bool _success)\r\n\t{\r\n\t\t_transfer(_sender, _recipient, _amount);\r\n\t\t_approve(_sender, _msgSender(), allowances_[_sender][_msgSender()].sub(_amount, \"ERC20: transfer amount exceeds allowance\"));\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _approve(address _owner, address _spender, uint256 _amount) internal virtual\r\n\t{\r\n\t\trequire(_owner != address(0), \"ERC20: approve from the zero address\");\r\n\t\trequire(_spender != address(0), \"ERC20: approve to the zero address\");\r\n\t\tallowances_[_owner][_spender] = _amount;\r\n\t\temit Approval(_owner, _spender, _amount);\r\n\t}\r\n\r\n\tfunction _transfer(address _sender, address _recipient, uint256 _amount) internal virtual\r\n\t{\r\n\t\tuint256 _unscaledAmount = _unscale(_amount, scalingFactor_);\r\n\t\trequire(_sender != address(0), \"ERC20: transfer from the zero address\");\r\n\t\trequire(_recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\t\t_beforeTokenTransfer(_sender, _recipient, _amount);\r\n\t\tunscaledBalances_[_sender] = unscaledBalances_[_sender].sub(_unscaledAmount, \"ERC20: transfer amount exceeds balance\");\r\n\t\tunscaledBalances_[_recipient] = unscaledBalances_[_recipient].add(_unscaledAmount);\r\n\t\temit Transfer(_sender, _recipient, _amount);\r\n\t}\r\n\r\n\tfunction _mint(address _account, uint256 _amount) internal virtual\r\n\t{\r\n\t\tuint256 _unscaledAmount = _unscale(_amount, scalingFactor_);\r\n\t\trequire(_account != address(0), \"ERC20: mint to the zero address\");\r\n\t\t_beforeTokenTransfer(address(0), _account, _amount);\r\n\t\tunscaledTotalSupply_ = unscaledTotalSupply_.add(_unscaledAmount);\r\n\t\tuint256 _maxScalingFactor = _calcMaxScalingFactor(unscaledTotalSupply_);\r\n\t\trequire(scalingFactor_ <= _maxScalingFactor, \"unsupported scaling factor\");\r\n\t\tunscaledBalances_[_account] = unscaledBalances_[_account].add(_unscaledAmount);\r\n\t\temit Transfer(address(0), _account, _amount);\r\n\t}\r\n\r\n\tfunction _burn(address _account, uint256 _amount) internal virtual\r\n\t{\r\n\t\tuint256 _unscaledAmount = _unscale(_amount, scalingFactor_);\r\n\t\trequire(_account != address(0), \"ERC20: burn from the zero address\");\r\n\t\t_beforeTokenTransfer(_account, address(0), _amount);\r\n\t\tunscaledBalances_[_account] = unscaledBalances_[_account].sub(_unscaledAmount, \"ERC20: burn amount exceeds balance\");\r\n\t\tunscaledTotalSupply_ = unscaledTotalSupply_.sub(_unscaledAmount);\r\n\t\temit Transfer(_account, address(0), _amount);\r\n\t}\r\n\r\n\tfunction _setupDecimals(uint8 _decimals) internal\r\n\t{\r\n\t\tdecimals_ = _decimals;\r\n\t\tscalingFactor_ = 10 ** uint256(_decimals);\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal virtual { }\r\n\r\n\tfunction unscaledTotalSupply() public view returns (uint256 _supply)\r\n\t{\r\n\t\treturn unscaledTotalSupply_;\r\n\t}\r\n\r\n\tfunction unscaledBalanceOf(address _account) public view returns (uint256 _balance)\r\n\t{\r\n\t\treturn unscaledBalances_[_account];\r\n\t}\r\n\r\n\tfunction scalingFactor() public view returns (uint256 _scalingFactor)\r\n\t{\r\n\t\treturn scalingFactor_;\r\n\t}\r\n\r\n\tfunction maxScalingFactor() public view returns (uint256 _maxScalingFactor)\r\n\t{\r\n\t\treturn _calcMaxScalingFactor(unscaledTotalSupply_);\r\n\t}\r\n\r\n\tfunction _calcMaxScalingFactor(uint256 _unscaledTotalSupply) internal pure returns (uint256 _maxScalingFactor)\r\n\t{\r\n\t\treturn uint256(-1).div(_unscaledTotalSupply);\r\n\t}\r\n\r\n\tfunction _scale(uint256 _unscaledAmount, uint256 _scalingFactor) internal pure returns (uint256 _amount)\r\n\t{\r\n\t\treturn _unscaledAmount.mul(_scalingFactor).div(UNSCALED_FACTOR);\r\n\t}\r\n\r\n\tfunction _unscale(uint256 _amount, uint256 _scalingFactor) internal pure returns (uint256 _unscaledAmount)\r\n\t{\r\n\t\treturn _amount.mul(UNSCALED_FACTOR).div(_scalingFactor);\r\n\t}\r\n\r\n\tfunction _setScalingFactor(uint256 _scalingFactor) internal\r\n\t{\r\n\t\tuint256 _maxScalingFactor = _calcMaxScalingFactor(unscaledTotalSupply_);\r\n\t\trequire(0 < _scalingFactor && _scalingFactor <= _maxScalingFactor, \"unsupported scaling factor\");\r\n\t\tscalingFactor_ = _scalingFactor;\r\n\t}\r\n}\r\n\r\n// File: contracts/Executor.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev This library provides support for the dynamic execution of external\r\n * contract calls.\r\n */\r\nlibrary Executor\r\n{\r\n\tstruct Target {\r\n\t\taddress to;\r\n\t\tbytes data;\r\n\t}\r\n\r\n\tfunction addTarget(Target[] storage _targets, address _to, bytes memory _data) internal\r\n\t{\r\n\t\t_targets.push(Target({ to: _to, data: _data }));\r\n\t}\r\n\r\n\tfunction removeTarget(Target[] storage _targets, uint256 _index) internal\r\n\t{\r\n\t\trequire(_index < _targets.length, \"invalid index\");\r\n\t\t_targets[_index] = _targets[_targets.length - 1];\r\n\t\t_targets.pop();\r\n\t}\r\n\r\n\tfunction executeAll(Target[] storage _targets) internal\r\n\t{\r\n\t\tfor (uint256 _i = 0; _i < _targets.length; _i++) {\r\n\t\t\tTarget storage _target = _targets[_i];\r\n\t\t\tbool _success = _externalCall(_target.to, _target.data);\r\n\t\t\trequire(_success, \"call failed\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _externalCall(address _to, bytes memory _data) private returns (bool _success)\r\n\t{\r\n\t\tassembly {\r\n\t\t\t_success := call(gas(), _to, 0, add(_data, 0x20), mload(_data), 0, 0)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File: contracts/GElastic.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev This interface exposes the base functionality of GElasticToken.\r\n */\r\ninterface GElastic\r\n{\r\n\t// view functions\r\n\tfunction referenceToken() external view returns (address _referenceToken);\r\n\tfunction treasury() external view returns (address _treasury);\r\n\tfunction rebaseMinimumDeviation() external view returns (uint256 _rebaseMinimumDeviation);\r\n\tfunction rebaseDampeningFactor() external view returns (uint256 _rebaseDampeningFactor);\r\n\tfunction rebaseTreasuryMintPercent() external view returns (uint256 _rebaseTreasuryMintPercent);\r\n\tfunction rebaseTimingParameters() external view returns (uint256 _rebaseMinimumInterval, uint256 _rebaseWindowOffset, uint256 _rebaseWindowLength);\r\n\tfunction rebaseActive() external view returns (bool _rebaseActive);\r\n\tfunction rebaseAvailable() external view returns (bool _available);\r\n\tfunction lastRebaseTime() external view returns (uint256 _lastRebaseTime);\r\n\tfunction epoch() external view returns (uint256 _epoch);\r\n\tfunction lastExchangeRate() external view returns (uint256 _exchangeRate);\r\n\tfunction currentExchangeRate() external view returns (uint256 _exchangeRate);\r\n\tfunction pair() external view returns (address _pair);\r\n\r\n\t// open functions\r\n\tfunction rebase() external;\r\n\r\n\t// priviledged functions\r\n\tfunction activateOracle(address _pair) external;\r\n\tfunction activateRebase() external;\r\n\tfunction setTreasury(address _newTreasury) external;\r\n\tfunction setRebaseMinimumDeviation(uint256 _newRebaseMinimumDeviation) external;\r\n\tfunction setRebaseDampeningFactor(uint256 _newRebaseDampeningFactor) external;\r\n\tfunction setRebaseTreasuryMintPercent(uint256 _newRebaseTreasuryMintPercent) external;\r\n\tfunction setRebaseTimingParameters(uint256 _newRebaseMinimumInterval, uint256 _newRebaseWindowOffset, uint256 _newRebaseWindowLength) external;\r\n\tfunction addPostRebaseTarget(address _to, bytes memory _data) external;\r\n\tfunction removePostRebaseTarget(uint256 _index) external;\r\n\r\n\t// emitted events\r\n\tevent Rebase(uint256 indexed _epoch, uint256 _oldScalingFactor, uint256 _newScalingFactor);\r\n\tevent ChangeTreasury(address _oldTreasury, address _newTreasury);\r\n\tevent ChangeRebaseMinimumDeviation(uint256 _oldRebaseMinimumDeviation, uint256 _newRebaseMinimumDeviation);\r\n\tevent ChangeRebaseDampeningFactor(uint256 _oldRebaseDampeningFactor, uint256 _newRebaseDampeningFactor);\r\n\tevent ChangeRebaseTreasuryMintPercent(uint256 _oldRebaseTreasuryMintPercent, uint256 _newRebaseTreasuryMintPercent);\r\n\tevent ChangeRebaseTimingParameters(uint256 _oldRebaseMinimumInterval, uint256 _oldRebaseWindowOffset, uint256 _oldRebaseWindowLength, uint256 _newRebaseMinimumInterval, uint256 _newRebaseWindowOffset, uint256 _newRebaseWindowLength);\r\n\tevent AddPostRebaseTarget(address indexed _to, bytes _data);\r\n\tevent RemovePostRebaseTarget(address indexed _to, bytes _data);\r\n}\r\n\r\n// File: contracts/GElasticTokenManager.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev This library helps managing rebase parameters and calculations.\r\n */\r\nlibrary GElasticTokenManager\r\n{\r\n\tusing SafeMath for uint256;\r\n\tusing GElasticTokenManager for GElasticTokenManager.Self;\r\n\r\n\tuint256 constant MAXIMUM_REBASE_TREASURY_MINT_PERCENT = 25e16; // 25%\r\n\r\n\tuint256 constant DEFAULT_REBASE_MINIMUM_INTERVAL = 24 hours;\r\n\tuint256 constant DEFAULT_REBASE_WINDOW_OFFSET = 17 hours; // 5PM UTC\r\n\tuint256 constant DEFAULT_REBASE_WINDOW_LENGTH = 1 hours;\r\n\tuint256 constant DEFAULT_REBASE_MINIMUM_DEVIATION = 5e16; // 5%\r\n\tuint256 constant DEFAULT_REBASE_DAMPENING_FACTOR = 10; // 10x to reach 100%\r\n\tuint256 constant DEFAULT_REBASE_TREASURY_MINT_PERCENT = 10e16; // 10%\r\n\r\n\tstruct Self {\r\n\t\taddress treasury;\r\n\r\n\t\tuint256 rebaseMinimumDeviation;\r\n\t\tuint256 rebaseDampeningFactor;\r\n\t\tuint256 rebaseTreasuryMintPercent;\r\n\r\n\t\tuint256 rebaseMinimumInterval;\r\n\t\tuint256 rebaseWindowOffset;\r\n\t\tuint256 rebaseWindowLength;\r\n\r\n\t\tbool rebaseActive;\r\n\t\tuint256 lastRebaseTime;\r\n\t\tuint256 epoch;\r\n\t}\r\n\r\n\tfunction init(Self storage _self, address _treasury) public\r\n\t{\r\n\t\t_self.treasury = _treasury;\r\n\r\n\t\t_self.rebaseMinimumDeviation = DEFAULT_REBASE_MINIMUM_DEVIATION;\r\n\t\t_self.rebaseDampeningFactor = DEFAULT_REBASE_DAMPENING_FACTOR;\r\n\t\t_self.rebaseTreasuryMintPercent = DEFAULT_REBASE_TREASURY_MINT_PERCENT;\r\n\r\n\t\t_self.rebaseMinimumInterval = DEFAULT_REBASE_MINIMUM_INTERVAL;\r\n\t\t_self.rebaseWindowOffset = DEFAULT_REBASE_WINDOW_OFFSET;\r\n\t\t_self.rebaseWindowLength = DEFAULT_REBASE_WINDOW_LENGTH;\r\n\r\n\t\t_self.rebaseActive = false;\r\n\t\t_self.lastRebaseTime = 0;\r\n\t\t_self.epoch = 0;\r\n\t}\r\n\r\n\tfunction activateRebase(Self storage _self) public\r\n\t{\r\n\t\trequire(!_self.rebaseActive, \"already active\");\r\n\t\t_self.rebaseActive = true;\r\n\t\t_self.lastRebaseTime = now.sub(now.mod(_self.rebaseMinimumInterval)).add(_self.rebaseWindowOffset);\r\n\t}\r\n\r\n\tfunction setTreasury(Self storage _self, address _treasury) public\r\n\t{\r\n\t\trequire(_treasury != address(0), \"invalid treasury\");\r\n\t\t_self.treasury = _treasury;\r\n\t}\r\n\r\n\tfunction setRebaseMinimumDeviation(Self storage _self, uint256 _rebaseMinimumDeviation) public\r\n\t{\r\n\t\trequire(_rebaseMinimumDeviation > 0, \"invalid minimum deviation\");\r\n\t\t_self.rebaseMinimumDeviation = _rebaseMinimumDeviation;\r\n\t}\r\n\r\n\tfunction setRebaseDampeningFactor(Self storage _self, uint256 _rebaseDampeningFactor) public\r\n\t{\r\n\t\trequire(_rebaseDampeningFactor > 0, \"invalid dampening factor\");\r\n\t\t_self.rebaseDampeningFactor = _rebaseDampeningFactor;\r\n\t}\r\n\r\n\tfunction setRebaseTreasuryMintPercent(Self storage _self, uint256 _rebaseTreasuryMintPercent) public\r\n\t{\r\n\t\trequire(_rebaseTreasuryMintPercent <= MAXIMUM_REBASE_TREASURY_MINT_PERCENT, \"invalid percent\");\r\n\t\t_self.rebaseTreasuryMintPercent = _rebaseTreasuryMintPercent;\r\n\t}\r\n\r\n\tfunction setRebaseTimingParameters(Self storage _self, uint256 _rebaseMinimumInterval, uint256 _rebaseWindowOffset, uint256 _rebaseWindowLength) public\r\n\t{\r\n\t\trequire(_rebaseMinimumInterval > 0, \"invalid interval\");\r\n\t\trequire(_rebaseWindowOffset.add(_rebaseWindowLength) <= _rebaseMinimumInterval, \"invalid window\");\r\n\t\t_self.rebaseMinimumInterval = _rebaseMinimumInterval;\r\n\t\t_self.rebaseWindowOffset = _rebaseWindowOffset;\r\n\t\t_self.rebaseWindowLength = _rebaseWindowLength;\r\n\t}\r\n\r\n\tfunction rebaseAvailable(Self storage _self) public view returns (bool _available)\r\n\t{\r\n\t\treturn _self._rebaseAvailable();\r\n\t}\r\n\r\n\tfunction rebase(Self storage _self, uint256 _exchangeRate, uint256 _totalSupply) public returns (uint256 _delta, bool _positive, uint256 _mintAmount)\r\n\t{\r\n\t\trequire(_self._rebaseAvailable(), \"not available\");\r\n\r\n\t\t_self.lastRebaseTime = now.sub(now.mod(_self.rebaseMinimumInterval)).add(_self.rebaseWindowOffset);\r\n\t\t_self.epoch = _self.epoch.add(1);\r\n\r\n\t\t_positive = _exchangeRate > 1e18;\r\n\r\n\t\tuint256 _deviation = _positive ? _exchangeRate.sub(1e18) : uint256(1e18).sub(_exchangeRate);\r\n\t\tif (_deviation < _self.rebaseMinimumDeviation) {\r\n\t\t\t_deviation = 0;\r\n\t\t\t_positive = false;\r\n\t\t}\r\n\r\n\t\t_delta = _deviation.div(_self.rebaseDampeningFactor);\r\n\r\n\t\t_mintAmount = 0;\r\n\t\tif (_positive) {\r\n\t\t\tuint256 _mintPercent = _delta.mul(_self.rebaseTreasuryMintPercent).div(1e18);\r\n\t\t\t_delta = _delta.sub(_mintPercent);\r\n\t\t\t_mintAmount = _totalSupply.mul(_mintPercent).div(1e18);\r\n\t\t}\r\n\r\n\t\treturn (_delta, _positive, _mintAmount);\r\n\t}\r\n\r\n\tfunction _rebaseAvailable(Self storage _self) internal view returns (bool _available)\r\n\t{\r\n\t\tif (!_self.rebaseActive) return false;\r\n\t\tif (now < _self.lastRebaseTime.add(_self.rebaseMinimumInterval)) return false;\r\n\t\tuint256 _offset = now.mod(_self.rebaseMinimumInterval);\r\n\t\treturn _self.rebaseWindowOffset <= _offset && _offset < _self.rebaseWindowOffset.add(_self.rebaseWindowLength);\r\n\t}\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/FullMath.sol\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\r\n// license is CC-BY-4.0\r\nlibrary FullMath {\r\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\r\n        uint256 mm = mulmod(x, y, uint256(-1));\r\n        l = x * y;\r\n        h = mm - l;\r\n        if (mm < l) h -= 1;\r\n    }\r\n\r\n    function fullDiv(\r\n        uint256 l,\r\n        uint256 h,\r\n        uint256 d\r\n    ) private pure returns (uint256) {\r\n        uint256 pow2 = d & -d;\r\n        d /= pow2;\r\n        l /= pow2;\r\n        l += h * ((-pow2) / pow2 + 1);\r\n        uint256 r = 1;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        return l * r;\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        (uint256 l, uint256 h) = fullMul(x, y);\r\n\r\n        uint256 mm = mulmod(x, y, d);\r\n        if (mm > l) h -= 1;\r\n        l -= mm;\r\n\r\n        if (h == 0) return l / d;\r\n\r\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\r\n        return fullDiv(l, h, d);\r\n    }\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/Babylonian.sol\r\n\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    // credit for this implementation goes to\r\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\r\n    function sqrt(uint256 x) internal pure returns (uint256) {\r\n        if (x == 0) return 0;\r\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\r\n        // however that code costs significantly more gas\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) {\r\n            xx >>= 128;\r\n            r <<= 64;\r\n        }\r\n        if (xx >= 0x10000000000000000) {\r\n            xx >>= 64;\r\n            r <<= 32;\r\n        }\r\n        if (xx >= 0x100000000) {\r\n            xx >>= 32;\r\n            r <<= 16;\r\n        }\r\n        if (xx >= 0x10000) {\r\n            xx >>= 16;\r\n            r <<= 8;\r\n        }\r\n        if (xx >= 0x100) {\r\n            xx >>= 8;\r\n            r <<= 4;\r\n        }\r\n        if (xx >= 0x10) {\r\n            xx >>= 4;\r\n            r <<= 2;\r\n        }\r\n        if (xx >= 0x8) {\r\n            r <<= 1;\r\n        }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return (r < r1 ? r : r1);\r\n    }\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/BitMath.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\nlibrary BitMath {\r\n    // returns the 0 indexed position of the most significant bit of the input x\r\n    // s.t. x >= 2**msb and x < 2**(msb+1)\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\r\n\r\n        if (x >= 0x100000000000000000000000000000000) {\r\n            x >>= 128;\r\n            r += 128;\r\n        }\r\n        if (x >= 0x10000000000000000) {\r\n            x >>= 64;\r\n            r += 64;\r\n        }\r\n        if (x >= 0x100000000) {\r\n            x >>= 32;\r\n            r += 32;\r\n        }\r\n        if (x >= 0x10000) {\r\n            x >>= 16;\r\n            r += 16;\r\n        }\r\n        if (x >= 0x100) {\r\n            x >>= 8;\r\n            r += 8;\r\n        }\r\n        if (x >= 0x10) {\r\n            x >>= 4;\r\n            r += 4;\r\n        }\r\n        if (x >= 0x4) {\r\n            x >>= 2;\r\n            r += 2;\r\n        }\r\n        if (x >= 0x2) r += 1;\r\n    }\r\n\r\n    // returns the 0 indexed position of the least significant bit of the input x\r\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\r\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\r\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\r\n\r\n        r = 255;\r\n        if (x & uint128(-1) > 0) {\r\n            r -= 128;\r\n        } else {\r\n            x >>= 128;\r\n        }\r\n        if (x & uint64(-1) > 0) {\r\n            r -= 64;\r\n        } else {\r\n            x >>= 64;\r\n        }\r\n        if (x & uint32(-1) > 0) {\r\n            r -= 32;\r\n        } else {\r\n            x >>= 32;\r\n        }\r\n        if (x & uint16(-1) > 0) {\r\n            r -= 16;\r\n        } else {\r\n            x >>= 16;\r\n        }\r\n        if (x & uint8(-1) > 0) {\r\n            r -= 8;\r\n        } else {\r\n            x >>= 8;\r\n        }\r\n        if (x & 0xf > 0) {\r\n            r -= 4;\r\n        } else {\r\n            x >>= 4;\r\n        }\r\n        if (x & 0x3 > 0) {\r\n            r -= 2;\r\n        } else {\r\n            x >>= 2;\r\n        }\r\n        if (x & 0x1 > 0) r -= 1;\r\n    }\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/FixedPoint.sol\r\n\r\npragma solidity >=0.4.0;\r\n\r\n\r\n\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 public constant RESOLUTION = 112;\r\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\r\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\r\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\r\n        uint256 z = 0;\r\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by an int and decode, returning an int\r\n    // reverts on overflow\r\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\r\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\r\n        require(z < 2**255, 'FixedPoint::muli: overflow');\r\n        return y < 0 ? -int256(z) : int256(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    // lossy\r\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\r\n        if (self._x == 0 || other._x == 0) {\r\n            return uq112x112(0);\r\n        }\r\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\r\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\r\n\r\n        // partial products\r\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\r\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\r\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\r\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\r\n\r\n        // so the bit shift does not overflow\r\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\r\n\r\n        // this cannot exceed 256 bits, all values are 224 bits\r\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\r\n\r\n        // so the cast does not overflow\r\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\r\n\r\n        return uq112x112(uint224(sum));\r\n    }\r\n\r\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\r\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\r\n        if (self._x == other._x) {\r\n            return uq112x112(uint224(Q112));\r\n        }\r\n        if (self._x <= uint144(-1)) {\r\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\r\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\r\n            return uq112x112(uint224(value));\r\n        }\r\n\r\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\r\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\r\n        return uq112x112(uint224(result));\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // can be lossy\r\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\r\n        if (numerator == 0) return FixedPoint.uq112x112(0);\r\n\r\n        if (numerator <= uint144(-1)) {\r\n            uint256 result = (numerator << RESOLUTION) / denominator;\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        } else {\r\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        }\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    // reverts on overflow\r\n    // lossy\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\r\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    // lossy between 0/1 and 40 bits\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        if (self._x <= uint144(-1)) {\r\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\r\n        }\r\n\r\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\r\n        safeShiftBits -= safeShiftBits % 2;\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\r\n    }\r\n}\r\n\r\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: @uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interop/UniswapV2.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Minimal set of declarations for Uniswap V2 interoperability.\r\n */\r\ninterface Factory\r\n{\r\n\tfunction getPair(address _tokenA, address _tokenB) external view returns (address _pair);\r\n\tfunction createPair(address _tokenA, address _tokenB) external returns (address _pair);\r\n}\r\n\r\ninterface PoolToken is IERC20\r\n{\r\n}\r\n\r\ninterface Pair is PoolToken\r\n{\r\n\tfunction token0() external view returns (address _token0);\r\n\tfunction token1() external view returns (address _token1);\r\n\tfunction price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\r\n\tfunction price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\r\n\tfunction getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n\tfunction mint(address _to) external returns (uint256 _liquidity);\r\n\tfunction sync() external;\r\n}\r\n\r\ninterface Router01\r\n{\r\n\tfunction WETH() external pure returns (address _token);\r\n\tfunction addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\r\n\tfunction removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\r\n\tfunction swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\r\n\tfunction swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\r\n\tfunction getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\r\n}\r\n\r\ninterface Router02 is Router01\r\n{\r\n}\r\n\r\n// File: contracts/GPriceOracle.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This library implements a TWAP oracle on Uniswap V2. Based on\r\n * https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\r\n */\r\nlibrary GPriceOracle\r\n{\r\n\tusing FixedPoint for FixedPoint.uq112x112;\r\n\tusing FixedPoint for FixedPoint.uq144x112;\r\n\tusing GPriceOracle for GPriceOracle.Self;\r\n\r\n\tuint256 constant DEFAULT_MINIMUM_INTERVAL = 23 hours;\r\n\r\n\tstruct Self {\r\n\t\taddress pair;\r\n\t\tbool use0;\r\n\r\n\t\tuint256 minimumInterval;\r\n\r\n\t\tuint256 priceCumulativeLast;\r\n\t\tuint32 blockTimestampLast;\r\n\t\tFixedPoint.uq112x112 priceAverage;\r\n\t}\r\n\r\n\tfunction init(Self storage _self) public\r\n\t{\r\n\t\t_self.pair = address(0);\r\n\r\n\t\t_self.minimumInterval = DEFAULT_MINIMUM_INTERVAL;\r\n\t}\r\n\r\n\tfunction active(Self storage _self) public view returns (bool _isActive)\r\n\t{\r\n\t\treturn _self._active();\r\n\t}\r\n\r\n\tfunction activate(Self storage _self, address _pair, bool _use0) public\r\n\t{\r\n\t\trequire(!_self._active(), \"already active\");\r\n\t\trequire(_pair != address(0), \"invalid pair\");\r\n\r\n\t\t_self.pair = _pair;\r\n\t\t_self.use0 = _use0;\r\n\r\n\t\t_self.priceCumulativeLast = _use0 ? Pair(_pair).price0CumulativeLast() : Pair(_pair).price1CumulativeLast();\r\n\r\n\t\tuint112 reserve0;\r\n\t\tuint112 reserve1;\r\n\t\t(reserve0, reserve1, _self.blockTimestampLast) = Pair(_pair).getReserves();\r\n\t\trequire(reserve0 > 0 && reserve1 > 0, \"no reserves\"); // ensure that there's liquidity in the pair\r\n\t}\r\n\r\n\tfunction changeMinimumInterval(Self storage _self, uint256 _minimumInterval) public\r\n\t{\r\n\t\trequire(_minimumInterval > 0, \"invalid interval\");\r\n\t\t_self.minimumInterval = _minimumInterval;\r\n\t}\r\n\r\n\tfunction consultLastPrice(Self storage _self, uint256 _amountIn) public view returns (uint256 _amountOut)\r\n\t{\r\n\t\trequire(_self._active(), \"not active\");\r\n\r\n\t\treturn _self.priceAverage.mul(_amountIn).decode144();\r\n\t}\r\n\r\n\tfunction consultCurrentPrice(Self storage _self, uint256 _amountIn) public view returns (uint256 _amountOut)\r\n\t{\r\n\t\trequire(_self._active(), \"not active\");\r\n\r\n\t\t(,, FixedPoint.uq112x112 memory _priceAverage) = _self._estimatePrice(false);\r\n\t\treturn _priceAverage.mul(_amountIn).decode144();\r\n\t}\r\n\r\n\tfunction updatePrice(Self storage _self) public\r\n\t{\r\n\t\trequire(_self._active(), \"not active\");\r\n\r\n\t\t(_self.priceCumulativeLast, _self.blockTimestampLast, _self.priceAverage) = _self._estimatePrice(true);\r\n\t}\r\n\r\n\tfunction _active(Self storage _self) internal view returns (bool _isActive)\r\n\t{\r\n\t\treturn _self.pair != address(0);\r\n\t}\r\n\r\n\tfunction _estimatePrice(Self storage _self, bool _enforceTimeElapsed) internal view returns (uint256 _priceCumulative, uint32 _blockTimestamp, FixedPoint.uq112x112 memory _priceAverage)\r\n\t{\r\n\t\tuint256 _price0Cumulative;\r\n\t\tuint256 _price1Cumulative;\r\n\t\t(_price0Cumulative, _price1Cumulative, _blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(_self.pair);\r\n\t\t_priceCumulative = _self.use0 ? _price0Cumulative : _price1Cumulative;\r\n\r\n\t\tuint32 _timeElapsed = _blockTimestamp - _self.blockTimestampLast; // overflow is desired\r\n\r\n\t\t// ensure that at least one full interval has passed since the last update\r\n\t\tif (_enforceTimeElapsed) {\r\n\t\t\trequire(_timeElapsed >= _self.minimumInterval, \"minimum interval not elapsed\");\r\n\t\t}\r\n\r\n\t\t// overflow is desired, casting never truncates\r\n\t\t// cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n\t\t_priceAverage = FixedPoint.uq112x112(uint224((_priceCumulative - _self.priceCumulativeLast) / _timeElapsed));\r\n\t}\r\n}\r\n\r\n// File: contracts/modules/Math.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev This library implements auxiliary math definitions.\r\n */\r\nlibrary Math\r\n{\r\n\tfunction _min(uint256 _amount1, uint256 _amount2) internal pure returns (uint256 _minAmount)\r\n\t{\r\n\t\treturn _amount1 < _amount2 ? _amount1 : _amount2;\r\n\t}\r\n\r\n\tfunction _max(uint256 _amount1, uint256 _amount2) internal pure returns (uint256 _maxAmount)\r\n\t{\r\n\t\treturn _amount1 > _amount2 ? _amount1 : _amount2;\r\n\t}\r\n}\r\n\r\n// File: contracts/GElasticToken.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice This contract implements an ERC20 compatible elastic token that\r\n * rebases according to the TWAP of another token. Inspired by AMPL and YAM.\r\n */\r\ncontract GElasticToken is ElasticERC20, Ownable, ReentrancyGuard, GElastic\r\n{\r\n\tusing SafeMath for uint256;\r\n\tusing GElasticTokenManager for GElasticTokenManager.Self;\r\n\tusing GPriceOracle for GPriceOracle.Self;\r\n\tusing Executor for Executor.Target[];\r\n\r\n\taddress public immutable override referenceToken;\r\n\r\n\tGElasticTokenManager.Self etm;\r\n\tGPriceOracle.Self oracle;\r\n\r\n\tExecutor.Target[] public targets;\r\n\r\n\tmodifier onlyEOA()\r\n\t{\r\n\t\trequire(tx.origin == _msgSender(), \"not an externally owned account\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor (string memory _name, string memory _symbol, uint8 _decimals, address _referenceToken, uint256 _initialSupply)\r\n\t\tElasticERC20(_name, _symbol) public\r\n\t{\r\n\t\taddress _treasury = msg.sender;\r\n\t\t_setupDecimals(_decimals);\r\n\t\tassert(_referenceToken != address(0));\r\n\t\treferenceToken = _referenceToken;\r\n\t\tetm.init(_treasury);\r\n\t\toracle.init();\r\n\t\t_mint(_treasury, _initialSupply);\r\n\t}\r\n\r\n\tfunction treasury() external view override returns (address _treasury)\r\n\t{\r\n\t\treturn etm.treasury;\r\n\t}\r\n\r\n\tfunction rebaseMinimumDeviation() external view override returns (uint256 _rebaseMinimumDeviation)\r\n\t{\r\n\t\treturn etm.rebaseMinimumDeviation;\r\n\t}\r\n\r\n\tfunction rebaseDampeningFactor() external view override returns (uint256 _rebaseDampeningFactor)\r\n\t{\r\n\t\treturn etm.rebaseDampeningFactor;\r\n\t}\r\n\r\n\tfunction rebaseTreasuryMintPercent() external view override returns (uint256 _rebaseTreasuryMintPercent)\r\n\t{\r\n\t\treturn etm.rebaseTreasuryMintPercent;\r\n\t}\r\n\r\n\tfunction rebaseTimingParameters() external view override returns (uint256 _rebaseMinimumInterval, uint256 _rebaseWindowOffset, uint256 _rebaseWindowLength)\r\n\t{\r\n\t\treturn (etm.rebaseMinimumInterval, etm.rebaseWindowOffset, etm.rebaseWindowLength);\r\n\t}\r\n\r\n\tfunction rebaseAvailable() external view override returns (bool _rebaseAvailable)\r\n\t{\r\n\t\treturn etm.rebaseAvailable();\r\n\t}\r\n\r\n\tfunction rebaseActive() external view override returns (bool _rebaseActive)\r\n\t{\r\n\t\treturn etm.rebaseActive;\r\n\t}\r\n\r\n\tfunction lastRebaseTime() external view override returns (uint256 _lastRebaseTime)\r\n\t{\r\n\t\treturn etm.lastRebaseTime;\r\n\t}\r\n\r\n\tfunction epoch() external view override returns (uint256 _epoch)\r\n\t{\r\n\t\treturn etm.epoch;\r\n\t}\r\n\r\n\tfunction lastExchangeRate() external view override returns (uint256 _exchangeRate)\r\n\t{\r\n\t\treturn oracle.consultLastPrice(10 ** uint256(decimals()));\r\n\t}\r\n\r\n\tfunction currentExchangeRate() external view override returns (uint256 _exchangeRate)\r\n\t{\r\n\t\treturn oracle.consultCurrentPrice(10 ** uint256(decimals()));\r\n\t}\r\n\r\n\tfunction pair() external view override returns (address _pair)\r\n\t{\r\n\t\treturn oracle.pair;\r\n\t}\r\n\r\n\tfunction rebase() external override onlyEOA nonReentrant\r\n\t{\r\n\t\toracle.updatePrice();\r\n\r\n\t\tuint256 _exchangeRate = oracle.consultLastPrice(10 ** uint256(decimals()));\r\n\r\n\t\tuint256 _totalSupply = totalSupply();\r\n\r\n\t\t(uint256 _delta, bool _positive, uint256 _mintAmount) = etm.rebase(_exchangeRate, _totalSupply);\r\n\r\n\t\t_rebase(etm.epoch, _delta, _positive);\r\n\r\n\t\tif (_mintAmount > 0) {\r\n\t\t\t_mint(etm.treasury, _mintAmount);\r\n\t\t}\r\n\r\n\t\t// updates cached reserve balances wherever necessary\r\n\t\tPair(oracle.pair).sync();\r\n\t\ttargets.executeAll();\r\n\t}\r\n\r\n\tfunction activateOracle(address _pair) external override onlyOwner nonReentrant\r\n\t{\r\n\t\taddress _token0 = Pair(_pair).token0();\r\n\t\taddress _token1 = Pair(_pair).token1();\r\n\t\trequire(_token0 == address(this) && _token1 == referenceToken || _token1 == address(this) && _token0 == referenceToken, \"invalid pair\");\r\n\t\toracle.activate(_pair, _token0 == address(this));\r\n\t}\r\n\r\n\tfunction activateRebase() external override onlyOwner nonReentrant\r\n\t{\r\n\t\trequire(oracle.active(), \"not available\");\r\n\t\tetm.activateRebase();\r\n\t}\r\n\r\n\tfunction setTreasury(address _newTreasury) external override onlyOwner nonReentrant\r\n\t{\r\n\t\taddress _oldTreasury = etm.treasury;\r\n\t\tetm.setTreasury(_newTreasury);\r\n\t\temit ChangeTreasury(_oldTreasury, _newTreasury);\r\n\t}\r\n\r\n\tfunction setRebaseMinimumDeviation(uint256 _newRebaseMinimumDeviation) external override onlyOwner nonReentrant\r\n\t{\r\n\t\tuint256 _oldRebaseMinimumDeviation = etm.rebaseMinimumDeviation;\r\n\t\tetm.setRebaseMinimumDeviation(_newRebaseMinimumDeviation);\r\n\t\temit ChangeRebaseMinimumDeviation(_oldRebaseMinimumDeviation, _newRebaseMinimumDeviation);\r\n\t}\r\n\r\n\tfunction setRebaseDampeningFactor(uint256 _newRebaseDampeningFactor) external override onlyOwner nonReentrant\r\n\t{\r\n\t\tuint256 _oldRebaseDampeningFactor = etm.rebaseDampeningFactor;\r\n\t\tetm.setRebaseDampeningFactor(_newRebaseDampeningFactor);\r\n\t\temit ChangeRebaseDampeningFactor(_oldRebaseDampeningFactor, _newRebaseDampeningFactor);\r\n\t}\r\n\r\n\tfunction setRebaseTreasuryMintPercent(uint256 _newRebaseTreasuryMintPercent) external override onlyOwner nonReentrant\r\n\t{\r\n\t\tuint256 _oldRebaseTreasuryMintPercent = etm.rebaseTreasuryMintPercent;\r\n\t\tetm.setRebaseTreasuryMintPercent(_newRebaseTreasuryMintPercent);\r\n\t\temit ChangeRebaseTreasuryMintPercent(_oldRebaseTreasuryMintPercent, _newRebaseTreasuryMintPercent);\r\n\t}\r\n\r\n\tfunction setRebaseTimingParameters(uint256 _newRebaseMinimumInterval, uint256 _newRebaseWindowOffset, uint256 _newRebaseWindowLength) external override onlyOwner nonReentrant\r\n\t{\r\n\t\tuint256 _oldRebaseMinimumInterval = etm.rebaseMinimumInterval;\r\n\t\tuint256 _oldRebaseWindowOffset = etm.rebaseWindowOffset;\r\n\t\tuint256 _oldRebaseWindowLength = etm.rebaseWindowLength;\r\n\t\tetm.setRebaseTimingParameters(_newRebaseMinimumInterval, _newRebaseWindowOffset, _newRebaseWindowLength);\r\n\t\toracle.changeMinimumInterval(_newRebaseMinimumInterval.sub(_newRebaseWindowLength));\r\n\t\temit ChangeRebaseTimingParameters(_oldRebaseMinimumInterval, _oldRebaseWindowOffset, _oldRebaseWindowLength, _newRebaseMinimumInterval, _newRebaseWindowOffset, _newRebaseWindowLength);\r\n\t}\r\n\r\n\tfunction addPostRebaseTarget(address _to, bytes memory _data) external override onlyOwner nonReentrant\r\n\t{\r\n\t\t_addPostRebaseTarget(_to, _data);\r\n\t}\r\n\r\n\tfunction removePostRebaseTarget(uint256 _index) external override onlyOwner nonReentrant\r\n\t{\r\n\t\t_removePostRebaseTarget(_index);\r\n\t}\r\n\r\n\tfunction addBalancerPostRebaseTarget(address _pool) external onlyOwner nonReentrant\r\n\t{\r\n\t\t_addPostRebaseTarget(_pool, abi.encodeWithSignature(\"gulp(address)\", address(this)));\r\n\t}\r\n\r\n\tfunction addUniswapV2PostRebaseTarget(address _pair) external onlyOwner nonReentrant\r\n\t{\r\n\t\t_addPostRebaseTarget(_pair, abi.encodeWithSignature(\"sync()\"));\r\n\t}\r\n\r\n\tfunction _addPostRebaseTarget(address _to, bytes memory _data) internal\r\n\t{\r\n\t\ttargets.addTarget(_to, _data);\r\n\t\temit AddPostRebaseTarget(_to, _data);\r\n\t}\r\n\r\n\tfunction _removePostRebaseTarget(uint256 _index) internal\r\n\t{\r\n\t\tExecutor.Target storage _target = targets[_index];\r\n\t\taddress _to = _target.to;\r\n\t\tbytes memory _data = _target.data;\r\n\t\ttargets.removeTarget(_index);\r\n\t\temit RemovePostRebaseTarget(_to, _data);\r\n\t}\r\n\r\n\tfunction _rebase(uint256 _epoch, uint256 _delta, bool _positive) internal virtual\r\n\t{\r\n\t\tuint256 _oldScalingFactor = scalingFactor();\r\n\t\tuint256 _newScalingFactor;\r\n\t\tif (_delta == 0) {\r\n\t\t\t_newScalingFactor = _oldScalingFactor;\r\n\t\t} else {\r\n\t\t\tif (_positive) {\r\n\t\t\t\t_newScalingFactor = _oldScalingFactor.mul(uint256(1e18).add(_delta)).div(1e18);\r\n\t\t\t} else {\r\n\t\t\t\t_newScalingFactor = _oldScalingFactor.mul(uint256(1e18).sub(_delta)).div(1e18);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (_newScalingFactor > _oldScalingFactor) {\r\n\t\t\t_newScalingFactor = Math._min(_newScalingFactor, maxScalingFactor());\r\n\t\t}\r\n\t\t_setScalingFactor(_newScalingFactor);\r\n\t\temit Rebase(_epoch, _oldScalingFactor, _newScalingFactor);\r\n\t}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: contracts/GLPMining.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev This interface exposes the base functionality of GLPMiningToken.\r\n */\r\ninterface GLPMining\r\n{\r\n\t// view functions\r\n\tfunction reserveToken() external view returns (address _reserveToken);\r\n\tfunction rewardsToken() external view returns (address _rewardsToken);\r\n\tfunction treasury() external view returns (address _treasury);\r\n\tfunction performanceFee() external view returns (uint256 _performanceFee);\r\n\tfunction rewardRatePerWeek() external view returns (uint256 _rewardRatePerWeek);\r\n\tfunction calcSharesFromCost(uint256 _cost) external view returns (uint256 _shares);\r\n\tfunction calcCostFromShares(uint256 _shares) external view returns (uint256 _cost);\r\n\tfunction calcSharesFromTokenAmount(address _token, uint256 _amount) external view returns (uint256 _shares);\r\n\tfunction calcTokenAmountFromShares(address _token, uint256 _shares) external view returns (uint256 _amount);\r\n\tfunction totalReserve() external view returns (uint256 _totalReserve);\r\n\tfunction rewardInfo() external view returns (uint256 _lockedReward, uint256 _unlockedReward, uint256 _rewardPerBlock);\r\n\tfunction pendingFees() external view returns (uint256 _feeShares);\r\n\r\n\t// open functions\r\n\tfunction deposit(uint256 _cost) external;\r\n\tfunction withdraw(uint256 _shares) external;\r\n\tfunction depositToken(address _token, uint256 _amount, uint256 _minShares) external;\r\n\tfunction withdrawToken(address _token, uint256 _shares, uint256 _minAmount) external;\r\n\tfunction gulpRewards(uint256 _minCost) external;\r\n\tfunction gulpFees() external;\r\n\r\n\t// priviledged functions\r\n\tfunction setTreasury(address _treasury) external;\r\n\tfunction setPerformanceFee(uint256 _performanceFee) external;\r\n\tfunction setRewardRatePerWeek(uint256 _rewardRatePerWeek) external;\r\n\r\n\t// emitted events\r\n\tevent ChangeTreasury(address _oldTreasury, address _newTreasury);\r\n\tevent ChangePerformanceFee(uint256 _oldPerformanceFee, uint256 _newPerformanceFee);\r\n\tevent ChangeRewardRatePerWeek(uint256 _oldRewardRatePerWeek, uint256 _newRewardRatePerWeek);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/modules/Transfers.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @dev This library abstracts ERC-20 operations in the context of the current\r\n * contract.\r\n */\r\nlibrary Transfers\r\n{\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\t/**\r\n\t * @dev Retrieves a given ERC-20 token balance for the current contract.\r\n\t * @param _token An ERC-20 compatible token address.\r\n\t * @return _balance The current contract balance of the given ERC-20 token.\r\n\t */\r\n\tfunction _getBalance(address _token) internal view returns (uint256 _balance)\r\n\t{\r\n\t\treturn IERC20(_token).balanceOf(address(this));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows a spender to access a given ERC-20 balance for the current contract.\r\n\t * @param _token An ERC-20 compatible token address.\r\n\t * @param _to The spender address.\r\n\t * @param _amount The exact spending allowance amount.\r\n\t */\r\n\tfunction _approveFunds(address _token, address _to, uint256 _amount) internal\r\n\t{\r\n\t\tuint256 _allowance = IERC20(_token).allowance(address(this), _to);\r\n\t\tif (_allowance > _amount) {\r\n\t\t\tIERC20(_token).safeDecreaseAllowance(_to, _allowance - _amount);\r\n\t\t}\r\n\t\telse\r\n\t\tif (_allowance < _amount) {\r\n\t\t\tIERC20(_token).safeIncreaseAllowance(_to, _amount - _allowance);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer a given ERC-20 token amount into the current contract.\r\n\t * @param _token An ERC-20 compatible token address.\r\n\t * @param _from The source address.\r\n\t * @param _amount The amount to be transferred.\r\n\t */\r\n\tfunction _pullFunds(address _token, address _from, uint256 _amount) internal\r\n\t{\r\n\t\tif (_amount == 0) return;\r\n\t\tIERC20(_token).safeTransferFrom(_from, address(this), _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer a given ERC-20 token amount from the current contract.\r\n\t * @param _token An ERC-20 compatible token address.\r\n\t * @param _to The target address.\r\n\t * @param _amount The amount to be transferred.\r\n\t */\r\n\tfunction _pushFunds(address _token, address _to, uint256 _amount) internal\r\n\t{\r\n\t\tif (_amount == 0) return;\r\n\t\tIERC20(_token).safeTransfer(_to, _amount);\r\n\t}\r\n}\r\n\r\n// File: contracts/network/$.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev This library is provided for convenience. It is the single source for\r\n *      the current network and all related hardcoded contract addresses.\r\n */\r\nlibrary $\r\n{\r\n\taddress constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\r\n\r\n\taddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n\taddress constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n\r\n\taddress constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n}\r\n\r\n// File: contracts/modules/UniswapV2LiquidityPoolAbstraction.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This library provides functionality to facilitate adding/removing\r\n * single-asset liquidity to/from a Uniswap V2 pool.\r\n */\r\nlibrary UniswapV2LiquidityPoolAbstraction\r\n{\r\n\tusing SafeMath for uint256;\r\n\r\n\tfunction _estimateJoinPool(address _pair, address _token, uint256 _amount) internal view returns (uint256 _shares)\r\n\t{\r\n\t\tif (_amount == 0) return 0;\r\n\t\taddress _router = $.UniswapV2_ROUTER02;\r\n\t\taddress _token0 = Pair(_pair).token0();\r\n\t\t(uint256 _reserve0, uint256 _reserve1,) = Pair(_pair).getReserves();\r\n\t\tuint256 _balance = _token == _token0 ? _reserve0 : _reserve1;\r\n\t\tuint256 _otherBalance = _token == _token0 ? _reserve1 : _reserve0;\r\n\t\tuint256 _totalSupply = Pair(_pair).totalSupply();\r\n\t\tuint256 _swapAmount = _calcSwapOutputFromInput(_balance, _amount);\r\n\t\tif (_swapAmount == 0) _swapAmount = _amount / 2;\r\n\t\tuint256 _leftAmount = _amount.sub(_swapAmount);\r\n\t\tuint256 _otherAmount = Router02(_router).getAmountOut(_swapAmount, _balance, _otherBalance);\r\n\t\t_shares = Math._min(_totalSupply.mul(_leftAmount) / _balance.add(_swapAmount), _totalSupply.mul(_otherAmount) / _otherBalance.sub(_otherAmount));\r\n\t\treturn _shares;\r\n\t}\r\n\r\n\tfunction _estimateExitPool(address _pair, address _token, uint256 _shares) internal view returns (uint256 _amount)\r\n\t{\r\n\t\tif (_shares == 0) return 0;\r\n\t\taddress _router = $.UniswapV2_ROUTER02;\r\n\t\taddress _token0 = Pair(_pair).token0();\r\n\t\t(uint256 _reserve0, uint256 _reserve1,) = Pair(_pair).getReserves();\r\n\t\tuint256 _balance = _token == _token0 ? _reserve0 : _reserve1;\r\n\t\tuint256 _otherBalance = _token == _token0 ? _reserve1 : _reserve0;\r\n\t\tuint256 _totalSupply = Pair(_pair).totalSupply();\r\n\t\tuint256 _baseAmount = _balance.mul(_shares) / _totalSupply;\r\n\t\tuint256 _swapAmount = _otherBalance.mul(_shares) / _totalSupply;\r\n\t\tuint256 _additionalAmount = Router02(_router).getAmountOut(_swapAmount, _otherBalance.sub(_swapAmount), _balance.sub(_baseAmount));\r\n\t\t_amount = _baseAmount.add(_additionalAmount);\r\n\t\treturn _amount;\r\n\t}\r\n\r\n\tfunction _joinPool(address _pair, address _token, uint256 _amount, uint256 _minShares) internal returns (uint256 _shares)\r\n\t{\r\n\t\tif (_amount == 0) return 0;\r\n\t\taddress _router = $.UniswapV2_ROUTER02;\r\n\t\taddress _token0 = Pair(_pair).token0();\r\n\t\taddress _token1 = Pair(_pair).token1();\r\n\t\taddress _otherToken = _token == _token0 ? _token1 : _token0;\r\n\t\t(uint256 _reserve0, uint256 _reserve1,) = Pair(_pair).getReserves();\r\n\t\tuint256 _swapAmount = _calcSwapOutputFromInput(_token == _token0 ? _reserve0 : _reserve1, _amount);\r\n\t\tif (_swapAmount == 0) _swapAmount = _amount / 2;\r\n\t\tuint256 _leftAmount = _amount.sub(_swapAmount);\r\n\t\tTransfers._approveFunds(_token, _router, _amount);\r\n\t\taddress[] memory _path = new address[](2);\r\n\t\t_path[0] = _token;\r\n\t\t_path[1] = _otherToken;\r\n\t\tuint256 _otherAmount = Router02(_router).swapExactTokensForTokens(_swapAmount, 1, _path, address(this), uint256(-1))[1];\r\n\t\tTransfers._approveFunds(_otherToken, _router, _otherAmount);\r\n\t\t(,,_shares) = Router02(_router).addLiquidity(_token, _otherToken, _leftAmount, _otherAmount, 1, 1, address(this), uint256(-1));\r\n\t\trequire(_shares >= _minShares, \"high slippage\");\r\n\t\treturn _shares;\r\n\t}\r\n\r\n\tfunction _exitPool(address _pair, address _token, uint256 _shares, uint256 _minAmount) internal returns (uint256 _amount)\r\n\t{\r\n\t\tif (_shares == 0) return 0;\r\n\t\taddress _router = $.UniswapV2_ROUTER02;\r\n\t\taddress _token0 = Pair(_pair).token0();\r\n\t\taddress _token1 = Pair(_pair).token1();\r\n\t\taddress _otherToken = _token == _token0 ? _token1 : _token0;\r\n\t\tTransfers._approveFunds(_pair, _router, _shares);\r\n\t\t(uint256 _baseAmount, uint256 _swapAmount) = Router02(_router).removeLiquidity(_token, _otherToken, _shares, 1, 1, address(this), uint256(-1));\r\n\t\tTransfers._approveFunds(_otherToken, _router, _swapAmount);\r\n\t\taddress[] memory _path = new address[](2);\r\n\t\t_path[0] = _otherToken;\r\n\t\t_path[1] = _token;\r\n\t\tuint256 _additionalAmount = Router02(_router).swapExactTokensForTokens(_swapAmount, 1, _path, address(this), uint256(-1))[1];\r\n\t\t_amount = _baseAmount.add(_additionalAmount);\r\n\t        require(_amount >= _minAmount, \"high slippage\");\r\n\t\treturn _amount;\r\n\t}\r\n\r\n\tfunction _calcSwapOutputFromInput(uint256 _reserveAmount, uint256 _inputAmount) private pure returns (uint256)\r\n\t{\r\n\t\treturn Babylonian.sqrt(_reserveAmount.mul(_inputAmount.mul(3988000).add(_reserveAmount.mul(3988009)))).sub(_reserveAmount.mul(1997)) / 1994;\r\n\t}\r\n}\r\n\r\n// File: contracts/GLPMiningToken.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice This contract implements liquidity mining for staking Uniswap V2\r\n * shares.\r\n */\r\ncontract GLPMiningToken is ERC20, Ownable, ReentrancyGuard, GLPMining\r\n{\r\n\tuint256 constant MAXIMUM_PERFORMANCE_FEE = 50e16; // 50%\r\n\r\n\tuint256 constant BLOCKS_PER_WEEK = 7 days / uint256(13 seconds);\r\n\tuint256 constant DEFAULT_PERFORMANCE_FEE = 10e16; // 10%\r\n\tuint256 constant DEFAULT_REWARD_RATE_PER_WEEK = 10e16; // 10%\r\n\r\n\taddress public immutable override reserveToken;\r\n\taddress public immutable override rewardsToken;\r\n\r\n\taddress public override treasury;\r\n\r\n\tuint256 public override performanceFee = DEFAULT_PERFORMANCE_FEE;\r\n\tuint256 public override rewardRatePerWeek = DEFAULT_REWARD_RATE_PER_WEEK;\r\n\r\n\tuint256 lastContractBlock = block.number;\r\n\tuint256 lastRewardPerBlock = 0;\r\n\tuint256 lastUnlockedReward = 0;\r\n\tuint256 lastLockedReward = 0;\r\n\r\n\tuint256 lastTotalSupply = 1;\r\n\tuint256 lastTotalReserve = 1;\r\n\r\n\tconstructor (string memory _name, string memory _symbol, uint8 _decimals, address _reserveToken, address _rewardsToken)\r\n\t\tERC20(_name, _symbol) public\r\n\t{\r\n\t\taddress _treasury = msg.sender;\r\n\t\t_setupDecimals(_decimals);\r\n\t\tassert(_reserveToken != address(0));\r\n\t\tassert(_rewardsToken != address(0));\r\n\t\tassert(_reserveToken != _rewardsToken);\r\n\t\treserveToken = _reserveToken;\r\n\t\trewardsToken = _rewardsToken;\r\n\t\ttreasury = _treasury;\r\n\t\t// just after creation it must transfer 1 wei from reserveToken\r\n\t\t// into this contract\r\n\t\t// this must be performed manually because we cannot approve\r\n\t\t// the spending by this contract before it exists\r\n\t\t// Transfers._pullFunds(_reserveToken, _from, 1);\r\n\t\t_mint(address(this), 1);\r\n\t}\r\n\r\n\tfunction calcSharesFromCost(uint256 _cost) public view override returns (uint256 _shares)\r\n\t{\r\n\t\treturn _cost.mul(totalSupply()).div(totalReserve());\r\n\t}\r\n\r\n\tfunction calcCostFromShares(uint256 _shares) public view override returns (uint256 _cost)\r\n\t{\r\n\t\treturn _shares.mul(totalReserve()).div(totalSupply());\r\n\t}\r\n\r\n\tfunction calcSharesFromTokenAmount(address _token, uint256 _amount) external view override returns (uint256 _shares)\r\n\t{\r\n\t\tuint256 _cost = UniswapV2LiquidityPoolAbstraction._estimateJoinPool(reserveToken, _token, _amount);\r\n\t\treturn calcSharesFromCost(_cost);\r\n\t}\r\n\r\n\tfunction calcTokenAmountFromShares(address _token, uint256 _shares) external view override returns (uint256 _amount)\r\n\t{\r\n\t\tuint256 _cost = calcCostFromShares(_shares);\r\n\t\treturn UniswapV2LiquidityPoolAbstraction._estimateExitPool(reserveToken, _token, _cost);\r\n\t}\r\n\r\n\tfunction totalReserve() public view override returns (uint256 _totalReserve)\r\n\t{\r\n\t\treturn Transfers._getBalance(reserveToken);\r\n\t}\r\n\r\n\tfunction rewardInfo() external view override returns (uint256 _lockedReward, uint256 _unlockedReward, uint256 _rewardPerBlock)\r\n\t{\r\n\t\t(, _rewardPerBlock, _unlockedReward, _lockedReward) = _calcCurrentRewards();\r\n\t\treturn (_lockedReward, _unlockedReward, _rewardPerBlock);\r\n\t}\r\n\r\n\tfunction pendingFees() external view override returns (uint256 _feeShares)\r\n\t{\r\n\t\treturn _calcFees();\r\n\t}\r\n\r\n\tfunction deposit(uint256 _cost) external override nonReentrant\r\n\t{\r\n\t\taddress _from = msg.sender;\r\n\t\tuint256 _shares = calcSharesFromCost(_cost);\r\n\t\tTransfers._pullFunds(reserveToken, _from, _cost);\r\n\t\t_mint(_from, _shares);\r\n\t}\r\n\r\n\tfunction withdraw(uint256 _shares) external override nonReentrant\r\n\t{\r\n\t\taddress _from = msg.sender;\r\n\t\tuint256 _cost = calcCostFromShares(_shares);\r\n\t\tTransfers._pushFunds(reserveToken, _from, _cost);\r\n\t\t_burn(_from, _shares);\r\n\t}\r\n\r\n\tfunction depositToken(address _token, uint256 _amount, uint256 _minShares) external override nonReentrant\r\n\t{\r\n\t\taddress _from = msg.sender;\r\n\t\tuint256 _minCost = calcCostFromShares(_minShares);\r\n\t\tTransfers._pullFunds(_token, _from, _amount);\r\n\t\tuint256 _cost = UniswapV2LiquidityPoolAbstraction._joinPool(reserveToken, _token, _amount, _minCost);\r\n\t\tuint256 _shares = _cost.mul(totalSupply()).div(totalReserve().sub(_cost));\r\n\t\t_mint(_from, _shares);\r\n\t}\r\n\r\n\tfunction withdrawToken(address _token, uint256 _shares, uint256 _minAmount) external override nonReentrant\r\n\t{\r\n\t\taddress _from = msg.sender;\r\n\t\tuint256 _cost = calcCostFromShares(_shares);\r\n\t\tuint256 _amount = UniswapV2LiquidityPoolAbstraction._exitPool(reserveToken, _token, _cost, _minAmount);\r\n\t\tTransfers._pushFunds(_token, _from, _amount);\r\n\t\t_burn(_from, _shares);\r\n\t}\r\n\r\n\tfunction gulpRewards(uint256 _minCost) external override nonReentrant\r\n\t{\r\n\t\t_updateRewards();\r\n\t\tUniswapV2LiquidityPoolAbstraction._joinPool(reserveToken, rewardsToken, lastUnlockedReward, _minCost);\r\n\t\tlastUnlockedReward = 0;\r\n\t}\r\n\r\n\tfunction gulpFees() external override nonReentrant\r\n\t{\r\n\t\tuint256 _feeShares = _calcFees();\r\n\t\tif (_feeShares > 0) {\r\n\t\t\tlastTotalSupply = totalSupply();\r\n\t\t\tlastTotalReserve = totalReserve();\r\n\t\t\t_mint(treasury, _feeShares);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setTreasury(address _newTreasury) external override onlyOwner nonReentrant\r\n\t{\r\n\t\trequire(_newTreasury != address(0), \"invalid address\");\r\n\t\taddress _oldTreasury = treasury;\r\n\t\ttreasury = _newTreasury;\r\n\t\temit ChangeTreasury(_oldTreasury, _newTreasury);\r\n\t}\r\n\r\n\tfunction setPerformanceFee(uint256 _newPerformanceFee) external override onlyOwner nonReentrant\r\n\t{\r\n\t\trequire(_newPerformanceFee <= MAXIMUM_PERFORMANCE_FEE, \"invalid rate\");\r\n\t\tuint256 _oldPerformanceFee = performanceFee;\r\n\t\tperformanceFee = _newPerformanceFee;\r\n\t\temit ChangePerformanceFee(_oldPerformanceFee, _newPerformanceFee);\r\n\t}\r\n\r\n\tfunction setRewardRatePerWeek(uint256 _newRewardRatePerWeek) external override onlyOwner nonReentrant\r\n\t{\r\n\t\trequire(_newRewardRatePerWeek <= 1e18, \"invalid rate\");\r\n\t\tuint256 _oldRewardRatePerWeek = rewardRatePerWeek;\r\n\t\trewardRatePerWeek = _newRewardRatePerWeek;\r\n\t\temit ChangeRewardRatePerWeek(_oldRewardRatePerWeek, _newRewardRatePerWeek);\r\n\t}\r\n\r\n\tfunction _updateRewards() internal\r\n\t{\r\n\t\t(lastContractBlock, lastRewardPerBlock, lastUnlockedReward, lastLockedReward) = _calcCurrentRewards();\r\n\t\tuint256 _balanceReward = Transfers._getBalance(rewardsToken);\r\n\t\tuint256 _totalReward = lastLockedReward.add(lastUnlockedReward);\r\n\t\tif (_balanceReward > _totalReward) {\r\n\t\t\tuint256 _newLockedReward = _balanceReward.sub(_totalReward);\r\n\t\t\tuint256 _newRewardPerBlock = _calcRewardPerBlock(_newLockedReward);\r\n\t\t\tlastRewardPerBlock = lastRewardPerBlock.add(_newRewardPerBlock);\r\n\t\t\tlastLockedReward = lastLockedReward.add(_newLockedReward);\r\n\t\t}\r\n\t\telse\r\n\t\tif (_balanceReward < _totalReward) {\r\n\t\t\tuint256 _removedLockedReward = _totalReward.sub(_balanceReward);\r\n\t\t\tif (_removedLockedReward >= lastLockedReward) {\r\n\t\t\t\t_removedLockedReward = lastLockedReward;\r\n\t\t\t}\r\n\t\t\tuint256 _removedRewardPerBlock = _calcRewardPerBlock(_removedLockedReward);\r\n\t\t\tif (_removedLockedReward >= lastLockedReward) {\r\n\t\t\t\t_removedRewardPerBlock = lastRewardPerBlock;\r\n\t\t\t}\r\n\t\t\tlastRewardPerBlock = lastRewardPerBlock.sub(_removedRewardPerBlock);\r\n\t\t\tlastLockedReward = lastLockedReward.sub(_removedLockedReward);\r\n\t\t\tlastUnlockedReward = _balanceReward.sub(lastLockedReward);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _calcFees() internal view returns (uint256 _feeShares)\r\n\t{\r\n\t\tuint256 _oldTotalSupply = lastTotalSupply;\r\n\t\tuint256 _oldTotalReserve = lastTotalReserve;\r\n\r\n\t\tuint256 _newTotalSupply = totalSupply();\r\n\t\tuint256 _newTotalReserve = totalReserve();\r\n\r\n\t\t// calculates the profit using the following formula\r\n\t\t// ((P1 - P0) * S1 * f) / P1\r\n\t\t// where P1 = R1 / S1 and P0 = R0 / S0\r\n\t\tuint256 _positive = _oldTotalSupply.mul(_newTotalReserve);\r\n\t\tuint256 _negative = _newTotalSupply.mul(_oldTotalReserve);\r\n\t\tif (_positive > _negative) {\r\n\t\t\tuint256 _profitCost = _positive.sub(_negative).div(_oldTotalSupply);\r\n\t\t\tuint256 _feeCost = _profitCost.mul(performanceFee).div(1e18);\r\n\t\t\treturn calcSharesFromCost(_feeCost);\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction _calcCurrentRewards() internal view returns (uint256 _currentContractBlock, uint256 _currentRewardPerBlock, uint256 _currentUnlockedReward, uint256 _currentLockedReward)\r\n\t{\r\n\t\tuint256 _contractBlock = lastContractBlock;\r\n\t\tuint256 _rewardPerBlock = lastRewardPerBlock;\r\n\t\tuint256 _unlockedReward = lastUnlockedReward;\r\n\t\tuint256 _lockedReward = lastLockedReward;\r\n\t\tif (_contractBlock < block.number) {\r\n\t\t\tuint256 _week = _contractBlock.div(BLOCKS_PER_WEEK);\r\n\t\t\tuint256 _offset = _contractBlock.mod(BLOCKS_PER_WEEK);\r\n\r\n\t\t\t_contractBlock = block.number;\r\n\t\t\tuint256 _currentWeek = _contractBlock.div(BLOCKS_PER_WEEK);\r\n\t\t\tuint256 _currentOffset = _contractBlock.mod(BLOCKS_PER_WEEK);\r\n\r\n\t\t\twhile (_week < _currentWeek) {\r\n\t\t\t\tuint256 _blocks = BLOCKS_PER_WEEK.sub(_offset);\r\n\t\t\t\tuint256 _reward = _blocks.mul(_rewardPerBlock);\r\n\t\t\t\t_unlockedReward = _unlockedReward.add(_reward);\r\n\t\t\t\t_lockedReward = _lockedReward.sub(_reward);\r\n\t\t\t\t_rewardPerBlock = _calcRewardPerBlock(_lockedReward);\r\n\t\t\t\t_week++;\r\n\t\t\t\t_offset = 0;\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _blocks = _currentOffset.sub(_offset);\r\n\t\t\tuint256 _reward = _blocks.mul(_rewardPerBlock);\r\n\t\t\t_unlockedReward = _unlockedReward.add(_reward);\r\n\t\t\t_lockedReward = _lockedReward.sub(_reward);\r\n\t\t}\r\n\t\treturn (_contractBlock, _rewardPerBlock, _unlockedReward, _lockedReward);\r\n\t}\r\n\r\n\tfunction _calcRewardPerBlock(uint256 _lockedReward) internal view returns (uint256 _rewardPerBlock)\r\n\t{\r\n\t\treturn _lockedReward.mul(rewardRatePerWeek).div(1e18).div(BLOCKS_PER_WEEK);\r\n\t}\r\n}\r\n\r\n// File: contracts/interop/WrappedEther.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Minimal set of declarations for WETH interoperability.\r\n */\r\ninterface WETH is IERC20\r\n{\r\n\tfunction deposit() external payable;\r\n\tfunction withdraw(uint256 _amount) external;\r\n}\r\n\r\n// File: contracts/modules/Wrapping.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @dev This library abstracts Wrapped Ether operations.\r\n */\r\nlibrary Wrapping\r\n{\r\n\t/**\r\n\t * @dev Sends some ETH to the Wrapped Ether contract in exchange for WETH.\r\n\t * @param _amount The amount of ETH to be wrapped.\r\n\t */\r\n\tfunction _wrap(uint256 _amount) internal\r\n\t{\r\n\t\tWETH($.WETH).deposit{value: _amount}();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Receives some ETH from the Wrapped Ether contract in exchange for WETH.\r\n\t *      Note that the contract using this library function must declare a\r\n\t *      payable receive/fallback function.\r\n\t * @param _amount The amount of ETH to be unwrapped.\r\n\t */\r\n\tfunction _unwrap(uint256 _amount) internal\r\n\t{\r\n\t\tWETH($.WETH).withdraw(_amount);\r\n\t}\r\n}\r\n\r\n// File: contracts/GEtherBridge.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\ncontract GEtherBridge\r\n{\r\n\tfunction deposit(address _stakeToken, uint256 _minShares) external payable\r\n\t{\r\n\t\taddress _from = msg.sender;\r\n\t\tuint256 _amount = msg.value;\r\n\t\taddress _token = $.WETH;\r\n\t\tWrapping._wrap(_amount);\r\n\t\tTransfers._approveFunds(_token, _stakeToken, _amount);\r\n\t\tGLPMining(_stakeToken).depositToken(_token, _amount, _minShares);\r\n\t\tuint256 _shares = Transfers._getBalance(_stakeToken);\r\n\t\tTransfers._pushFunds(_stakeToken, _from, _shares);\r\n\t}\r\n\r\n\tfunction withdraw(address _stakeToken, uint256 _shares, uint256 _minAmount) external\r\n\t{\r\n\t\taddress payable _from = msg.sender;\r\n\t\taddress _token = $.WETH;\r\n\t\tTransfers._pullFunds(_stakeToken, _from, _shares);\r\n\t\tGLPMining(_stakeToken).withdrawToken(_token, _shares, _minAmount);\r\n\t\tuint256 _amount = Transfers._getBalance(_token);\r\n\t\tWrapping._unwrap(_amount);\r\n\t\t_from.transfer(_amount);\r\n\t}\r\n\r\n\treceive() external payable {} // not to be used directly\r\n}\r\n\r\n// File: contracts/GTokens.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Definition of rAAVE. It is an elastic supply token that uses AAVE\r\n * as reference token.\r\n */\r\ncontract rAAVE is GElasticToken\r\n{\r\n\tconstructor (uint256 _initialSupply)\r\n\t\tGElasticToken(\"rebase AAVE\", \"rAAVE\", 18, $.AAVE, _initialSupply) public\r\n\t{\r\n\t}\r\n}\r\n\r\n/**\r\n * @notice Definition of stkAAVE/rAAVE. It provides mining or reward rAAVE when\r\n * providing liquidity to the AAVE/rAAVE pool.\r\n */\r\ncontract stkAAVE_rAAVE is GLPMiningToken\r\n{\r\n\tconstructor (address _AAVE_rAAVE, address _rAAVE)\r\n\t\tGLPMiningToken(\"staked AAVE/rAAVE\", \"stkAAVE/rAAVE\", 18, _AAVE_rAAVE, _rAAVE) public\r\n\t{\r\n\t}\r\n}\r\n\r\n/**\r\n * @notice Definition of stkGRO/rAAVE. It provides mining or reward rAAVE when\r\n * providing liquidity to the GRO/rAAVE pool.\r\n */\r\ncontract stkGRO_rAAVE is GLPMiningToken\r\n{\r\n\tconstructor (address _GRO_rAAVE, address _rAAVE)\r\n\t\tGLPMiningToken(\"staked GRO/rAAVE\", \"stkGRO/rAAVE\", 18, _GRO_rAAVE, _rAAVE) public\r\n\t{\r\n\t}\r\n}\r\n\r\n/**\r\n * @notice Definition of stkETH/rAAVE. It provides mining or reward rAAVE when\r\n * providing liquidity to the WETH/rAAVE pool.\r\n */\r\ncontract stkETH_rAAVE is GLPMiningToken\r\n{\r\n\tconstructor (address _ETH_rAAVE, address _rAAVE)\r\n\t\tGLPMiningToken(\"staked ETH/rAAVE\", \"stkETH/rAAVE\", 18, _ETH_rAAVE, _rAAVE) public\r\n\t{\r\n\t}\r\n}\r\n\r\n// File: contracts/GTokenRegistry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @notice This contract allows external agents to detect when new GTokens\r\n *         are deployed to the network.\r\n */\r\ncontract GTokenRegistry is Ownable\r\n{\r\n\t/**\r\n\t * @notice Registers a new gToken.\r\n\t * @param _growthToken The address of the token being registered.\r\n\t * @param _oldGrowthToken The address of the token implementation\r\n\t *                        being replaced, for upgrades, or 0x0 0therwise.\r\n\t */\r\n\tfunction registerNewToken(address _growthToken, address _oldGrowthToken) public onlyOwner\r\n\t{\r\n\t\temit NewToken(_growthToken, _oldGrowthToken);\r\n\t}\r\n\r\n\tevent NewToken(address indexed _growthToken, address indexed _oldGrowthToken);\r\n}"}
{"address": "0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50", "attacktype": "Unfair slippage protection", "sourcecode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BoringOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\n\\n// P1 - P3: OK\\npragma solidity 0.6.12;\\n\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\n// Edited by BoringCrypto\\n\\n// T1 - T4: OK\\ncontract BoringOwnableData {\\n    // V1 - V5: OK\\n    address public owner;\\n    // V1 - V5: OK\\n    address public pendingOwner;\\n}\\n\\n// T1 - T4: OK\\ncontract BoringOwnable is BoringOwnableData {\\n    // E1: OK\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () internal {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    // F1 - F9: OK\\n    // C1 - C21: OK\\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\\n        if (direct) {\\n            // Checks\\n            require(newOwner != address(0) || renounce, \\\"Ownable: zero address\\\");\\n\\n            // Effects\\n            emit OwnershipTransferred(owner, newOwner);\\n            owner = newOwner;\\n        } else {\\n            // Effects\\n            pendingOwner = newOwner;\\n        }\\n    }\\n\\n    // F1 - F9: OK\\n    // C1 - C21: OK\\n    function claimOwnership() public {\\n        address _pendingOwner = pendingOwner;\\n        \\n        // Checks\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\n\\n        // Effects\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    // M1 - M5: OK\\n    // C1 - C21: OK\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/SushiMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// P1 - P3: OK\\npragma solidity 0.6.12;\\nimport \\\"./libraries/BoringMath.sol\\\";\\nimport \\\"./libraries/BoringERC20.sol\\\";\\n\\nimport \\\"./uniswapv2/interfaces/IUniswapV2ERC20.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\n\\nimport \\\"./BoringOwnable.sol\\\";\\n\\n// SushiMaker is MasterChef's left hand and kinda a wizard. He can cook up Sushi from pretty much anything!\\n// This contract handles \\\"serving up\\\" rewards for xSushi holders by trading tokens collected from fees for Sushi.\\n\\n// T1 - T4: OK\\ncontract SushiMaker is BoringOwnable {\\n    using BoringMath for uint256;\\n    using BoringERC20 for IERC20;\\n\\n    // V1 - V5: OK\\n    IUniswapV2Factory public immutable factory;\\n    //0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\\n    // V1 - V5: OK\\n    address public immutable bar; \\n    //0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272\\n    // V1 - V5: OK\\n    address private immutable sushi;\\n    //0x6B3595068778DD592e39A122f4f5a5cF09C90fE2\\n    // V1 - V5: OK\\n    address private immutable weth; \\n    //0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\\n\\n    // V1 - V5: OK\\n    mapping(address => address) internal _bridges;\\n\\n    // E1: OK\\n    event LogBridgeSet(address indexed token, address indexed bridge);\\n    // E1: OK\\n    event LogConvert(address indexed server, address indexed token0, address indexed token1, uint256 amount0, uint256 amount1, uint256 amountSUSHI);\\n\\n\\n    constructor (address _factory, address _bar, address _sushi, address _weth) public {\\n       factory = IUniswapV2Factory(_factory);\\n       bar = _bar;\\n       sushi = _sushi;\\n       weth = _weth;\\n    }\\n    \\n    // F1 - F10: OK\\n    // C1 - C24: OK\\n    function bridgeFor(address token) public view returns (address bridge) {\\n        bridge = _bridges[token];\\n        if (bridge == address(0)) {\\n            bridge = weth;\\n        }\\n    }\\n\\n    // F1 - F10: OK\\n    // C1 - C24: OK\\n    function setBridge(address token, address bridge) external onlyOwner {\\n        // Checks\\n        require(token != sushi && token != weth && token != bridge, \\\"SushiMaker: Invalid bridge\\\");\\n\\n        // Effects\\n        _bridges[token] = bridge;\\n        emit LogBridgeSet(token, bridge);\\n    }\\n\\n    // M1 - M5: OK\\n    // C1 - C24: OK\\n    // C6: It's not a fool proof solution, but it prevents flash loans, so here it's ok to use tx.origin\\n    modifier onlyEOA() {\\n        // Try to make flash-loan exploit harder to do.\\n        require(msg.sender == tx.origin, \\\"SushiMaker: must use EOA\\\");\\n        _;\\n    }\\n\\n    // F1 - F10: OK\\n    // F3: _convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple\\n    // F6: There is an exploit to add lots of SUSHI to the bar, run convert, then remove the SUSHI again.\\n    //     As the size of the SushiBar has grown, this requires large amounts of funds and isn't super profitable anymore\\n    //     The onlyEOA modifier prevents this being done with a flash loan.\\n    // C1 - C24: OK\\n    function convert(address token0, address token1) external onlyEOA() {\\n        _convert(token0, token1);\\n    }\\n\\n    // F1 - F10: OK, see convert\\n    // C1 - C24: OK\\n    // C3: Loop is under control of the caller\\n    function convertMultiple(address[] calldata token0, address[] calldata token1) external onlyEOA() {\\n        // TODO: This can be optimized a fair bit, but this is safer and simpler for now\\n        uint256 len = token0.length;\\n        for(uint256 i=0; i < len; i++) {\\n            _convert(token0[i], token1[i]);\\n        }\\n    }\\n\\n    // F1 - F10: OK\\n    // C1- C24: OK\\n    function _convert(address token0, address token1) internal {\\n        // Interactions\\n        // S1 - S4: OK\\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));\\n        require(address(pair) != address(0), \\\"SushiMaker: Invalid pair\\\");\\n        // balanceOf: S1 - S4: OK\\n        // transfer: X1 - X5: OK\\n        IERC20(address(pair)).safeTransfer(address(pair), pair.balanceOf(address(this)));\\n        // X1 - X5: OK\\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\\n        if (token0 != pair.token0()) {\\n            (amount0, amount1) = (amount1, amount0);\\n        }\\n        emit LogConvert(msg.sender, token0, token1, amount0, amount1, _convertStep(token0, token1, amount0, amount1));\\n    }\\n\\n    // F1 - F10: OK\\n    // C1 - C24: OK\\n    // All safeTransfer, _swap, _toSUSHI, _convertStep: X1 - X5: OK\\n    function _convertStep(address token0, address token1, uint256 amount0, uint256 amount1) internal returns(uint256 sushiOut) {\\n        // Interactions\\n        if (token0 == token1) {\\n            uint256 amount = amount0.add(amount1);\\n            if (token0 == sushi) {\\n                IERC20(sushi).safeTransfer(bar, amount);\\n                sushiOut = amount;\\n            } else if (token0 == weth) {\\n                sushiOut = _toSUSHI(weth, amount);\\n            } else {\\n                address bridge = bridgeFor(token0);\\n                amount = _swap(token0, bridge, amount, address(this));\\n                sushiOut = _convertStep(bridge, bridge, amount, 0);\\n            }\\n        } else if (token0 == sushi) { // eg. SUSHI - ETH\\n            IERC20(sushi).safeTransfer(bar, amount0);\\n            sushiOut = _toSUSHI(token1, amount1).add(amount0);\\n        } else if (token1 == sushi) { // eg. USDT - SUSHI\\n            IERC20(sushi).safeTransfer(bar, amount1);\\n            sushiOut = _toSUSHI(token0, amount0).add(amount1);\\n        } else if (token0 == weth) { // eg. ETH - USDC\\n            sushiOut = _toSUSHI(weth, _swap(token1, weth, amount1, address(this)).add(amount0));\\n        } else if (token1 == weth) { // eg. USDT - ETH\\n            sushiOut = _toSUSHI(weth, _swap(token0, weth, amount0, address(this)).add(amount1));\\n        } else { // eg. MIC - USDT\\n            address bridge0 = bridgeFor(token0);\\n            address bridge1 = bridgeFor(token1);\\n            if (bridge0 == token1) { // eg. MIC - USDT - and bridgeFor(MIC) = USDT\\n                sushiOut = _convertStep(bridge0, token1,\\n                    _swap(token0, bridge0, amount0, address(this)),\\n                    amount1\\n                );\\n            } else if (bridge1 == token0) { // eg. WBTC - DSD - and bridgeFor(DSD) = WBTC\\n                sushiOut = _convertStep(token0, bridge1,\\n                    amount0,\\n                    _swap(token1, bridge1, amount1, address(this))\\n                );\\n            } else {\\n                sushiOut = _convertStep(bridge0, bridge1, // eg. USDT - DSD - and bridgeFor(DSD) = WBTC\\n                    _swap(token0, bridge0, amount0, address(this)),\\n                    _swap(token1, bridge1, amount1, address(this))\\n                );\\n            }\\n        }\\n    }\\n\\n    // F1 - F10: OK\\n    // C1 - C24: OK\\n    // All safeTransfer, swap: X1 - X5: OK\\n    function _swap(address fromToken, address toToken, uint256 amountIn, address to) internal returns (uint256 amountOut) {\\n        // Checks\\n        // X1 - X5: OK\\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(fromToken, toToken));\\n        require(address(pair) != address(0), \\\"SushiMaker: Cannot convert\\\");\\n\\n        // Interactions\\n        // X1 - X5: OK\\n        (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        if (fromToken == pair.token0()) {\\n            amountOut = amountIn.mul(997).mul(reserve1) / reserve0.mul(1000).add(amountInWithFee);\\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\\n            pair.swap(0, amountOut, to, new bytes(0));\\n            // TODO: Add maximum slippage?\\n        } else {\\n            amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);\\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\\n            pair.swap(amountOut, 0, to, new bytes(0));\\n            // TODO: Add maximum slippage?\\n        }\\n    }\\n\\n    // F1 - F10: OK\\n    // C1 - C24: OK\\n    function _toSUSHI(address token, uint256 amountIn) internal returns(uint256 amountOut) {\\n        // X1 - X5: OK\\n        amountOut = _swap(token, sushi, amountIn, bar);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\\nlibrary BoringMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \\\"BoringMath: Mul Overflow\\\");}\\n    function to128(uint256 a) internal pure returns (uint128 c) {\\n        require(a <= uint128(-1), \\\"BoringMath: uint128 Overflow\\\");\\n        c = uint128(a);\\n    }\\n}\\n\\nlibrary BoringMath128 {\\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n}\"\r\n    },\r\n    \"contracts/libraries/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary BoringERC20 {\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeName(IERC20 token) internal view returns(string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeDecimals(IERC20 token) public view returns (uint8) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BentoBox: Transfer failed\\\");\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BentoBox: TransferFrom failed\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2ERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    // EIP 2612\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.6.12;\\n\\n\\nimport './libraries/UniswapV2Library.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/TransferHelper.sol';\\nimport './interfaces/IUniswapV2Router02.sol';\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IWETH.sol';\\n\\ncontract UniswapV2Router02 is IUniswapV2Router02 {\\n    using SafeMathUniswap for uint;\\n\\n    address public immutable override factory;\\n    address public immutable override WETH;\\n\\n    modifier ensure(uint deadline) {\\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\\n        _;\\n    }\\n\\n    constructor(address _factory, address _WETH) public {\\n        factory = _factory;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    // **** ADD LIQUIDITY ****\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin\\n    ) internal virtual returns (uint amountA, uint amountB) {\\n        // create the pair if it doesn't exist yet\\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\\n        }\\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal <= amountBDesired) {\\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal <= amountADesired);\\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n        liquidity = IUniswapV2Pair(pair).mint(to);\\n    }\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\\n        (amountToken, amountETH) = _addLiquidity(\\n            token,\\n            WETH,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(pair, amountETH));\\n        liquidity = IUniswapV2Pair(pair).mint(to);\\n        // refund dust eth, if any\\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    // **** REMOVE LIQUIDITY ****\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\\n    }\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\\n        (amountToken, amountETH) = removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, amountToken);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external virtual override returns (uint amountA, uint amountB) {\\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\\n        uint value = approveMax ? uint(-1) : liquidity;\\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\\n    }\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external virtual override returns (uint amountToken, uint amountETH) {\\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\\n        uint value = approveMax ? uint(-1) : liquidity;\\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\\n    }\\n\\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\\n        (, amountETH) = removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, IERC20Uniswap(token).balanceOf(address(this)));\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external virtual override returns (uint amountETH) {\\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\\n        uint value = approveMax ? uint(-1) : liquidity;\\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\\n        );\\n    }\\n\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\\n        for (uint i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\\n            uint amountOut = amounts[i + 1];\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\\n                amount0Out, amount1Out, to, new bytes(0)\\n            );\\n        }\\n    }\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, to);\\n    }\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to);\\n    }\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, address(this));\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to);\\n        // refund dust eth, if any\\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    // **** SWAP (supporting fee-on-transfer tokens) ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\\n        for (uint i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\\n            uint amountInput;\\n            uint amountOutput;\\n            { // scope to avoid stack too deep errors\\n            (uint reserve0, uint reserve1,) = pair.getReserves();\\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n            amountInput = IERC20Uniswap(input).balanceOf(address(pair)).sub(reserveInput);\\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\\n            }\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n        }\\n    }\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) {\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\\n        );\\n        uint balanceBefore = IERC20Uniswap(path[path.length - 1]).balanceOf(to);\\n        _swapSupportingFeeOnTransferTokens(path, to);\\n        require(\\n            IERC20Uniswap(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n        );\\n    }\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        virtual\\n        override\\n        payable\\n        ensure(deadline)\\n    {\\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\\n        uint amountIn = msg.value;\\n        IWETH(WETH).deposit{value: amountIn}();\\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\\n        uint balanceBefore = IERC20Uniswap(path[path.length - 1]).balanceOf(to);\\n        _swapSupportingFeeOnTransferTokens(path, to);\\n        require(\\n            IERC20Uniswap(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\\n        );\\n    }\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n    {\\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\\n        );\\n        _swapSupportingFeeOnTransferTokens(path, address(this));\\n        uint amountOut = IERC20Uniswap(WETH).balanceOf(address(this));\\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(to, amountOut);\\n    }\\n\\n    // **** LIBRARY FUNCTIONS ****\\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\\n        public\\n        pure\\n        virtual\\n        override\\n        returns (uint amountOut)\\n    {\\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\\n    }\\n\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\\n        public\\n        pure\\n        virtual\\n        override\\n        returns (uint amountIn)\\n    {\\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\\n    }\\n\\n    function getAmountsOut(uint amountIn, address[] memory path)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint[] memory amounts)\\n    {\\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\\n    }\\n\\n    function getAmountsIn(uint amountOut, address[] memory path)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint[] memory amounts)\\n    {\\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport '../interfaces/IUniswapV2Pair.sol';\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMathUniswap for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\\n            ))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMathUniswap {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IERC20Uniswap {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.6.12;\\n\\nimport './UniswapV2ERC20.sol';\\nimport './libraries/Math.sol';\\nimport './libraries/UQ112x112.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './interfaces/IUniswapV2Callee.sol';\\n\\n\\ninterface IMigrator {\\n    // Return the desired amount of liquidity token that the migrator wants.\\n    function desiredLiquidity() external view returns (uint256);\\n}\\n\\ncontract UniswapV2Pair is UniswapV2ERC20 {\\n    using SafeMathUniswap  for uint;\\n    using UQ112x112 for uint224;\\n\\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n\\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    uint public price0CumulativeLast;\\n    uint public price1CumulativeLast;\\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n    uint private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'UniswapV2: LOCKED');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(address token, address to, uint value) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\\n    }\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    constructor() public {\\n        factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\\n        address feeTo = IUniswapV2Factory(factory).feeTo();\\n        feeOn = feeTo != address(0);\\n        uint _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\\n                uint rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\\n                    uint denominator = rootK.mul(5).add(rootKLast);\\n                    uint liquidity = numerator / denominator;\\n                    if (liquidity > 0) _mint(feeTo, liquidity);\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external lock returns (uint liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));\\n        uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));\\n        uint amount0 = balance0.sub(_reserve0);\\n        uint amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            address migrator = IUniswapV2Factory(factory).migrator();\\n            if (msg.sender == migrator) {\\n                liquidity = IMigrator(migrator).desiredLiquidity();\\n                require(liquidity > 0 && liquidity != uint256(-1), \\\"Bad desired liquidity\\\");\\n            } else {\\n                require(migrator == address(0), \\\"Must not have migrator\\\");\\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            }\\n        } else {\\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\\n        }\\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        address _token0 = token0;                                // gas savings\\n        address _token1 = token1;                                // gas savings\\n        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        uint liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\\n\\n        uint balance0;\\n        uint balance1;\\n        { // scope for _token{0,1}, avoids stack too deep errors\\n        address _token0 = token0;\\n        address _token1 = token1;\\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        }\\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\\n        }\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external lock {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        _safeTransfer(_token0, to, IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0));\\n        _safeTransfer(_token1, to, IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1));\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(IERC20Uniswap(token0).balanceOf(address(this)), IERC20Uniswap(token1).balanceOf(address(this)), reserve0, reserve1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.6.12;\\n\\nimport './libraries/SafeMath.sol';\\n\\ncontract UniswapV2ERC20 {\\n    using SafeMathUniswap for uint;\\n\\n    string public constant name = 'SushiSwap LP Token';\\n    string public constant symbol = 'SLP';\\n    uint8 public constant decimals = 18;\\n    uint  public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public nonces;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.6.12;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/UQ112x112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.6.12;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Callee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Callee {\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/SushiSwapPairMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../uniswapv2/UniswapV2Pair.sol\\\";\\n\\ncontract SushiSwapPairMock is UniswapV2Pair {\\n    constructor() public UniswapV2Pair() {}\\n}\"\r\n    },\r\n    \"contracts/SushiRoll.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Router01.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./uniswapv2/libraries/UniswapV2Library.sol\\\";\\n\\n// SushiRoll helps your migrate your existing Uniswap LP tokens to SushiSwap LP ones\\ncontract SushiRoll {\\n    using SafeERC20 for IERC20;\\n\\n    IUniswapV2Router01 public oldRouter;\\n    IUniswapV2Router01 public router;\\n\\n    constructor(IUniswapV2Router01 _oldRouter, IUniswapV2Router01 _router) public {\\n        oldRouter = _oldRouter;\\n        router = _router;\\n    }\\n\\n    function migrateWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public {\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));\\n        pair.permit(msg.sender, address(this), liquidity, deadline, v, r, s);\\n\\n        migrate(tokenA, tokenB, liquidity, amountAMin, amountBMin, deadline);\\n    }\\n\\n    // msg.sender should have approved 'liquidity' amount of LP token of 'tokenA' and 'tokenB'\\n    function migrate(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline\\n    ) public {\\n        require(deadline >= block.timestamp, 'SushiSwap: EXPIRED');\\n\\n        // Remove liquidity from the old router with permit\\n        (uint256 amountA, uint256 amountB) = removeLiquidity(\\n            tokenA,\\n            tokenB,\\n            liquidity,\\n            amountAMin,\\n            amountBMin,\\n            deadline\\n        );\\n\\n        // Add liquidity to the new router\\n        (uint256 pooledAmountA, uint256 pooledAmountB) = addLiquidity(tokenA, tokenB, amountA, amountB);\\n\\n        // Send remaining tokens to msg.sender\\n        if (amountA > pooledAmountA) {\\n            IERC20(tokenA).safeTransfer(msg.sender, amountA - pooledAmountA);\\n        }\\n        if (amountB > pooledAmountB) {\\n            IERC20(tokenB).safeTransfer(msg.sender, amountB - pooledAmountB);\\n        }\\n    }\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline\\n    ) internal returns (uint256 amountA, uint256 amountB) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));\\n        pair.transferFrom(msg.sender, address(pair), liquidity);\\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA >= amountAMin, 'SushiRoll: INSUFFICIENT_A_AMOUNT');\\n        require(amountB >= amountBMin, 'SushiRoll: INSUFFICIENT_B_AMOUNT');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairForOldRouter(address tokenA, address tokenB) internal view returns (address pair) {\\n        (address token0, address token1) = UniswapV2Library.sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                oldRouter.factory(),\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            ))));\\n    }\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired\\n    ) internal returns (uint amountA, uint amountB) {\\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired);\\n        address pair = UniswapV2Library.pairFor(router.factory(), tokenA, tokenB);\\n        IERC20(tokenA).safeTransfer(pair, amountA);\\n        IERC20(tokenB).safeTransfer(pair, amountB);\\n        IUniswapV2Pair(pair).mint(msg.sender);\\n    }\\n\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired\\n    ) internal returns (uint256 amountA, uint256 amountB) {\\n        // create the pair if it doesn't exist yet\\n        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\\n        if (factory.getPair(tokenA, tokenB) == address(0)) {\\n            factory.createPair(tokenA, tokenB);\\n        }\\n        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(address(factory), tokenA, tokenB);\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal <= amountBDesired) {\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal <= amountADesired);\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\n// Copyright 2020 Compound Labs, Inc.\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n//\\n// Ctrl+f for XXX to see all the modifications.\\n\\n// XXX: pragma solidity ^0.5.16;\\npragma solidity 0.6.12;\\n\\n// XXX: import \\\"./SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract Timelock {\\n    using SafeMath for uint;\\n\\n    event NewAdmin(address indexed newAdmin);\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\n    event NewDelay(uint indexed newDelay);\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\\n\\n    uint public constant GRACE_PERIOD = 14 days;\\n    uint public constant MINIMUM_DELAY = 2 days;\\n    uint public constant MAXIMUM_DELAY = 30 days;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    uint public delay;\\n    bool public admin_initialized;\\n\\n    mapping (bytes32 => bool) public queuedTransactions;\\n\\n\\n    constructor(address admin_, uint delay_) public {\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::constructor: Delay must not exceed maximum delay.\\\");\\n\\n        admin = admin_;\\n        delay = delay_;\\n        admin_initialized = false;\\n    }\\n\\n    // XXX: function() external payable { }\\n    receive() external payable { }\\n\\n    function setDelay(uint delay_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n        delay = delay_;\\n\\n        emit NewDelay(delay);\\n    }\\n\\n    function acceptAdmin() public {\\n        require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n        admin = msg.sender;\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(admin);\\n    }\\n\\n    function setPendingAdmin(address pendingAdmin_) public {\\n        // allows one time setting of admin for deployment purposes\\n        if (admin_initialized) {\\n            require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\n        } else {\\n            require(msg.sender == admin, \\\"Timelock::setPendingAdmin: First call must come from admin.\\\");\\n            admin_initialized = true;\\n        }\\n        pendingAdmin = pendingAdmin_;\\n\\n        emit NewPendingAdmin(pendingAdmin);\\n    }\\n\\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\\n        require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n        require(eta >= getBlockTimestamp().add(delay), \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = true;\\n\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\n        return txHash;\\n    }\\n\\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\\n        require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = false;\\n\\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\\n    }\\n\\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\\n        require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\");\\n        require(getBlockTimestamp() >= eta, \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\");\\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n        queuedTransactions[txHash] = false;\\n\\n        bytes memory callData;\\n\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n        return returnData;\\n    }\\n\\n    function getBlockTimestamp() internal view returns (uint) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp;\\n    }\\n}\"\r\n    },\r\n    \"contracts/SushiBar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n// SushiBar is the coolest bar in town. You come in with some Sushi, and leave with more! The longer you stay, the more Sushi you get.\\n//\\n// This contract handles swapping to and from xSushi, SushiSwap's staking token.\\ncontract SushiBar is ERC20(\\\"SushiBar\\\", \\\"xSUSHI\\\"){\\n    using SafeMath for uint256;\\n    IERC20 public sushi;\\n\\n    // Define the Sushi token contract\\n    constructor(IERC20 _sushi) public {\\n        sushi = _sushi;\\n    }\\n\\n    // Enter the bar. Pay some SUSHIs. Earn some shares.\\n    // Locks Sushi and mints xSushi\\n    function enter(uint256 _amount) public {\\n        // Gets the amount of Sushi locked in the contract\\n        uint256 totalSushi = sushi.balanceOf(address(this));\\n        // Gets the amount of xSushi in existence\\n        uint256 totalShares = totalSupply();\\n        // If no xSushi exists, mint it 1:1 to the amount put in\\n        if (totalShares == 0 || totalSushi == 0) {\\n            _mint(msg.sender, _amount);\\n        } \\n        // Calculate and mint the amount of xSushi the Sushi is worth. The ratio will change overtime, as xSushi is burned/minted and Sushi deposited + gained from fees / withdrawn.\\n        else {\\n            uint256 what = _amount.mul(totalShares).div(totalSushi);\\n            _mint(msg.sender, what);\\n        }\\n        // Lock the Sushi in the contract\\n        sushi.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Leave the bar. Claim back your SUSHIs.\\n    // Unclocks the staked + gained Sushi and burns xSushi\\n    function leave(uint256 _share) public {\\n        // Gets the amount of xSushi in existence\\n        uint256 totalShares = totalSupply();\\n        // Calculates the amount of Sushi the xSushi is worth\\n        uint256 what = _share.mul(sushi.balanceOf(address(this))).div(totalShares);\\n        _burn(msg.sender, _share);\\n        sushi.transfer(msg.sender, what);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ERC20Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract ERC20Mock is ERC20 {\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint256 supply\\n    ) public ERC20(name, symbol) {\\n        _mint(msg.sender, supply);\\n    }\\n}\"\r\n    },\r\n    \"contracts/MasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./SushiToken.sol\\\";\\n\\n\\ninterface IMigratorChef {\\n    // Perform LP token migration from legacy UniswapV2 to SushiSwap.\\n    // Take the current LP token address and return the new LP token address.\\n    // Migrator should have full access to the caller's LP token.\\n    // Return the new LP token address.\\n    //\\n    // XXX Migrator must have allowance access to UniswapV2 LP tokens.\\n    // SushiSwap must mint EXACTLY the same amount of SushiSwap LP tokens or\\n    // else something bad will happen. Traditional UniswapV2 does not\\n    // do that so be careful!\\n    function migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n// MasterChef is the master of Sushi. He can make Sushi and he is a fair guy.\\n//\\n// Note that it's ownable and the owner wields tremendous power. The ownership\\n// will be transferred to a governance smart contract once SUSHI is sufficiently\\n// distributed and the community can show to govern itself.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract MasterChef is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount;     // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        //\\n        // We do some fancy math here. Basically, any point in time, the amount of SUSHIs\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   pending reward = (user.amount * pool.accSushiPerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n        //   1. The pool's `accSushiPerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 lpToken;           // Address of LP token contract.\\n        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\\n        uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.\\n        uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\\n    }\\n\\n    // The SUSHI TOKEN!\\n    SushiToken public sushi;\\n    // Dev address.\\n    address public devaddr;\\n    // Block number when bonus SUSHI period ends.\\n    uint256 public bonusEndBlock;\\n    // SUSHI tokens created per block.\\n    uint256 public sushiPerBlock;\\n    // Bonus muliplier for early sushi makers.\\n    uint256 public constant BONUS_MULTIPLIER = 10;\\n    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n    IMigratorChef public migrator;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes LP tokens.\\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n    // The block number when SUSHI mining starts.\\n    uint256 public startBlock;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n\\n    constructor(\\n        SushiToken _sushi,\\n        address _devaddr,\\n        uint256 _sushiPerBlock,\\n        uint256 _startBlock,\\n        uint256 _bonusEndBlock\\n    ) public {\\n        sushi = _sushi;\\n        devaddr = _devaddr;\\n        sushiPerBlock = _sushiPerBlock;\\n        bonusEndBlock = _bonusEndBlock;\\n        startBlock = _startBlock;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        poolInfo.push(PoolInfo({\\n            lpToken: _lpToken,\\n            allocPoint: _allocPoint,\\n            lastRewardBlock: lastRewardBlock,\\n            accSushiPerShare: 0\\n        }));\\n    }\\n\\n    // Update the given pool's SUSHI allocation point. Can only be called by the owner.\\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n    }\\n\\n    // Set the migrator contract. Can only be called by the owner.\\n    function setMigrator(IMigratorChef _migrator) public onlyOwner {\\n        migrator = _migrator;\\n    }\\n\\n    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\\n    function migrate(uint256 _pid) public {\\n        require(address(migrator) != address(0), \\\"migrate: no migrator\\\");\\n        PoolInfo storage pool = poolInfo[_pid];\\n        IERC20 lpToken = pool.lpToken;\\n        uint256 bal = lpToken.balanceOf(address(this));\\n        lpToken.safeApprove(address(migrator), bal);\\n        IERC20 newLpToken = migrator.migrate(lpToken);\\n        require(bal == newLpToken.balanceOf(address(this)), \\\"migrate: bad\\\");\\n        pool.lpToken = newLpToken;\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\\n        if (_to <= bonusEndBlock) {\\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\\n        } else if (_from >= bonusEndBlock) {\\n            return _to.sub(_from);\\n        } else {\\n            return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\\n                _to.sub(bonusEndBlock)\\n            );\\n        }\\n    }\\n\\n    // View function to see pending SUSHIs on frontend.\\n    function pendingSushi(uint256 _pid, address _user) external view returns (uint256) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accSushiPerShare = pool.accSushiPerShare;\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n            uint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n            accSushiPerShare = accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\\n        }\\n        return user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n        sushi.mint(devaddr, sushiReward.div(10));\\n        sushi.mint(address(this), sushiReward);\\n        pool.accSushiPerShare = pool.accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    // Deposit LP tokens to MasterChef for SUSHI allocation.\\n    function deposit(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n            if(pending > 0) {\\n                safeSushiTransfer(msg.sender, pending);\\n            }\\n        }\\n        if(_amount > 0) {\\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\n            user.amount = user.amount.add(_amount);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n        emit Deposit(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens from MasterChef.\\n    function withdraw(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        updatePool(_pid);\\n        uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n        if(pending > 0) {\\n            safeSushiTransfer(msg.sender, pending);\\n        }\\n        if(_amount > 0) {\\n            user.amount = user.amount.sub(_amount);\\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n        emit Withdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        uint256 amount = user.amount;\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\\n    }\\n\\n    // Safe sushi transfer function, just in case if rounding error causes pool to not have enough SUSHIs.\\n    function safeSushiTransfer(address _to, uint256 _amount) internal {\\n        uint256 sushiBal = sushi.balanceOf(address(this));\\n        if (_amount > sushiBal) {\\n            sushi.transfer(_to, sushiBal);\\n        } else {\\n            sushi.transfer(_to, _amount);\\n        }\\n    }\\n\\n    // Update dev address by the previous dev.\\n    function dev(address _devaddr) public {\\n        require(msg.sender == devaddr, \\\"dev: wut?\\\");\\n        devaddr = _devaddr;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SushiToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n\\n// SushiToken with Governance.\\ncontract SushiToken is ERC20(\\\"SushiToken\\\", \\\"SUSHI\\\"), Ownable {\\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\\n    function mint(address _to, uint256 _amount) public onlyOwner {\\n        _mint(_to, _amount);\\n        _moveDelegates(address(0), _delegates[_to], _amount);\\n    }\\n\\n    // Copied and modified from YAM code:\\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\\n    // Which is copied and modified from COMPOUND:\\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\\n\\n    /// @notice A record of each accounts delegate\\n    mapping (address => address) internal _delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint256 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public nonces;\\n\\n      /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegator The address to get delegatee for\\n     */\\n    function delegates(address delegator)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return _delegates[delegator];\\n    }\\n\\n   /**\\n    * @notice Delegate votes from `msg.sender` to `delegatee`\\n    * @param delegatee The address to delegate votes to\\n    */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint nonce,\\n        uint expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n    {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name())),\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                delegatee,\\n                nonce,\\n                expiry\\n            )\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                structHash\\n            )\\n        );\\n\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"SUSHI::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"SUSHI::delegateBySig: invalid nonce\\\");\\n        require(now <= expiry, \\\"SUSHI::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(blockNumber < block.number, \\\"SUSHI::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee)\\n        internal\\n    {\\n        address currentDelegate = _delegates[delegator];\\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                // decrease old representative\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                // increase new representative\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint256 dstRepNew = dstRepOld.add(amount);\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    )\\n        internal\\n    {\\n        uint32 blockNumber = safe32(block.number, \\\"SUSHI::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Migrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\n\\n\\ncontract Migrator {\\n    address public chef;\\n    address public oldFactory;\\n    IUniswapV2Factory public factory;\\n    uint256 public notBeforeBlock;\\n    uint256 public desiredLiquidity = uint256(-1);\\n\\n    constructor(\\n        address _chef,\\n        address _oldFactory,\\n        IUniswapV2Factory _factory,\\n        uint256 _notBeforeBlock\\n    ) public {\\n        chef = _chef;\\n        oldFactory = _oldFactory;\\n        factory = _factory;\\n        notBeforeBlock = _notBeforeBlock;\\n    }\\n\\n    function migrate(IUniswapV2Pair orig) public returns (IUniswapV2Pair) {\\n        require(msg.sender == chef, \\\"not from master chef\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n        require(orig.factory() == oldFactory, \\\"not from old factory\\\");\\n        address token0 = orig.token0();\\n        address token1 = orig.token1();\\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));\\n        if (pair == IUniswapV2Pair(address(0))) {\\n            pair = IUniswapV2Pair(factory.createPair(token0, token1));\\n        }\\n        uint256 lp = orig.balanceOf(msg.sender);\\n        if (lp == 0) return pair;\\n        desiredLiquidity = lp;\\n        orig.transferFrom(msg.sender, address(orig), lp);\\n        orig.burn(address(pair));\\n        pair.mint(msg.sender);\\n        desiredLiquidity = uint256(-1);\\n        return pair;\\n    }\\n}\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.6.12;\\n\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './UniswapV2Pair.sol';\\n\\ncontract UniswapV2Factory is IUniswapV2Factory {\\n    address public override feeTo;\\n    address public override feeToSetter;\\n    address public override migrator;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    address[] public override allPairs;\\n\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    constructor(address _feeToSetter) public {\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    function allPairsLength() external override view returns (uint) {\\n        return allPairs.length;\\n    }\\n\\n    function pairCodeHash() external pure returns (bytes32) {\\n        return keccak256(type(UniswapV2Pair).creationCode);\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        UniswapV2Pair(pair).initialize(token0, token1);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function setFeeTo(address _feeTo) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        feeTo = _feeTo;\\n    }\\n\\n    function setMigrator(address _migrator) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        migrator = _migrator;\\n    }\\n\\n    function setFeeToSetter(address _feeToSetter) external override {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/SushiSwapFactoryMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../uniswapv2/UniswapV2Factory.sol\\\";\\n\\ncontract SushiSwapFactoryMock is UniswapV2Factory {\\n    constructor(address _feeToSetter) public UniswapV2Factory(_feeToSetter) {}\\n}\"\r\n    },\r\n    \"contracts/mocks/SushiMakerExploitMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../SushiMaker.sol\\\";\\n\\ncontract SushiMakerExploitMock {\\n    SushiMaker public immutable sushiMaker;\\n    constructor (address _sushiMaker) public{\\n        sushiMaker = SushiMaker(_sushiMaker);\\n    } \\n    function convert(address token0, address token1) external {\\n        sushiMaker.convert(token0, token1);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}"}
{"address": "0xacd43e627e64355f1861cec6d3a6688b31a6f952", "attacktype": "Flash liquidity borrow, purchase, mint or deposit, Unfair liquidity providing", "sourcecode": "pragma solidity ^0.5.16;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Context {\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface Controller {\r\n    function withdraw(address, uint) external;\r\n    function balanceOf(address) external view returns (uint);\r\n    function earn(address, uint) external;\r\n}\r\n\r\ncontract yVault is ERC20, ERC20Detailed {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    IERC20 public token;\r\n    \r\n    uint public min = 9500;\r\n    uint public constant max = 10000;\r\n    \r\n    address public governance;\r\n    address public controller;\r\n    \r\n    constructor (address _token, address _controller) public ERC20Detailed(\r\n        string(abi.encodePacked(\"yearn \", ERC20Detailed(_token).name())),\r\n        string(abi.encodePacked(\"y\", ERC20Detailed(_token).symbol())),\r\n        ERC20Detailed(_token).decimals()\r\n    ) {\r\n        token = IERC20(_token);\r\n        governance = msg.sender;\r\n        controller = _controller;\r\n    }\r\n    \r\n    function balance() public view returns (uint) {\r\n        return token.balanceOf(address(this))\r\n                .add(Controller(controller).balanceOf(address(token)));\r\n    }\r\n    \r\n    function setMin(uint _min) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        min = _min;\r\n    }\r\n    \r\n    function setGovernance(address _governance) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        governance = _governance;\r\n    }\r\n    \r\n    function setController(address _controller) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        controller = _controller;\r\n    }\r\n    \r\n    // Custom logic in here for how much the vault allows to be borrowed\r\n    // Sets minimum required on-hand to keep small withdrawals cheap\r\n    function available() public view returns (uint) {\r\n        return token.balanceOf(address(this)).mul(min).div(max);\r\n    }\r\n    \r\n    function earn() public {\r\n        uint _bal = available();\r\n        token.safeTransfer(controller, _bal);\r\n        Controller(controller).earn(address(token), _bal);\r\n    }\r\n    \r\n    function depositAll() external {\r\n        deposit(token.balanceOf(msg.sender));\r\n    }\r\n    \r\n    function deposit(uint _amount) public {\r\n        uint _pool = balance();\r\n        uint _before = token.balanceOf(address(this));\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint _after = token.balanceOf(address(this));\r\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\r\n        uint shares = 0;\r\n        if (totalSupply() == 0) {\r\n            shares = _amount;\r\n        } else {\r\n            shares = (_amount.mul(totalSupply())).div(_pool);\r\n        }\r\n        _mint(msg.sender, shares);\r\n    }\r\n    \r\n    function withdrawAll() external {\r\n        withdraw(balanceOf(msg.sender));\r\n    }\r\n    \r\n    \r\n    // Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\r\n    function harvest(address reserve, uint amount) external {\r\n        require(msg.sender == controller, \"!controller\");\r\n        require(reserve != address(token), \"token\");\r\n        IERC20(reserve).safeTransfer(controller, amount);\r\n    }\r\n    \r\n    // No rebalance implementation for lower fees and faster swaps\r\n    function withdraw(uint _shares) public {\r\n        uint r = (balance().mul(_shares)).div(totalSupply());\r\n        _burn(msg.sender, _shares);\r\n        \r\n        // Check balance\r\n        uint b = token.balanceOf(address(this));\r\n        if (b < r) {\r\n            uint _withdraw = r.sub(b);\r\n            Controller(controller).withdraw(address(token), _withdraw);\r\n            uint _after = token.balanceOf(address(this));\r\n            uint _diff = _after.sub(b);\r\n            if (_diff < _withdraw) {\r\n                r = b.add(_diff);\r\n            }\r\n        }\r\n        \r\n        token.safeTransfer(msg.sender, r);\r\n    }\r\n    \r\n    function getPricePerFullShare() public view returns (uint) {\r\n        return balance().mul(1e18).div(totalSupply());\r\n    }\r\n}"}
